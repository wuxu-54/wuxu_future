# Android 年薪百万必备：基础知识与底层知识体系

## 一、计算机基础：底层能力的基石

### 1.1 操作系统基础

#### 1.1.1 Linux 内核核心概念（Android 基于 Linux 内核，必掌握）

* **进程与线程**：

  * 进程：资源分配的基本单位（内存、CPU 时间片），每个进程有独立地址空间（用户空间 + 内核空间）

  * 线程：CPU 调度的基本单位，共享进程资源，线程切换开销远低于进程

  * 轻量级进程（LWP）：Android 中进程管理的底层实现，通过`clone()`系统调用创建，共享部分资源（如文件描述符表）

* **内存管理**：

  * 虚拟内存：通过 MMU（内存管理单元）实现虚拟地址到物理地址的映射，支持地址空间隔离、内存复用

  * 页面置换算法：LRU（最近最少使用）——Android 内存回收（如 AMS 的低内存查杀）核心算法

  * 内存分区：内核空间（高地址，Linux 通常为 1GB）、用户空间（低地址，3GB），Android 中进程间通信依赖内核空间共享

* **文件系统**：

  * Ext4：Android 默认文件系统，支持日志功能（防止数据丢失）、大文件存储（最大单文件 16TB）

  * 特殊文件系统：`/proc`（虚拟文件系统，存储进程状态信息，如`/proc/pid/status`查看进程内存）、`/sys`（硬件信息与驱动交互）

* **IO 模型**：

  * 阻塞 IO（BIO）：进程等待 IO 完成才能继续执行，如早期 Socket 编程

  * 非阻塞 IO（NIO）：进程不等待 IO，通过轮询判断 IO 状态，CPU 开销高

  * IO 多路复用：Android 底层核心 IO 模型，通过`epoll`（Linux）实现 ——Handler 消息循环、Binder 通信均依赖此模型

    * `epoll_create()`：创建 epoll 实例

    * `epoll_ctl()`：注册 / 修改 / 删除 IO 事件（如读事件、写事件）

    * `epoll_wait()`：阻塞等待事件触发，仅返回就绪的文件描述符，效率远高于`select/poll`

#### 1.1.2 进程间通信（IPC）底层实现

* 传统 Linux IPC 方式（理解为何 Android 选择 Binder）：

  * 管道（Pipe）：半双工，仅支持父子进程通信，基于文件系统实现

  * 消息队列（Message Queue）：内核维护的消息链表，支持多进程通信，但数据拷贝次数多（用户→内核→用户）

  * 共享内存（Shared Memory）：最高效的 IPC 方式，直接映射物理内存到进程地址空间，但需配合信号量实现同步

  * 信号（Signal）：用于进程间紧急通知（如`SIGKILL`终止进程），承载信息有限

### 1.2 计算机网络基础

#### 1.2.1 TCP/IP 协议栈（Android 网络通信底层）

* **OSI 七层模型与 TCP/IP 四层模型对应**：

| OSI 七层    | TCP/IP 四层 | Android 中应用场景               |
| --------- | --------- | --------------------------- |
| 应用层       | 应用层       | HTTP/HTTPS、WebSocket、Socket |
| 表示层 / 会话层 | 应用层（封装）   | 数据加密（TLS）、会话管理              |
| 传输层       | 传输层       | TCP（可靠）、UDP（不可靠）            |
| 网络层       | 网络层       | IP（路由）、ICMP（ping）           |
| 数据链路层     | 网络接口层     | 以太网、WiFi（802.11）            |
| 物理层       | 网络接口层     | 网线、无线信号                     |

* **TCP 核心机制**：

  * 三次握手：建立连接（SYN→SYN+ACK→ACK），防止历史连接干扰

  * 四次挥手：关闭连接（FIN→ACK→FIN→ACK），确保双方数据传输完成

  * 滑动窗口：流量控制核心，动态调整接收方缓冲区大小，避免数据溢出

  * 拥塞控制：慢启动、拥塞避免、快速重传、快速恢复 ——Android 网络框架（如 OkHttp）底层依赖 TCP 拥塞控制优化传输效率

* **HTTP/HTTPS 底层**：

  * HTTP 1.1：长连接（Connection: keep-alive）、管线化（批量发送请求），但同一连接串行响应

  * HTTP 2：二进制帧、多路复用（同一连接并行处理多个请求）、头部压缩（HPACK）——Android 7.0 + 默认支持，OkHttp 已集成

  * HTTPS：HTTP+TLS，TLS 握手过程（客户端 Hello→服务器 Hello→证书验证→密钥协商→数据加密传输），Android 中证书校验（SSLContext）、证书钉扎（Certificate Pinning）均基于此

## 二、Java 核心：Android 开发的语言基石

### 2.1 JVM 基础（Android Dalvik/ART 虚拟机的设计参考）

#### 2.1.1 JVM 内存模型（Java 内存区域）

* **运行时数据区域**：

  * 程序计数器：线程私有，记录当前执行字节码地址，无 OOM（OutOfMemoryError）

  * 虚拟机栈：线程私有，存储方法调用栈帧（局部变量表、操作数栈、动态链接、方法出口），栈深度溢出抛`StackOverflowError`，栈扩展失败抛 OOM

  * 本地方法栈：与虚拟机栈类似，为 Native 方法（如 Java 调用 C/C++）服务，Android 中 JNI 调用依赖此区域

  * 堆：线程共享，存储对象实例，GC（垃圾回收）主要区域，分代收集（新生代：Eden、Survivor；老年代；永久代 / 元空间），OOM 高发区域

  * 方法区：线程共享，存储类信息（类结构、字段、方法）、常量、静态变量，Java 8 后改为元空间（MetaSpace），使用本地内存（不再受 JVM 堆大小限制）

#### 2.1.2 GC 机制（Android ART 虚拟机 GC 优化的基础）

* **垃圾判定算法**：

  * 引用计数法：通过对象引用计数器判断是否存活，无法解决循环引用（如 A 引用 B，B 引用 A），Android 早期 Dalvik 虚拟机曾用，现已淘汰

  * 可达性分析：JVM/ART 核心算法，以 GC Roots（虚拟机栈引用、静态变量引用、本地方法栈引用）为起点，遍历对象引用链，不可达对象标记为垃圾

* **GC 收集算法**：

  * 标记 - 清除（Mark-Sweep）：标记垃圾→清除垃圾，效率低（两次遍历）、产生内存碎片 —— 老年代常用

  * 复制（Copying）：将新生代分为 Eden（8）、Survivor0（1）、Survivor1（1），Eden 满后复制存活对象到 Survivor，无碎片、效率高 —— 新生代常用

  * 标记 - 整理（Mark-Compact）：标记垃圾→将存活对象向一端移动→清除垃圾，无碎片但效率低 —— 老年代常用

* **GC 收集器**：

  * Serial 收集器：单线程 GC，Stop-The-World（STW）时间长，适用于客户端（如桌面应用）

  * Parallel 收集器：多线程 GC，注重吞吐量（GC 时间 / 总时间），JDK 默认

  * CMS 收集器：并发标记 - 清除，低延迟（STW 时间短），适用于服务端 ——Android ART 虚拟机的 Concurrent GC（并发 GC）设计参考 CMS

### 2.2 Java 并发编程（Android 多线程开发基础）

#### 2.2.1 线程基础与线程池

* **线程创建方式**：

  * 继承 Thread 类：重写`run()`方法，无法实现多继承

  * 实现 Runnable 接口：重写`run()`方法，可多实现，推荐使用

  * 实现 Callable 接口：重写`call()`方法，支持返回值和异常抛出，需配合 FutureTask 使用

* **线程状态**：

  * 新建（New）→就绪（Runnable）→运行（Running）→阻塞（Blocked/Waiting/Timed Waiting）→死亡（Terminated）

  * 阻塞状态区别：

    * Blocked：等待锁（如`synchronized`未获取锁）

    * Waiting：无超时等待（如`Object.wait()`、`Thread.join()`）

    * Timed Waiting：有超时等待（如`Object.wait(1000)`、`Thread.sleep(1000)`）

* **线程池核心参数（ThreadPoolExecutor）**：

  * 核心线程数（corePoolSize）：常驻线程数，即使空闲也不销毁

  * 最大线程数（maximumPoolSize）：线程池允许的最大线程数

  * 空闲线程存活时间（keepAliveTime）：核心线程外的线程空闲超过此时间销毁

  * 工作队列（workQueue）：存储待执行任务，如 LinkedBlockingQueue（无界队列）、ArrayBlockingQueue（有界队列）

  * 拒绝策略（RejectedExecutionHandler）：任务满时处理方式，如 AbortPolicy（抛异常，默认）、CallerRunsPolicy（调用者线程执行）——Android 中线程池优化（如避免 OOM）需合理配置队列和拒绝策略

#### 2.2.2 同步与锁机制

* **synchronized 底层**：

  * 修饰方法：锁对象为 this（非静态方法）或类对象（静态方法）

  * 修饰代码块：锁对象为括号内的对象

  * 底层实现：基于对象头的 Mark Word（存储锁状态：无锁、偏向锁、轻量级锁、重量级锁），通过监视器锁（Monitor）实现，JDK 1.6 后优化为偏向锁（减少无竞争开销）、轻量级锁（CAS 自旋，避免线程阻塞）、重量级锁（操作系统互斥量，线程阻塞）

* **volatile 关键字**：

  * 可见性：禁止 CPU 缓存，写操作后立即刷新到主内存，读操作直接从主内存读取

  * 有序性：禁止指令重排序（通过内存屏障），如 DCL（双重检查锁定）单例模式中需用 volatile 修饰实例变量（防止指令重排序导致未初始化的实例被使用）

  * 不保证原子性：如`volatile int i=0; i++`仍需配合锁或原子类（AtomicInteger）保证原子性

* **原子类（java.util.concurrent.atomic）**：

  * 基于 CAS（Compare And Swap）实现原子操作，无锁机制，效率高于 synchronized

  * 常用类：AtomicInteger（原子 int）、AtomicReference（原子引用）、AtomicStampedReference（解决 ABA 问题）——Android 中线程安全的计数器、状态标记常用原子类

## 三、Android 底层原理：Framework 层核心知识

### 3.1 Android 系统架构（从底层到上层）

| 架构层       | 核心组件                            | 底层实现与作用                           |
| --------- | ------------------------------- | --------------------------------- |
| 应用层       | 系统应用、第三方应用                      | 基于 Framework 层 API 开发，运行在独立进程中    |
| 应用框架层     | ActivityManager、WindowManager 等 | Java 层框架，提供应用开发 API，依赖 Native 层服务 |
| 系统运行库层    | Binder 驱动、ART 虚拟机、媒体库           | C/C++ 实现，为 Framework 层提供底层支持      |
| Linux 内核层 | 进程管理、内存管理、驱动                    | Android 系统的底层内核，提供硬件抽象            |

### 3.2 Binder 机制：Android IPC 的核心（底层实现必掌握）

#### 3.2.1 Binder 通信模型

* **四组件架构**：

  * Client（客户端）：请求服务的进程，如 App 进程

  * Server（服务端）：提供服务的进程，如 SystemServer 进程（管理 AMS、WMS 等）

  * ServiceManager（SM）：Binder 服务注册表，管理 Server 的 Binder 引用，Client 通过 SM 获取 Server 的 Binder 代理

  * Binder 驱动：内核层组件，负责进程间数据传输、Binder 引用管理、线程调度

* **通信流程（以 App 调用 AMS 为例）**：

1. Server（AMS）向 SM 注册服务，SM 记录 AMS 的 Binder 引用和服务名（如 "activity"）

2. Client（App）向 SM 查询 "activity" 服务，SM 返回 AMS 的 Binder 代理（BinderProxy）

3. Client 通过 BinderProxy 发送请求（如 startActivity），请求经 Binder 驱动转发到 Server

4. Server 处理请求后，将结果经 Binder 驱动返回给 Client

#### 3.2.2 Binder 底层实现（基于 Linux 内核）

* **内存映射（mmap）**：Binder 高效通信的核心，仅需 1 次数据拷贝（传统 IPC 需 2 次：用户→内核→用户）

  * 流程：Binder 驱动为 Client 和 Server 创建共享内存区域，Client 将请求数据写入共享内存，Server 直接从共享内存读取数据，无需拷贝

* **Binder 引用计数**：

  * 内核维护 Binder 引用计数，确保 Server 进程退出时，释放所有 Client 持有的 Binder 引用，避免野指针

  * 强引用：Client 持有强引用时，Server 进程无法被查杀；弱引用：不影响 Server 进程生命周期

* **Binder 线程池**：

  * Server 进程创建 Binder 线程池（默认 16 个线程），处理 Client 的并发请求

  * 线程池调度：Binder 驱动通过轮询分配请求到空闲线程，避免单线程阻塞

### 3.3 Handler 机制：Android 消息循环核心（底层实现）

#### 3.3.1 Handler 核心组件与流程

* **四组件**：

  * Handler：发送和处理消息（`sendMessage()`、`handleMessage()`）

  * Looper：消息循环，循环从 MessageQueue 取消息并分发（`loop()`方法）

  * MessageQueue：消息队列，存储 Message，基于链表实现，按时间戳排序

  * Message：消息载体，包含 what、arg1、arg2、obj 等字段，可复用（`obtainMessage()`）

* **核心流程**：

1. 线程创建 Looper（`Looper.prepare()`），创建 MessageQueue，将 Looper 绑定到当前线程（ThreadLocal 存储）

2. Handler 初始化时，绑定当前线程的 Looper 和 MessageQueue

3. Handler 发送 Message（`sendMessage()`），MessageQueue 插入消息（`enqueueMessage()`）

4. Looper 循环调用`MessageQueue.next()`取消息，若队列空则阻塞（通过`nativePollOnce()`）

5. Looper 将消息分发给对应的 Handler（`handler.dispatchMessage()`），Handler 处理消息（`handleMessage()`）

#### 3.3.2 底层阻塞与唤醒机制（基于 Linux epoll）

* **nativePollOnce()**：

  * MessageQueue 的`next()`方法调用`nativePollOnce()`，通过 JNI 调用内核`epoll_wait()`，阻塞等待消息

  * 当 MessageQueue 为空时，线程进入阻塞状态（可中断），不消耗 CPU

* **nativeWake()**：

  * Handler 发送消息（`enqueueMessage()`）后，调用`nativeWake()`，通过 JNI 调用内核`epoll_ctl()`，唤醒阻塞的 Looper 线程

* **主线程 Looper**：

  * Android 应用启动时，ActivityThread 的`main()`方法创建主线程 Looper（`Looper.prepareMainLooper()`），启动消息循环（`Looper.loop()`）

  * 主线程 Looper 不允许退出（`quit()`方法禁用），确保应用持续运行

### 3.4 ART 虚拟机：Android 应用的运行环境（底层优化）

#### 3.4.1 ART 与 Dalvik 的区别

* **Dalvik**：Android 4.4 前使用，基于 JIT（即时编译），运行时将字节码编译为机器码，启动慢、运行效率低

* **ART**：Android 5.0 + 默认，基于 AOT（预编译）+JIT+GC 优化：

  * AOT：应用安装时，将 DEX 字节码编译为机器码（OAT 文件），启动速度提升

  * JIT：运行时监控热点代码（频繁执行的代码），动态优化编译，提升运行效率

  * 垃圾回收：并发 GC（减少 STW 时间）、分代 GC（新生代、老年代分开回收）、紧凑 GC（减少内存碎片）

#### 3.4.2 DEX 文件与 OAT 文件

* **DEX 文件**：Android 应用的字节码文件，将多个 Java 类合并为一个 DEX，减少文件大小和 IO 开销

* **OAT 文件**：ART 的可执行文件，包含 DEX 字节码和 AOT 编译后的机器码，运行时直接执行机器码，无需实时编译

* **DEX 优化（dex2oat）**：应用安装时，`dex2oat`工具将 DEX 编译为 OAT，编译过程考虑设备 CPU 架构（如 ARM、x86）

## 四、C/C++ 与 JNI：Android 底层开发基础

### 4.1 JNI 基础（Java 调用 C/C++）

#### 4.1.1 JNI 函数注册

* **静态注册**：

  * 函数名格式：`Java_包名_类名_方法名`（如`Java_com_example_NativeUtils_add`）

  * 缺点：函数名冗长，包名 / 类名修改后需重新编译

* **动态注册**：

  * 通过`JNI_OnLoad()`函数，将 Java 方法与 C/C++ 函数绑定（`RegisterNatives()`）

  * 优点：函数名灵活，支持方法名映射，Android Framework 层（如 Handler 的 Native 方法）均使用动态注册

  * 示例代码：

```txt
JNINativeMethod methods\[] = {

&#x20;   {"nativePollOnce", "(JZ)V", (void\*)android\_os\_MessageQueue\_nativePollOnce},

&#x20;   {"nativeWake", "(J)V", (void\*)android\_os\_MessageQueue\_nativeWake}

};

jint JNI\_OnLoad(JavaVM\* vm, void\* reserved) {

&#x20;   JNIEnv\* env;

&#x20;   if (vm->GetEnv((void\*\*)\&env, JNI\_VERSION\_1\_6) != JNI\_OK) {

&#x20;       return JNI\_ERR;

&#x20;   }

&#x20;   jclass clazz = env->FindClass("android/os/MessageQueue");

&#x20;   env->RegisterNatives(clazz, methods, sizeof(methods)/sizeof(methods\[0]));

&#x20;   return JNI\_VERSION\_1\_6;

}
```

#### 4.1.2 JNI 数据类型与引用管理

* **数据类型映射**：

| Java 类型 | JNI 类型  | C/C++ 类型     |
| ------- | ------- | ------------ |
| int     | jint    | int          |
| long    | jlong   | long long    |
| String  | jstring | const char\* |
| Object  | jobject | void\*       |

* **引用管理**：

  * 局部引用（Local Reference）：JNI 函数内创建，函数返回后自动释放，不能跨线程使用（如`env->NewObject()`创建的对象）

  * 全局引用（Global Reference）：需手动创建（`env->NewGlobalRef()`）和释放（`env->DeleteGlobalRef()`），可跨线程使用，避免内存泄漏

  * 弱全局引用（Weak Global Reference）：`env->NewWeakGlobalRef()`，不影响对象 GC 回收，需先检查是否存活（`env->IsSameObject()`）

### 4.2 Native 层内存管理（Android 内存泄漏排查基础）

* **Native 内存分配与释放**：

  * 分配：`malloc()`、`calloc()`、`realloc()`——Android Native 层常用

  * 释放：`free()`—— 必须与分配函数配对，否则导致 Native 内存泄漏（LeakCanary 无法检测，需用`ndk-stack`、`valgrind`工具）

* **Ashmem（匿名共享内存）**：

  * Android 特有的共享内存机制，基于 Linux 共享内存优化，支持内存大小动态调整

  * 应用场景：跨进程共享大数据（如图片、视频帧），避免 Binder 传输大数据的性能问题

  * 使用流程：`ashmem_create_region()`创建共享内存→`mmap()`映射到进程地址空间→`ioctl()`控制内存大小

* **Native 内存泄漏排查工具**：

  * `ndk-stack`：分析 Native 崩溃日志，定位崩溃位置（需符号表.so 文件）

  * `valgrind`：检测 Native 内存泄漏、越界访问（仅支持 Debug 版本，性能开销大）

  * `memtrack`：Android 系统工具，查看进程 Native 内存占用（`adb shell dumpsys memtrack <pid>`）

> （注：文档部分内容可能由 AI 生成）

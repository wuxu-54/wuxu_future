# IPC

在 Linux 系统中，**IPC（Inter-Process Communication，进程间通信）** 是不同进程之间交换数据、同步行为或传递信号的核心机制。由于 Linux 进程具有 **地址空间独立性**（每个进程的虚拟地址空间相互隔离，无法直接访问对方内存），必须通过内核提供的专用接口实现进程间交互。

Linux 继承并扩展了 Unix 的 IPC 模型，目前主流的 IPC 机制可分为 **传统 Unix IPC**、**System V IPC** 和 **POSIX IPC** 三大类，同时还包括管道、信号等基础机制。以下将从机制原理、使用场景、优缺点等维度详细解析。

## 一、基础 IPC 机制：信号（Signal）

信号是 Linux 中最古老、最基础的 IPC 方式，用于向进程传递 **异步事件通知**（如中断、错误、终止指令等），本质是内核向进程发送的“软件中断”。

### 1. 核心原理

- 每个信号对应一个唯一的整数标识（如 `SIGINT=2`、`SIGKILL=9`），内核维护进程的“信号掩码”（Signal Mask），记录哪些信号被暂时阻塞。
- 当信号产生（如用户按 `Ctrl+C` 触发 `SIGINT`、进程访问非法内存触发 `SIGSEGV`），内核会将信号加入进程的“未决信号队列”；若信号未被阻塞，进程会暂停当前执行流，转去执行该信号的 **处理函数**（默认/自定义/忽略）。

### 2. 常见信号及用途

| 信号名 | 编号 | 用途 | 默认行为 |
|--------|------|------|----------|
| `SIGINT` | 2 | 中断进程（用户按 `Ctrl+C`） | 终止进程 |
| `SIGKILL` | 9 | 强制终止进程 | 终止进程（无法捕获/忽略） |
| `SIGTERM` | 15 | 请求进程正常终止（`kill` 命令默认信号） | 终止进程 |
| `SIGSEGV` | 11 | 段错误（进程访问非法内存） | 终止进程并生成核心转储（core dump） |
| `SIGPIPE` | 13 | 向已关闭的管道写入数据 | 终止进程 |

### 3. 优缺点与场景

- **优点**：轻量、异步，可跨进程传递紧急通知。
- **缺点**：仅能传递“信号标识”，无法携带自定义数据；信号可能丢失（如未决队列中同一信号默认只存1个）。
- **典型场景**：进程终止/中断（`SIGKILL`/`SIGINT`）、异常处理（`SIGSEGV`）、父子进程同步（如子进程退出时向父进程发送 `SIGCHLD`）。

## 二、传统 Unix IPC：管道（Pipe）与命名管道（FIFO）

管道是基于“文件描述符”的字节流通信机制，本质是内核维护的一块临时缓冲区，进程通过读写文件描述符实现数据交换，遵循 **FIFO（先进先出）** 原则。

### 1. 匿名管道（Pipe）

匿名管道是最基础的管道形式，仅支持 **父子进程/兄弟进程** 间通信（依赖进程的文件描述符继承）。

#### 核心原理

- 通过 `pipe()` 系统调用创建管道，内核会分配一个缓冲区，并返回两个文件描述符：
  - `fd[0]`：只读端（接收数据）；
  - `fd[1]`：只写端（发送数据）；
- 父进程创建管道后，通过 `fork()` 创建子进程，子进程会继承父进程的管道文件描述符；之后双方关闭不需要的端（如父进程关 `fd[0]`、子进程关 `fd[1]`），即可实现单向通信。

#### 关键特性

- **单向通信**：默认是“半双工”（同一时间只能一个方向传输），需创建两个管道实现双向通信。
- **无名称**：仅通过文件描述符引用，无法被非亲缘进程访问。
- **字节流**：数据无边界，需进程自行定义“消息分隔符”（如换行符 `\n`）。
- **自动回收**：所有引用管道的进程关闭文件描述符后，内核自动释放缓冲区。

#### 示例代码片段（C语言）

```c
#include <unistd.h>
#include <stdio.h>

int main() {
    int pipe_fd[2];
    char buf[1024];
    pid_t pid;

    // 1. 创建管道
    if (pipe(pipe_fd) == -1) { perror("pipe"); return 1; }

    // 2. 创建子进程（继承管道fd）
    if ((pid = fork()) == -1) { perror("fork"); return 1; }

    if (pid == 0) { // 子进程：读数据（关闭写端fd[1]）
        close(pipe_fd[1]);
        read(pipe_fd[0], buf, sizeof(buf));
        printf("子进程收到：%s\n", buf);
        close(pipe_fd[0]);
    } else { // 父进程：写数据（关闭读端fd[0]）
        close(pipe_fd[0]);
        write(pipe_fd[1], "Hello from parent", 16);
        close(pipe_fd[1]);
        wait(NULL); // 等待子进程结束
    }
    return 0;
}
```

### 2. 命名管道（FIFO）

匿名管道的局限性在于“仅支持亲缘进程”，命名管道（FIFO，First In First Out）通过 **文件系统中的路径名** 标识，突破了亲缘关系限制，支持任意进程通信。

#### 核心原理

- 通过 `mkfifo()` 系统调用在文件系统中创建一个“FIFO文件”（类型为 `p`，可通过 `ls -l` 查看），该文件仅作为“通信入口”，数据仍存储在内核缓冲区。
- 任意进程通过 `open()` 打开该FIFO文件（读方式 `O_RDONLY` 或写方式 `O_WRONLY`），即可与其他打开该文件的进程通信。
- 特性与匿名管道一致（半双工、字节流），但支持非亲缘进程。

#### 优缺点与场景

- **优点**：支持任意进程通信，无需亲缘关系；实现简单，基于文件操作接口（`read`/`write`）。
- **缺点**：半双工（需两个FIFO实现双向）；无消息边界，需自定义协议；无法随机访问（仅FIFO顺序）。
- **典型场景**：命令行工具交互（如 `mkfifo log.fifo; tail -f log.fifo &` 后台监听日志）、不同服务进程间的低频率数据传输。

## 三、System V IPC 机制

System V IPC 是 Unix System V 标准定义的一套IPC接口，包含 **消息队列、共享内存、信号量** 三种机制，特点是通过“键（Key）”标识资源，支持持久化（资源不会随进程退出自动销毁，需手动删除）。

### 1. System V 消息队列（Message Queue）

消息队列是内核维护的 **链表结构**，用于存储“带有类型标识的消息”，进程可按“消息类型”读取数据（突破管道的FIFO限制，支持“优先级读取”）。

#### 核心原理

- 进程通过 `msgget()` 系统调用创建/获取消息队列（需指定一个唯一的 `key_t` 键值，通常通过 `ftok()` 从文件路径生成）。
- 发送进程通过 `msgsnd()` 向队列发送消息（消息结构包含“类型”和“数据”）；接收进程通过 `msgrcv()` 从队列读取消息（可指定读取特定类型的消息）。
- 消息队列的生命周期由内核管理，需通过 `msgctl()` 手动删除（否则会残留在内核中，可通过 `ipcs -q` 查看）。

#### 优缺点与场景

- **优点**：支持消息类型（可按优先级读取）；消息有边界（无需自定义分隔符）；支持非亲缘进程。
- **缺点**：消息大小和队列容量有限（内核参数限制，如 `MSGMAX` 限制单条消息大小）；效率低于共享内存；资源需手动回收，易泄漏。
- **典型场景**：进程间需要按优先级传递结构化数据的场景（如任务调度系统）。

### 2. System V 共享内存（Shared Memory）

共享内存是 **效率最高** 的 IPC 机制，它直接让多个进程共享一块物理内存区域（映射到各自的虚拟地址空间），进程无需通过内核转发数据，直接读写内存即可。

#### 核心原理

1. **创建共享内存**：进程通过 `shmget()` 创建/获取一块共享内存（指定键值和大小），内核会分配物理内存，并返回一个“共享内存标识符（shmid）”。
2. **映射到虚拟地址**：进程通过 `shmat()` 将共享内存映射到自身的虚拟地址空间，获得一个指针，之后可通过该指针直接读写共享内存。
3. **解除映射与删除**：进程退出前通过 `shmdt()` 解除虚拟地址映射；最后一个进程需通过 `shmctl()` 手动删除共享内存（否则残留，可通过 `ipcs -m` 查看）。

#### 关键问题：同步与互斥

共享内存本身 **不提供同步机制**，多个进程同时读写可能导致“数据竞争”（如进程A写一半时进程B读取），因此必须搭配 **信号量** 或 **互斥锁** 实现同步。

#### 优缺点与场景

- **优点**：效率极高（无内核转发开销）；数据传输量大（仅受内存大小限制）。
- **缺点**：需手动处理同步（复杂度高）；资源需手动回收，易泄漏；安全性低（无访问控制，需进程自行保证数据一致性）。
- **典型场景**：高频、大数据量的进程间通信（如数据库服务、视频处理程序）。

### 3. System V 信号量（Semaphore）

信号量本质是内核维护的一个 **计数器**，用于实现进程间的 **同步与互斥**（如控制对共享资源的访问），而非传递数据。

#### 核心概念

- **互斥（Mutual Exclusion）**：保证同一时间只有一个进程访问共享资源（信号量初始值为1，称为“互斥锁”）。
- **同步（Synchronization）**：协调多个进程的执行顺序（如进程A必须在进程B之后执行，信号量初始值为0）。
- **P操作（Wait）**：信号量值减1，若结果小于0，进程阻塞（等待其他进程释放资源）。
- **V操作（Signal）**：信号量值加1，若结果大于等于0，唤醒一个阻塞的进程。

#### 核心原理

- 进程通过 `semget()` 创建/获取一个“信号量集”（可包含多个信号量，用于管理多组资源），返回信号量标识符（semid）。
- 进程通过 `semop()` 执行P/V操作（传入操作数组，指定对哪个信号量执行P/V）。
- 最后通过 `semctl()` 手动删除信号量集（否则残留，可通过 `ipcs -s` 查看）。

#### 优缺点与场景

- **优点**：可靠的同步机制，支持多进程互斥/同步；可管理多个资源（信号量集）。
- **缺点**：仅用于同步，不传递数据；操作复杂（需处理信号量集、错误码）；资源需手动回收。
- **典型场景**：搭配共享内存/消息队列使用，保证共享资源的安全访问（如多进程读写共享内存时的互斥）。

## 四、POSIX IPC 机制

POSIX IPC 是 POSIX 标准定义的新一代 IPC 接口，旨在替代 System V IPC，解决其“资源泄漏、接口复杂”等问题，支持 **消息队列、共享内存、信号量** 三种机制，且接口更统一（基于“名字”而非“键”）。

### 1. POSIX 消息队列

与 System V 消息队列功能类似，但接口更简洁，支持 **消息优先级** 和 **异步通知**（通过信号或线程通知进程有新消息）。

- 核心接口：`mq_open()`（创建/打开队列，名字格式为 `/mqname`）、`mq_send()`/`mq_receive()`（发送/接收消息）、`mq_close()`/`mq_unlink()`（关闭/删除队列）。
- 优势：支持消息优先级；资源自动回收（最后一个进程 `mq_close()` 后，队列仍存在，需 `mq_unlink()` 删除，但接口更清晰）；支持异步通知。

### 2. POSIX 共享内存

与 System V 共享内存原理一致，但映射流程更简化（结合文件系统，通过 `shm_open()` 创建“共享内存文件”，再通过 `mmap()` 映射到虚拟地址）。

- 核心接口：`shm_open()`（创建/打开共享内存文件，路径为 `/shmname`）、`ftruncate()`（设置共享内存大小）、`mmap()`（映射到虚拟地址）、`munmap()`/`shm_unlink()`（解除映射/删除文件）。
- 优势：基于文件系统，管理更直观（可通过 `ls /dev/shm/` 查看共享内存文件）；接口与文件操作更统一（如 `ftruncate()` 调整大小）。

### 3. POSIX 信号量

分为 **有名信号量**（支持任意进程）和 **无名信号量**（仅支持线程或共享内存的进程），接口更简洁，支持线程同步。

- 核心接口（有名信号量）：`sem_open()`（创建/打开信号量，名字为 `/semname`）、`sem_wait()`（P操作）、`sem_post()`（V操作）、`sem_close()`/`sem_unlink()`（关闭/删除）。
- 优势：支持线程同步（无名信号量）；接口更简单，无需处理信号量集；资源管理更清晰。

## 五、其他 IPC 机制

### 1. 套接字（Socket）

Socket 原本用于 **网络通信**（跨主机进程），但在 Linux 中也支持 **本地进程通信**（通过 `AF_UNIX` 域套接字），是功能最强大的 IPC 机制之一。

- 核心原理：本地套接字通过文件系统中的路径标识（如 `/tmp/mysocket`），数据不经过网络协议栈，直接在内核中转发，效率接近管道。
- 优势：支持双向通信（全双工）；接口统一（网络/本地通信可复用代码）；支持多客户端连接（如服务器进程同时与多个客户端通信）。
- 场景：本地服务程序（如数据库、Web服务器）与客户端的通信（如 `mysql` 客户端与 `mysqld` 进程）。

### 2. 文件（File）

通过读写同一个文件实现进程间通信，是最直观的方式，但效率较低。

- 原理：进程A将数据写入文件，进程B通过读取该文件获取数据，需自行处理“文件锁”（如 `flock()`、`fcntl()`）保证同步。
- 优势：简单易懂，数据可持久化（文件保存在磁盘）。
- 缺点：效率低（磁盘I/O开销）；同步复杂（需处理锁竞争、文件截断等问题）。
- 场景：低频率、大数据量且需持久化的通信（如日志同步、配置文件更新）。

## 六、Linux 主流 IPC 机制对比

| 机制         | 通信方式 | 数据边界 | 同步支持 | 亲缘限制 | 效率   | 典型场景                     |
|--------------|----------|----------|----------|----------|--------|------------------------------|
| 信号         | 异步通知 | 无（仅标识） | 无       | 无       | 极高   | 进程终止、异常通知           |
| 匿名管道     | 字节流   | 无       | 无       | 有（亲缘） | 中     | 父子进程简单数据传输         |
| 命名管道     | 字节流   | 无       | 无       | 无       | 中     | 非亲缘进程低频率通信         |
| System V 消息队列 | 消息（带类型） | 有       | 无       | 无       | 中     | 按优先级传递结构化数据       |
| System V 共享内存 | 共享内存 | 无       | 需搭配信号量 | 无       | 极高   | 高频、大数据量通信           |
| System V 信号量 | 计数器   | 无（仅同步） | 有       | 无       | 中     | 共享资源互斥/同步            |
| POSIX 共享内存 | 共享内存 | 无       | 需搭配信号量 | 无       | 极高   | 现代高频通信（替代System V） |
| AF_UNIX 套接字 | 字节流/数据报 | 可选     | 无       | 无       | 中     | 本地服务与客户端通信         |

## 七、总结

Linux 的 IPC 机制覆盖了从“简单通知”到“高频大数据传输”的全场景，选择时需根据 **通信频率、数据量、同步需求、亲缘关系** 综合判断：

- 若需 **异步通知**（如终止进程）：优先用 **信号**；
- 若需 **简单亲缘进程通信**（如脚本管道）：优先用 **匿名管道**；
- 若需 **非亲缘进程低频率通信**：优先用 **命名管道** 或 **AF_UNIX 套接字**；
- 若需 **高频大数据量通信**：优先用 **POSIX 共享内存**（搭配 POSIX 信号量同步）；
- 若需 **按优先级传递结构化数据**：优先用 **POSIX 消息队列**；
- 若需 **本地服务多客户端通信**：优先用 **AF_UNIX 套接字**（接口统一，支持全双工）。

理解不同 IPC 机制的底层原理和适用场景，是 Linux 进程开发和性能优化的核心基础。

# mmap

`mmap`（Memory Mapping，内存映射）是 Unix/Linux 系统中一种高效的 I/O 机制，它将**文件或其他对象**直接映射到进程的虚拟地址空间，使进程可以通过**内存读写操作**替代传统的 `read`/`write` 系统调用来操作文件，从而大幅减少数据拷贝开销，提升 I/O 性能。

## 一、mmap 核心功能与设计初衷

传统文件 I/O（`read`/`write`）存在**两次数据拷贝**：  

1. 磁盘数据 → 内核缓冲区（内核态）；  
2. 内核缓冲区 → 用户态缓冲区（用户进程内存）。  

而 `mmap` 通过将文件直接映射到进程的虚拟地址空间，使进程可以**直接读写内存**（映射区域）来操作文件，仅需**一次数据拷贝**（磁盘 → 内存映射区域），彻底消除了内核态与用户态之间的拷贝开销。

此外，`mmap` 还支持**进程间共享内存**（多进程映射同一文件）和**匿名内存分配**（无需文件支持，用于进程内或进程间临时共享数据），是高性能 I/O 和进程通信的核心机制。

## 二、mmap 系统调用原型与参数解析

`mmap` 的系统调用原型如下（C语言）：

```c
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

### 参数详解：

1. **`addr`**：  
   - 建议的映射起始虚拟地址（用户指定）。  
   - 内核通常会忽略该值（为 `NULL` 时由内核自动选择合适地址），仅当 `flags` 包含 `MAP_FIXED` 时强制使用该地址（不推荐，可能导致地址冲突）。  

2. **`length`**：  
   - 映射的内存长度（字节），必须 ≥ 0。  
   - 实际映射大小会被内核向上取整为**页大小的整数倍**（通常 4KB，可通过 `getpagesize()` 获取）。  

3. **`prot`**：  
   - 映射区域的**保护权限**（内存访问权限），必须指定以下至少一种，且不能与文件打开权限冲突：  
     - `PROT_READ`：可读（对应文件需有读权限）；  
     - `PROT_WRITE`：可写（对应文件需有写权限）；  
     - `PROT_EXEC`：可执行（映射区域的指令可被CPU执行）；  
     - `PROT_NONE`：不可访问（任何读写都会触发段错误）。  

4. **`flags`**：  
   - 映射类型和行为标志，核心标志如下（必选其一或组合）：  
     - **共享与私有映射**（核心区分）：  
       - `MAP_SHARED`：对映射区域的修改会**同步回原文件**，且对其他映射同一文件的进程可见（共享修改）；  
       - `MAP_PRIVATE`：对映射区域的修改是**进程私有**（写时复制，Copy-On-Write），不会同步回原文件，也不影响其他进程。  
     - **匿名映射**（无需文件支持）：  
       - `MAP_ANONYMOUS`（或 `MAP_ANON`）：映射不关联任何文件（`fd` 需设为 `-1`，`offset` 忽略），通常用于进程内动态内存分配或进程间共享内存（需配合 `MAP_SHARED`）。  
     - **其他常用标志**：  
       - `MAP_FIXED`：强制使用 `addr` 作为映射起始地址（若该地址已被占用则失败，风险高，慎用）；  
       - `MAP_LOCKED`：将映射区域锁定在物理内存（不被换出到swap），需 `CAP_IPC_LOCK` 权限。  

5. **`fd`**：  
   - 待映射的文件描述符（通过 `open` 获得）。  
   - 若为匿名映射（`MAP_ANONYMOUS`），`fd` 需设为 `-1`。  

6. **`offset`**：  
   - 文件中映射的起始偏移量（字节），必须是**页大小的整数倍**（否则返回 `MAP_FAILED`）。  

### 返回值：

- 成功：返回映射区域的起始虚拟地址（`void *`）；  
- 失败：返回 `MAP_FAILED`（通常是 `(void *)-1`），并设置 `errno`（如 `EINVAL` 表示参数无效，`ENOMEM` 表示内存不足）。  

## 三、mmap 工作原理（从映射到访问）

`mmap` 的核心是建立**虚拟地址空间 ↔ 文件/物理内存**的映射关系，整个过程可分为三个阶段：

### 1. 映射创建（`mmap` 调用时）

- 内核在进程的虚拟地址空间中**分配一块连续的虚拟地址区域**（大小为 `length` 向上取整为页大小的倍数）。  
- 内核创建**映射结构体**（记录文件描述符、偏移量、长度、保护权限等信息），并将其与进程的虚拟地址空间关联。  
- **不立即加载文件数据到物理内存**（按需分页，Lazy Allocation），仅建立虚拟地址与文件页的映射关系（页表项标记为“未分配”）。  

### 2. 首次访问（缺页中断）

当进程读写映射区域的虚拟地址时，由于对应的物理内存尚未分配，CPU 会触发**缺页中断**（Page Fault），内核处理流程如下：  

- 检查虚拟地址是否在 `mmap` 映射范围内，权限是否匹配（如写操作需 `PROT_WRITE`）。  
- 若合法，内核从磁盘读取文件中对应偏移量的数据（大小为一页），分配物理内存页，并将数据加载到该页。  
- 更新进程页表：将虚拟地址与新分配的物理页关联，标记页表项为“已分配”和对应权限（读/写）。  
- 中断处理完成，进程恢复执行，此时可正常访问该虚拟地址。  

### 3. 数据同步（修改后）

- 若为 `MAP_SHARED` 映射：进程对映射区域的修改会**异步同步回磁盘文件**（由内核的页缓存机制负责，类似 `write` 的延迟写）。若需立即同步，需调用 `msync`。  
- 若为 `MAP_PRIVATE` 映射：进程首次修改时触发**写时复制**（Copy-On-Write）：内核为该页分配新的物理内存，复制原数据，更新页表指向新页，后续修改仅作用于新页（不影响原文件和其他进程）。  

## 四、mmap 相关系统调用

### 1. 解除映射：`munmap`

```c
int munmap(void *addr, size_t length);
```

- 功能：解除从 `addr` 开始、长度为 `length` 的映射区域（需与 `mmap` 的映射范围一致）。  
- 注意：解除映射后，该虚拟地址区域不再有效，访问会触发段错误（SIGSEGV）。  

### 2. 同步映射到文件：`msync`

```c
int msync(void *addr, size_t length, int flags);
```

- 功能：将 `MAP_SHARED` 映射区域的修改**强制同步到磁盘文件**（解决 `MAP_SHARED` 异步同步的不确定性）。  
- `flags` 选项：  
  - `MS_SYNC`：同步等待（直到数据写入磁盘才返回）；  
  - `MS_ASYNC`：异步同步（仅调度写入，立即返回）；  
  - `MS_INVALIDATE`：使其他进程对同一文件的映射失效（重新从磁盘加载最新数据）。  

### 3. 锁定映射区域：`mlock`/`mlockall`

```c
int mlock(const void *addr, size_t length);  // 锁定指定地址范围
int mlockall(int flags);                     // 锁定进程所有虚拟地址空间
```

- 功能：将映射区域锁定在物理内存（不被换出到 swap），适用于低延迟场景（如实时数据处理）。  
- 需 `CAP_IPC_LOCK` 权限，且锁定内存量受 `/proc/sys/vm/mlock_max` 限制。  

## 五、mmap 常见映射类型与场景

### 1. 文件映射（关联文件的映射）

通过 `fd` 关联文件，将文件内容映射到进程内存，适用于**大文件高效读写**。

#### 示例：用 mmap 读取并修改文件

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>

int main() {
    int fd;
    struct stat st;
    char *map_addr;

    // 1. 打开文件（需读权限，若要写需加O_WRONLY/O_RDWR）
    fd = open("test.txt", O_RDWR);
    if (fd == -1) { perror("open"); exit(1); }

    // 2. 获取文件大小（用于映射长度）
    if (fstat(fd, &st) == -1) { perror("fstat"); exit(1); }
    size_t file_size = st.st_size;

    // 3. 映射文件到内存（共享映射，可读可写）
    map_addr = mmap(NULL, file_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (map_addr == MAP_FAILED) { perror("mmap"); exit(1); }

    // 4. 操作映射区域（像内存一样读写文件）
    printf("原内容: %s\n", map_addr);
    map_addr[0] = 'H';  // 修改首字符（会同步回文件，因MAP_SHARED）

    // 5. 解除映射
    if (munmap(map_addr, file_size) == -1) { perror("munmap"); exit(1); }

    // 6. 关闭文件
    close(fd);
    return 0;
}
```

### 2. 匿名映射（无文件关联的映射）

通过 `MAP_ANONYMOUS` 创建，不关联任何文件，适用于：  

- **进程内大块内存分配**（比 `malloc` 更高效，尤其当内存大小超过 `MMAP_THRESHOLD` 时，glibc 的 `malloc` 会自动使用 `mmap`）；  
- **进程间共享内存**（多进程通过 `fork` 继承匿名映射，或通过 `shm_open` 配合 `mmap` 实现）。

#### 示例：匿名映射实现父子进程共享内存

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    // 创建匿名共享映射（大小4KB，可读可写，父子进程共享）
    int *shared_data = mmap(NULL, 4096, PROT_READ | PROT_WRITE, 
                           MAP_ANONYMOUS | MAP_SHARED, -1, 0);
    if (shared_data == MAP_FAILED) { perror("mmap"); exit(1); }

    *shared_data = 0;  // 初始值

    pid_t pid = fork();
    if (pid == -1) { perror("fork"); exit(1); }

    if (pid == 0) {  // 子进程：修改共享数据
        *shared_data = 100;
        printf("子进程修改后: %d\n", *shared_data);
        munmap(shared_data, 4096);  // 子进程解除映射
        exit(0);
    } else {  // 父进程：等待子进程并读取共享数据
        wait(NULL);
        printf("父进程读取: %d\n", *shared_data);  // 输出100（子进程修改生效）
        munmap(shared_data, 4096);  // 父进程解除映射
    }

    return 0;
}
```

### 3. 共享内存通信（多进程映射同一文件）

多个进程通过 `mmap` 映射同一文件，实现高效数据共享（无需内核中转，直接内存访问）。  

- 步骤：进程A创建文件 → 映射为 `MAP_SHARED` → 写入数据；进程B打开同一文件 → 映射为 `MAP_SHARED` → 读取数据（实时可见A的修改）。  

## 六、mmap 优缺点与适用场景

### 优点：

1. **减少数据拷贝**：相比 `read`/`write` 减少一次内核态→用户态拷贝，大文件读写效率提升显著。  
2. **操作简单**：将文件视为内存数组，通过指针直接读写，无需处理 `read` 的返回值（部分读取）等复杂逻辑。  
3. **共享高效**：多进程映射同一文件时，共享数据无需额外IPC机制（如管道、消息队列），适合高频数据交换。  
4. **灵活的内存分配**：匿名映射可分配大块内存（不受堆大小限制），且释放时无需逐个释放（`munmap` 一次解除）。  

### 缺点：

1. **页对齐限制**：`offset` 必须是页大小的整数倍，`length` 会被向上取整为页大小，可能浪费少量内存。  
2. **潜在的信号风险**：若映射的文件被截断（`truncate`），访问超出新文件大小的区域会触发 `SIGBUS` 信号（终止进程）。  
3. **内存占用**：`MAP_PRIVATE` 映射修改大量数据时，会因写时复制分配大量物理页，可能导致内存紧张。  
4. **同步开销**：`MAP_SHARED` 的异步同步可能导致数据丢失（如进程崩溃前未同步），需手动调用 `msync` 保证可靠性（增加开销）。  

### 适用场景：

- **大文件频繁读写**（如数据库、日志系统）：减少拷贝开销，提升吞吐量。  
- **进程间高频数据共享**（如多线程服务、分布式计算）：通过共享内存避免IPC中转。  
- **大块内存分配**（如视频处理、科学计算）：匿名映射比 `malloc` 更高效，且无堆碎片问题。  
- **零拷贝I/O**（如网络传输）：结合 `sendfile` 或直接将文件映射到用户态，减少数据移动。  

## 七、mmap 与传统 I/O（read/write）的对比

| 维度                | mmap                          | read/write                     |
|---------------------|-------------------------------|--------------------------------|
| 数据拷贝次数        | 1次（磁盘→映射区域）          | 2次（磁盘→内核缓冲区→用户缓冲区） |
| 适用文件大小        | 大文件（≥1MB）效率更高        | 小文件（<1MB）更灵活           |
| 操作复杂度          | 简单（指针操作）              | 复杂（需处理部分读取、缓冲区管理） |
| 共享能力            | 支持多进程共享（MAP_SHARED）  | 需额外IPC机制（如管道）         |
| 内存占用            | 可能因页对齐浪费少量内存      | 需维护用户缓冲区               |
| 同步可靠性          | 需手动 msync 保证（MAP_SHARED）| 写入即进入内核缓冲区（延迟刷盘） |

## 八、注意事项与最佳实践

1. **页对齐检查**：确保 `offset` 是页大小的整数倍（可通过 `offset & (getpagesize() - 1) == 0` 验证），否则 `mmap` 会失败。  
2. **文件大小处理**：映射长度建议与文件大小一致，避免访问超出文件范围的地址（可能触发 `SIGBUS`）。  
3. **及时解除映射**：不再使用的映射区域需用 `munmap` 解除，否则会导致内存泄漏（进程退出前不会自动释放）。  
4. **谨慎使用 MAP_FIXED**：强制指定地址可能覆盖已有映射（如动态库、堆），导致程序崩溃。  
5. **同步策略**：`MAP_SHARED` 映射在关键数据修改后调用 `msync(..., MS_SYNC)` 确保数据写入磁盘，避免进程崩溃丢失数据。  

## 总结

`mmap` 是 Linux 中高效的 I/O 与内存管理机制，通过将文件映射到虚拟地址空间，实现了“以内存操作代文件操作”的高效模式。其核心优势在于减少数据拷贝、简化操作、支持高效共享，尤其适合大文件处理和进程间高频通信。但需注意页对齐、同步可靠性等细节，才能充分发挥其性能优势。

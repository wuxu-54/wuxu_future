# mmap 共享内存

`mmap` 是实现进程间共享内存的高效机制，它通过将同一块物理内存映射到多个进程的虚拟地址空间，使进程可以直接通过内存读写实现数据交换，避免了传统 IPC 机制（如管道、消息队列）的内核中转开销。下面详细解析 `mmap` 实现进程间共享内存的原理、方法和注意事项。

## 一、mmap 实现进程间共享内存的核心原理

进程间共享内存的本质是让多个进程的虚拟地址空间映射到**同一块物理内存**。`mmap` 实现这一目标的方式有两种：  

1. **基于文件的共享映射（`MAP_SHARED` + 磁盘文件）**：多个进程通过映射同一个磁盘文件，共享内核页缓存中的物理内存页。  
2. **匿名共享映射（`MAP_ANONYMOUS | MAP_SHARED`）**：不依赖磁盘文件，内核直接分配物理内存，通过 `fork` 继承或特殊文件（如 `/dev/shm`）实现进程间共享。  

两种方式的核心都是通过 `mmap` 的 `MAP_SHARED` 标志，确保对映射区域的修改能被其他进程可见。

## 二、基于文件的共享内存（`MAP_SHARED` + 磁盘文件）

这种方式利用磁盘文件作为共享内存的“载体”，多个进程通过映射同一个文件实现数据共享，适合需要**持久化共享数据**的场景（如进程重启后数据不丢失）。

### 实现步骤

1. **创建/打开共享文件**：一个进程创建文件并写入初始数据，其他进程打开该文件。  
2. **映射文件为共享内存**：所有进程通过 `mmap` 以 `MAP_SHARED` 标志映射该文件，指定相同的文件描述符、偏移量和长度。  
3. **读写共享内存**：任意进程对映射区域的修改会自动同步到文件（由内核页缓存机制负责），其他进程可立即看到修改。  
4. **解除映射与清理**：进程退出前用 `munmap` 解除映射，最后一个进程可删除文件（可选）。  

### 示例代码（两个进程共享文件映射）

#### 进程A（写入共享数据）

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>

#define FILE_PATH "shared_mem.dat"
#define SIZE 4096  // 映射大小（页对齐）

int main() {
    int fd;
    char *shared_mem;

    // 1. 创建并打开共享文件（读写权限）
    fd = open(FILE_PATH, O_CREAT | O_RDWR, 0666);
    if (fd == -1) { perror("open"); exit(1); }

    // 2. 扩展文件大小（否则映射后写入会触发SIGBUS）
    if (ftruncate(fd, SIZE) == -1) { perror("ftruncate"); exit(1); }

    // 3. 映射文件为共享内存（MAP_SHARED：修改同步到文件和其他进程）
    shared_mem = mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (shared_mem == MAP_FAILED) { perror("mmap"); exit(1); }

    // 4. 写入共享数据
    sprintf(shared_mem, "Hello from Process A! Counter: %d", 0);
    printf("Process A wrote: %s\n", shared_mem);

    // 等待Process B读取（实际场景用信号量/条件变量同步）
    sleep(10);

    // 5. 解除映射并清理
    munmap(shared_mem, SIZE);
    close(fd);
    // unlink(FILE_PATH);  // 可选：最后一个进程删除文件
    return 0;
}
```

#### 进程B（读取并修改共享数据）

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>

#define FILE_PATH "shared_mem.dat"
#define SIZE 4096

int main() {
    int fd;
    char *shared_mem;

    // 1. 打开共享文件（Process A已创建）
    fd = open(FILE_PATH, O_RDWR);
    if (fd == -1) { perror("open"); exit(1); }

    // 2. 映射文件为共享内存（与Process A映射相同的文件）
    shared_mem = mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (shared_mem == MAP_FAILED) { perror("mmap"); exit(1); }

    // 3. 读取并修改共享数据
    printf("Process B read: %s\n", shared_mem);
    sprintf(shared_mem, "Hello from Process B! Counter: %d", 1);
    printf("Process B modified: %s\n", shared_mem);

    // 4. 解除映射
    munmap(shared_mem, SIZE);
    close(fd);
    return 0;
}
```

### 关键特性

- **数据持久化**：修改会同步到磁盘文件，进程重启后可重新映射文件恢复数据。  
- **跨非亲缘进程**：无需父子关系，任意进程只要能访问文件即可共享（通过文件权限控制访问）。  
- **同步机制**：示例中用 `sleep` 简化同步，实际需搭配信号量（`semaphore`）或互斥锁（`mutex`）防止数据竞争。  

## 三、匿名共享映射（`MAP_ANONYMOUS | MAP_SHARED`）

匿名映射不关联磁盘文件，内存区域由内核直接分配，适合**临时共享数据**（进程退出后数据消失）。根据进程关系，有两种实现方式：

### 1. 父子进程共享（通过 `fork` 继承）

父子进程通过 `fork` 继承匿名映射的内存区域，适合亲缘进程间的临时数据共享。

#### 实现原理

- 父进程创建匿名映射（`MAP_ANONYMOUS | MAP_SHARED`）。  
- `fork` 后，子进程继承该映射（虚拟地址可能不同，但指向同一块物理内存）。  
- 父子进程对映射区域的修改相互可见。

#### 示例代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/wait.h>

#define SIZE 4096

int main() {
    // 1. 创建匿名共享映射（不关联文件，fd=-1）
    int *shared_data = mmap(NULL, SIZE, PROT_READ | PROT_WRITE, 
                           MAP_ANONYMOUS | MAP_SHARED, -1, 0);
    if (shared_data == MAP_FAILED) { perror("mmap"); exit(1); }

    *shared_data = 0;  // 初始值

    pid_t pid = fork();
    if (pid == -1) { perror("fork"); exit(1); }

    if (pid == 0) {  // 子进程：修改共享数据
        *shared_data = 100;
        printf("Child: set shared_data = %d\n", *shared_data);
        munmap(shared_data, SIZE);
        exit(0);
    } else {  // 父进程：读取修改后的数据
        wait(NULL);  // 等待子进程完成
        printf("Parent: read shared_data = %d\n", *shared_data);  // 输出100
        munmap(shared_data, SIZE);
    }

    return 0;
}
```

### 2. 非亲缘进程共享（通过 `/dev/shm` 临时文件）

`/dev/shm` 是 Linux 系统中基于内存的临时文件系统（tmpfs），文件内容存储在内存中（而非磁盘），结合 `mmap` 可实现非亲缘进程的匿名共享（本质是“伪匿名”，依赖内存文件）。

#### 实现步骤

1. 进程A通过 `shm_open` 创建 `/dev/shm` 下的临时文件（如 `shm_abc`）。  
2. 进程A用 `ftruncate` 设置文件大小，再通过 `mmap(MAP_SHARED)` 映射。  
3. 进程B通过 `shm_open` 打开同一文件，同样 `mmap` 映射。  
4. 两进程共享该内存区域，进程退出后可通过 `shm_unlink` 删除临时文件。

#### 示例代码（非亲缘进程）

#### 进程A（创建共享内存）

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#define SHM_NAME "/shm_example"
#define SIZE 4096

int main() {
    int shm_fd;
    char *shared_mem;

    // 1. 创建/dev/shm下的共享内存文件（O_CREAT：不存在则创建）
    shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) { perror("shm_open"); exit(1); }

    // 2. 设置共享内存大小
    if (ftruncate(shm_fd, SIZE) == -1) { perror("ftruncate"); exit(1); }

    // 3. 映射为共享内存
    shared_mem = mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_mem == MAP_FAILED) { perror("mmap"); exit(1); }

    // 4. 写入数据
    sprintf(shared_mem, "Shared data from Process A");
    printf("Process A wrote: %s\n", shared_mem);

    // 等待Process B读取
    sleep(10);

    // 5. 清理
    munmap(shared_mem, SIZE);
    close(shm_fd);
    shm_unlink(SHM_NAME);  // 删除共享内存文件
    return 0;
}
```

#### 进程B（访问共享内存）

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#define SHM_NAME "/shm_example"
#define SIZE 4096

int main() {
    int shm_fd;
    char *shared_mem;

    // 1. 打开已创建的共享内存文件
    shm_fd = shm_open(SHM_NAME, O_RDWR, 0666);
    if (shm_fd == -1) { perror("shm_open"); exit(1); }

    // 2. 映射为共享内存
    shared_mem = mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_mem == MAP_FAILED) { perror("mmap"); exit(1); }

    // 3. 读取并修改数据
    printf("Process B read: %s\n", shared_mem);
    sprintf(shared_mem, "Modified by Process B");
    printf("Process B modified: %s\n", shared_mem);

    // 4. 清理
    munmap(shared_mem, SIZE);
    close(shm_fd);
    return 0;
}
```

### 关键特性

- **内存存储**：`/dev/shm` 文件存储在内存中，读写速度快，进程退出后数据可通过 `shm_unlink` 自动清理。  
- **非亲缘支持**：突破 `fork` 限制，任意进程可通过文件名访问共享内存。  
- **大小限制**：默认受 `/dev/shm` 挂载大小限制（通常为物理内存的一半，可通过 `mount -o remount,size=4G /dev/shm` 调整）。  

## 四、共享内存的同步机制（避免数据竞争）

`mmap` 共享内存本身**不提供同步机制**，多个进程同时读写可能导致数据不一致（如进程A写入一半时进程B读取）。必须通过以下方式保证同步：

### 1. 信号量（Semaphore）

最常用的同步方式，通过计数器控制对共享资源的访问。  

- **P操作（`sem_wait`）**：获取资源前减1，若为负数则阻塞。  
- **V操作（`sem_post`）**：释放资源后加1，唤醒阻塞进程。  

#### 示例：用信号量保护共享内存

```c
#include <semaphore.h>
#include <fcntl.h>

// 在共享内存中定义信号量（或单独创建命名信号量）
typedef struct {
    sem_t sem;  // 信号量
    int data;   // 共享数据
} SharedStruct;

// 初始化信号量（进程A）
SharedStruct *shared = mmap(...);  // 映射共享内存
sem_init(&shared->sem, 1, 1);  // 1：共享给其他进程；初始值1（互斥锁）

// 进程A写入数据
sem_wait(&shared->sem);       // 加锁
shared->data = 100;           // 操作共享数据
sem_post(&shared->sem);       // 解锁

// 进程B读取数据
sem_wait(&shared->sem);
printf("Data: %d\n", shared->data);
sem_post(&shared->sem);
```

### 2. 互斥锁（Mutex）与条件变量（Condition Variable）

- **互斥锁**：保证同一时间只有一个进程访问共享资源（类似二进制信号量）。  
- **条件变量**：用于进程间等待/通知（如进程B等待进程A写入数据后再读取）。  

需注意：**普通用户态互斥锁（如 pthread_mutex_t）不能直接用于共享内存**，需设置 `PTHREAD_PROCESS_SHARED` 属性：  

```c
pthread_mutexattr_t attr;
pthread_mutexattr_init(&attr);
pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);  // 跨进程共享
pthread_mutex_init(&shared->mutex, &attr);  // 初始化共享内存中的互斥锁
```

## 五、mmap 共享内存的优缺点

### 优点

1. **效率极高**：数据直接在内存中交换，无内核中转或数据拷贝（仅缺页时一次加载）。  
2. **操作简单**：通过指针直接读写内存，无需复杂的 IPC 接口（如 `msgsnd`/`msgrcv`）。  
3. **灵活性强**：支持亲缘/非亲缘进程，可持久化（文件映射）或临时（匿名映射）共享。  

### 缺点

1. **同步复杂**：需手动实现同步机制（信号量/互斥锁），否则会出现数据竞争。  
2. **内存管理风险**：若进程崩溃未释放映射，可能导致内存泄漏（尤其 System V 共享内存）。  
3. **文件依赖**：基于文件的映射需处理文件创建、权限和大小，匿名映射依赖 `fork` 或 `/dev/shm`。  

## 六、最佳实践与注意事项

1. **选择合适的映射类型**：  
   - 需持久化数据 → 基于磁盘文件的 `MAP_SHARED` 映射。  
   - 临时共享（亲缘进程）→ 匿名映射 + `fork`。  
   - 临时共享（非亲缘进程）→ `/dev/shm` + `shm_open`。  

2. **严格同步**：任何共享内存操作必须用信号量或互斥锁保护，尤其在多写场景。  

3. **避免越界访问**：映射区域大小固定，访问超出范围会触发 `SIGSEGV` 或 `SIGBUS`（文件被截断时）。  

4. **及时清理资源**：进程退出前用 `munmap` 解除映射，非匿名映射需删除关联文件（`unlink`/`shm_unlink`）。  

5. **权限控制**：共享文件/`/dev/shm` 文件需设置合理权限（如 `0600`），防止未授权进程访问。  

## 总结

`mmap` 是进程间共享内存的高效方案，通过将物理内存映射到多个进程的虚拟地址空间，实现了接近原生内存的访问性能。基于文件的映射适合持久化数据，匿名映射适合临时共享，配合信号量等同步机制可安全地实现高频率数据交换，广泛应用于数据库、分布式计算等高性能场景。

# 命令执行

在 shell 脚本中执行其他指令（命令、工具、脚本等）是核心功能，语法灵活且支持多种场景（如直接执行、传递参数、处理输出、条件执行等）。以下从 **基础执行方式** 到 **高级用法** 详细说明：

## 一、基础执行：直接调用命令

最常用的方式是直接在脚本中写入命令，shell 会按顺序逐行执行。

### 语法格式：

```bash
# 直接写命令（支持系统命令、工具、其他脚本等）
命令名 [参数1] [参数2] ...
```

### 示例：

```bash
#!/bin/bash

# 执行系统命令（列出当前目录文件）
ls -l

# 执行工具命令（创建目录）
mkdir test_dir

# 执行其他脚本（需有执行权限或指定解释器）
./other_script.sh  # 调用当前目录的脚本（需 chmod +x 权限）
bash ./another_script.sh  # 用 bash 解释器调用（无需执行权限）

# 带参数的命令
echo "Hello, Shell"  # 输出字符串
cp file1.txt ./test_dir/  # 复制文件
```

### 注意：

- 命令需在系统 `PATH` 环境变量指定的路径中（如 `/bin`、`/usr/bin`），或使用 **绝对路径**（如 `/usr/bin/ls`）。  
- 若命令不在 `PATH` 中且未指定路径，会报错 `command not found`。  

## 二、命令替换：获取命令输出

将一个命令的输出作为另一个命令的参数，或赋值给变量，称为“命令替换”。

### 语法格式（两种方式）：

1. 推荐：`$(命令)`（支持嵌套，可读性好）  
2. 兼容：`` `命令` ``（反引号，不支持嵌套，旧语法）

### 示例：

```bash
#!/bin/bash

# 1. 赋值给变量
current_time=$(date +"%Y-%m-%d")  # 获取当前日期，赋值给变量
echo "今天是：$current_time"

# 2. 作为参数传递给其他命令
# 统计当前目录下 .txt 文件的总行数（嵌套用法）
txt_line_count=$(cat $(ls *.txt) | wc -l)
echo ".txt 文件总行数：$txt_line_count"

# 3. 反引号写法（不推荐嵌套）
file_count=`ls | wc -l`
echo "当前目录文件数：$file_count"
```

### 注意：

- `$(命令)` 支持嵌套（如 `$(ls $(pwd))`），`` `命令` `` 不支持（嵌套会解析错误）。  
- 命令输出中的换行符会被替换为空格，如需保留换行需用双引号包裹（如 `var="$(command)"`）。  

## 三、管道：多命令协作（`|`）

用 `|`（管道符）将多个命令连接，前一个命令的 **标准输出（stdout）** 会作为后一个命令的 **标准输入（stdin）**，实现“数据流水线”处理。

### 语法格式：

```bash
命令1 | 命令2 | 命令3 ...
```

### 示例：

```bash
#!/bin/bash

# 1. 过滤 .txt 文件（ls 输出给 grep 过滤）
ls -l | grep "\.txt$"  # 列出所有 .txt 文件

# 2. 统计进程数（ps 输出给 wc 计数）
ps -ef | wc -l  # 统计当前系统所有进程数

# 3. 多管道协作（查找含 "error" 的日志行并排序去重）
cat app.log | grep "error" | sort | uniq  # 提取 error 日志并去重
```

### 注意：

- 管道中每个命令在 **独立的子shell** 中执行，变量修改不会影响父shell（如 `echo 123 | read num` 后，`num` 仍为空）。  
- 若需处理标准错误（stderr），需先重定向到 stdout（如 `command 2>&1 | grep "error"`）。  

## 四、重定向：控制输入/输出

默认情况下，命令的输入来自终端（stdin），输出到终端（stdout），错误信息也输出到终端（stderr）。重定向用于改变这些默认行为（如输出到文件、从文件读取输入）。

### 常用重定向符号：

| 符号       | 作用                                  | 示例                                  |
|------------|---------------------------------------|---------------------------------------|
| `>`        | 覆盖写入：将 stdout 输出到文件        | `ls -l > file_list.txt`               |
| `>>`       | 追加写入：将 stdout 追加到文件        | `echo "new line" >> log.txt`          |
| `2>`       | 覆盖写入：将 stderr 输出到文件        | `command 2> error.log`                |
| `2>>`      | 追加写入：将 stderr 追加到文件        | `command 2>> error.log`               |
| `2>&1`     | 将 stderr 合并到 stdout（同方向输出） | `command > all.log 2>&1`              |
| `<`        | 从文件读取 stdin（输入重定向）        | `cat < input.txt`                     |
| `<< 分界符` | Here Document：从脚本内读取多行输入   | `cat << EOF ... EOF`                  |
| `<<< "字符串"` | Here String：将字符串作为 stdin      | `grep "key" <<< "this is a key"`      |

### 示例：

```bash
#!/bin/bash

# 1. 标准输出重定向（覆盖）
echo "覆盖写入" > output.txt  # 若文件存在，原有内容会被删除

# 2. 标准输出追加
echo "追加一行" >> output.txt  # 内容添加到文件末尾

# 3. 错误重定向（如执行一个不存在的命令）
invalid_command 2> error.log  # 错误信息写入 error.log

# 4. 合并 stdout 和 stderr 到同一文件
ls -l valid_file invalid_file > all_output.log 2>&1  # 正确和错误信息都写入

# 5. Here Document（多行输入到命令）
cat << EOF > config.ini  # 生成配置文件
[server]
port=8080
host=localhost
EOF

# 6. Here String（字符串作为输入）
grep "shell" <<< "I love shell scripting"  # 输出：I love shell scripting
```

## 五、后台执行：不阻塞脚本运行（`&`）

用 `&` 在命令末尾标记，使命令在 **后台运行**，脚本会继续执行后续命令（不等待该命令完成）。

### 语法格式：

```bash
命令 [参数] &
```

### 示例：

```bash
#!/bin/bash

# 1. 后台执行耗时命令（如睡眠10秒）
echo "开始后台任务..."
sleep 10 &  # 后台运行，脚本不等待
echo "后台任务已启动，继续执行其他操作"

# 2. 查看后台任务（jobs 命令）
echo "当前后台任务："
jobs  # 列出脚本中启动的后台任务

# 3. 等待后台任务完成（wait 命令）
wait  # 等待所有后台任务完成后再继续
echo "所有后台任务已完成"
```

### 扩展：

- `nohup 命令 &`：让后台命令在终端关闭后继续运行（输出默认到 `nohup.out`）。  
- `fg %任务编号`：将后台任务调至前台（如 `fg %1` 调起编号1的任务）。  
- `bg %任务编号`：让暂停的后台任务继续运行（如 `bg %1`）。  

## 六、条件执行：根据命令结果决定是否执行（`&&`/`||`）

通过 `&&`（逻辑与）和 `||`（逻辑或），可根据前一个命令的执行结果（成功/失败）决定是否执行后一个命令。

### 语法规则：

- `命令1 && 命令2`：**命令1执行成功（退出码0）后，才执行命令2**。  
- `命令1 || 命令2`：**命令1执行失败（退出码非0）后，才执行命令2**。  

### 示例：

```bash
#!/bin/bash

# 1. &&：前一个成功才执行后一个（如创建目录成功后复制文件）
mkdir test_dir && cp file.txt test_dir/  # 若目录创建成功，才复制文件

# 2. ||：前一个失败才执行后一个（如创建目录失败则提示）
mkdir test_dir || echo "创建目录失败！"  # 若目录已存在，输出错误提示

# 3. 组合使用（类似 if-else）
# 检查文件是否存在：存在则输出内容，不存在则提示
[ -f "file.txt" ] && cat file.txt || echo "file.txt 不存在"
```

### 注意：

- 命令的“成功/失败”由 **退出码** 决定：成功退出码为 `0`，失败为非 `0`（可通过 `$?` 获取上一个命令的退出码）。  
- 组合使用时注意优先级：`&&` 优先级高于 `||`，复杂逻辑建议用 `if` 语句替代。  

## 七、执行脚本/函数：调用自定义逻辑

在脚本中执行其他脚本或自定义函数，本质是调用“用户定义的命令”。

### 1. 执行其他脚本

```bash
#!/bin/bash

# 方式1：直接调用（需执行权限 + 正确路径）
./sub_script.sh  # 当前目录的脚本（需 chmod +x sub_script.sh）
/path/to/script.sh  # 绝对路径调用

# 方式2：指定解释器调用（无需执行权限）
bash ./sub_script.sh  # 用 bash 解释器
sh ./sub_script.sh    # 用 sh 解释器（兼容性更强）

# 方式3：source 或 . 命令（在当前shell执行，共享变量）
source ./config.sh  # 加载配置文件的变量到当前脚本
. ./utils.sh        # 等价于 source（注意 . 后有空格）
```

### 2. 调用自定义函数

```bash
#!/bin/bash

# 先定义函数
greet() {
  echo "Hello, $1!"  # $1 是函数的第一个参数
}

# 再调用函数（需在定义后）
greet "Shell"  # 输出：Hello, Shell!
```

## 八、特殊场景：处理特殊字符与空格

当命令参数包含空格、引号、通配符（`*`、`?`）等特殊字符时，需用 **引号包裹** 避免解析错误。

### 示例：

```bash
#!/bin/bash

# 1. 参数含空格（必须用双引号包裹）
file_name="my document.txt"
cat "$file_name"  # 正确：识别为一个文件 "my document.txt"
# 错误写法：cat $file_name（会被解析为 cat "my" "document.txt"，报错）

# 2. 参数含通配符（需保留通配符时不加引号，需原样传递时加引号）
ls *.txt  # 正确：列出所有 .txt 文件（通配符被解析）
echo "*.txt"  # 正确：输出字符串 "*.txt"（通配符不解析）

# 3. 参数含单引号（用双引号包裹，或转义单引号）
echo "It's a test"  # 正确：输出 It's a test
echo 'It'\''s a test'  # 正确：用 \' 转义单引号
```

## 总结

shell 脚本执行其他命令的核心是理解 **命令解析规则** 和 **输入输出控制**：  

- 基础执行：直接写命令，注意路径和权限；  
- 数据流转：用管道（`|`）串联命令，用重定向控制输入输出；  
- 流程控制：用 `&&`/`||` 实现简单条件，用后台执行（`&`）实现并行；  
- 特殊处理：用引号解决空格和特殊字符问题，用命令替换获取输出。  

根据场景选择合适的语法，可大幅提升脚本的灵活性和效率。

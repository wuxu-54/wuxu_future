# 早知道

在 shell 脚本中，很多看似微小的语法细节（空格、符号、引号等）会直接导致脚本报错或逻辑异常，这些“细解点”往往是新手最容易踩的坑。以下是更多高频细节错误及规范写法：

## 一、变量赋值与引用的细节

### 1. 变量赋值时**不能有空格**错误写法：  

```bash
num = 10  # 错误：= 两边有空格，shell 会把 num 当成命令
name = "test"  # 同理错误
```  

正确写法：  

```bash
num=10  # = 两边无空格
name="test"
```  

**原因**：shell 中 `=` 是赋值运算符，两边加空格会被解析为“执行 `num` 命令，参数为 `=10`”，导致“command not found”。

### 2. 引用变量时**建议加双引号**错误写法：  

```bash
name="hello world"
echo $name  # 输出：hello world（看似正确，但有隐患）
if [ $name = "hello world" ]; then ...  # 错误：会被解析为多个参数
```  

正确写法：  

```bash
name="hello world"
echo "$name"  # 输出：hello world（安全）
if [ "$name" = "hello world" ]; then ...  # 正确：双引号避免参数分割
```  

**原因**：变量值包含空格时，不加双引号会被 shell 按空格分割成多个参数（如 `$name` 会变成 `hello` 和 `world` 两个参数），导致判断或输出异常。

## 二、条件判断（`if` 语句）的细节

### 1. `[ ]` 内部的空格必须严格保留  

错误写法：  

```bash
if [$num -gt 5]; then ...  # 错误：[ 后和 ] 前缺少空格
if [ $num-gt 5 ]; then ...  # 错误：-gt 两边缺少空格
```  

正确写法：  

```bash
if [ $num -gt 5 ]; then ...  # 正确：[ 后、] 前、运算符两边都有空格
```  

**原因**：`[` 是 shell 的内置命令（等价于 `test` 命令），必须作为独立的“命令”存在，因此前后必须有空格；运算符（`-gt`、`-eq` 等）也需要空格分隔参数。

### 2. 字符串比较用 `=`，数字比较用 `-eq`/`-gt` 等  

错误写法：  

```bash
if [ $num = 10 ]; then ...  # 错误：数字比较用了字符串运算符 =
if [ "$name" -eq "test" ]; then ...  # 错误：字符串比较用了数字运算符 -eq
```  

正确写法：  

```bash
if [ $num -eq 10 ]; then ...  # 数字比较用 -eq（等于）、-gt（大于）等
if [ "$name" = "test" ]; then ...  # 字符串比较用 =（注意不是 ==，POSIX 标准用 =）
```  

### 3. `[[ ]]` 与 `[ ]` 的区别（bash 扩展）  

`[[ ]]` 是 bash 的扩展语法，支持更多特性，但兼容性不如 `[ ]`（POSIX 标准）：  

- 支持 `&&`/`||` 逻辑运算符（`[ ]` 中需用 `-a`/`-o`）；  
- 支持模式匹配（如 `*`、`?`）；  
- 变量引用可省略双引号（但仍建议加上）。  

示例：  

```bash
# 正确：[[ ]] 中用 &&
if [[ $num -gt 5 && $num -lt 15 ]]; then ...

# 错误：[ ] 中不能用 &&，需用 -a（与）
if [ $num -gt 5 && $num -lt 15 ]; then ...  # 报错

# 正确：[ ] 中用 -a
if [ $num -gt 5 -a $num -lt 15 ]; then ...
```  

## 三、函数与参数的细节

### 1. 函数调用时**参数传递的空格问题**  

错误写法：  

```bash
myfunc() {
  echo "参数1: $1, 参数2: $2"
}
myfunc "hello world"  # 错误：只传了 1 个参数，但函数可能期望 2 个
```  

正确写法（按需传递）：  

```bash
myfunc "hello" "world"  # 正确：传递 2 个参数，空格分隔
myfunc "hello world"  # 若函数只需要 1 个参数，用双引号包裹带空格的值
```  

### 2. 函数定义后**必须先定义再调用**  

错误写法：  

```bash
myfunc  # 错误：调用在定义之前
myfunc() {
  echo "test"
}
```  

正确写法：  

```bash
myfunc() {  # 先定义
  echo "test"
}
myfunc  # 后调用
```  

## 四、循环与分支的细节

### 1. `for` 循环遍历带空格的列表  

错误写法：  

```bash
files="file1.txt file2.txt file with space.txt"
for file in $files; do  # 错误：会把 "file with space.txt" 拆成 3 个文件
  echo $file
done
```  

正确写法（用数组）：  

```bash
files=("file1.txt" "file2.txt" "file with space.txt")  # 数组存储
for file in "${files[@]}"; do  # 用 "${数组名[@]}" 遍历，保留空格
  echo "$file"
done
```  

### 2. `case` 语句的格式细节  

错误写法：  

```bash
case $num in
  1) echo "one"  # 错误：缺少 ;; 结束符
  2) echo "two";;
esac
```  

正确写法：  

```bash
case $num in
  1) echo "one";;  # 每个分支必须用 ;; 结束
  2) echo "two";;
  *) echo "other";;  # * 表示默认分支
esac
```  

## 五、命令与管道的细节

### 1. 管道（`|`）的错误处理  

默认情况下，管道中某个命令失败不会导致整个管道返回失败，例如：  

```bash
false | echo "hello"  # 输出 hello，且脚本返回码为 0（成功），但 false 实际失败了
```  

如需管道中任一命令失败则整体失败，需开启 `pipefail`：  

```bash
set -o pipefail  # 开启管道失败检测
false | echo "hello"  # 输出 hello，但返回码为 1（失败）
```  

### 2. 命令替换的嵌套问题  

错误写法（用反引号 `` ` `` 嵌套）：  

```bash
echo "当前目录: `dirname `pwd``"  # 错误：反引号嵌套会解析错误
```  

正确写法（用 `$( )` 嵌套，推荐）：  

```bash
echo "当前目录: $(dirname $(pwd))"  # 正确：$( ) 支持嵌套，更清晰
```  

## 六、文件操作的细节

### 1. 文件测试运算符的空格  

错误写法：  

```bash
if [-f "file.txt"]; then ...  # 错误：[ 后、-f 后、] 前缺少空格
```  

正确写法：  

```bash
if [ -f "file.txt" ]; then ...  # 正确：-f（检测普通文件）前后有空格
```  

常见文件测试运算符：`-f`（普通文件）、`-d`（目录）、`-e`（存在）、`-r`（可读）等。

### 2. 通配符扩展的意外匹配  

错误写法（删除文件时未处理空匹配）：  

```bash
rm *.txt  # 若当前目录无 .txt 文件，会被解析为 rm "*.txt"，报错“无此文件”
```  

正确写法（开启 `nullglob` 避免空匹配）：  

```bash
shopt -s nullglob  # 开启后，无匹配时通配符扩展为“空”
rm *.txt  # 无 .txt 文件时，等价于 rm（无参数），不会报错
```  

这些细节的核心是：**shell 对空格、引号、符号的解析非常严格**，很多错误并非逻辑问题，而是语法格式不符合 shell 的解析规则。写脚本时建议边写边用 `shellcheck`（一款 shell 语法检查工具）检测，能快速定位这类细节错误。

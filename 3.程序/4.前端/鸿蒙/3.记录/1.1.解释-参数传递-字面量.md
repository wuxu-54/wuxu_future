# 响应式参数传递

自定义构建函数的参数传递有按值传递和按引用传递两种，均需遵守以下规则：

- 参数的类型必须与参数声明的类型一致，不允许undefined、null和返回undefined、null的表达式。
- 在@Builder装饰的函数内部，不允许改变参数值。
- @Builder内UI语法遵循UI语法规则。
- **只有当传入一个参数且该参数直接传入对象字面量时**，才会按引用传递，其他传递方式均为按值传递。

## UI刷新

只有按引用传递才会有响应式UI刷新：

1. 值传递：调用@Builder装饰的函数默认按值传递。当传递的参数为状态变量时，状态变量的改变不会引起@Builder函数内的UI刷新。所以当使用状态变量的时候，推荐使用按引用传递。
2. 引用传递：按引用传递参数时，传递的参数可为状态变量，且状态变量的改变会引起@Builder函数内的UI刷新。

## 问题

官文有这样一段代码我不理解，后来明白字面量的含义才知道其中区别。

问题：在`@Builder`内创建自定义组件传递参数不刷新问题：在parentBuilder函数中创建自定义组件HelloComponent，传递参数为class对象并修改对象内的值时，UI不会触发刷新功能。

反例：

```TS
class Tmp {
  name: string = 'Hello';
  age: number = 16;
}

@Builder
function parentBuilder(params: Tmp) {
  Row() {
    Column() {
      Text(`parentBuilder===${params.name}===${params.age}`)
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
      // 此写法不属于按引用传递方式，用法错误导致UI不刷新。
      HelloComponent({ info: params })
    }
  }
}

@Component
struct HelloComponent {
  @Prop info: Tmp = new Tmp();

  build() {
    Row() {
      Text(`HelloComponent===${this.info.name}===${this.info.age}`)
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
    }
  }
}

@Entry
@Component
struct ParentPage {
  @State nameValue: string = '张三';
  @State ageValue: number = 18;

  build() {
    Column() {
      parentBuilder({ name: this.nameValue, age: this.ageValue })
      Button('Click me')
        .onClick(() => {
          // 此处修改内容时，不会引起HelloComponent处的变化
          this.nameValue = '李四';
          this.ageValue = 20;
        })
    }
    .height('100%')
    .width('100%')
  }
}
```

正例：在parentBuilder函数中创建自定义组件HelloComponent，传递参数为对象字面量形式并修改对象内的值时，UI触发刷新功能。

```TS
class Tmp {
  name: string = 'Hello';
  age: number = 16;
}

@Builder
function parentBuilder(params: Tmp) {
  Row() {
    Column() {
      Text(`parentBuilder===${params.name}===${params.age}`)
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
      // 将整个对象拆分开变成简单类型，属于按引用传递方式，更改属性能够触发UI刷新。
      HelloComponent({ childName: params.name, childAge: params.age })
    }
  }
}

@Component
struct HelloComponent {
  @Prop childName: string = '';
  @Prop childAge: number = 0;

  build() {
    Row() {
      Text(`HelloComponent===${this.childName}===${this.childAge}`)
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
    }
  }
}

@Entry
@Component
struct ParentPage {
  @State nameValue: string = '张三';
  @State ageValue: number = 18;

  build() {
    Column() {
      parentBuilder({ name: this.nameValue, age: this.ageValue })
      Button('Click me')
        .onClick(() => {
          // 此处修改内容时，会引起HelloComponent处的变化
          this.nameValue = '李四';
          this.ageValue = 20;
        })
    }
    .height('100%')
    .width('100%')
  }
}
```

上面二者有什么不同？答：反例中不是引用传递，他传入的是变量而不是字面量。下面是字面量的说明

---

## 字面量

在编程中，**字面量（Literal）** 指的是**直接写出的值本身**，而不是通过变量、表达式或函数计算得到的值。它是“所见即所得”的具体值，是代码中直接表示数据的方式。

### 常见的字面量类型（以ArkTS/JavaScript为例）：

1. **字符串字面量**  
   用单引号或双引号包裹的具体文本，例如：  

   ```typescript
   const name = "张三"; // "张三" 是字符串字面量
   const message = 'Hello'; // 'Hello' 是字符串字面量
   ```

2. **数字字面量**  
   直接写出的数字（整数、小数、科学计数法等），例如：  

   ```typescript
   const age = 18; // 18 是数字字面量
   const price = 99.9; // 99.9 是数字字面量
   const large = 1e6; // 1e6（即1000000）是数字字面量
   ```

3. **布尔字面量**  
   只有两个值：`true` 和 `false`，例如：  

   ```typescript
   const isReady = true; // true 是布尔字面量
   const hasError = false; // false 是布尔字面量
   ```

4. **对象字面量**  
   用 `{}` 直接定义的对象，里面包含键值对，例如：  

   ```typescript
   const user = { name: "李四", age: 20 }; // { ... } 整体是对象字面量
   ```

   这里的 `{ name: "李四", age: 20 }` 就是一个对象字面量，它直接描述了一个对象的结构和值。

5. **数组字面量**  
   用 `[]` 直接定义的数组，例如：  

   ```typescript
   const numbers = [1, 2, 3]; // [1, 2, 3] 是数组字面量
   ```

6. **null/undefined字面量**  
   表示“空”或“未定义”的特殊值：  

   ```typescript
   const empty = null; // null 是字面量
   const nothing = undefined; // undefined 是字面量
   ```

### 字面量的核心特点：

- **直接性**：它是值本身，不是“获取值的方式”。  
  例如，`100` 是数字字面量，而 `getNumber()`（函数调用）、`a + b`（表达式）都不是字面量，因为它们需要计算才能得到值。
  
- **不可变**：字面量本身是固定的，例如 `5` 永远是 `5`，`"abc"` 永远是 `"abc"`。  
  （注意：对象字面量创建的对象可以修改属性，但字面量本身的写法是固定的。）

### 回到之前的ArkTS响应式问题：

当我们说“传入对象字面量”时，指的是像这样直接写出对象：  

```typescript
Child({ info: { name: "张三", age: 18 } }); 
// 这里的 { name: "张三", age: 18 } 就是对象字面量
```

而如果先把对象存到变量里再传递，就不是“直接传入字面量”了：  

```typescript
const temp = { name: "张三", age: 18 };
Child({ info: temp }); // temp是变量，不是字面量
```

这就是为什么ArkTS中“直接传入对象字面量”会有特殊的响应式处理——因为框架能通过这种写法直接识别出你要传递的是一个具体的对象结构，从而建立正确的引用关系。

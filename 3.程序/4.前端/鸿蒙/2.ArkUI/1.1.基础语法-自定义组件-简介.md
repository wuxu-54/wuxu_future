# 自定义组件简介

在鸿蒙（HarmonyOS）开发中，自定义组件是提升开发效率、实现代码复用和优化UI设计的关键要素。它允许开发者将特定的UI结构与业务逻辑封装在一起，在应用的不同部分共享使用。

1. **自定义组件基础概念**
    - **定义与分类**：在ArkUI中，组件是构成用户界面的基本单元，分为基础组件（如Text、Button、Image）、容器组件（如Column、Row、Flex ）和自定义组件。自定义组件是开发者根据业务需求自主创建的组件，用于封装特定的UI和业务逻辑。
    - **优势**：可显著提升代码复用率，减少重复代码编写，降低维护成本；将UI与业务逻辑分离，便于维护和更新；确保应用界面元素的视觉和交互效果一致，提升用户体验；在团队开发中，支持并行开发，简化团队协作流程。
2. **创建自定义组件**
    - **基本结构**：基于struct实现，采用“struct + 自定义组件名 + {...}”的组合形式，且不能有继承关系，实例化时可省略new 。例如：

    ```typescript
    struct MyCustomComponent {
    // 组件内容
    }
    ```

    - **装饰器使用**
        - **@Component**：仅用于装饰struct声明的数据结构，使struct具备组件化能力，被装饰的struct需实现build方法来描述UI，且一个struct只能被一个@Component装饰 。从API version 11开始，可接受一个可选的bool类型参数freezeWhenInactive用于控制组件冻结。
        - **@Entry**：装饰的自定义组件作为UI页面入口，单个UI页面最多有一个@Entry装饰的组件。从API version 10开始，@Entry可接受可选的LocalStorage参数或EntryOptions参数。
        - **@Preview**：用于单独预览组件，方便开发过程中查看组件效果。
        - **@Reusable**：从API version 10开始在ArkTS卡片中支持，使自定义组件具备可复用能力。
    - **build()函数**：自定义组件必须定义build()函数，用于定义声明式UI描述。@Entry装饰的组件，build()函数根节点唯一且必须为容器组件（ForEach禁止作为根节点）；@Component装饰的组件，build()函数根节点唯一且可为非容器组件（ForEach禁止作为根节点） 。同时，build()函数有诸多限制，如不允许调用未用@Builder装饰的方法、不允许使用switch语法（需用if进行条件判断）、不允许直接改变状态变量（防止循环渲染风险 ）。
3. **组件属性、方法与数据传递**
    - **成员函数和变量**：成员函数和变量均为私有，不建议声明为静态函数或变量。成员变量可本地初始化，也可从父组件通过参数传递初始化。
    - **属性传递**：使用@Prop修饰符接收外部传入属性，增强组件复用性和灵活性。可设置默认值，防止外部未传递数据时出错。例如：

    ```typescript
    @Component
    struct MyComponent {
    @Prop title: string = '默认标题';
    build() {
        Text(this.title)
    }
    }
    ```

    - **传递函数作为参数**：父组件能将函数传递给子组件，子组件可调用该函数，实现父子组件间的交互和逻辑传递。
4. **组件状态管理**：使用@State管理组件内部状态，控制组件动态变化。状态变量改变时会触发UI刷新，实现数据驱动UI更新。例如，在组件内部定义@State变量，通过修改该变量的值来更新UI显示内容。
5. **通用样式与事件**：自定义组件可通过点语法设置通用样式和事件，如设置背景颜色、字体大小、点击事件等。但设置样式时，实际是给组件套了一个不可见的容器组件，样式应用在该容器组件上，而非组件自身。
6. **嵌套与组合自定义组件**：自定义组件支持嵌套使用，通过组合多个简单组件创建更复杂的UI布局，实现界面模块化。例如，创建一个包含图片、标题和内容的卡片组件，可嵌套使用其他自定义组件来构建。
7. **响应式与自适应设计**：结合响应式和自适应布局技巧，如使用GridRow、GridCol组件，设置不同断点下的布局参数，动态调整组件的宽度、高度、字体大小等样式，确保组件在不同屏幕尺寸和设备类型下都能完美适配 。

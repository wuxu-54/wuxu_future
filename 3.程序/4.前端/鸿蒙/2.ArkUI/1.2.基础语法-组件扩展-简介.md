# ArkUI 组件扩展详细说明

在 ArkUI 开发中，组件扩展是提升代码复用性、统一 UI 风格和增强组件功能的核心手段。通过对现有组件（原生组件或自定义组件）进行扩展，可以快速构建符合业务需求的定制化组件，同时减少重复开发。ArkUI 提供了多种组件扩展方式，适用于不同场景，以下详细说明：

## 一、基于 `@Extend` 的样式扩展

`@Extend` 是 ArkUI 中用于扩展原生组件样式的装饰器，通过封装常用样式组合，实现样式复用和统一管理。

### 1. 基本特性

- **适用范围**：仅支持扩展**原生组件**（如 Text、Button、Image 等），不支持自定义组件。
- **定义位置**：必须在全局作用域（组件外部）定义，确保所有组件可复用。
- **动态参数**：支持传递参数（包括状态变量），实现动态样式调整。
- **样式继承**：扩展方法中可调用原生组件的所有样式和事件，且支持链式调用。

### 2. 基础用法

```typescript
// 扩展 Text 组件：定义标题样式
@Extend(Text)
function TitleStyle(fontSize: number, color: Color = Color.Black) {
  .fontSize(fontSize)
  .fontColor(color)
  .fontWeight(FontWeight.Bold)
  .margin({ bottom: 10 })
}

// 扩展 Button 组件：定义提交按钮样式
@Extend(Button)
function SubmitButton(text: string) {
  .backgroundColor('#007DFF')
  .color(Color.White)
  .borderRadius(8)
  .width('100%')
  .height(48)
  .text(text)
  .onClick(() => {
    console.log('提交按钮被点击');
  })
}
```

### 3. 使用扩展样式

```typescript
@Entry
@Component
struct ExtendExample {
  build() {
    Column({ space: 15 }) {
      // 应用 Text 扩展样式
      Text('用户注册')
        .TitleStyle(20, Color.DarkGray) // 传递参数：字体大小20，颜色深灰
      
      // 应用 Button 扩展样式
      Button()
        .SubmitButton('完成注册') // 传递按钮文本
    }
    .padding(20)
  }
}
```

### 4. 高级特性

- **状态变量关联**：扩展方法的参数可关联状态变量，变量变化时自动更新样式：

  ```typescript
  @Extend(Text)
  function HighlightText(active: boolean) {
    .fontColor(active ? Color.Red : Color.Gray)
    .fontWeight(active ? FontWeight.Bold : FontWeight.Normal)
  }

  // 使用时关联状态变量
  @State isActive: boolean = false;
  Text('动态文本')
    .HighlightText(this.isActive)
    .onClick(() => this.isActive = !this.isActive)
  ```

- **事件封装**：可在扩展中封装常用事件逻辑（如点击、长按），减少重复代码。

## 二、基于自定义组件的功能扩展

通过 `@Component` 装饰器将多个基础组件组合成具有独立功能的复合组件，实现 UI 结构与业务逻辑的复用。

### 1. 基本特性

- **功能独立性**：包含完整的 UI 结构和业务逻辑，可作为独立单元使用。
- **参数化配置**：通过 `@Prop`、`@Link` 等装饰器接收外部参数，实现灵活适配。
- **事件交互**：通过 `@Event` 暴露回调事件，支持组件间通信。
- **嵌套复用**：可嵌套其他自定义组件，构建复杂 UI 层级。

### 2. 示例：封装卡片组件

```typescript
// 自定义卡片组件
@Component
struct CardComponent {
  // 输入参数（带默认值）
  @Prop title: string = '默认标题';
  @Prop content: string = '默认内容';
  // 输出事件（点击卡片时触发）
  @Event('onCardClick') onCardClick: () => void;

  build() {
    Column() {
      // 卡片标题区
      Row() {
        Text(this.title)
          .fontSize(16)
          .fontWeight(FontWeight.Bold)
        Button('编辑')
          .fontSize(12)
          .backgroundColor(Color.Transparent)
          .color('#007DFF')
      }
      .padding(15)
      .justifyContent(FlexAlign.SpaceBetween)

      // 卡片内容区
      Text(this.content)
        .fontSize(14)
        .color('#666666')
        .padding({ left: 15, right: 15, bottom: 15 })
    }
    .backgroundColor(Color.White)
    .borderRadius(12)
    .shadow({ radius: 4, color: '#00000010' })
    .width('100%')
    .onClick(() => this.onCardClick()) // 触发外部事件
  }
}
```

### 3. 使用自定义组件

```typescript
@Entry
@Component
struct CardExample {
  build() {
    Column({ space: 15 }) {
      CardComponent({
        title: '个人资料',
        content: '姓名：张三 | 年龄：25',
        onCardClick: () => console.log('点击个人资料卡片')
      })

      CardComponent({
        title: '账户余额',
        content: '当前余额：1000.00 元',
        onCardClick: () => console.log('点击账户余额卡片')
      })
    }
    .padding(20)
    .backgroundColor('#F5F5F5')
  }
}
```

## 三、基于 `@Builder` 的 UI 片段扩展

`@Builder` 用于定义可复用的 UI 片段，适用于重复出现的简单 UI 结构（如图标+文本组合、标签样式等），简化代码编写。

### 1. 基本特性

- **定义范围**：可在组件内部定义（私有片段）或全局定义（公共片段）。
- **参数传递**：支持传递任意类型参数，动态生成 UI 内容。
- **组合使用**：可嵌套其他 `@Builder` 片段或组件，构建复杂结构。

### 2. 全局 UI 片段

```typescript
// 全局定义：带图标的文本片段
@Builder
export function IconText(icon: Resource, text: string) {
  Row({ space: 8 }) {
    Image(icon)
      .width(20)
      .height(20)
    Text(text)
      .fontSize(14)
  }
}
```

### 3. 组件内部 UI 片段

```typescript
@Entry
@Component
struct BuilderExample {
  // 组件内私有片段：标签样式
  @Builder
  Label(text: string, bgColor: Color = '#E8F3FF') {
    Text(text)
      .fontSize(12)
      .padding({ left: 6, right: 6, top: 2, bottom: 2 })
      .backgroundColor(bgColor)
      .color('#007DFF')
      .borderRadius(4)
  }

  build() {
    Column({ space: 15 }) {
      // 使用全局片段
      IconText($r('app.media.ic_phone'), '联系电话')

      // 使用组件内片段
      this.Label('官方认证')
      this.Label('新用户', '#FFF0F0')
    }
    .padding(20)
  }
}
```

## 四、基于 `@BuilderParam` 的内容自定义扩展

`@BuilderParam` 允许父组件向子组件传递 `@Builder` 片段，实现子组件内容的动态定制，提升组件灵活性。

### 1. 基本特性

- **内容注入**：子组件通过 `@BuilderParam` 声明占位内容，父组件传递具体实现。
- **参数化定制**：父组件可根据需求传递不同的 `@Builder` 片段，定制子组件局部内容。

### 2. 示例：可定制内容的列表项

```typescript
// 子组件：支持自定义右侧内容
@Component
struct ListItemComponent {
  @Prop title: string;
  // 声明可定制的右侧内容
  @BuilderParam rightContent: () => void;

  build() {
    Row() {
      Text(this.title)
        .fontSize(16)
        .flexGrow(1)
      this.rightContent() // 渲染父组件传递的内容
    }
    .padding(15)
    .backgroundColor(Color.White)
    .borderBottom({ width: 1, color: '#EEEEEE' })
  }
}

// 父组件：传递不同的右侧内容
@Entry
@Component
struct BuilderParamExample {
  @Builder
  ArrowIcon() {
    Image($r('app.media.ic_arrow'))
      .width(16)
      .height(16)
  }

  @Builder
  SwitchButton() {
    Switch()
      .checked(false)
  }

  build() {
    Column() {
      ListItemComponent({
        title: '个人设置',
        rightContent: this.ArrowIcon // 传递箭头图标
      })
      ListItemComponent({
        title: '消息通知',
        rightContent: this.SwitchButton // 传递开关组件
      })
    }
    .backgroundColor('#F5F5F5')
    .width('100%')
    .height('100%')
  }
}
```

## 五、扩展方式对比与适用场景

| 扩展方式       | 核心优势                          | 适用场景                                   | 局限性                                   |
|----------------|-----------------------------------|--------------------------------------------|------------------------------------------|
| `@Extend`      | 简洁高效，专注样式复用            | 统一按钮、文本等原生组件的样式规范         | 仅支持原生组件，无法扩展功能             |
| 自定义组件     | 功能完整，可包含复杂业务逻辑      | 封装卡片、表单、列表项等独立功能单元       | 代码量较大，简单样式复用不够灵活         |
| `@Builder`     | 轻量灵活，专注UI结构复用          | 重复出现的简单UI片段（如图标+文本、标签）  | 无法包含复杂业务逻辑，依赖外部状态       |
| `@BuilderParam`| 动态定制组件内容，灵活性极高      | 需根据场景定制局部内容的组件（如列表项）   | 仅用于内容定制，不适合样式或功能扩展     |

## 六、组件扩展的最佳实践

1. **样式归一化**：
   - 使用 `@Extend` 定义应用全局的样式规范（如主题色、圆角、间距），确保UI一致性。
   - 示例：定义统一的按钮样式体系（主要按钮、次要按钮、文本按钮）。

2. **功能模块化**：
   - 将高频使用的功能单元（如搜索框、下拉菜单、加载动画）封装为自定义组件。
   - 组件设计遵循“单一职责”，确保复用性和可维护性。

3. **性能优化**：
   - 避免过度封装：简单UI片段优先用 `@Builder` 而非自定义组件，减少性能开销。
   - 长列表中慎用复杂扩展组件，优先使用 `LazyForEach` 配合轻量扩展。

4. **版本兼容性**：
   - `@Extend` 从 API 9 开始支持，低版本需通过自定义组件实现样式复用。
   - `@BuilderParam` 在 API 10+ 功能更完善，低版本需注意兼容性处理。

## 七、总结

ArkUI 提供的组件扩展机制（`@Extend`、自定义组件、`@Builder` 等）从不同维度解决了代码复用和功能增强的问题。合理选择扩展方式可显著提升开发效率：

- 样式复用优先用 `@Extend`；
- 独立功能单元封装为自定义组件；
- 重复UI结构用 `@Builder`；
- 动态内容定制用 `@BuilderParam`。

通过组件扩展，既能保证应用UI的一致性，又能提高代码的可维护性和复用率，是 ArkUI 开发中的核心技巧。

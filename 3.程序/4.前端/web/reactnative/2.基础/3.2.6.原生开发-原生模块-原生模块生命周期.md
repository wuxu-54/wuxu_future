# Native Modules Lifecycle

原地址：<https://reactnative.dev/docs/next/the-new-architecture/native-modules-lifecycle>

该网页是 React Native 新架构下关于原生模块生命周期（Native Modules Lifecycle）的指南文档，主要面向需要正确管理原生模块初始化、资源释放和状态重置的开发者。文档明确要求读者需先熟悉原生模块的基本开发方法，本文档聚焦于原生模块在创建、销毁过程中的关键操作。

## 原生模块生命周期核心背景

- **单例特性**：React Native 中的原生模块是单例模式，基础设施会在模块首次被访问时延迟创建，并在应用需要时一直保留，这是为了避免应用启动时的性能开销，提升启动速度。
- **生命周期需求**：在纯 React Native 应用中，原生模块通常创建后不会被销毁；但在复杂场景（如混合原生视图与 React Native 界面的“brownfield 应用”）中，模块可能会被销毁并重新创建。此时，**有状态的原生模块**需通过生命周期方法正确处理初始化和资源清理，避免内存泄漏或状态异常。

## Android 平台原生模块生命周期

Android 平台的原生模块默认实现 `TurboModule` 接口，该接口直接定义了生命周期核心方法 `initialize()` 和 `invalidate()`，无需额外协议声明。

### 1. `initialize()` 方法

- **调用时机**：当原生模块被创建时，由 Native Module 基础设施自动调用。
- **核心作用**：执行需要依赖 `ReactApplicationContext` 的初始化操作，如注册监听器、初始化资源等。
- **示例模块**：核心模块中实现此方法的例子包括 `BlobModule`（Blob 数据处理）、`NetworkingModule`（网络请求管理）。

### 2. `invalidate()` 方法

- **调用时机**：当原生模块被销毁时，由基础设施自动调用。
- **核心作用**：执行清理操作，如重置模块状态、释放内存、关闭文件句柄、移除监听器等，避免资源泄漏。
- **示例模块**：核心模块中实现此方法的例子包括 `DeviceInfoModule`（设备信息管理）、`NetworkModule`（网络状态监听）。

## iOS 平台原生模块生命周期

iOS 平台的原生模块需遵循 `RCTTurboModule` 协议，但该协议未直接定义生命周期方法。需通过额外协议 `RCTInitializing` 和 `RCTInvalidating` 分别实现初始化和清理逻辑。

### 1. 初始化：`RCTInitializing` 协议

- **协议作用**：定义模块初始化方法 `initialize`，用于执行模块创建后的初始化操作。
- **实现步骤**：
  - **修改头文件**：在 `NativeModule.h` 中导入协议头文件 `#import <React/RCTInitializing.h>`，并让模块类遵循 `RCTInitializing` 协议：

    ```objectivec
    @interface NativeModule : NSObject <NativeModuleSpec, RCTInitializing>
    ```

  - **实现方法**：在 `NativeModule.mm` 中编写初始化逻辑：

    ```objectivec
    @implementation NativeModule
    - (void)initialize {
      // 初始化代码（如配置初始状态、注册通知等）
    }
    @end
    ```

- **示例模块**：核心模块中实现此方法的例子包括 `RCTBlobManager`（Blob 管理）、`RCTTiming`（定时器管理）。

### 2. 清理：`RCTInvalidating` 协议

- **协议作用**：定义模块销毁时的清理方法 `invalidate`，用于释放资源和重置状态。
- **实现步骤**：
  - **修改头文件**：在 `NativeModule.h` 中导入协议头文件 `#import <React/RCTInvalidating.h>`，并让模块类遵循 `RCTInvalidating` 协议：

    ```objectivec
    @interface NativeModule : NSObject <NativeModuleSpec, RCTInvalidating>
    ```

  - **实现方法**：在 `NativeModule.mm` 中编写清理逻辑：

    ```objectivec
    @implementation NativeModule
    - (void)invalidate {
      // 清理代码（如移除监听器、释放内存等）
    }
    @end
    ```

- **示例模块**：核心模块中实现此方法的例子包括 `RCTAppearance`（外观样式管理）、`RCTDeviceInfo`（设备信息）。

## 核心要点总结

- **平台差异**：Android 通过 `TurboModule` 接口直接提供 `initialize()` 和 `invalidate()`；iOS 需分别通过 `RCTInitializing` 和 `RCTInvalidating` 协议实现。
- **方法作用**：`initialize()` 负责初始化依赖资源，`invalidate()` 负责清理资源，二者确保模块在生命周期内状态正确。
- **适用场景**：尤其对有状态模块（如持有监听器、缓存数据的模块）至关重要，在混合应用中可避免模块销毁/重建导致的异常。

```mermaid
graph TD
    A[原生模块生命周期核心背景] --> A1[单例模式：首次访问时延迟创建，提升启动速度]
    A --> A2[复杂场景需求：混合应用中模块可能销毁并重建，需生命周期管理]
    A --> A3[前提：需先熟悉原生模块开发基础]
    
    B[Android 平台生命周期] --> B1[默认实现 TurboModule 接口]
    B1 --> B1a[initialize()：模块创建时调用，执行初始化（如注册监听器）]
    B1 --> B1b[示例：BlobModule、NetworkingModule]
    B1 --> B2a[invalidate()：模块销毁时调用，执行清理（如释放资源）]
    B1 --> B2b[示例：DeviceInfoModule、NetworkModule]
    
    C[iOS 平台生命周期] --> C1[遵循 RCTTurboModule 协议，需额外协议扩展]
    C1 --> C2[初始化：实现 RCTInitializing 协议]
    C2 --> C2a[步骤：导入协议头文件 + 类遵循协议 + 实现 initialize() 方法]
    C2 --> C2b[示例：RCTBlobManager、RCTTiming]
    C1 --> C3[清理：实现 RCTInvalidating 协议]
    C3 --> C3a[步骤：导入协议头文件 + 类遵循协议 + 实现 invalidate() 方法]
    C3 --> C3b[示例：RCTAppearance、RCTDeviceInfo]
```

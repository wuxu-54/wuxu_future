# 什么是 Codegen？

<https://www.react-native.cn/docs/next/the-new-architecture/what-is-codegen>

React Native中的Codegen是一个强大的工具，主要用于在JavaScript和原生代码（像Java、Kotlin、Objective - C、Swift这类）之间生成类型安全的桥接代码。它能够极大地减少手动编写样板代码的工作量，还能增强跨平台通信的可靠性。

使用 Codegen 并不是必须的：您可以手动编写所有生成的代码。然而，Codegen 生成的脚手架代码可以节省您很多时间。

React Native 会在每次构建 iOS 或 Android 应用时自动调用 Codegen。偶尔，您可能需要手动运行 Codegen 脚本来了解实际生成的类型和文件：这在开发 Turbo Native Modules 和 Fabric Native Components 时很常见。

## Codegen 是如何工作的

Codegen 是一个与 React Native 应用紧密耦合的工具。Codegen 脚本位于 react-native NPM 包中，并在构建时调用这些脚本。

Codegen 会遍历您项目中的文件夹，从 package.json 中指定的目录开始，寻找包含特定 API 规范（或规范）的 JS 文件。规范文件是用一种类型化方言编写的 JS 文件：React Native 目前支持 Flow 和 TypeScript。

每当 Codegen 找到规范文件时，它会生成与该文件关联的脚手架代码。Codegen 会生成一些 C++ 粘合代码，然后生成特定于平台的代码，使用 Java 为 Android 生成代码，使用 Objective-C++ 为 iOS 生成代码。

### 核心作用

1. **类型自动同步**：Codegen会依据TypeScript或者Flow定义的类型，自动生成原生代码对应的类型定义。
2. **通信接口生成**：它可以自动创建模块之间的通信接口，像Native Modules和Turbo Modules的接口。
3. **类型安全保障**：借助生成的代码，能有效降低JavaScript和原生代码之间因类型不匹配而产生的错误。

### 工作流程

1. **定义接口**：先在JavaScript端用TypeScript或者Flow定义好模块接口。
2. **配置Codegen**：通过配置文件，告知Codegen要处理哪些文件以及生成何种类型的代码。
3. **生成代码**：运行Codegen命令，它就会自动生成对应的原生代码文件。
4. **集成到项目**：把生成的代码集成到iOS和Android项目中。

### 具体使用步骤

#### 1. 安装依赖

```bash
npm install --save-dev @react-native/codegen
```

#### 2. 定义模块接口

创建一个`.ts`文件，例如`MyModule.ts`，并定义模块接口：

```typescript
// MyModule.ts
export type MyModuleType = {
  multiply(a: number, b: number): Promise<number>;
  showMessage(message: string): void;
};

// 定义事件类型
export type MyEvent = {
  name: string;
  data: any;
};
```

#### 3. 配置Codegen

在项目根目录下创建`codegen-config.json`文件：

```json
{
  "modules": {
    "MyModule": {
      "type": "specs",
      "jsSrcs": [
        "MyModule.ts"
      ],
      "outputDir": "generated"
    }
  }
}
```

#### 4. 运行Codegen命令

```bash
npx react-native-codegen --config codegen-config.json
```

#### 5. 实现原生模块

**iOS（Swift）示例**：

```swift
import Foundation
import React

@objc(MyModule)
class MyModule: RCTEventEmitter {
  // 实现由Codegen生成的接口
  override func supportedEvents() -> [String]! {
    return ["myEvent"]
  }
  
  @objc func multiply(_ a: Double, b: Double, resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
    resolve(a * b)
  }
  
  @objc func showMessage(_ message: String) {
    print("Message: \(message)")
  }
}
```

**Android（Kotlin）示例**：

```kotlin
package com.example.myapp

import com.facebook.react.bridge.*
import com.facebook.react.module.annotations.ReactModule

@ReactModule(name = MyModule.NAME)
class MyModule(reactContext: ReactApplicationContext) :
  ReactContextBaseJavaModule(reactContext) {
  
  companion object {
    const val NAME = "MyModule"
  }
  
  override fun getName(): String {
    return NAME
  }
  
  @ReactMethod
  fun multiply(a: Double, b: Double, promise: Promise) {
    promise.resolve(a * b)
  }
  
  @ReactMethod
  fun showMessage(message: String) {
    Log.d("MyModule", "Message: $message")
  }
}
```

#### 6. 注册模块

**iOS**：在`AppDelegate.m`中注册：

```objective-c
#import "MyModule.h"

@implementation AppDelegate

// ...

- (NSArray<id<RCTBridgeModule>> *)extraModulesForBridge:(RCTBridge *)bridge {
  return @[[MyModule new]];
}

@end
```

**Android**：在`MainApplication.java`中注册：

```java
import com.example.myapp.MyModule;

public class MainApplication extends Application implements ReactApplication {
  // ...
  
  @Override
  protected List<ReactPackage> getPackages() {
    @SuppressWarnings("UnnecessaryLocalVariable")
    List<ReactPackage> packages = new PackageList(this).getPackages();
    // 添加我们的模块
    packages.add(new ReactPackage() {
      @Override
      public List<NativeModule> createNativeModules(ReactApplicationContext reactContext) {
        List<NativeModule> modules = new ArrayList<>();
        modules.add(new MyModule(reactContext));
        return modules;
      }
      
      // ...
    });
    return packages;
  }
}
```

#### 7. 在JavaScript中使用

```javascript
import { NativeModules } from 'react-native';

const { MyModule } = NativeModules;

// 使用模块
MyModule.multiply(2, 3).then(result => {
  console.log('Result:', result); // 输出 6
});

MyModule.showMessage('Hello from Native Module!');
```

### 优势

1. **减少错误**：由于是自动生成代码，降低了手动编写代码时可能出现的错误。
2. **提升效率**：节省了编写和维护桥接代码的大量时间。
3. **类型安全**：确保JavaScript和原生代码之间的数据类型一致。
4. **易于维护**：当接口发生变化时，只需更新TypeScript定义，然后重新生成代码即可。

### 注意事项

1. 要保证TypeScript类型定义准确无误，因为Codegen是依据这些定义来生成代码的。
2. 对于复杂类型，如自定义对象，需要在两端都有清晰的定义。
3. 不同版本的React Native，Codegen的配置和用法可能会有所不同，建议参考对应版本的官方文档。

通过合理运用Codegen工具，能够让React Native项目的开发更加高效，代码质量更高。

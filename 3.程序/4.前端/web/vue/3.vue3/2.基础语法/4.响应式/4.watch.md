# watch

>vue2中有对watch的详细描述，vue3中watch作用与vue2一致，所以这里只做简要表述

watch可以以下观察响应式数据的变化：

* ref定义的数据
* reactive定义的数据
* 函数返回一个值（getter函数）
* 一个包含上述内容的数组

## watch结构

watch 函数接受两个参数：第一个参数是你想要观察的数据源，它可以是一个ref、reactive对象，或者是一个getter函数；第二个参数是一个回调函数，当被观察的数据发生变化时，这个回调函数会被调用。

这里是watch函数的一个基本用法示例：

```javascript
import { ref, watch } from 'vue';

const count = ref(0);

watch(count, (newValue, oldValue) => {
  console.log(`count changed from ${oldValue} to ${newValue}`);
});
```

在这个例子中，我们创建了一个响应式的count变量，并使用watch函数来观察它的变化。每当count的值发生变化时，都会打印出变化前后的值。

## watch配置项

watch 函数还有一些可选的配置项，例如：

* **immediate**: 如果设置为true，watcher将立即执行一次回调函数，而不是等待源数据变化。
* **flush**: 控制回调函数的执行时机，可以是'pre'、'post'、'sync'等。
* **deep**: 如果设置为true，watcher将会递归地观察对象内部的所有数据变化，即深度监视。

## 停止观察

watch 函数返回一个停止观察的函数，你可以调用它来停止watcher：

```javascript
const stopWatching = watch(count, (newValue, oldValue) => {
  console.log(`count changed from ${oldValue} to ${newValue}`);
});

// 当你想要停止观察时，调用这个函数
stopWatching();
```

## 与computed区别

* **用途**：`computed`用于声明性地创建派生状态，而`watch`用于观察数据变化并执行逻辑。
* **惰性求值**：`computed`属性是惰性求值的，只有当依赖变化时才重新计算；`watch`则是实时响应数据变化。
* **缓存**：`computed`有内置的缓存机制，只有依赖变化时才更新；`watch`不缓存结果，每次变化都会执行回调。
* **复杂逻辑**：`watch`可以执行更复杂的逻辑，如异步操作，而`computed`通常只用于简单的数据转换。

## 监视的情况

使用监视会有以下情况：

1. 监视`ref`的基础类型数据 ：直接写数据名，监视其value的改变
2. 监视`ref`的对象类型数据 ：直接写数据名，监视的是地址值，如果想监视其内部数据，需要开启deep
3. 监视`reactive`的对象类型数据，默认开启深度监视
4. 监视`ref`或`reactive`定义的对象类型数据内的某个**属性**，注意如下：
    * 若此属性为基础类型，watch第一个参需要写成函数形式
    * 若此属性是对象类型，watch第一个参可以直接写，也可以写成函数，建议写成函数。

# readonly 和 shallowReadonly

在Vue 3中，`Readonly`和`shallowReadonly`是用于创建不可变数据的API，它们是`TypeScript`的类型修饰符，用于提高代码的安全性和可读性。这些API并不直接改变数据的响应性，而是在Type检查时提供信息，告诉TypeScript编译器这些值是只读的。

## Readonly

`Readonly`是一个`TypeScript`的类型修饰符，用于将一个对象标记为只读。当你对一个对象使用Readonly时，你告诉编译器这个对象不应该被修改。尝试修改一个Readonly对象的属性将导致TypeScript编译错误。

使用场景：在Vue 3中，通常与响应式系统结合使用，如使用reactive或ref创建响应式数据，然后使用Readonly来防止外部代码修改这些数据。

## shallowReadonly

`shallowReadonly`同样是`TypeScript`的类型修饰符，它用于创建一个浅层只读的对象。这意味着对象的直接属性将被标记为只读，但对象内部的深层次属性仍然可以被修改。

使用场景：当你想要确保对象的外部结构不被改变，但内部对象仍然可以被修改时，可以使用shallowReadonly。

## 示例

```js
import { ref } from 'vue';

// 创建一个响应式引用
const count = ref(0);

// 使用Readonly创建一个只读的响应式引用
const readonlyCount: Readonly<typeof count.value> = count.value;

// 创建一个浅层只读的响应式对象
const state = ref({ count: 0 });
const shallowReadonlyState: Readonly<typeof state.value> = state.value;
```

在这个例子中，`readonlyCount`是一个只读的响应式引用，尝试修改它将导致TypeScript编译错误。而`shallowReadonlyState`是一个浅层只读的响应式对象，你可以修改count属性的值，但不能更改这个对象本身，比如替换新对象。

## 总结

`Readonly`和`shallowReadonly`是TypeScript的类型修饰符，它们在Vue 3中与响应式系统结合使用，提供了一种在Type检查阶段防止数据被修改的方法。这些API有助于提高代码的安全性和可维护性，特别是在处理来自外部的或不确定的数据时。使用这些API时，需要注意**它们只影响TypeScript的类型检查，并不会改变数据的实际响应性。**

# ref与reactive

在Vue 3中，ref和reactive是两个用于创建响应式数据的API，它们都是Composition API的一部分。尽管它们的目的相似，但它们在使用和行为上有一些区别。以下是ref和reactive的详细比较：

## ref对象

* **创建基本响应式值**：ref用于创建一个响应式的引用，适用于基本数据类型（如字符串、数字、布尔值等）。
* **使用.value属性**：ref也支持对象类型，底层是与reactive相同方法即`Proxy对象`实现。创建的响应式引用对象需要通过`.value`属性来获取或修改它的值。
  >注意，在其他响应式内部，调用时会无需.value，底层会自动切value属性，直接写【属性.名称】即可（如：`reactive({ a:ref(3) })`，调用到`a`时，需要加`.value`）。
* **更好的类型推断**：对于基本数据类型，ref提供了更好的类型推断，因为它始终是一个单一的值。
* **模板语法友好**：在Vue模板中，可以直接使用ref创建的变量，而不需要通过`.value`属性。

### ref示例

```javascript
import { ref } from 'vue';
const count = ref(0);
const obj = ref({a:1})
// ref定义的对象，取值必须使用 .value；注意，在其他响应式内部，调用时会无需.value，底层会自动切value属性，直接写【属性.名称】即可，
console.log(obj.value.a)

// 模版中使用
<template>
  <div>{{ count }}</div> <!-- 直接使用count -->
</template>
```

---

## reactive对象

* **创建响应式对象**：reactive用于创建一个响应式的对象，适用于对象或数组，**不能创建基础类型响应式**。
* **直接修改对象属性**：reactive返回的对象是原始对象的代理（是Proxy对象），可以直接修改对象的属性，而不需要通过某种特定的方法或属性。
* **深层响应式**：reactive确保对象的所有嵌套属性都是响应式的。
* **类型推断**：reactive通常用于处理复杂对象，因此类型推断可能不如ref直接，但仍然提供了良好的类型推断支持。

### reactive示例

```javascript
import { reactive } from 'vue';

const state = reactive({
  count: 0,
  message: 'Hello Vue 3'
});

// 在模板中：
<template>
  <div>{{ state.count }}</div>
  <div>{{ state.message }}</div>
</template>
```

---

## 响应式对象的赋值

不论是ref还是reactive，响应式对象在赋值时，不能直接替换赋值（因为对象指向一个地址，直接赋值其实就不是原对象了），可以采用`Object.assign()`进行浅拷贝赋值。

---

## 区别总结

* `ref`支持**基础数据类型、对象类型**响应式数据，但更适合用于单个**基本数据类型**的响应式值，而`reactive` 只能用于**对象或数组**的响应式处理。
* 在模板中使用`ref`时，不需要额外的`.value`属性，而`reactive`返回的对象需要通过属性访问。
* `ref`对于基本数据类型提供了更好的类型推断，而`reactive`则适用于处理复杂对象的类型推断。
* `ref`创建的响应式引用在JavaScript中使用`.value`属性，这有助于避免潜在的混淆，而`reactive`创建的对象则更接近原始对象的使用方式。

## 使用原则

* 基本类型响应式数据，必须使用ref
* 响应式对象，层级不深，ref或reactive都行
* 响应式对象，层级较深，推荐reactive。(因为ref中对象响应式在底层通过Proxy对象来实现。每个响应式对象是一个Proxy对象，层级很深时会有很多Proxy对象，性能有损耗)

## 补充说明

官方文档中还有一些特别说明：

1. reactive解构后的数据不会响应式，从对象角度来说，解构是新值，也就不是操作原响应式对象了，所以没有响应式了。
2. ref在模版中使用只有顶级的ref会自动解包，其深层的ref不会再解包，无法直接使用，还是需要通过 `.value`使用。

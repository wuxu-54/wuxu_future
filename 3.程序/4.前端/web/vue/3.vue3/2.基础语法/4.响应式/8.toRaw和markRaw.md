# toRaw和markRaw

在Vue 3中，toRaw和markRaw是两个与响应式系统相关的函数，它们用于处理响应式对象。

* toRaw：将响应式数据转换为非响应式数据。（全部转换）
* markRaw：用于将一个对象标记为非响应式。（标记部分转换）

## toRaw

toRaw函数用于获取一个响应式对象的原始（raw）版本。在Vue 3中，响应式系统使用了Proxy来追踪依赖和变化，但是有时候我们需要获取到对象的原始版本，即没有被Proxy包装的版本。toRaw函数在这种情况下非常有用。

使用场景包括：

* 当你需要传递一个对象给一个非响应式的API或者一个不关心响应式的库时。
* 当你需要比较两个对象是否是同一个实例，而不是比较它们的值是否相等时。

## markRaw

markRaw函数用于将一个对象标记为非响应式，即使它位于响应式对象的属性中。当你使用markRaw时，Vue将不会追踪这个对象的变化，也不会递归地将其内部属性转换为响应式。

使用场景包括：

* 当你有一个大型对象，但只需要其中的一小部分是响应式的。
* 当你需要确保对象的某个属性不会被Vue的响应式系统追踪时

## 示例

* toRaw示例

    假设你有一个响应式对象state，并且你想要获取它的原始版本

    ```js
    import { reactive, toRaw } from 'vue';

    const state = reactive({ count: 0 });
    const rawState = toRaw(state);//现在rawState是state的非响应式版本。
    ```

* markRaw示例

    如果你有一个响应式对象，但你想要确保某个属性不会被Vue追踪。

    ```js
    import { reactive, markRaw } from 'vue';

    const state = reactive({
    count: 0,
    largeObject: {}
    });

    // 在这个例子中，largeObject将不会被Vue转换为响应式，即使它是state对象的一个属性。
    markRaw(state, 'largeObject');
    ```

## 总结

`toRaw`和`markRaw`是Vue 3响应式系统中的两个高级API，它们允许开发者更细粒度地控制响应性。使用这些函数时需要谨慎，因为它们可能会影响Vue的响应式追踪和依赖收集机制。在大多数情况下，Vue的默认响应式行为已经足够好，只有在特定场景下才需要使用这些函数。

# computed

完全跟vue2一样，用于创建计算属性。计算属性是**基于响应式依赖**的派生状态，它们会根据依赖的状态自动更新。
>本文示例，都采用vue3中setup的写法，不会单独写到 computed 中

好处：

通过使用计算属性，你可以创建基于响应式数据的派生状态，并且确保这些状态是响应式的，只有当需要时才会更新。这有助于减少不必要的计算，提高应用的性能。

## 特性

1. **缓存**：计算属性具有缓存特性。只有当其依赖的响应式数据发生变化时，计算属性才会重新计算。
2. **惰性求值**：计算属性只有在被访问时才会计算。这意味着如果你定义了一个计算属性，但从未在模板或其他代码中使用它，那么计算逻辑将不会被执行。
3. **链式计算**：计算属性可以基于其他计算属性。这允许你构建复杂的派生状态。
4. **模板中的使用**：在Vue模板中，可以直接使用计算属性，而不需要通过.value属性访问。

## 基本用法

`computed`对象，参数传函数，必须带有返回值。

```javascript
import { ref, computed } from 'vue';

const count = ref(0);
// 传函数，带有返回值。
// 这里因为setup中没有this，所以直接用箭头函数
const doubledCount = computed(() => count.value * 2);

// 模版中使用
<template>
  <div>{{ doubledCount }}</div> 
</template>
```

在这个例子中，count是一个响应式引用（ref），而doubledCount是一个计算属性。doubledCount的值是count的值乘以2。当count的值改变时，doubledCount会自动更新。

## 链式计算

```javascript
import { ref, computed } from 'vue';

const count = ref(0);
const doubledCount = computed(() => count.value * 2);
const squaredCount = computed(() => {
  const doubled = doubledCount.value; // 使用另一个计算属性
  return doubled * doubled;
});
```

在这个例子中，squaredCount是一个基于doubledCount的计算属性。这展示了如何创建基于其他计算属性的派生状态。

## 计算属性与方法的区别

>vue2中有描述，这里再重复下

* **计算属性**：基于它们的依赖进行缓存，并且只有当依赖发生变化时才会重新计算。它们适合用于定义复杂的派生状态。
* **方法**：每次组件渲染时都会执行，即使它们的依赖没有变化。方法更适合用于执行副作用，如调用API、更改DOM等。

# 状态管理

状态变化会引起ui变化，如果多个vue 数据对象中持有同一个状态，这种情况变多时会变得不易维护，且无法感知变化时机，所以需要对状态（即数据）进行管理。

## 简单状态管理示例

Vue 应用中原始 data 对象的实际来源——当访问数据对象时，一个 Vue 实例只是简单的代理访问。所以，如果你有一处需要被多个实例间共享的状态，可以简单地通过维护一份数据来实现共享:

```js
var sourceOfTruth = {}

var vmA = new Vue({
  data: sourceOfTruth
})

var vmB = new Vue({
  data: sourceOfTruth
})
```

上述会有一个问题，不方便调试，在任何数据改变后，都不会留下变更过的记录。优化如下：

```js
var store = {
  debug: true,
  state: {
    message: 'Hello!'
  },
  setMessageAction (newValue) {
    if (this.debug) console.log('setMessageAction triggered with', newValue)
    this.state.message = newValue
  },
  clearMessageAction () {
    if (this.debug) console.log('clearMessageAction triggered')
    this.state.message = ''
  }
}

// 每个组件通过store进行状态管理
var vmA = new Vue({
  data: {
    privateState: {},
    sharedState: store.state
  }
})

var vmB = new Vue({
  data: {
    privateState: {},
    sharedState: store.state
  }
})
```

---

## 状态库：vuex

在Vue 2中，store（通常指的是Vuex,也是官方推荐库）是一个非常重要的概念，它用于管理和存储应用的所有组件的共享状态，并通过相应的规则来修改状态。以下是Vue 2中使用store的基本步骤和概念。

### 安装Vuex

首先，需要通过npm或yarn安装Vuex。使用npm的命令如下：

```shell
#注意：vue2 不能安装 vuex4以上版本，需要指定版本 vuex@3 
npm install vuex --save
```

>vue提供了 [vuex](https://github.com/vuejs/vuex)，已集成到[vue-devtools](https://github.com/vuejs/vue-devtools)中，无需配置即可进行调试。

### 创建Store

创建一个新的store文件夹，并在其中创建一个index.js文件。这个文件将用来存放store的配置和状态。一个基本的store结构如下：

```js
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    count: 0 // 初始状态
  },
  mutations: {
    increment(state) {
      state.count++;
    }
  }
});
```

### 在main.js中注册Store

在Vue实例化的时候，需要将store注册到Vue的实例中：

```js
import Vue from 'vue';
import App from './App.vue';
import store from './store'; // 引入store
import Vuex from 'vuex';

Vue.use(Vuex);

new Vue({
  store, // 注册store
  render: h => h(App),
}).$mount('#app');
```

### 在组件中使用Store

在组件中，可以通过`this.$store`来访问store。例如，可以调用mutation来改变状态：

```js
methods: {
  increment() {
    this.$store.commit('increment');
  }
}
```

也可以直接访问state中的数据：

```js
computed: {
  count() {
    return this.$store.state.count;
  }
}
```

### 使用Mutations修改状态

Mutations是**同步函数**，用于修改state中的数据。Mutations的调用方式如下：

```js
mutations: {
  changeCityCode(cityCode) {
  }
}

//-----------------------

//外部通过commit 调用此方法
this.$store.commit('setCityCode', cityCode);
```

### 使用Actions处理异步操作

Actions类似于mutations，但是它们可以包含异步操作。Actions的调用方式如下：

```js
actions: {
  setAsyncCount({commit},id) {
    //id == 200
  }
}

//-----------------------

//外部通过dispatch调用此方法
this.$store.dispatch('setAsyncCount', 200);
```

### 使用Modules进行模块化管理

当应用变得复杂时，store可能会变得臃肿。Vuex允许我们将store分割成模块（modules），每个模块可以包含自己的state、mutations、actions和getters。模块的创建和使用如下：

```js
import moduleA from './modules/a';
import moduleB from './modules/b';

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
});
```

在模块中使用state和getters时，需要指定模块名：

```js
computed: {
  ...mapState('a', ['count'])
},
methods: {
  ...mapActions('b', ['fetchData'])
}
```

### Getters

在Vuex中，getters用于从store中的状态（state）派生出一些状态的表现形式，它们可以被视为计算属性，并且可以进行缓存以优化性能。getters接收state作为其第一个参数，可以返回任何类型的值。

#### 定义Getters

```js
const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    // 一个getter的示例
    doneTodosCount(state) {
      return state.todos.filter(todo => todo.done).length;
    },
    // 另一个getter可以接收其他getter作为依赖
    doneTodos(state, getters) {
      return state.todos.filter(todo => todo.done);
    }
  }
});
```

#### 使用Getters

在Vue组件中，你可以通过`this.$store.getters[getterName]`来访问getter：

```js
export default {
  computed: {
    // 使用getter
    doneTodosCount() {
      return this.$store.getters.doneTodosCount;
    }
  }
};
```

或者，你也可以在模板中直接使用：

```html
<!-- 在模板中直接使用getter -->
<p>Done Todos Count: {{ doneTodosCount }}</p>
```

#### Getters作为依赖

Vuex中的getters还可以作为其他getters的依赖，这使得你可以构建更复杂的状态派生。

```js
getters: {
  // 一个简单的getter
  allDone(state) {
    return state.todos.every(todo => todo.done);
  },
  // 依赖于另一个getter的getter
  doneTodosCountPlusOne(getters) {
    // 依赖于allDone getter
    return getters.doneTodosCount + 1;
  }
}
```

#### 传递参数给Getters

通常情况下，getters不接受参数，因为它们应该仅依赖于state或其他getters。然而，有时候你可能需要根据一些外部的参数来获取状态。在这种情况下，你可以在Vue组件中这样使用：

```js
computed: {
  // 将参数传递给getter
  getTodoById() {
    return this.$store.getters.getTodoById(this.todoId);
  }
}
然后在store中定义一个接受参数的getter：

getters: {
  getTodoById(state) {
    return id => {
      return state.todos.find(todo => todo.id === id);
    };
  }
}
```

请注意，这种模式下，getter实际上返回了一个函数，这个函数在调用时可以接收参数。

### 使用MapState和MapGetters辅助函数

为了简化代码，Vuex提供了`mapState`和`mapGetters`辅助函数，它们可以将store中的状态和getters映射到组件的计算属性中：

```js
import { mapState, mapGetters } from 'vuex';

export default {
  computed: {
    ...mapState(['count']), // 将 `this.$store.state.count` 映射为 `this.count`
    ...mapGetters(['doneTodosCount']) // 将 `this.$store.getters.doneTodosCount` 映射为 `this.doneTodosCount`

    //也可以指定组件名
    ...mapState('store组件名',['count'])
    ...mapGetters('store组件名',['doneTodosCount'])
  }
}
```

---

以上就是Vue 2中使用store的基本方法和概念。通过这些方法，可以有效地管理应用的状态，并在组件之间共享数据。

---

## vuex命名空间

在Vuex的上下文中，命名空间用于隔离模块内部的mutation、action和getter，使得它们不会与其他模块的同名函数发生冲突。这在大型应用中尤其有用，因为它可以帮助开发者更好地组织和管理代码。

### 为什么使用命名空间

* 避免全局命名冲突：在一个大型应用中，可能会有很多状态和函数。使用命名空间可以确保模块之间不会发生命名冲突。
* 清晰的代码结构：命名空间提供了一种清晰的方式来组织代码，使得相关的功能和状态被分组在一起。
* 更好的模块化：命名空间允许开发者创建独立的模块，这些模块可以被重用和维护，而不会影响到应用的其他部分。

### 如何在Vuex中使用命名空间

在Vuex中，可以通过在模块的定义中设置`namespaced: true`来启用命名空间。这样，模块内部的所有状态、mutation、action和getter都会被限定在这个命名空间内。

```js
const moduleA = {
  namespaced: true, // 启用命名空间
  state: () => ({
    count: 0
  }),
  mutations: {
    increment(state) {
      state.count++;
    }
  },
  getters: {
    getCount(state) {
      return state.count;
    }
  },
  actions: {
    incrementIfOdd({ state, commit }) {
      if (state.count % 2 !== 0) {
        commit('increment');
      }
    }
  }
};
```

### 如何访问命名空间内的状态和函数

当模块启用了命名空间后，访问该模块的状态和函数需要**使用模块的路径作为前缀**。

在**组件**中，使用mapState、mapGetters、mapActions和mapMutations辅助函数时，需要指定模块的名称：

```js
import { mapState, mapActions } from 'vuex';

export default {
  computed: {
    ...mapState('moduleA', ['count'])
  },
  methods: {
    ...mapActions('moduleA', ['incrementIfOdd'])
  }
};
```

在**模板**中，直接访问状态时，也需要使用模块的名称作为前缀：

```html
<template>
  <div>
    <p>Count: {{ moduleA.count }}</p>
  </div>
</template>
```

在**其他模块或全局范围内**，访问命名空间内的函数时，需要使用完整的命名空间路径：

```js
store.commit('moduleA/increment');
store.getters['moduleA/getterName'];
```

通过使用命名空间，Vuex为大型应用提供了一种有效的方式来组织和管理状态。这不仅有助于避免潜在的命名冲突，还可以使代码更加清晰和易于维护。

---

## commit和dispatch

在Vuex中，mutations和actions都是处理和响应应用状态变化的重要部分。

### Mutations

mutations是同步事务，它们改变Vuex store中的状态。每个mutation都有一个字符串类型的type属性和一个handler函数。handler函数是当mutation被触发时执行的函数，它接收state作为第一个参数。

```js
const mutations = {
  // 定义mutation类型
  INCREMENT(state) {
    // 这里的state是Vuex store的状态对象
    state.count++;
  }
};
```

如果mutation需要接收额外的参数，可以在触发mutation时传递：

```js
// 触发mutation并传递额外的参数
commit('INCREMENT', payload);
```

在mutation的handler函数中，可以使用解构赋值来接收这些额外的参数：

```js
const mutations = {
  INCREMENT(state, payload) {
    state.count += payload.amount;
  }
};
```

### Actions

actions可以看作是mutation的异步版本。它们可以包含任何异步操作，并且在完成后可以提交mutation。actions接收一个与store实例具有相同方法和属性的context对象作为第一个参数。这个context对象通常简写为`{ commit, state, rootState, dispatch, getters}`。

```js
const actions = {
  async incrementAsync({ commit }) {
    setTimeout(() => {
      commit('INCREMENT');
    }, 1000);
  }
};
```

如果action需要接收额外的参数，可以在通过dispatch触发action时传递：

```js
// 触发action并传递额外的参数
this.$store.dispatch('incrementAsync', payload);
```

在action函数中，可以使用解构赋值来接收这些额外的参数：

```js
const actions = {
  async incrementAsync({ commit }, payload) {
    setTimeout(() => {
      commit('INCREMENT', payload);
    }, 1000);
  }
};
```

### 参数传递示例

以下是Vuex store中actions和mutations参数传递的一个完整示例：

```js
// Vuex store的actions定义
const actions = {
  async fetchData({ commit }, id) {
    try {
      const data = await fetchDataFromApi(id); // 假设的API调用
      commit('SET_DATA', data);
    } catch (error) {
      commit('SET_ERROR', error);
    }
  }
};

// Vuex store的mutations定义
const mutations = {
  SET_DATA(state, data) {
    state.items = data;
  },
  SET_ERROR(state, error) {
    state.error = error;
  }
};

// 触发action并传递额外的参数
this.$store.dispatch('fetchData', itemId);

// 在mutation中使用解构赋值来接收额外的参数
const mutations = {
  SET_DATA(state, { data }) {
    state.items = data;
  },
  // ...
};
```

在这个示例中，fetchData是一个action，它接收一个id参数，然后异步地从API获取数据，并在成功时提交SET_DATA mutation，或者在出错时提交SET_ERROR mutation。在mutation中，我们使用解构赋值来接收传递的参数。

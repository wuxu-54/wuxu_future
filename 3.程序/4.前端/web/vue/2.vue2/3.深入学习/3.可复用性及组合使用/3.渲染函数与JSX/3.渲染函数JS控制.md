# 渲染函数JS控制

前面讲`render`就是渲染函数，内部可以使用JS进行元素渲染的控制。

## 替代`v-if`和`v-for` 的控制示例

render中可以使用JS语法，完成Vue中`v-if`、`v-for`指令相同的处理。

例子：

```javascript
Vue.component("tt",{
props: ['items'],
render: function (createElement) {
    //这是if判断
  if (this.items.length) {
    //这是for 循环创建虚节点
    return createElement('ul', this.items.map(function (item) {
      return createElement('li', item.name)
    }))
  } else {
    return createElement('p', 'No items found.')
  }
}
})
```

## 替代`v-model`的控制示例

```javascript
Vue.component("tt",{
props: ['value'],
render: function (createElement) {
  var self = this
  return createElement('input', {
    domProps: {
      value: self.value
    },
    on: {
      input: function (event) {
        self.$emit('input', event.target.value)
      }
    }
  })
}
})
```

## 事件&按键修饰符

对于 `.passive`、`.capture` 和 `.once` 这些事件修饰符，Vue 提供了相应的前缀可以用于 `on` property:

|修饰符|处理函数中的等价操作|
|--|--|
|`.passive`|`&`|
|`.capture`|`!`|
|`.once`|`~`|
|`.capture.once` 或`.once.capture`|`~!`|

例子

```javascript
on: {
  '!click': this.doThisInCapturingMode,
  '~keyup': this.doThisOnce,
  '~!mouseover': this.doThisOnceInCapturingMode
}
```

对于其它的所有修饰符，私有前缀都不是必须的，因为你可以在事件处理函数中使用事件方法:

|修饰符|处理函数中的等价操作|
|--|--|
|`.stop`|`event.stopPropagation()`|
|`.prevent`|`event.preventDefault()`|
|`.self`|`if (event.target !== event.currentTarget) return`|
|按键：`.enter`, `.13`|`if (event.keyCode !== 13) return` (对于别的按键修饰符来说，可将 13 改为另一个按键码)|
|修饰键：`.ctrl`, `.alt`, `.shift`, `.meta`|`if (!event.ctrlKey) return`(将 `ctrlKey` 分别修改为 `altKey`、`shiftKey` 或者 `metaKey`)|

## 渲染函数实现插槽

渲染函数中可以使用插槽，等同于模版中插槽。

### 使用静态插槽

使用`this.$slots`获取静态插槽,每个插槽是一个`VNode数组`

slots对象格式：`{ [name: string]: ?Array<VNode> }`

例子：

```javascript
render: function (createElement) {
  // 最终渲染函数创建的虚节点等同于模版：`<div><slot></slot></div>`
  // 获取静态插槽，并将其作为子节点设定给当前组件
  return createElement('div', this.$slots.default) //default是插槽默认名，可以自定义，此插槽就变为具名插槽
}
```

### 使用作用域插槽

通过 `this.$scopedSlots` 设定作用域插槽，每个作用域插槽都是一个函数,返回若干 `VNode`对象

scopedSlots对象格式：`{ [name: string]: props => Array<VNode> | undefined }`

例子：

```javascript
props: ['message'],
render: function (createElement) {
  //等同于模版： `<div><slot :text="message"></slot></div>`
  return createElement('div', [
    //获取作用域插槽，并作为内容设定给当前组件
    this.$scopedSlots.default({//default是插槽默认名，可以自定义，此插槽就变为具名插槽
      text: this.message //作用域插槽：子组件数据绑定到text属性上
    })
  ])
}
```

### 访问子组件作用域数据

利用 VNode 数据对象中的 `scopedSlots` 设置作用域插槽对象：

```javascript
render: function (createElement) {
  // 等同于模版：`<div><child v-slot="props"><span>{{ props.text }}</span></child></div>`
  return createElement('div', [
    createElement('child', {
      // 在数据对象中传递 `scopedSlots`
      // 格式为 { name: props => VNode | Array<VNode> }
      scopedSlots: {
        default: function (props) {//这个props就是插槽对象
          return createElement('span', props.text)
        }
      }
    })
  ])
}
```

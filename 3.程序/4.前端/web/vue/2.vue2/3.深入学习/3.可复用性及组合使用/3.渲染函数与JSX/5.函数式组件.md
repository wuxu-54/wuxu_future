# 函数式组件

含义：组件单纯作为函数使用，不涉及任何响应式、vue绑定、ui状态、事件，也没有实例（this）。
定义：使用property `functional`，值为true，此组件即为函数式组件。
好处：因为只是函数，渲染时性能开销相对组件会低很多。

例子：

```javascript
Vue.component('my-component', {
  functional: true,
  // Props 是可选的
  props: {
    // ...
  },
  // 为了弥补缺少的实例
  // 提供第二个参数作为上下文
  render: function (createElement, context) {
    // ...
  }
})
```

## 组件参数`context`

函数式组件中需要的一切都是通过 `context` 参数传递，它是一个包括如下字段的对象：

* `props`：提供所有 prop 的对象
* `children`：VNode 子节点的数组
* `slots`：一个函数，返回了包含所有插槽的对象
* `scopedSlots`：(2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。
* `data`：传递给组件的整个数据对象，作为 `createElement` 的第二个参数传入组件
* `parent`：对父组件的引用
* `listeners`：(2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 data.on 的一个别名。
* `injections`：(2.3.0+) 如果使用了 `inject` 选项，则该对象包含了应当被注入的 property。

当设定为函数式组件后，`this`由`context`代替。

## 与普通函数区别

1. 函数式组件需要在声明组件是指定functional,使用click方法必须加 `v-on="listeners"` 才生效
2. 函数式组件不需要实例化，所以没有this，this通过`render`函数的第二个参数来代替。
3. 函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等。
4. 函数式组件不能通过`$emit`对外暴露事件，调用事件只能通过`context.listeners.click`的方式调用外部传入的事件。
5. 因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement。

## 注意

1. 在 `2.3.0` 之前的版本中，如果一个函数式组件想要接收 prop，则 `props` 选项是必须的。在 `2.3.0 或以上的版本`中，你可以省略 `props` 选项，所有组件上的 attribute 都会被自动隐式解析为 prop。
2. 当使用函数式组件时，该引用将会是 HTMLElement，因为他们是无状态的也是无实例的。
3. 在 `2.5.0 及以上版本`中，如果你使用了`单文件组件`(后面会讲)，那么基于模板的函数式组件可以这样声明:

    ```html
    <template functional></template>
    ```

## 什么时候使用

1. 自己不渲染，而是需要通过条件判断选择已有组件时。
2. 需要想子组件传递数据时，如:`children`,`props`,`data`等。

## 组件继承

前面我们学过，子组件会默认继承父组件的Attribute属性（具体规则可看[非Prop的Attribute](../../1.%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6/2.Prop/3.%E9%9D%9EProp%E7%9A%84Attribute.md)），函数是组件必须显示传递！

例子：

```javascript
Vue.component('my-functional-button', {
  functional: true,
  render: function (createElement, context) {
    // 显示透传任何 attribute、事件监听器、子节点等。
    return createElement('button', context.data, context.children)
  }
})
```

如果使用基于模版的函数式组件，可以使用 `data.attrs`传递任何Attribute，使用`listeners`（`data.on`的别名）传递任何事件

例子：

```html
<template functional>
  <button
    class="btn btn-primary"
    v-bind="data.attrs"
    v-on="listeners"
  >
    <slot/>
  </button>
</template>
```

## `slots()` 和 `children` 对比

示例:

```html
<my-functional-component>
  <p v-slot:foo>
    first
  </p>
  <p>second</p>
</my-functional-component>
```

上述是个带有子节点的函数式组件，在向子组件传递插槽内容时，二者有明显使用区别：

* 使用slots可以根据插槽名称选择匹配哪个插槽，`slots().default` 只会传递第二个匿名段落标签，`slots().foo` 会传递第一个具名段落标签。
* children是给出所有子节点。

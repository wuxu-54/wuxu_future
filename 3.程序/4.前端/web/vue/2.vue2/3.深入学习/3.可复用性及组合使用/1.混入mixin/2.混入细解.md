# 混入细解

一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项

## 实现混入

```javascript
// 定义一个混入对象
var myMixin = {
  created: function () {
    this.hello()
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!')
    }
  }
}

// 定义一个使用混入对象的组件
var Component = Vue.extend({
  //通过 mixins 属性，配置混入对象
  mixins: [myMixin]
})

var component = new Component() // => "hello from mixin!"

//Vue对象，直接混入
new Vue({
    mixins:[myMixin]
})
```

*补充知识*：

什么是`Vue.extend()`?

答：Vue的全局API，官方解释是*继承构造函数*，用于创建一个组件对象。参数是个组件对象，返回值是`扩展实例构造器`。
>个人理解，通过此API传入一个组件类型对象，类似于一个**模版组件对象**。此函数返回一个构造函数，通过此构造函数创建的对象都是从模版组件对象复制而来。

什么时候用?

答：需要动态渲染组件时

---

## 混入时同名项合并

当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。

### 合并规则

1. 非同名，会合并到组件中
2. 同名项数据会合并，若发生冲突时以组件数据优先。如：值为对象的选项，例如 `methods`、`components` 和 `directives`，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。
3. 同名钩子函数合并为一个数组，且混入对象优先调用

例子：

```javascript
var mixin = {
  methods: {
    foo: function () {
      console.log('foo')
    },
    conflicting: function () {
      console.log('from mixin')
    }
  }
}

var vm = new Vue({
  mixins: [mixin],
  methods: {
    bar: function () {
      console.log('bar')
    },
    conflicting: function () {
      console.log('from self')
    }
  }
})

vm.foo() // => "foo"
vm.bar() // => "bar"
vm.conflicting() // => "from self"
```

### 自定义合并策略

使用`Vue.config.optionMergeStrategies`

例子：

```javascript
Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {
  // 返回合并后的值
}
```

---

## 全局混入

通过`Vue.mixin`实现
>注意，全局混入是全局生效影响每一个后建的vue实例，使用时要格外小心！

例子：

```javascript
// 为自定义的选项 'myOption' 注入一个处理器。
Vue.mixin({
  created: function () {
    var myOption = this.$options.myOption
    if (myOption) {
      console.log(myOption)
    }
  }
})

new Vue({
  myOption: 'hello!'
})
// => "hello!"
```

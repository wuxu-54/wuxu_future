# 侦听属性

设计用途：当数据变化时执行异步或开销较大的操作时，这个方式是最有用的。

定义：Vue对象中的watch属性

实例：

```javascript
<div id="demo">{{ fullName }}</div>

new Vue({
    el:'#demo',
    data:{
        firstName:"a",
        lastName:"b",
        fullName:"a b"
    },
    watch:{ //监听 data中的属性值变化
       
        //firstName 属性值有变化，这里就会回调
        firstName:function(val){
            this.fullName = val + " " + lastName
        },
        lastName:function(val){
            this.fullName=firstName+ " " + val
        }
    }
})
```

---

## watch里常用的属性

以下是watch中可以设置的一些常用属性：

* **handler**：必需的属性，它是一个函数，当观察的目标发生变化时，这个函数将被调用。

* **immediate**：可选属性，一个布尔值。如果为true，则在开始观察数据变化之前立即执行handler函数一次。

* **deep**：可选属性，一个布尔值。如果为true，将使用deep watcher，观察目标对象内部属性的变化。

* **shallow**：可选属性，一个布尔值。如果为true，将使用shallow watcher，仅观察目标对象本身的变化，不观察其内部属性。

* **flush**：可选属性，可以是字符串或函数。控制handler函数执行的时机。

* **deepHandlers**：可选属性，一个布尔值。如果为true，将对对象的每个嵌套属性使用deep watcher。

* **unwatch**：可选属性，一个函数，用于停止观察。

* **sync**：可选属性，一个布尔值。如果为true，将同步执行handler函数。

* **before**：可选属性，一个函数，在执行handler函数之前调用。

---

## immediate 的用法

* 当immediate设置为true时，handler函数会在开始观察数据变化之前立即执行一次。这在需要立即获取数据或者执行某些初始化逻辑时非常有用。
* 当immediate设置为false（默认值），handler函数只会在观察到数据变化后执行。

### 示例

假设你有一个组件，需要在挂载后立即从服务器获取数据，并且之后每当数据变化时更新视图：

```js
export default {
  data() {
    return {
      // 你的数据属性
      someData: null,
    };
  },
  watch: {
    // 观察 'someData' 属性
    someData: {
      // 这里的handler就是当 'someData' 发生变化时调用的函数
      handler(newValue, oldValue) {
        // 在这里编写数据变化时的逻辑
        console.log(`someData changed to ${newValue}`);
      },
      // 立即执行handler函数
      immediate: true
    },
  },
  // ... 其他选项如 methods, created 等
};
```

在这个例子中，当组件实例被创建并且watch被设置后，handler函数会立即执行，即使someData的值尚未变化。

### $route 的 watch 与 immediate

当观察$route对象时（在Vue Router中代表当前路由），使用`immediate: true`可以确保在路由对象首次被观察时，就立即执行`handler函数`。这对于执行与路由相关的初始化逻辑非常有用，比如检查权限、设置页面标题、获取页面数据等。

```js
export default {
  watch: {
    $route: {
      // 这个handler函数会在路由变化时调用...
      handler(to, from) {
        // 'to' 是目标路由对象，'from' 是来源路由对象
        console.log(`从 ${from.path} 路由到了 ${to.path}`);
      },
      // 立即执行handler，适用于在开始时执行路由相关的逻辑
      immediate: true
    }
  },
  // ... 其他选项
};
```

在这个例子中，无论何时路由变化，都会打印出从哪个路由路径跳转到哪个路由路径，包括首次观察`$route`时。这可以确保即使用户没有离开当前页面，必要的路由相关逻辑也会执行。

---

## flush

在Vue 2中，`flush` 是一个与侦听器（watchers）相关的配置选项，它可以用来控制侦听器回调的刷新时机。Vue 2的响应式系统是异步的，这意味着当你更改数据时，视图的更新会异步进行。`flush` 选项允许你指定回调执行的时间点，相对于DOM的更新。

Vue 2提供了以下几种`flush`策略：

1. **`pre`**：这是默认值，表示在DOM更新之前执行回调。这意味着你可以在DOM更新之前获取到最新的数据状态。

2. **`post`**：表示在DOM更新之后执行回调。这在你想要在DOM更新后立即执行某些操作时非常有用，例如，当你需要基于更新后的DOM进行操作时。

3. **`sync`**：表示立即同步执行回调。这将跳过异步更新队列，直接执行回调。

在Vue 2中，`flush` 选项通常与`watch`或`watchEffect` API一起使用。例如，如果你想要确保在DOM更新后立即执行某些操作，你可以这样设置：

```javascript
watch(() => state.someObject, (newValue, oldValue) => {
  // 注意：`newValue` 此处和 `oldValue` 是相等的
  // *除非* state.someObject 被整个替换了
}, { deep: true, flush: 'post' })
```

或者，如果你使用的是`watchEffect`：

```javascript
watchEffect(() => {
  /* 在 Vue 更新后执行 */
}, {
  flush: 'post'
})
```

`flush: 'post'`选项在Vue 3中被重命名为`watchPostEffect`，它是一个更方便的别名，用于在Vue更新后执行回调。

需要注意的是，`flush` 选项并不会影响数据变更的异步性，它只是改变了回调执行的时机。这意味着，即使你使用了`flush: 'post'`，数据变更和DOM更新之间仍然存在异步延迟。如果你需要在数据变更后立即执行某些操作，你应该考虑使用`flush: 'sync'`选项，但这会牺牲掉异步更新的性能优势。

---

## 与计算属性区别

1. 侦听属性对象的属性，依赖已有属性数据如data中的属性。当data中属性的值变化，watch中会有回调。而计算属性的对象中的属性就是一个新的属性，值是函数返回的。
2. 二者都可进行复杂操作，但侦听属性更适用在异步请求等更复杂的操作。
3. 计算属性对象中的属性可以设置set、get函数对值进行处理后再设置或取出

# 使用v-for

v-for有不同使用场景

---

## 显示过滤/排序后的结果

有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组。

例子：

```html
<li v-for="n in evenNumbers">{{ n }}</li>

<script>
data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
computed: {
  evenNumbers: function () {
    return this.numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
</script>
```

当计算属性不适用时，如嵌套在v-for中，可以通过【方法】处理：

```html
<ul v-for="set in sets">
  <li v-for="n in even(set)">{{ n }}</li>
</ul>

<script>
  data: {
  sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]
},
methods: {
  //使用方法，进行数据处理
  even: function (numbers) {
    return numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
</script>
```

---

## v-for 使用整数

```javascript
<div>
  <span v-for="n in 10">{{ n }} </span>
</div>
```

---

## 在 `<template>` 上使用 v-for

类似于 v-if，也可以使用 `<template>` 来循环渲染一段包含多个元素的内容。比如：

```javascript
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider" role="presentation"></li>
  </template>
</ul>
```

---

## 一同使用 v-for 与 v-if

注意: 不推荐在同一元素上使用 v-if 和 v-for

当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下：

```html
<!-- 这里只渲染 if 为true时的内容 -->
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo }} 
</li>
```

如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 `<template>`) 上。如：

```html
<ul v-if="todos.length">
  <li v-for="todo in todos">
    {{ todo }}
  </li>
</ul>
<p v-else>No todos left!</p>
```

---

## 在组件上使用 v-for

在自定义组件上，你可以像在任何普通元素上一样使用 v-for。

```html
<my-component v-for="item in items" :key="item.id"></my-component>
```

注意！！！

自定义组件中，数据不会自动传入到组件里，因为自定义组件有自己的作用域，需要使用属性指定：

```html
<!-- 
  不自动将 item 注入到组件里的原因是，这会使得组件与 v-for 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。

  这里 v-bind 就是手动绑定了值
 -->
<my-component
  v-for="(item, index) in items"
  v-bind:item="item"
  v-bind:index="index"
  v-bind:key="item.id"
></my-component>
```

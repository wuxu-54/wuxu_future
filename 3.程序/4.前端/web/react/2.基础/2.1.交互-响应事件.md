# 响应事件

- 执行事件需要是一个函数`onclick={function}`，而不是调用函数`onclick={function()}`
- 可以是普通函数，也可以是匿名函数
- 如果写成了调用函数，那么在渲染时会被立刻触发。
- 事件处理程序因为在组件内部声明，所以可以直接访问组件属性。

    ```js
    function AlertButton({ message, children }) {
    return (//直接访问组件的message属性
        <button onClick={() => alert(message)}>
        {children}
        </button>
    );
    }
    ```

- 事件处理程序可以作为属性传递。
- 事件处理程序可以有副作用（即一些异步处理等）

## 组件自定义事件处理程序属性

`<button>` 和 `<div>` 等内置组件仅支持 浏览器事件名称，如 onClick。但是，当你构建自己的组件时，你可以按照自己喜欢的方式命名它们的事件处理程序属性。

```js
function Button({ onSmash, children }) {
  return (
    <button onClick={onSmash}>
      {children}
    </button>
  );
}

export default function App() {
  return (
    //自定义 onSmash 事件
    <div>
      <Button onSmash={() => alert('Playing!')}>
        Play Movie
      </Button>
      <Button onSmash={() => alert('Uploading!')}>
        Upload Image
      </Button>
    </div>
  );
}
```

>注意：确保为事件处理程序使用适当的 HTML 标记。例如，要处理点击，请使用 `<button onClick={handleClick}>` 而不是 `<div onClick={handleClick}>`。使用真正的浏览器 `<button>`启用内置浏览器行为，如键盘导航。如果你不喜欢按钮的默认浏览器样式并且想让它看起来更像一个链接或不同的 UI 元素，你可以使用 CSS 来实现。

## 事件传播

事件在树上 “冒泡” 或 “传播”：它从事件发生的地方开始，然后沿着树上升。事件处理程序携带`event`参数

### 冒泡

一个点击事件，子组件先响应，然后向上传递给父组件。可以通过`e.stopPropagation()`拦截

### 捕获

父组件获取事件：`e.stopPropagation()` , 先触发，然后才给到子组件。

## 传递处理程序作为传播的替代方法

即通过将事件作为属性传递给子组件的方式，作为原始行为的替代。

```js
function Button({ onClick, children }) {//外部传入事件属性
  return (
    <button onClick={e => {
      e.stopPropagation();
      onClick();
    }}>
      {children}
    </button>
  );
}
```

你也可以在调用父 onClick 事件处理程序之前向此处理程序添加更多代码。此模式提供了传播的替代方案。它让子组件处理事件，同时也让父组件指定一些额外的行为。与传播不同，它不是自动的。但这种模式的好处是你可以清楚地跟踪作为某个事件的结果执行的整个代码链。

## 阻止默认行为

使用`e.preventDefault()`阻止浏览器的默认处理，比避免提交表单后重新加载页面。

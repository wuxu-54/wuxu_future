# 更新状态中的对象和数组

同其他语言一样，react对于`堆内存变量`需要特殊处理，不能直接修改其值，原因是指向同一堆内存地址的多个引用变量，其实都是同一个数据，直接修改值，其他引用位置都会立刻变化，因此状态设置校验结果一直是无变化，也就无法实时更新ui了。

## 更新引用类型变量

直接创建一个新引用变量，使用js的`...`展开语法，将不变的数据复制过去，仅修改变化的数据。(数组同理，直接创建新数组)

```js
const [person, setPerson] = useState({
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  }
});

const nextArtwork = { ...person.artwork, city: 'New Delhi' }; // 直接创建新对象
const nextPerson = { ...person, artwork: nextArtwork };
setPerson(nextPerson);
```

### 对象并没有真正嵌套

像这样的对象在代码中出现 “嵌套”：

```js
let obj = {
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  }
};
```

但是，“嵌套” 是一种不准确的思考对象行为方式的方法。当代码执行时，没有 “嵌套” 对象这样的东西。你真的在看两个不同的对象：

```js
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1
};
```

obj1 对象不是在 obj2 “里面” 。例如，obj3 也可以 “指向” obj1：

```js
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1
};

let obj3 = {
  name: 'Copycat',
  artwork: obj1
};
```

如果你要突变 obj3.artwork.city，它会影响 obj2.artwork.city 和 obj1.city。这是因为 obj3.artwork、obj2.artwork 和 obj1 是同一个对象。当你将对象视为 “嵌套” 时，很难看出这一点。而是，它们是具有属性的彼此独立的对象 “指向”。

## 数组类型状态设置

这里特别说一下数组一般怎么设置状态。

|  |	避免（改变数组）| 更喜欢（返回新数组）|
|:-|:-|:-|
|添加|	push, unshift|	concat、[...arr] 展开语法 (示例)|
|删除|	pop, shift, splice|	filter, slice (示例)|
|替换|	splice、arr[i] = ... 赋值|	map(示例)|
|排序|	reverse, sort|	首先复制数组 (示例)|

注意：

不幸的是，slice 和 splice 的命名相似但差别很大：

- slice 允许你复制一个数组或其中的一部分。
- splice 改变数组（插入或删除项目）。

在 React 中，你将更频繁地使用 slice（没有 p！），因为你不想改变状态中的对象或数组。更新对象 解释了什么是突变以及为什么不建议将其用于状态。

### 更新数组中的对象

对象并不是真正位于数组 “里面”。它们在代码中可能看起来是 “里面”，但数组中的每个对象都是一个单独的值，数组 “指向” 为该值。这就是为什么在更改像 list[0] 这样的嵌套字段时需要小心。另一个人的作品列表可能指向数组的同一个元素！

更改方法：直接以修改对象的方式，在数组中对象元素位置设置新对象即可。

### 示例

1. 使用`map()`修改数据

```js
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <button onClick={() => {
        setArtists([
          ...artists,
          { id: nextId++, name: name }
        ]);
      }}>Add</button>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

2. 使用`filter()`过滤数据

```js
import { useState } from 'react';

let initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye'},
  { id: 2, name: 'Louise Nevelson'},
];

export default function List() {
  const [artists, setArtists] = useState(
    initialArtists
  );

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>
            {artist.name}{' '}
            <button onClick={() => {
              setArtists(
                artists.filter(a =>
                  a.id !== artist.id
                )
              );
            }}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </>
  );
}
```

## 使用 Immer 编写简洁的更新逻辑

不改变地更新嵌套数组可能会有点重复。就像对象一样：

- 通常，你不需要更新超过几个层级的状态。如果你的状态对象非常深，你可能需要 以不同的方式重组它们 以便它们变平。
- 如果你不想更改你的状态结构，你可能更喜欢使用 Immer，它允许你使用方便但可变的语法进行编写，并负责为你生成副本。

示例：

```js
import { useState } from 'react';
import { useImmer } from 'use-immer';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, updateMyList] = useImmer(
    initialList
  );
  const [yourList, updateYourList] = useImmer(
    initialList
  );

  function handleToggleMyList(id, nextSeen) {
    updateMyList(draft => {
      const artwork = draft.find(a =>
        a.id === id
      );
      artwork.seen = nextSeen;
    });
  }

  function handleToggleYourList(artworkId, nextSeen) {
    updateYourList(draft => {
      const artwork = draft.find(a =>
        a.id === artworkId
      );
      artwork.seen = nextSeen;
    });
  }

  return (
    <>
      <h1>Art Bucket List</h1>
      <h2>My list of art to see:</h2>
      <ItemList
        artworks={myList}
        onToggle={handleToggleMyList} />
      <h2>Your list of art to see:</h2>
      <ItemList
        artworks={yourList}
        onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map(artwork => (
        <li key={artwork.id}>
          <label>
            <input
              type="checkbox"
              checked={artwork.seen}
              onChange={e => {
                onToggle(
                  artwork.id,
                  e.target.checked
                );
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

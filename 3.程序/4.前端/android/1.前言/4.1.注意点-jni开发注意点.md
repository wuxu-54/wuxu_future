# Android JNI

Android JNI（Java Native Interface）开发是连接Java层与Native层（C/C++）的关键技术，涉及跨语言交互、内存管理、线程模型等复杂问题。以下是JNI开发中需要注意的核心细节和关键点，覆盖从基础到进阶的全流程：

## 一、开发环境与配置细节

1. **NDK版本适配**  
   - 需匹配项目的`minSdkVersion`，高版本NDK可能不支持低版本Android系统（如NDK 23+不支持Android 4.1及以下）。  
   - 优先使用CMake（Android Studio推荐）而非ndk-build，CMake对现代C++特性支持更好，且与Gradle集成更友好。  

2. **ABI（应用二进制接口）管理**  
   - 明确指定支持的CPU架构（如`arm64-v8a`、`armeabi-v7a`、`x86_64`），避免冗余架构导致APK体积膨胀。  
   - 64位设备优先加载64位库，若只提供32位库可能导致崩溃（需在`build.gradle`中通过`ndk.abiFilters`控制）。  

3. **头文件与库依赖**  
   - 引入系统库（如`log`、`android`）时需在`CMakeLists.txt`中用`target_link_libraries`声明（如`-llog`）。  
   - 第三方库需确保与目标ABI兼容，静态库（`.a`）会被打包进SO，动态库（`.so`）需单独放置在对应ABI目录。  

## 二、Java与Native层绑定细节

1. **方法注册方式**  
   - **静态注册**：通过`javah`生成头文件，方法名格式为`Java_包名_类名_方法名`（如`Java_com_example_jnidemo_MainActivity_stringFromJNI`）。  
     - 注意：包名、类名、方法名若修改，需同步更新Native层方法名，否则会报`No implementation found for...`错误。  
   - **动态注册**：在`JNI_OnLoad`中通过`RegisterNatives`手动绑定方法签名与函数指针，更灵活（避免方法名过长），但需确保签名正确。  

2. **方法签名规则**  
   - 签名格式：`(参数类型)返回值类型`，基础类型对应规则（如`int→I`、`long→J`、`float→F`），引用类型以`L`开头、`;`结尾（如`String→Ljava/lang/String;`），数组以`[`开头（如`int[]→[I`）。  
   - 错误示例：若Java方法为`public native void setData(int[] data, String name)`，签名应为`([ILjava/lang/String;)V`，签名错误会导致方法绑定失败。  

## 三、数据类型转换与操作

1. **基础类型与引用类型区别**  
   - 基础类型（`int`、`float`等）可直接在Java与Native层传递，无需额外处理。  
   - 引用类型（`String`、`Object`、数组等）需通过JNI函数转换（如`String`需用`GetStringUTFChars`/`ReleaseStringUTFChars`，数组需用`GetXXXArrayElements`/`ReleaseXXXArrayElements`）。  

2. **字符串处理**  
   - Java的`String`是Unicode编码，Native层需通过`GetStringUTFChars`转为UTF-8格式（需检查返回值是否为`NULL`，避免内存分配失败）。  
   - 从Native层创建Java字符串需用`NewStringUTF`，注意传入的C字符串必须是UTF-8编码（避免中文乱码）。  

3. **数组操作**  
   - 对于`int[]`、`byte[]`等基本类型数组，使用`GetXXXArrayElements`获取Native层指针（返回的是拷贝或直接指针，由`isCopy`参数标识），操作完成后必须调用`ReleaseXXXArrayElements`释放，否则内存泄漏。  
   - 对象数组（如`Object[]`）需用`GetObjectArrayElement`/`SetObjectArrayElement`逐个访问，不能直接获取指针。  

4. **对象字段与方法调用**  
   - 获取字段：通过`GetFieldID`（实例字段）或`GetStaticFieldID`（静态字段）获取字段ID，再用`GetXXXField`/`SetXXXField`操作（字段ID可缓存，避免重复获取影响性能）。  
   - 调用方法：通过`GetMethodID`（实例方法）或`GetStaticMethodID`（静态方法）获取方法ID，再用`CallXXXMethod`调用（需传入对象实例，静态方法传入`NULL`）。  

## 四、内存管理核心注意点

1. **引用类型分类与生命周期**  
   - **局部引用（Local Reference）**：  
     - 由JNI函数创建（如`NewStringUTF`、`FindClass`），仅在当前JNI方法调用中有效，方法返回后自动释放。  
     - 若创建大量局部引用（如循环中创建），可能导致局部引用表溢出（默认容量512），需手动调用`DeleteLocalRef`释放。  
   - **全局引用（Global Reference）**：  
     - 通过`NewGlobalRef`创建，生命周期由开发者控制，需调用`DeleteGlobalRef`手动释放，否则内存泄漏（会阻止GC回收引用的Java对象）。  
     - 用途：缓存频繁使用的Java对象（如上下文`Context`）。  
   - **弱全局引用（Weak Global Reference）**：  
     - 通过`NewWeakGlobalRef`创建，不会阻止GC回收，需用`IsSameObject`检查是否被回收，用完调用`DeleteWeakGlobalRef`释放。  
     - 用途：缓存非必须对象（如配置信息），避免强引用导致内存泄漏。  

2. **Native层内存与Java层内存隔离**  
   - Native层通过`malloc`/`new`分配的内存，Java的GC无法管理，必须手动`free`/`delete`，否则导致Native内存泄漏。  
   - 避免在Native层长期持有Java对象的全局引用（如缓存过大的`Bitmap`），可能导致Java堆内存溢出。  

3. **Direct Buffer（直接缓冲区）**  
   - 通过`NewDirectByteBuffer`创建，内存分配在Native堆，Java层通过`ByteBuffer`访问，避免Java与Native层数据拷贝（提升IO性能）。  
   - 注意：Direct Buffer的内存不由GC直接管理，需通过`Cleaner`或显式释放（如调用`free`），否则可能导致Native内存泄漏。  

## 五、异常处理

1. **Native层捕获Java异常**  
   - Java层调用Native方法时，若Native层调用Java方法（如`CallVoidMethod`）可能抛出异常，需通过`ExceptionCheck()`或`ExceptionOccurred()`检查。  
   - 若有异常，需调用`ExceptionClear()`清除，否则异常会向上传递至Java层，可能导致应用崩溃。  
   - 示例：  

     ```c
     jclass cls = env->FindClass("java/lang/IllegalArgumentException");
     env->ThrowNew(cls, "Invalid parameter"); // 主动抛出异常
     if (env->ExceptionCheck()) {
         env->ExceptionClear(); // 清除异常（或不清除，让Java层处理）
     }
     ```

2. **避免Native层未处理异常**  
   - 若Native层调用Java方法后未检查异常，直接返回，异常会在Java层执行后续代码时触发，可能导致难以调试的崩溃。  

## 六、线程管理

1. **JNIEnv的线程私有性**  
   - `JNIEnv`是线程私有对象，不能跨线程传递（每个线程有独立的`JNIEnv`）。  
   - 若在Native线程（非Java创建的线程）中需要调用JNI函数，需通过`JavaVM*`（全局唯一）调用`AttachCurrentThread`获取当前线程的`JNIEnv*`，使用完毕后调用`DetachCurrentThread`释放。  

2. **线程附着与分离**  
   - Native线程附着到VM（`AttachCurrentThread`）时，会创建一个对应的Java线程对象，若不调用`DetachCurrentThread`，线程资源不会释放，导致内存泄漏。  
   - 注意：主线程（UI线程）不能调用`DetachCurrentThread`，否则会导致应用崩溃。  

3. **同步与锁**  
   - 若多线程操作Java对象，需在Native层使用`MonitorEnter`/`MonitorExit`进行同步（对应Java的`synchronized`），避免线程安全问题。  

## 七、性能优化

1. **减少JNI调用次数**  
   - JNI调用有固定开销（约几微秒），频繁调用（如循环中调用）会显著影响性能，建议批量传递数据（如一次性传递数组而非单个元素）。  

2. **缓存ID（字段ID、方法ID）**  
   - `FindClass`、`GetFieldID`、`GetMethodID`等操作耗时，建议在`JNI_OnLoad`中缓存ID（存储在全局变量），避免每次调用重复获取。  

3. **避免不必要的数据拷贝**  
   - 优先使用Direct Buffer传递大块数据（如文件、网络数据），减少Java堆与Native堆之间的拷贝。  
   - 对数组使用`GetXXXArrayRegion`/`SetXXXArrayRegion`（直接拷贝）而非`GetXXXArrayElements`（可能返回指针，也可能拷贝，取决于VM实现）。  

## 八、安全性与兼容性

1. **输入验证**  
   - Native层对Java传入的参数（如字符串长度、数组边界）必须验证，避免缓冲区溢出（如`strcpy`使用未验证的字符串长度）。  
   - 示例：处理`byte[]`时，需检查`GetArrayLength`返回的长度，避免访问越界。  

2. **权限与沙箱限制**  
   - Native层虽可绕过部分Java层权限检查，但仍受Android沙箱限制（如无法直接访问其他应用的文件）。  
   - Android 10+的Scoped Storage限制，Native层通过路径访问文件需与Java层保持一致（避免直接读写被限制的路径）。  

3. **API版本兼容性**  
   - 部分JNI函数在高版本Android中被废弃或行为变更（如`GetStringUTFChars`在Android 7.0+对空字符串的处理），需通过`__ANDROID_API__`宏做版本适配。  
   - 示例：  

     ```c
     #if __ANDROID_API__ >= 24
         // 适配Android 7.0+的API
     #else
         // 兼容低版本的实现
     #endif
     ```

## 九、调试与问题排查

1. **日志输出**  
   - 使用`__android_log_print`（需链接`log`库）输出日志，格式与Android Log一致（如`LOGD("tag", "message: %d", value)`）。  

2. **Native崩溃调试**  
   - 崩溃时通过`adb logcat`查看`tombstone_xxx`文件，获取Native堆栈（需配合NDK的`addr2line`工具解析地址到具体代码行）。  
   - 集成Crash捕获工具（如Breakpad、Google Play Console的Native Crash报告），收集崩溃信息。  

3. **常见问题排查**  
   - `UnsatisfiedLinkError`：SO库未加载、方法签名错误或ABI不匹配。  
   - 内存泄漏：通过`adb shell dumpsys meminfo <包名>`观察Native内存增长，结合`valgrind`（Android NDK提供）检测Native层泄漏。  
   - 线程崩溃：检查`AttachCurrentThread`后是否`Detach`，或`JNIEnv`跨线程使用。  

## 十、其他细节

- **静态代码块加载SO**：Java层需在`static`块中通过`System.loadLibrary("库名")`加载SO，确保在调用Native方法前完成加载。  
- **避免在Native层做UI操作**：UI操作必须在主线程（Java层）执行，Native层若需更新UI，需通过JNI回调Java层的主线程方法。  
- **C++异常与Java异常隔离**：Native层的C++异常（如`throw`）若未捕获，会导致应用崩溃，且无法被Java的`try-catch`捕获，需在Native层用`try-catch`处理。  

总结：JNI开发的核心是**严格管理内存与引用**、**确保跨层交互的正确性**，同时兼顾性能、安全性与兼容性。开发中需多借助调试工具排查问题，优先遵循Android官方推荐的最佳实践。

# 术语解释

## 内存

- `VSS`：Virtual Set Size，虚拟耗用内存（包含共享库占用的内存）；
   >VSS表示一个进程可访问的全部内存地址空间的大小。这个大小包括了进程已经申请但尚未使用的内存空间。在实际中很少用这种方式来表示进程占用内存的情况，用它来表示单个进程的内存使用情况是不准确的。此大小还包括可能不驻留在RAM中的内存，如已分配但未写入的malloc。 VSS对于确定进程的实际内存使用非常少用。
- `RSS`： Resident Set Size，实际使用物理内存（包含共享库占用的内存）；
   >表示一个进程在RAM中实际使用的空间地址大小，包括了全部共享库占用的内存，这种表示进程占用内存的情况也是不准确的。RSS可能会产生误导，因为它报告进程使用的所有共享库的总数，即使共享库只加载到内存中一次，无论有多少进程使用它。 RSS不是单个进程的内存使用的准确表示。
- `PSS`：Proportional Set Size，实际使用物理内存（比例分配共享库占用的内存）；
   >Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）表示一个进程在RAM中实际使用的空间地址大小，它按比例包含了共享库占用的内存。假如有3个进程使用同一个共享库，那么每个进程的PSS就包括了1/3大小的共享库内存。这种方式表示进程的内存使用情况较准确，但当只有一个进程使用共享库时，其情况和RSS一模一样。PSS可能有点误导，因为当进程被杀死时，PSS不能准确地表示返回到整个系统的内存。
- `USS`：Unique Set Size，进程独自占用的物理内存（不包含共享库占用的内存）；
   >表示一个进程本身占用的内存空间大小，不包含其它任何成分，这是表示进程内存大小的最好方式！USS是一个非常有用的数字，因为它表示运行特定进程的真正增量成本。当进程被终止时，USS是实际返回到系统的总内存。 **USS是判断进程中的内存泄漏时最值得注意的数字。**  一般来说内存占用大小有如下规律：VSS >= RSS >= PSS >= USS
- `Heap Size`：堆大小；
- `Heap Alloc`：分配的堆大小；
- `Heap Free`：空闲的堆大小；
- `Pss`：实际使用物理内存（比例分配共享库占用的内存）；
- `PrivateDirty`：非共享的，又不能换页出去的内存大小；
- `SharedDirty`：共享的，又不能换页出去的内存大小；

## cpu

- `idle`：cpu 空闲
- `user`： 用户态
- `kernel`： 内核态
- `faults`： 内存缺页
- `minor`： 轻微
- `major`： 重度
- `iowait`： IO使用（等待）占比
- `irq`： 硬中断
- `softirq`： 软中断
- `CPU duration`：表示CPU实际工作在这个操作上的时间。
- `wall duration`：一个操作的总耗时（包括等待时间）。

## 问题

- **inputDispatcher ANR问题原因**
  - inputDispatcher发送key事件给对应进程的Focused Window
    1. 对应的Window不存在
    2. 处于暂停态、通道(input channel)占满
    3. 通道未注册
    4. 通道异常
    5. 5秒内没有处理完一个事件

---

## 内存缺页

内存缺页（Page Fault）是操作系统中的一个术语，它指的是当程序试图访问一个未映射到物理内存中的虚拟内存页时发生的情况。内存缺页是虚拟内存管理的一部分，操作系统使用虚拟内存来允许程序使用比物理内存更多的内存空间。以下是关于内存缺页的一些关键点：

1. **虚拟内存**：现代操作系统使用虚拟内存来允许每个程序有一个连续的地址空间，而实际上这些地址可能映射到物理内存的不同部分，或者暂时不在物理内存中。

2. **缺页中断**：当程序访问一个未映射的内存页时，硬件会触发一个缺页中断。操作系统的内存管理器会捕获这个中断，并处理缺页异常。

3. **处理缺页**：处理缺页通常涉及以下步骤：
   - 确定需要访问的数据在磁盘上的哪个位置（如果数据从未加载到内存中）。
   - 将数据从磁盘读取到物理内存中。
   - 更新页表，将虚拟地址映射到新的物理页。
   - 重新启动导致缺页的指令。

4. **缺页的性能影响**：缺页可能会导致程序执行的显著延迟，因为需要从磁盘读取数据。这种情况被称为“缺页抖动”（Page Fault Thrashing），当系统频繁地处理缺页中断，而没有足够的内存来保持数据时，就会发生这种情况。

5. **优化内存使用**：操作系统会尝试通过各种策略来优化内存使用，减少缺页的发生。例如，它可以预加载数据到内存中，或者使用页面替换算法来决定哪些页面应该被交换出去。

6. **内存损坏**：内存损坏（Memory Corruption）通常指的是由于硬件故障、软件错误或其他原因导致的数据不一致或丢失。内存损坏可能引起不可预测的行为，包括程序崩溃、数据丢失或安全漏洞。

7. **检测和修复**：为了检测内存损坏，操作系统和应用程序可以使用各种技术，如校验和、内存测试工具或内置的硬件错误检测功能。在检测到内存损坏后，可能需要采取修复措施，如重启系统、恢复数据或使用冗余系统。

内存缺页是操作系统正常工作的一部分，而内存损坏则是需要避免和处理的问题。了解这两种情况对于开发高效、可靠的软件至关重要。

---

## 硬中断（IRQ）和软中断（SoftIRQ）

在Linux系统中，中断处理是操作系统响应硬件事件的重要机制，它分为两种类型：硬中断（IRQ）和软中断（SoftIRQ）。

1. **硬中断（IRQ）**：
   - 硬中断是由硬件设备直接触发的中断，它们通常与特定的硬件设备相关联，如网络卡、磁盘驱动器等。
   - 硬中断处理程序（ISR - Interrupt Service Routine）需要尽快执行，因为它们直接影响系统的响应时间和性能。
   - 硬中断处理程序通常很短，执行时间有限，以避免影响CPU的其他任务。

2. **软中断（SoftIRQ）**：
   - 软中断是一种软件触发的中断机制，用于处理那些不适合在硬中断上下文中完成的任务，如网络数据包的处理、定时器处理等。
   - 软中断是可推迟的，它们可以排队等待处理，并且通常在硬中断处理程序执行完成后或特定的调度点被处理。
   - 软中断通过任务队列（tasklets）实现，这些任务队列可以被CPU上的软中断处理器（softirq handler）处理。

在Android系统中，软中断主要用于处理那些需要较长时间执行的任务，或者那些可以并行处理的任务，以避免阻塞硬中断处理程序的执行。软中断的使用可以提高系统的响应性和性能。

例如，网络设备驱动可能会在收到大量数据包时触发硬中断，然后通过软中断来处理这些数据包，这样可以避免在硬中断处理程序中执行过多的工作，从而减少对CPU性能的影响。

总的来说，硬中断和软中断是Linux系统中中断处理的两个重要组成部分，它们共同协作以确保系统能够高效地响应硬件事件。

---

## adb top命令名词

在Android的adb（Android Debug Bridge）工具中，`adb top`命令用于显示设备上当前运行的进程的实时信息。以下是`adb top`命令输出中常见名词及其解释：

1. **PID**：进程ID（Process ID），唯一标识每个进程的数字。
2. **USER**：用户，运行该进程的用户名称。
3. **PR**：优先级（Priority），进程的调度优先级。
4. **NI**：Nice值，表示进程的“友好”程度，Nice值越高，进程越“友好”，即越容易将CPU时间让给其他进程。
5. **VIRT**：虚拟内存（Virtual Memory），进程使用的虚拟内存总量，包括进程使用的所有内存（代码、数据、共享库等）。
6. **RES**：物理内存（Resident Memory），进程实际使用的物理内存量，不包括已经交换出去的部分。
7. **SHR**：共享内存（Shared Memory），进程使用的共享内存量。
8. **S**：进程状态（Status），表示进程当前的状态，如R（运行）、S（睡眠）、D（不可中断的睡眠状态）、T（跟踪/停止）、Z（僵尸进程）等。
9. **%CPU**：CPU使用率，表示进程当前使用的CPU百分比。
10. **%MEM**：内存占用率，表示进程当前使用的物理内存占总物理内存的百分比。
11. **TIME+**：CPU时间，表示进程自启动以来占用的CPU总时间。
12. **COMMAND** 或 **NAME**：进程名称，显示进程的命令行或名称。

此外，还有一些可能在某些特定版本的`adb top`命令输出中出现的名词，如：

- **#THR**：线程数，表示进程当前使用的线程数量。
- **VSS**：虚拟耗用内存（Virtual Set Size），包含进程使用的所有内存（代码、数据、共享库等）以及预留的未使用内存。
- **RSS**：实际使用物理内存（Resident Set Size），表示进程实际使用的物理内存量，包括共享库占用的内存。
- **PCY**：调度策略优先级（Scheduling Policy Priority），表示进程的调度策略优先级。
- **UID**：进程所有者的用户ID，用于标识进程的拥有者。

需要注意的是，`adb top`命令的输出可能会因Android版本和设备制造商的不同而有所差异。某些字段可能不会出现，或者字段的排序和格式可能有所不同。为了获取最准确的信息，建议参考具体设备和Android版本的官方文档。

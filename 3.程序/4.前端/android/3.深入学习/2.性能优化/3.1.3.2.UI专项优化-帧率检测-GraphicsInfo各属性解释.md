# Graphics info 各属性解释

在Android中，通过 `adb shell dumpsys gfxinfo <PACKAGE_NAME>` 命令获取的 **Graphics info** 包含多个关键属性，这些属性反映了应用渲染流程的性能表现。以下是对各属性的详细解释：

## 一、全局统计指标

### 1. **基础信息**

- **Graphics info for pid X (PACKAGE_NAME)**  
  标识当前分析的应用进程ID和包名，用于区分多应用数据。

- **Stats since: TIMESTAMP**  
  统计数据的起始时间戳（纳秒级），表示从该时间点开始收集后续帧数据。

### 2. **总帧统计**

- **Total frames rendered**  
  应用渲染的总帧数。例如，若输出为 `105`，表示本次统计共收集了105帧数据。

- **Janky frames**  
  **卡顿帧数**，即耗时超过 **16.67ms**（60FPS设备的单帧阈值）的帧数。  
  - 计算公式：`卡顿率 = (Janky frames / Total frames) × 100%`  
  - 示例：`Janky frames: 2 (1.90%)` 表示105帧中有2帧卡顿，卡顿率1.9%。

- **百分位数（Percentile）**  
  按耗时排序后，不同位置的帧耗时值：  
  - **50th percentile**（中位数）：50%的帧耗时小于该值，反映多数帧的表现。  
  - **90th percentile**：90%的帧耗时小于该值，用于评估流畅度下限。  
  - **99th percentile**：99%的帧耗时小于该值，反映极端卡顿情况。  
  - 示例：若90th percentile为7ms，说明90%的帧耗时在7ms以内，性能较好。

### 3. **卡顿原因分类**

- **Number Missed Vsync**  
  **垂直同步失败次数**。若应用未能在VSYNC信号到来时准备好数据，会导致帧渲染延迟，引发卡顿。

- **Number High input latency**  
  **输入事件处理超时次数**。若应用处理 `onTouchEvent` 等输入事件耗时超过2ms，可能阻塞UI线程。

- **Number Slow UI thread**  
  **UI线程处理超时次数**。UI线程执行布局、绘制等操作耗时过长，导致无法及时响应VSYNC信号。

- **Number Slow bitmap uploads**  
  **纹理上传耗时次数**。位图数据从CPU内存传输到GPU显存的时间超过阈值（如5ms），可能因大图片或频繁上传导致。

- **Number Slow issue draw commands**  
  **绘制命令发送耗时次数**。应用向GPU发送绘制指令的时间过长，通常与复杂的DisplayList（如多层嵌套的自定义View）有关。

## 二、单帧阶段耗时（Profile data in ms）

### 1. **Draw（绘制阶段）**

- **含义**：应用层执行 `View.draw()` 或 `onDraw()` 的时间，包括创建显示列表（DisplayList）和记录绘制命令（如 `drawRect`、`drawText`）。  
- **影响因素**：  
  - 自定义View的复杂度（如多层叠加、复杂路径计算）。  
  - 频繁调用 `invalidate()` 触发重绘。  
  - 位图缩放或滤镜处理（如 `BlurMaskFilter`）。

### 2. **Process（布局阶段）**

- **含义**：执行 `View.measure()` 和 `View.layout()` 的时间，包括计算视图尺寸、位置及布局层级关系。  
- **影响因素**：  
  - 布局嵌套过深（如多层 `LinearLayout` 嵌套）。  
  - 动态修改布局参数（如 `LayoutParams`）。  
  - 复杂的约束关系（如 `ConstraintLayout` 未优化）。

### 3. **Execute（渲染阶段）**

- **含义**：GPU执行实际渲染的时间，包括纹理采样、栅格化（Rasterization）和缓冲区交换（`eglSwapBuffers`）。  
- **影响因素**：  
  - 高分辨率纹理或过多纹理叠加。  
  - 复杂的GPU运算（如 `Canvas.drawBitmapMesh`）。  
  - 合成层（Composite Layer）的数量和层级关系。

### 4. **Total（总耗时）**

- **含义**：`Draw + Process + Execute` 的总和，反映单帧完整渲染时间。  
- **阈值**：  
  - 60FPS设备：Total应 ≤ 16.67ms。  
  - 90FPS设备：Total应 ≤ 11.11ms。  
  - 若超过阈值，该帧会被标记为 **Janky**，导致画面卡顿。

## 三、帧时间分布直方图（HISTOGRAM）

- **格式**：`Xms=Y` 表示耗时在 `Xms~(X+1)ms` 区间的帧数。  
- **示例**：`5ms=78` 表示78帧的耗时在5-6ms之间。  
- **作用**：  
  - 快速定位耗时集中区间（如多数帧耗时＞16ms，说明普遍卡顿）。  
  - 对比优化前后的分布变化，验证优化效果。

## 四、系统级渲染流程（补充解析）

### 1. **SurfaceFlinger合成**

- **含义**：系统服务 `SurfaceFlinger` 负责将所有应用的图层（Layer）合成到屏幕上。通过 `dumpsys SurfaceFlinger` 可查看全局帧率，但需系统权限。  
- **关键指标**：  
  - **HWC（Hardware Composer）**：硬件合成器处理时间，若耗时高可能因复杂的透明度混合或多图层叠加导致。  
  - **GPU load**：GPU利用率，超过80%可能引发帧率下降。

### 2. **VSYNC与三重缓冲**

- **VSYNC（垂直同步）**：屏幕刷新率信号（如60Hz设备每16.67ms一次），应用需在信号到来前完成渲染，否则丢帧。  
- **三重缓冲（Triple Buffering）**：通过额外的缓冲区减少VSYNC等待，但可能增加内存消耗。

## 五、高级帧数据（framestats）

通过 `adb shell dumpsys gfxinfo <PACKAGE_NAME> framestats` 可获取更详细的帧时间戳（纳秒级），关键字段包括：

- **INTENDED_VSYNC**：预期的VSYNC信号时间。  
- **FRAME_COMPLETED**：帧渲染完成时间。  
- **DRAW_START**：应用层开始绘制的时间。  
- **SYNC_START**：CPU向GPU同步数据的时间。  
- **ISSUE_DRAW_COMMANDS_START**：向GPU发送绘制指令的时间。  

通过计算这些时间差，可精确定位卡顿发生的具体阶段（如 `DRAW_START - INTENDED_VSYNC` 表示应用层处理延迟）。

## 六、优化方向建议

1. **减少Draw阶段耗时**  
   - 避免在 `onDraw()` 中创建对象（如 `Paint`、`Path`）。  
   - 使用 `RenderNode` 或 `Canvas.saveLayer()` 减少重叠区域的重复绘制。

2. **优化Process阶段**  
   - 扁平化布局层级（如用 `ConstraintLayout` 替代多层嵌套）。  
   - 缓存 `LayoutParams` 避免重复计算。

3. **降低Execute阶段压力**  
   - 压缩图片尺寸并使用 `WebP` 等高效格式。  
   - 将频繁动画的元素提升为合成层（通过 `setLayerType(LAYER_TYPE_HARDWARE, null)`）。

4. **监控与调试**  
   - 使用 **Choreographer** 实时监听帧率（如腾讯Matrix的 `FPSTracer`）。  
   - 通过 **Systrace** 分析系统级瓶颈（如 `python systrace.py -o trace.html gfx input view`）。

## 总结

Graphics info 是分析Android应用渲染性能的核心工具，通过理解各属性的含义，可快速定位卡顿根源（如UI线程阻塞、GPU负载过高），并针对性地优化。实际开发中，需结合 **framestats** 详细时间戳和 **Systrace** 系统调用栈，实现精准调优。

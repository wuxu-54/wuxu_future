# 三种采集帧率方式

在Android中采集FPS（帧率）是衡量应用UI流畅度的重要手段，常用的实现方式有以下几种，适用于不同场景（如实时监控、性能测试等）：

## 一、基于 `Choreographer` 实时采集（推荐）

`Choreographer` 是Android系统中用于协调UI绘制、输入和动画的类，它会在每帧渲染前回调 `FrameCallback`，通过监听回调间隔可计算FPS。

### 实现原理：

1. 利用 `Choreographer.postFrameCallback()` 注册帧回调；
2. 记录相邻两帧的时间差（`frameInterval`）；
3. 计算单位时间内的帧数（`FPS = 1000 / frameInterval`，单位：帧/秒）。

### 代码示例：

```java
import android.view.Choreographer;
import java.util.ArrayList;
import java.util.List;

public class FPSMonitor {
    private static final String TAG = "FPSMonitor";
    private long mLastFrameTimeNanos = 0;
    private double mFPS = 0;
    // 保存最近10帧的时间差，用于平滑计算FPS
    private List<Long> mFrameIntervals = new ArrayList<>();
    private static final int MAX_FRAME_COUNT = 10;

    private Choreographer.FrameCallback mFrameCallback = new Choreographer.FrameCallback() {
        @Override
        public void doFrame(long frameTimeNanos) {
            if (mLastFrameTimeNanos != 0) {
                // 计算两帧之间的时间差（纳秒转毫秒）
                long frameIntervalMs = (frameTimeNanos - mLastFrameTimeNanos) / 1_000_000;
                // 过滤异常值（如卡顿导致的超大间隔）
                if (frameIntervalMs > 0 && frameIntervalMs < 1000) {
                    mFrameIntervals.add(frameIntervalMs);
                    // 只保留最近10帧数据
                    if (mFrameIntervals.size() > MAX_FRAME_COUNT) {
                        mFrameIntervals.remove(0);
                    }
                    // 计算平均FPS
                    long total = 0;
                    for (long interval : mFrameIntervals) {
                        total += interval;
                    }
                    if (total > 0) {
                        mFPS = 1000.0 * mFrameIntervals.size() / total;
                    }
                    // 输出或回调FPS（如UI显示）
                    onFPSUpdated(mFPS);
                }
            }
            mLastFrameTimeNanos = frameTimeNanos;
            // 继续注册下一次回调
            Choreographer.getInstance().postFrameCallback(this);
        }
    };

    // 开始监控
    public void start() {
        mLastFrameTimeNanos = 0;
        mFrameIntervals.clear();
        Choreographer.getInstance().postFrameCallback(mFrameCallback);
    }

    // 停止监控
    public void stop() {
        Choreographer.getInstance().removeFrameCallback(mFrameCallback);
    }

    // FPS更新回调（可自定义处理，如显示到UI）
    private void onFPSUpdated(double fps) {
        // 示例：打印FPS
        // Log.d(TAG, "Current FPS: " + String.format("%.1f", fps));
    }
}
```

### 使用方式：

```java
// 在Activity或Application中启动监控
FPSMonitor fpsMonitor = new FPSMonitor();
fpsMonitor.start();

// 不需要时停止
// fpsMonitor.stop();
```

### 特点：

- **优势**：实时性高（每帧回调），适合应用内实时显示；
- **注意**：需在主线程调用，过度频繁计算可能轻微影响性能（可通过限制采样频率优化）。

## 二、通过 `dumpsys gfxinfo` 命令采集（调试用）

Android系统提供 `dumpsys gfxinfo` 命令，可输出应用的帧率相关信息（如每帧的绘制时间），适合线下性能测试。

### 操作步骤：

1. 连接设备并确保ADB可用；
2. 执行命令（替换 `packageName` 为应用包名）：

   ```bash
   adb shell dumpsys gfxinfo <packageName>
   ```

3. 输出结果中，`Profile data in ms` 部分包含每帧的 `Draw`（绘制）、`Process`（布局）、`Execute`（执行）时间，总和越小越流畅（理想状态下每帧应 < 16.67ms，对应60FPS）。

### 示例输出解析：

```txt
Profile data in ms:
    Draw    Process  Execute  Total
    2.3     3.5      1.2      7.0    // 第1帧总耗时7ms（远低于16.67ms，流畅）
    1.8     2.1      1.5      5.4    // 第2帧
    ...
```

### 特点：

- **优势**：系统级数据，准确反映渲染性能；
- **局限**：非实时，需手动执行命令，适合调试分析。

## 三、基于 `SurfaceFlinger` 采集（系统级，需权限）

`SurfaceFlinger` 是Android系统负责合成所有窗口到屏幕的服务，通过它可获取全局帧率（包括所有应用），但需要系统权限。

### 实现方式：

1. 反射调用 `SurfaceFlinger` 的接口（需 `INTERNET` 权限或系统签名）；
2. 示例代码（仅示意，实际需处理AIDL通信）：

   ```java
   // 注意：该方法需要系统权限，普通应用无法使用
   private void getSurfaceFlingerFPS() {
       try {
           Class<?> surfaceFlinger = Class.forName("android.view.SurfaceFlinger");
           // 反射获取帧率相关方法（不同Android版本接口可能不同）
           // ...
       } catch (Exception e) {
           e.printStackTrace();
       }
   }
   ```

### 特点：

- **优势**：可监控全局帧率；
- **局限**：需要系统权限，不适合普通应用。

## 四、第三方库（如性能监控SDK）

成熟的性能监控库（如腾讯Matrix、字节跳动Booster）已封装FPS采集逻辑，可直接集成：

- **Matrix**：提供 `FPSTracer` 组件，支持实时监控和卡顿分析；
- **Booster**：通过AOP插桩实现帧率采集，支持性能数据上报。

### 示例（Matrix）：

```java
// 集成Matrix后初始化
FPSConfig config = new FPSConfig.Builder()
    .setOpen(true)
    .build();
Matrix.with().installPlugin(new FPSPlugin(config));
```

## 关键指标说明：

- **正常范围**：60FPS（每帧≈16.67ms）、90FPS（≈11.11ms）、120FPS（≈8.33ms），取决于设备刷新率；
- **卡顿判断**：单帧耗时 > 16.67ms（60FPS设备）可视为轻微卡顿，> 33ms（两帧）为明显卡顿。

## 总结

- **应用内实时监控**：优先使用 `Choreographer` 方案，简单易用；
- **线下调试分析**：使用 `dumpsys gfxinfo` 命令，获取详细帧数据；
- **系统级监控**：需基于 `SurfaceFlinger`，但受权限限制；
- **生产环境**：推荐集成成熟第三方库，兼顾性能和稳定性。

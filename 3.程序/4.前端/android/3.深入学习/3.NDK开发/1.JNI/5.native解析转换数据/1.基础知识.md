# native层jni的数据转换及解析

## 基础知识

参考：[简书 Android JNI 笔记 | GetObjectClass、FindClass和GetMethodID](https://www.jianshu.com/p/dddb0ccd476a)

* `FindClass(完整类名)`native中获取jclass引用，对应java中的某个类

    ```c
    jclass  clazz = (*env)->FindClass(env,"java/lang/String");
    ```

* `GetFieldID`是得到java类中的全局变量参数ID

    ```c
    jfieldID topicFieldId = env->GetFieldID(objectClass,"name", "Ljava/lang/String;"); 
    ```

* `GetMethodID`得到java类中方法的ID，它们只能调用类中声明为**非静态**的参数或方法  

    ```c
    jmethodID mid = (*env)->GetMethodID(env, clazz,"getBytes","([B)Ljava/lang/String;")
    ```

个人理解：native层 jni的数据处理如同java层的反射，一步步反射获取class对象，class中的变量、方法、方法参数及返回值等。

* 补充说明
  开发中不需要手写，但可以了解对应关系。
  * sig参数示意：

    |java类型|sig|
    |-|-|
    |boolean|Z|
    |byte|B|
    |char|C|
    |short|S|
    |int|I|
    |long|J|
    |float|F|
    |double|D|
    |void|V|
    |[数组]|`[`|
    |类型Object对象|L包名/类名; 或 包名/类名$标识嵌套类;|

  * 例子(方法 -> 对应的sig)  

    `void M1(int A,int B) -> "(II)V"`
    `void M2(String S) -> "(Ljava/lang/String;)V"`
    `void M3(int[] I) -> "([I)V"`
    `String M4(String S) -> "(Ljava/lang/String;)Ljava/lang/String"`
    `long M5(int I,Class class) -> "(ILjava/lang/Class;)J"`
    `void M6(long LONG) -> "(J)V"`

## 练习

* java

```java
public native String passString(String str);
```

* native

```c

/**
 * 将strig类型变为char*
 * @param env
 * @param thiz
 * @param str
 * @return
 */
char* string2CStr(JNIEnv *env,  jstring str) {
    //与反射类似，一步步获取对应值
    //获取类jcass
    jclass  clazz = (*env)->FindClass(env,"java/lang/String");
    //获取编码格式
    jstring charset = (*env)->NewStringUTF(env,"GB2312");
    //获取方法id
    jmethodID mid = (*env)->GetMethodID(env, clazz,"getBytes","(Ljava/lang/String;)[B");
    //调用方法，并获取方法返回的字节数组。这一步是调用java方法将string类型变为字节数组
    jbyteArray jByteArray = (*env)->CallObjectMethod(env,str,mid,charset);
    //获取字节数组的长度
    jsize arrLength = (*env)->GetArrayLength(env,jByteArray);

    //获取字节数组每一个元素
    //GetByteArrayElements 函数用于获取 Java 数组的直接内存引用，这样本地代码就可以直接访问和修改数组元素。这个函数的第三个参数是一个 jboolean 类型的值，用来指定在访问数组元素后是否需要自动释放数组的引用。
    //JNI_FALSE：宏定义，表示 false，在这个上下文中，它告诉 JNI 在调用 GetByteArrayElements 后不要自动释放 jByteArray 的引用。这意味着你需要在适当的时候手动调用 ReleaseByteArrayElements 来释放引用，否则可能会导致内存泄漏。
    //JNI_TRUE：宏定义，表示 true，如果使用 JNI_TRUE，JNI 会在 GetByteArrayElements 返回后自动释放数组的引用，这通常在你不再需要访问数组元素时使用。
    jbyte* jByteArrPointer=(*env)->GetByteArrayElements(env,jByteArray,JNI_FALSE);

    //存放到本地数组中
    char* cCharPointer = NULL;
    if (arrLength>0) {
        cCharPointer = (char*)malloc(arrLength+1);//这里需要多一个内存空间，因为数组要有'\0'
        memcpy(cCharPointer,jByteArrPointer,arrLength);//复制给新开辟的地址
        cCharPointer[arrLength] = 0;//末尾写上'\0'表示字符串结束
    }

    (*env)->ReleaseByteArrayElements(env,jByteArray,jByteArrPointer,0);//释放旧内存。

    return cCharPointer;
}

JNIEXPORT jstring JNICALL
Java_com_wuxu_ndk1_JNIPassData_passString(JNIEnv *env, jobject thiz, jstring str) {

    char *cStr = string2CStr(env,str);

    int len = strlen(cStr);
    int i;
    for ( i = 0; i < len; ++i) {
        *(cStr +i) =*(cStr+i) +1;
    }

    return (**env).NewStringUTF(env,cStr);
}

```

# c调用java代码，详解

## 前提练习：java反射

1. 获取需要反射的类的字节码
2. 通过类字节码获取对应的方法（Method）或是变量（Field），私有方法或变量，需要调用Declared的函数，且设置 setAccessible(true);
3. 通过方法或变量的反射对象，获取或修改具体的数据

```java
class Test{
    public void printString(String string){
        System.out.println(string);
        Log.e("sky",string);
    }


    private void privatePrintString(String string){
        System.out.println(string);
        Log.e("sky-private",string);
    }
}

//反射
public class Fanshe {
    /**
     * 方式1
     * @throws Exception
     */
   void testFanshe() throws  Exception{

       //1.获取需要反射的类的字节码
       Class<Test> s = Test.class;
       //2.获取要反射的方法
       Method method = s.getMethod("printString", String.class);

       //3.创建对象
      Test test = s.newInstance();

      //4.调用方法
       method.invoke(test, "sss");
   }


    /**
     * 方式2 处理私有方法
     * @throws Exception
     */
   void testFanshe2() throws Exception{
      Test test = new Test();
      //1.获取字节码
      Class<Test> s = (Class<Test>) test.getClass();
      //2.反射获取私有方法
      Method method = s.getDeclaredMethod("privatePrintString", String.class);
      //3.调用，私有方法需要设置 method.setAccessible(true);
       method.setAccessible(true);
       method.invoke(test,"private sss");

   }

    /**
     * 方式3
     * @throws Exception
     */
   void testFanshe3() throws Exception{
       //1.获取需要反射的类的字节码
       Class<Test> s = (Class<Test>) Class.forName("com.wuxu.ndk1.Test");
       //2.获取要反射的方法
       Method method = s.getMethod("printString", String.class);

       //3.创建对象
       Test test = s.newInstance();

       //4.调用方法
       method.invoke(test, "sss");
   }
}
```

## c调用java方法

1. c调用java方法 使用的是反射，但是c中具体实现上与java层的反射有些区别，使用不同的api，同时需要获取java方法签名;
    * 获取java方法签名  
    > 找到class文件，javap -s 全类名（如果在class同级目录下，只写类名就可以）

    ```cmd
    cd intermediates/javac/debug/classes/com/wuxu/ndk1/java 

    javap -s JNICInvokeJava
    ```

2. 示例代码

    * java层展示

    ```java
    public class JNICInvokeJava {

        static {
            System.loadLibrary("ndk1");
        }

        private Context context;
        public JNICInvokeJava(Context context) {
            this.context = context;
        }
        /**
         * 空方法
         */
        public void printHelloWorld(){
            Toast.makeText(context, "Hello World from java!", Toast.LENGTH_SHORT).show();
        }

        public int add(int x, int y){
            return  x + y;
        }

        private void printString(String string){
            Toast.makeText(context, string, Toast.LENGTH_SHORT).show();
        }


        public native void cCallJavaVoidMethod();

        public native void cCallJavaIntMethod();

        public native void cCallJavaStringMethod();
    }

    ````

    * c调用java空方法

    ```c  
    #include "stdlib.h"
    #include "jni.h"
    #include "android/log.h"

    #define LOG_D(...) __android_log_print(ANDROID_LOG_DEBUG,"sky",__VA_ARGS__)

    void showToast(JNIEnv *env,jobject thiz);
    JNIEXPORT void JNICALL
    Java_com_wuxu_ndk1_java_JNICInvokeJava_cCallJavaIntMethod(JNIEnv *env, jobject thiz) {

    //    1. 获取需要反射的类的字节码
    jclass  clazz = (*env)->FindClass(env,"com/wuxu/ndk1/java/JNICInvokeJava");
    //    2. 通过类字节码获取对应的方法
    jmethodID  mid = (*env)->GetMethodID(env,clazz,"add","(II)I");
    //    3. 获取或创建对象 ,这里已经有对象了，thiz
    //    4. 调用方法
    jint  intValue = (*env)->CallIntMethod(env,thiz,mid,1,2);

    LOG_D("int value = %d",intValue);

        showToast(env,thiz);
    }

    JNIEXPORT void JNICALL
    Java_com_wuxu_ndk1_java_JNICInvokeJava_cCallJavaStringMethod(JNIEnv *env, jobject thiz) {
    jclass clazz = (**env).FindClass(env, "com/wuxu/ndk1/java/JNICInvokeJava");
    jmethodID mid = (**env).GetMethodID(env, clazz, "printString","(Ljava/lang/String;)V");
    //  char* string = "my string";
    char string[] = "my string";
    jstring x = (**env).NewStringUTF(env,string);
    (**env).CallVoidMethod(env,thiz,mid,x);
    }

    JNIEXPORT void JNICALL
    Java_com_wuxu_ndk1_java_JNICInvokeJava_cCallJavaVoidMethod(JNIEnv *env, jobject thiz) {
    //类名 .换成/
    jclass  clazz = (**env).FindClass(env,"com/wuxu/ndk1/java/JNICInvokeJava");
    jmethodID mid =  (**env).GetMethodID(env,clazz, "printHelloWorld","()V");//最后一个参数是方法签名
    //调用对象方法
    (**env).CallVoidMethod(env,thiz,mid);
    }


    /**
    * C中弹吐司, 练习获取成员你变量、方法调用,调用静态
    * @param env
    * @param thiz
    * @return
    */
    void showToast(JNIEnv *env,jobject thiz){
        //Context 上下文
    jclass JNICInvokeJavaClass = (**env).FindClass(env,"com/wuxu/ndk1/java/JNICInvokeJava");
    jfieldID fid = (**env).GetFieldID(env,JNICInvokeJavaClass,"context","Landroid/content/Context;");
    jobject context=(**env).GetObjectField(env,thiz,fid);
        //toast Msg
        char* str = "cesss";
        jstring toastMsg = (**env).NewStringUTF(env,str);


        jclass toastClass = (**env).FindClass(env,"android/widget/Toast");
        jmethodID  toastMid = (**env).GetStaticMethodID(env, toastClass, "makeText", "(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;");
        jobject toastObject=  (**env).CallStaticObjectMethod(env,toastClass,toastMid,context,toastMsg,0);

        jmethodID  showMid = (**env).GetMethodID(env, toastClass,"show", "()V");
        (**env).CallVoidMethod(env,toastObject,showMid);
    }

    ```

---  

## 总结

1. c调用java方法 使用的是反射，但是c中具体实现上与java层的反射有些区别，使用不同的api，同时需要获取java方法签名; Android studio会自动提示上，很方便；  

     手动获取java方法签名  
    > 找到class文件，javap -s 全类名（如果在class同级目录下，只写类名就可以）

    ```cmd
    cd intermediates/javac/debug/classes/com/wuxu/ndk1/java 

    javap -s JNICInvokeJava
    ```

2. c中反射调用

* 调用方法  

  * (**env).FindClass  
  * (**env).GetMethodID(静态：GetStaticMethodID)
  * 调用类的对象 ：jobject
  * (**env).CallVoidMethod(静态：CallStaticVoidMethod)；这里的Void指无返回值，带有返回值有不同的表示如CallIntMethod 表示int返回值的方法；

* 调用变量

  * (**env).FindClass  
  * (**env).GetFieldID(静态：GetStaticFieldID)
  * 调用类的对象 ：jobject
  * (**env).GetObjectField(静态：GetStaticObjectField)；这里的Object指对象，基础类型有其他表示如GetIntField 表示获取int变量；

# Android JNI 细节

Android JNI（Java Native Interface）是连接Java层与原生层（C/C++）的桥梁，在Android开发中常用于性能优化、调用系统底层API或复用C/C++库。由于涉及跨语言交互和底层内存管理，JNI开发存在较多细节陷阱，以下是需要重点注意的核心细节：

## 一、数据类型与映射规则

1. **基本类型映射**  
   Java基本类型（`int`、`float`等）与JNI类型（`jint`、`jfloat`等）直接对应，无需额外处理，但需注意位数匹配（如`jint`对应32位`int`，`jlong`对应64位`long`）。  
   - 示例：`int` ↔ `jint`，`boolean` ↔ `jboolean`（JNI中用`jboolean`表示，非0为`true`，0为`false`）。

2. **引用类型处理**  
   Java对象（`String`、`Object`、数组等）在JNI中以**引用类型**（`jobject`、`jstring`、`jarray`等）表示，**不能直接操作内存**，必须通过JNI函数（如`GetStringUTFChars`、`GetIntArrayElements`）转换为C/C++可访问的形式。  
   - 错误示例：直接将`jstring`强制转换为`char*`（`char* str = (char*)jstr;`）会导致崩溃。

## 二、引用管理（避免内存泄漏）

JNI中的引用分为三类，若管理不当会导致内存泄漏或野指针：  

1. **局部引用（Local Reference）**  
   - 生命周期：在原生方法（`native`）执行期间有效，方法返回后自动释放。  
   - 限制：不能跨方法/线程使用，数量有限（默认512个），过多会导致`OutOfMemoryError`。  
   - 手动释放：用`DeleteLocalRef`提前释放大对象（如长字符串、大数组），避免超出限制。  

2. **全局引用（Global Reference）**  
   - 生命周期：需手动创建（`NewGlobalRef`）和释放（`DeleteGlobalRef`），否则永久占用内存。  
   - 用途：跨方法/线程保存Java对象（如缓存全局配置对象）。  
   - 陷阱：忘记释放会导致对象无法被GC回收，造成内存泄漏。  

3. **弱全局引用（Weak Global Reference）**  
   - 特点：用`NewWeakGlobalRef`创建，不阻止GC回收，需用`IsSameObject`检查是否被回收。  
   - 用途：缓存大对象但不希望影响GC（如缓存Bitmap等资源）。  

## 三、字符串处理（编码与释放）

Java字符串（`String`）是Unicode编码，C/C++常用UTF-8，需通过JNI函数转换，且必须成对使用避免内存泄漏：  

1. **获取C字符串**  

   ```cpp
   jstring jstr = ...; // 从Java层传入
   const char* cstr = env->GetStringUTFChars(jstr, nullptr); 
   // 使用cstr...（注意：cstr可能为NULL，需判断）
   env->ReleaseStringUTFChars(jstr, cstr); // 必须释放，否则内存泄漏
   ```  

   - 第二个参数（`isCopy`）：判断返回的是原字符串指针还是拷贝（通常传`nullptr`忽略）。  

2. **创建Java字符串**  
   用`NewStringUTF`从C字符串创建`jstring`，注意C字符串必须是UTF-8编码：  

   ```cpp
   const char* cstr = "hello";
   jstring jstr = env->NewStringUTF(cstr); // 自动管理内存，返回给Java层即可
   ```  

3. **陷阱**  
   - 忘记调用`ReleaseStringUTFChars`会导致内存泄漏。  
   - `NewStringUTF`传入非UTF-8字符串（如GBK）会导致乱码或崩溃。  

## 四、数组处理（避免数据拷贝）

Java数组（基本类型数组、对象数组）在JNI中需通过专用函数访问，注意“直接访问”与“拷贝”的区别：  

1. **基本类型数组（如`int[]`）**  

   ```cpp
   jintArray jarr = ...; // 从Java层传入
   jint* carr = env->GetIntArrayElements(jarr, nullptr); // 获取C数组
   jsize len = env->GetArrayLength(jarr); // 获取长度
   // 操作carr[0...len-1]...
   // 释放：模式参数需谨慎
   env->ReleaseIntArrayElements(jarr, carr, JNI_ABORT); // 放弃修改，不回写Java数组
   // env->ReleaseIntArrayElements(jarr, carr, 0); // 回写修改并释放（默认）
   ```  

   - 模式参数：`0`（回写+释放）、`JNI_COMMIT`（只回写不释放）、`JNI_ABORT`（不回写只释放）。  

2. **对象数组（如`Object[]`）**  
   需通过`GetObjectArrayElement`/`SetObjectArrayElement`逐个访问元素，不能直接获取指针：  

   ```cpp
   jobjectArray jarr = ...;
   jobject elem = env->GetObjectArrayElement(jarr, 0); // 获取第0个元素
   ```  

3. **直接缓冲区（Direct Buffer）**  
   用`NewDirectByteBuffer`创建的缓冲区（`ByteBuffer`）可直接映射到C内存，避免数据拷贝，适合大数据传输（如音视频帧）：  

   ```cpp
   void* data = malloc(1024);
   jobject directBuf = env->NewDirectByteBuffer(data, 1024); // 关联C内存
   // 注意：需手动释放data（如在Java层调用free时通过JNI释放）
   ```  

## 五、异常处理（避免程序崩溃）

1. **Java层异常传递到原生层**  
   Java层抛出的异常不会立即终止原生代码执行，需主动检查并处理，否则后续JNI调用会失败：  

   ```cpp
   jmethodID mid = env->GetMethodID(cls, "method", "()V");
   if (env->ExceptionCheck()) { // 检查是否有异常（如方法未找到）
       env->ExceptionDescribe(); // 打印异常信息
       env->ExceptionClear(); // 清除异常，避免影响后续操作
       return;
   }
   ```  

2. **原生层抛出异常到Java层**  
   用`ThrowNew`创建异常并抛出，Java层需用`try-catch`捕获：  

   ```cpp
   jclass exCls = env->FindClass("java/lang/IllegalArgumentException");
   env->ThrowNew(exCls, "参数无效"); // 抛出异常
   ```  

## 六、方法与字段ID的缓存（性能优化）

`FindClass`、`GetMethodID`、`GetFieldID`等函数通过字符串查找类/方法/字段，**耗时且易出错**，需缓存结果：  

1. **缓存时机**  
   在`JNI_OnLoad`（库加载时）中初始化并缓存ID，避免每次调用原生方法时重复查找：  

   ```cpp
   jclass g_cls; // 全局变量存储类引用
   jmethodID g_mid; // 全局变量存储方法ID

   jint JNI_OnLoad(JavaVM* vm, void* reserved) {
       JNIEnv* env;
       if (vm->GetEnv((void**)&env, JNI_VERSION_1_6) != JNI_OK) {
           return JNI_ERR;
       }
       jclass cls = env->FindClass("com/example/MyClass");
       g_cls = (jclass)env->NewGlobalRef(cls); // 缓存全局类引用
       g_mid = env->GetMethodID(g_cls, "myMethod", "(I)V"); // 缓存方法ID
       return JNI_VERSION_1_6;
   }
   ```  

2. **注意事项**  
   - 类引用需用全局引用（`NewGlobalRef`）缓存，局部引用会在`JNI_OnLoad`结束后失效。  
   - 若类被卸载（如热修复场景），缓存的ID会失效，需重新查找。  

## 七、线程相关（JNIEnv与线程绑定）

1. **JNIEnv的线程私有性**  
   `JNIEnv`是线程私有对象，**不能跨线程传递**。原生线程（非Java创建的线程）需先“附着”到VM才能获取`JNIEnv`：  

   ```cpp
   JavaVM* g_vm; // 全局保存JavaVM（在JNI_OnLoad中初始化）

   // 原生线程函数
   void* nativeThread(void* arg) {
       JNIEnv* env;
       // 附着线程到VM，获取JNIEnv
       if (g_vm->AttachCurrentThread(&env, nullptr) != JNI_OK) {
           return nullptr;
       }
       // 使用env调用JNI函数...
       g_vm->DetachCurrentThread(); // 线程结束前必须分离
       return nullptr;
   }
   ```  

2. **主线程操作限制**  
   避免在原生层直接操作UI（如调用`TextView.setText`），需通过`Handler`或`runOnUiThread`切换到主线程，否则可能导致UI崩溃。  

## 八、内存管理（跨层内存职责）

1. **Java层内存**：由GC管理，但JNI引用（如全局引用）会阻止GC回收，需及时释放。  
2. **原生层内存**：用`malloc`/`new`分配的内存需手动用`free`/`delete`释放，否则导致内存泄漏。  
3. **跨层传递内存**：  
   - 若Java层接收原生层分配的内存（如直接缓冲区），需在Java层提供释放接口（通过JNI调用`free`）。  
   - 避免在JNI中创建大量临时对象（如频繁调用`NewStringUTF`），会触发GC频繁回收，影响性能。  

## 九、签名规则（方法与字段的标识）

JNI通过**签名字符串**识别方法和字段，格式严格，错误会导致`FindMethodID`等函数返回`NULL`：  

1. **基本类型签名**：  
   `V`（void）、`Z`（boolean）、`B`（byte）、`C`（char）、`S`（short）、`I`（int）、`J`（long）、`F`（float）、`D`（double）。  

2. **引用类型签名**：  
   格式为`L包名/类名;`（注意末尾的`;`），如`String`的签名是`Ljava/lang/String;`，`int[]`是`[I`，`Object[][]`是`[[Ljava/lang/Object;`。  

3. **方法签名**：  
   格式为`(参数签名)返回值签名`，如`int add(int a, String b)`的签名是`(ILjava/lang/String;)I`。  

   - 工具：用`javap -s 类名`自动生成签名（如`javap -s com.example.MyClass`）。  

## 十、其他关键细节

1. **NDK版本与兼容性**  
   - 不同Android版本对应不同NDK API级别，需在`Android.mk`或`build.gradle`中指定`minSdkVersion`，避免使用高版本API在低版本设备上崩溃。  
   - 优先使用NDK提供的稳定API（如`android/log.h`），避免直接调用系统私有库（如`libandroid_runtime.so`）。  

2. **日志输出**  
   用`__android_log_print`打印日志（需链接`log`库：`-llog`），便于调试：  

   ```cpp
   #include <android/log.h>
   #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, "MyTag", __VA_ARGS__)
   LOGD("value: %d", 123); // 输出到logcat
   ```  

3. **调试困难**  
   - 原生代码崩溃会生成`tombstone`日志（位于`/data/tombstones/`），需用`ndk-stack`工具解析。  
   - 建议使用Android Studio的LLDB调试器，或通过日志逐步定位问题。  

4. **性能陷阱**  
   - 避免频繁在Java与原生层之间传递数据（如循环中传递字符串/数组），跨层调用有固定开销。  
   - 计算密集型任务（如图片处理、加密）适合放在原生层，但需注意线程调度（避免阻塞主线程）。  

## 总结

JNI开发的核心是**严格遵循跨层交互规则**：妥善管理引用与内存、处理异常、缓存关键ID、注意线程隔离。多数问题源于“想当然的直接操作”（如直接转换引用类型、忘记释放资源），需养成“通过JNI函数操作Java对象”的习惯，并借助日志和调试工具验证每一步跨层交互。

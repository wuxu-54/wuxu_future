# JNI_OnLoad

在JNI（Java Native Interface）编程中，`JNI_OnLoad` 是一个特殊的 native 函数，当 Java 虚拟机（JVM）加载 native 库（如 `.so`、`.dll` 或 `.dylib`）时会自动调用它。它的主要作用是初始化 native 库、指定使用的 JNI 版本，并可用于动态注册 native 方法，是连接 Java 与 native 代码的重要入口。

## 一、函数定义与原型

`JNI_OnLoad` 的标准原型如下：

```c
jint JNI_OnLoad(JavaVM* vm, void* reserved);
```

- **参数说明**：
  - `vm`：指向 Java 虚拟机（`JavaVM`）的指针，整个进程中只有一个 `JavaVM` 实例，可缓存供后续使用。
  - `reserved`：保留参数，通常为 `NULL`，用于未来扩展。

- **返回值**：返回当前 native 库所使用的 JNI 版本（如 `JNI_VERSION_1_6`）。JVM 会检查该版本是否被支持，若不支持则加载库失败。

## 二、调用时机

当 Java 代码通过 `System.loadLibrary("库名")` 或 `System.load("库路径")` 加载 native 库时，JVM 会执行以下步骤：

1. 加载 native 库到内存。
2. 搜索库中是否存在 `JNI_OnLoad` 函数。
3. 若存在，则调用 `JNI_OnLoad`，并传入 `JavaVM` 指针。
4. 若 `JNI_OnLoad` 返回的 JNI 版本不被 JVM 支持（如 JVM 只支持 1.6，而返回 1.8），则加载失败。

## 三、主要作用

`JNI_OnLoad` 的核心作用有三个：

### 1. 声明 JNI 版本

JNI 有多个版本（如 `JNI_VERSION_1_1`、`JNI_VERSION_1_2`、`JNI_VERSION_1_4`、`JNI_VERSION_1_6`、`JNI_VERSION_1_8` 等），高版本兼容低版本，但低版本不支持高版本的新特性（如 1.6 支持 `InvokeDynamic`，1.8 支持泛型相关函数）。

通过返回特定版本，native 库可以明确告知 JVM 自己依赖的特性，避免因版本不兼容导致的问题。例如：

```c
#include <jni.h>

jint JNI_OnLoad(JavaVM* vm, void* reserved) {
    // 声明使用 JNI 1.6 版本
    return JNI_VERSION_1_6;
}
```

### 2. 缓存 JavaVM 指针

`JavaVM` 是 JVM 的全局接口，一个进程只有一个实例，且线程安全。在 `JNI_OnLoad` 中缓存 `JavaVM` 指针，方便后续在其他线程中获取 `JNIEnv`（线程相关的 JNI 接口）。

示例：

```c
#include <jni.h>

// 全局缓存 JavaVM 指针
static JavaVM* g_vm = NULL;

jint JNI_OnLoad(JavaVM* vm, void* reserved) {
    g_vm = vm; // 缓存 JavaVM
    return JNI_VERSION_1_6;
}

// 后续在其他线程中可通过 g_vm 获取 JNIEnv
JNIEnv* get_env() {
    JNIEnv* env = NULL;
    // 附加当前线程到 JVM 并获取 JNIEnv
    if (g_vm->AttachCurrentThread(&env, NULL) == JNI_OK) {
        return env;
    }
    return NULL;
}
```

### 3. 动态注册 Native 方法

JNI 中注册 native 方法有两种方式：**静态注册**和**动态注册**。

- **静态注册**：通过「Java_包名_类名_方法名」的命名规则自动关联（如 `Java_com_example_MyClass_add` 对应 Java 类 `com.example.MyClass` 的 `add` 方法）。缺点是方法名冗长、首次调用需解析（效率低）。
  
- **动态注册**：在 `JNI_OnLoad` 中通过 `RegisterNatives` 函数手动关联 Java 方法与 native 函数，避免冗长命名，且注册时一次性解析，效率更高（适合大量 native 方法的场景）。

**动态注册示例**：

假设 Java 类 `com.example.NativeDemo` 有一个 native 方法：

```java
package com.example;

public class NativeDemo {
    public native int add(int a, int b); // native 方法
    static {
        System.loadLibrary("native-lib"); // 加载库
    }
}
```

对应的 native 代码（动态注册 `add` 方法）：

```c
#include <jni.h>
#include <stdio.h>

// 全局缓存 JavaVM
static JavaVM* g_vm = NULL;

// native 函数实现（对应 Java 的 add 方法）
jint native_add(JNIEnv* env, jobject thiz, jint a, jint b) {
    return a + b;
}

// 方法签名数组：描述 Java 方法与 native 函数的映射关系
static JNINativeMethod methods[] = {
    // 字段1：Java 方法名（"add"）
    // 字段2：方法签名（"(II)I" 表示入参为两个 int，返回值为 int）
    // 字段3：native 函数指针（指向 native_add）
    {"add", "(II)I", (void*)native_add}
};

// 要注册的 Java 类全路径
static const char* class_path = "com/example/NativeDemo";

// 动态注册方法
static int register_natives(JNIEnv* env) {
    jclass clazz = env->FindClass(class_path);
    if (clazz == NULL) {
        return JNI_ERR; // 类未找到
    }
    // 注册方法：参数为 类、方法数组、方法数量
    if (env->RegisterNatives(clazz, methods, sizeof(methods)/sizeof(methods[0])) < 0) {
        return JNI_ERR; // 注册失败
    }
    return JNI_OK;
}

// JNI_OnLoad 中执行注册
jint JNI_OnLoad(JavaVM* vm, void* reserved) {
    JNIEnv* env = NULL;
    g_vm = vm;

    // 获取当前线程的 JNIEnv
    if (vm->GetEnv((void**)&env, JNI_VERSION_1_6) != JNI_OK) {
        return JNI_ERR;
    }
    // 执行动态注册
    if (register_natives(env) != JNI_OK) {
        return JNI_ERR;
    }
    // 返回 JNI 版本
    return JNI_VERSION_1_6;
}
```

## 四、注意事项

1. **版本兼容性**：返回的 JNI 版本必须被 JVM 支持（如 Android 通常支持到 `JNI_VERSION_1_6`），否则库加载失败。

2. **线程安全**：`JavaVM` 是线程安全的，但 `JNIEnv` 是线程私有（每个线程有自己的 `JNIEnv`），需通过 `JavaVM->AttachCurrentThread` 在非 JVM 创建的线程中获取 `JNIEnv`。

3. **注册失败处理**：动态注册失败时（如类未找到、方法签名错误），`JNI_OnLoad` 应返回 `JNI_ERR`，避免库加载后方法调用崩溃。

4. **与 JNI_OnUnload 的配合**：`JNI_OnUnload` 是库卸载时的回调（如 `System.unloadLibrary`），可在其中释放 `JNI_OnLoad` 中初始化的资源（如全局引用）。

## 总结

`JNI_OnLoad` 是 native 库的初始化入口，通过它可以：指定 JNI 版本、缓存 `JavaVM`、动态注册 native 方法，从而高效连接 Java 与 native 代码。相比静态注册，动态注册在方法数量多的场景下更优，且能避免冗长的方法名。

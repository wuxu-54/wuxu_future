# 注册方式

在JNI（Java Native Interface）开发中，**方法注册**是连接Java层`native`方法与C/C++层实现函数的核心环节，其本质是让JVM知晓“Java的某个native方法对应C/C++中的哪个函数”。JNI提供两种主流注册方式：**静态注册**和**动态注册**，此外还有一些特殊场景的扩展方式。以下从原理、步骤、示例、优缺点、注意事项等维度详细说明。

## 一、基础概念铺垫

在讲解注册方式前，需明确几个关键概念，避免后续理解混淆：

1. **JNIEnv**：JNI环境指针，每个线程有独立的`JNIEnv`，封装了JNI提供的所有API（如创建Java对象、调用Java方法、操作Java数组等）。
2. **jobject/jclass**：
   - 若Java`native`方法是**实例方法**，C/C++函数的第二个参数为`jobject`（对应Java中的`this`，即调用该方法的实例对象）；
   - 若Java`native`方法是**静态方法**，第二个参数为`jclass`（对应Java中的类对象，即方法所属的Class）。
3. **方法签名（Method Signature）**：描述Java方法的参数类型和返回值类型的字符串（动态注册必需），格式规则如下：

   | 类型分类       | 签名规则                                  | 示例                  |
   |----------------|-------------------------------------------|-----------------------|
   | 基本数据类型   | 单个大写字母（如`int`→`I`，`void`→`V`）   | `int add(int a)`→`(I)I` |
   | 引用数据类型   | `L全类名;`（类名用`/`分隔，末尾必须加`;`） | `String`→`Ljava/lang/String;` |
   | 数组类型       | `[+元素签名`（多维数组多一个`[`）          | `int[]`→`[I`，`String[][]`→`[[Ljava/lang/String;` |

   - 可通过`javap -s 全类名`命令自动生成方法签名（如`javap -s com.example.JNITest`）。
4. **动态库**：C/C++代码编译生成的平台相关库（Windows→`.dll`，Linux→`.so`，macOS→`.dylib`），Java层通过`System.loadLibrary()`或`System.load()`加载。

## 二、核心注册方式：静态注册

静态注册是**最基础、最常用**的方式，依赖“Java native方法名与C/C++函数名的固定映射规则”，JVM通过函数名自动匹配方法，无需手动关联。

### 1. 原理

Java层声明`native`方法后，通过工具（`javac -h`或`javah`）生成对应的C/C++头文件，头文件中会自动生成**固定格式的函数声明**（包含Java类的全路径、方法名）。开发者实现该函数后，编译为动态库；Java加载库时，JVM会根据`native`方法的全类名+方法名，在动态库中查找匹配的C/C++函数，完成注册。

### 2. 固定函数名格式

C/C++函数名必须遵循以下格式（区分大小写）：

```c
// 实例方法：Java_包名_类名_方法名
JNIEXPORT 返回值类型 JNICALL Java_com_example_JNITest_add(JNIEnv *env, jobject thiz, int a, int b);

// 静态方法：Java_包名_类名_方法名（参数2为jclass）
JNIEXPORT 返回值类型 JNICALL Java_com_example_JNITest_print(JNIEnv *env, jclass cls, jstring msg);
```

- `JNIEXPORT`：声明该函数为JNI导出函数，允许JVM调用（不同平台编译器宏定义不同，无需手动修改）；
- `JNICALL`：指定函数调用规范（确保JVM与C/C++函数的参数传递方式一致）；
- 包名中的`.`替换为`_`，若类在内部类中，内部类名与外部类名用`_`连接（如`com.example.Outer.Inner`→`Java_com_example_Outer_Inner_method`）。

### 3. 完整步骤（示例）

以“Java调用C实现整数加法”为例，步骤如下：

#### 步骤1：Java层声明native方法

创建`com/example/JNITest.java`，声明`native`方法：

```java
package com.example;

public class JNITest {
    // 加载动态库（库名：Windows→jnitest.dll，Linux→libjnitest.so，macOS→libjnitest.dylib）
    static {
        System.loadLibrary("jnitest"); // 无需加前缀（lib）和后缀（.so/.dll）
    }

    // 实例native方法：两数相加
    public native int add(int a, int b);
    // 静态native方法：打印字符串
    public static native void print(String msg);

    public static void main(String[] args) {
        JNITest test = new JNITest();
        System.out.println("1+2=" + test.add(1, 2)); // 调用native方法
        JNITest.print("Hello JNI");
    }
}
```

#### 步骤2：生成C/C++头文件

使用`javac -h`命令（Java 8及以上推荐，替代旧的`javah`）生成头文件：

1. 进入项目根目录（假设Java文件在`src/main/java`下）；
2. 执行命令：

   ```bash
   # 编译Java文件并生成头文件（-d 指定头文件输出目录，这里输出到jni目录）
   javac -h jni src/main/java/com/example/JNITest.java
   ```

3. 生成的头文件路径为`jni/com_example_JNITest.h`，内容如下（自动生成，无需修改）：

   ```c
   /* DO NOT EDIT THIS FILE - it is machine generated */
   #include <jni.h>
   /* Header for class com_example_JNITest */

   #ifndef _Included_com_example_JNITest
   #define _Included_com_example_JNITest
   #ifdef __cplusplus
   extern "C" { // 若用C++编译，需加extern "C"避免函数名被编译器篡改（C++支持函数重载，会修改函数名）
   #endif

   /*
    * Class:     com_example_JNITest
    * Method:    add
    * Signature: (II)I
    */
   JNIEXPORT jint JNICALL Java_com_example_JNITest_add
     (JNIEnv *, jobject, jint, jint);

   /*
    * Class:     com_example_JNITest
    * Method:    print
    * Signature: (Ljava/lang/String;)V
    */
   JNIEXPORT void JNICALL Java_com_example_JNITest_print
     (JNIEnv *, jclass, jstring);

   #ifdef __cplusplus
   }
   #endif
   #endif
   ```

#### 步骤3：实现C/C++函数

创建`jni/JNITestImpl.c`，实现头文件中的函数：

```c
#include "com_example_JNITest.h"
#include <stdio.h>

// 实现add方法（实例方法，参数2为jobject）
JNIEXPORT jint JNICALL Java_com_example_JNITest_add(JNIEnv *env, jobject thiz, jint a, jint b) {
    return a + b; // 直接返回结果
}

// 实现print方法（静态方法，参数2为jclass）
JNIEXPORT void JNICALL Java_com_example_JNITest_print(JNIEnv *env, jclass cls, jstring msg) {
    // jstring转C字符串（需释放内存）
    const char *c_msg = (*env)->GetStringUTFChars(env, msg, NULL);
    if (c_msg == NULL) return; // 避免空指针

    printf("From C: %s\n", c_msg);

    // 释放C字符串（JNI的局部引用需手动释放，避免内存泄漏）
    (*env)->ReleaseStringUTFChars(env, msg, c_msg);
}
```

- 若用C++实现，需注意`JNIEnv`的调用方式（C++中`env`是指针，无需`(*env)->`，直接`env->`）：

  ```cpp
  #include "com_example_JNITest.h"
  #include <iostream>

  JNIEXPORT jint JNICALL Java_com_example_JNITest_add(JNIEnv *env, jobject thiz, jint a, jint b) {
      return a + b;
  }

  JNIEXPORT void JNICALL Java_com_example_JNITest_print(JNIEnv *env, jclass cls, jstring msg) {
      const char *c_msg = env->GetStringUTFChars(msg, NULL);
      if (c_msg == NULL) return;
      std::cout << "From C++: " << c_msg << std::endl;
      env->ReleaseStringUTFChars(msg, c_msg);
  }
  ```

#### 步骤4：编译动态库

根据平台编写编译脚本（以Linux为例，使用`gcc`；Windows用`MinGW`或`MSVC`）：

```bash
# Linux下编译为libjnitest.so（-fPIC生成位置无关代码，-shared生成动态库）
gcc -fPIC -shared -I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux \
    jni/JNITestImpl.c -o libjnitest.so
```

- 编译参数说明：
  - `-I${JAVA_HOME}/include`：指定`jni.h`的路径（`JAVA_HOME`为JDK安装目录）；
  - `-I${JAVA_HOME}/include/linux`：指定平台相关头文件（如`jni_md.h`）；
  - `-o libjnitest.so`：输出动态库文件名（Linux需以`lib`开头，Java加载时用`jnitest`）。

#### 步骤5：运行Java程序

1. 将动态库路径加入系统环境变量（或通过`-Djava.library.path`指定）：

   ```bash
   # Linux：临时添加库路径
   export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/your/library
   ```

2. 运行Java程序：

   ```bash
   java com.example.JNITest
   ```

3. 输出结果：

   ```txt
   1+2=3
   From C: Hello JNI
   ```

### 4. 静态注册的优缺点

| 优点                                  | 缺点                                  |
|---------------------------------------|---------------------------------------|
| 实现简单，无需手动管理方法映射        | 函数名冗长（如多层包名时），易写错    |
| 无需理解方法签名，工具自动生成头文件  | 重构Java类/方法名后，需重新生成头文件并修改C/C++函数名 |
| 适合少量`native`方法的场景            | JVM加载时需遍历动态库函数名匹配，效率较低（对比动态注册） |

### 5. 注意事项

1. **C++编译需加`extern "C"`**：C++支持函数重载，会对函数名进行“名字修饰”（如`add`变为`_Z3addii`），导致JVM无法匹配。头文件中已自动生成`extern "C"`，实现文件若为`.cpp`，需确保包含头文件，或手动加`extern "C"`。
2. **释放JNI资源**：如`GetStringUTFChars`、`GetObjectArrayElement`等获取的资源，需调用对应`ReleaseXXX`方法释放（如`ReleaseStringUTFChars`），避免内存泄漏。
3. **函数参数类型匹配**：Java的`int`对应JNI的`jint`，`long`对应`jlong`，`String`对应`jstring`，不可直接混用（如`jstring`不能直接用`char*`接收）。

## 三、核心注册方式：动态注册

动态注册是**更灵活、高效**的方式，无需依赖固定函数名，而是在C/C++代码中通过`JNINativeMethod`结构体手动定义“Java native方法→C/C++函数”的映射关系，再通过`RegisterNatives` API向JVM注册。

### 1. 原理

Java层加载动态库时，会自动调用C/C++中的`JNI_OnLoad`函数（若存在）。在`JNI_OnLoad`中，开发者需完成以下操作：

1. 通过`FindClass`获取Java对应的类（`jclass`）；
2. 定义`JNINativeMethod`数组，每个元素对应一个“Java native方法→C/C++函数”的映射；
3. 调用`RegisterNatives`将映射关系注册到JVM；
4. 返回支持的JNI版本（如`JNI_VERSION_1_8`），告知JVM当前动态库的JNI版本。

JVM注册成功后，调用Java`native`方法时，直接通过注册的映射找到C/C++函数，无需遍历函数名匹配。

### 2. 关键结构体与API

#### （1）JNINativeMethod结构体

定义在`jni.h`中，用于描述Java方法与C/C++函数的映射：

```c
typedef struct {
    const char* name;      // Java native方法的名字（如"add"）
    const char* signature; // Java方法的签名（如"(II)I"）
    void*       fnPtr;     // C/C++函数的指针（需强制转换为void*）
} JNINativeMethod;
```

#### （2）核心API

| API名称          | 作用                                  | 原型（C语言）                                  |
|------------------|---------------------------------------|-----------------------------------------------|
| `FindClass`      | 根据类名查找Java类，返回`jclass`      | `jclass (*FindClass)(JNIEnv*, const char*);`   |
| `RegisterNatives`| 向JVM注册方法映射，成功返回0          | `jint (*RegisterNatives)(JNIEnv*, jclass, const JNINativeMethod*, jint);` |
| `UnregisterNatives` | 注销已注册的方法（可选，一般无需手动调用） | `jint (*UnregisterNatives)(JNIEnv*, jclass);` |

### 3. 完整步骤（示例）

沿用静态注册的Java代码（`com/example/JNITest.java`），仅修改C/C++实现：

#### 步骤1：实现C/C++函数（函数名可自定义）

创建`jni/JNITestDynamicImpl.c`，函数名无需遵循固定格式：

```c
#include <jni.h>
#include <stdio.h>

// 自定义函数名：实现Java的add方法（参数与静态注册一致）
jint native_add(JNIEnv *env, jobject thiz, jint a, jint b) {
    return a + b;
}

// 自定义函数名：实现Java的print方法
void native_print(JNIEnv *env, jclass cls, jstring msg) {
    const char *c_msg = (*env)->GetStringUTFChars(env, msg, NULL);
    if (c_msg == NULL) return;
    printf("From Dynamic C: %s\n", c_msg);
    (*env)->ReleaseStringUTFChars(env, msg, c_msg);
}
```

#### 步骤2：实现JNI_OnLoad函数（核心：注册映射）

在同一C文件中，实现`JNI_OnLoad`，完成动态注册：

```c
// 1. 定义JNINativeMethod数组：映射关系
static const JNINativeMethod g_methods[] = {
    // {Java方法名, 方法签名, C函数指针}
    {"add",  "(II)I",    (void*)native_add},  // 实例方法
    {"print", "(Ljava/lang/String;)V", (void*)native_print} // 静态方法
};

// 2. 定义Java类的全路径（注意：用/分隔包名，而非.）
static const char* g_class_name = "com/example/JNITest";

// 3. 实现JNI_OnLoad：JVM加载动态库时自动调用
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {
    JNIEnv* env = NULL;
    jint result = -1;

    // 步骤1：获取JNIEnv（JavaVM是JVM的全局实例，每个进程一个；通过JavaVM获取当前线程的JNIEnv）
    if ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_8) != JNI_OK) {
        return result; // 获取失败，返回-1
    }

    // 步骤2：查找Java对应的类（com.example.JNITest）
    jclass clazz = (*env)->FindClass(env, g_class_name);
    if (clazz == NULL) {
        return result; // 类未找到，返回-1
    }

    // 步骤3：注册方法映射（参数：env、类、方法数组、数组长度）
    jint method_count = sizeof(g_methods) / sizeof(g_methods[0]); // 计算方法数量
    if ((*env)->RegisterNatives(env, clazz, g_methods, method_count) != JNI_OK) {
        return result; // 注册失败，返回-1
    }

    // 步骤4：返回支持的JNI版本（必须返回正确版本，否则JVM加载失败）
    result = JNI_VERSION_1_8;
    return result;
}
```

- 若用C++实现，`GetEnv`和`FindClass`的调用方式简化：

  ```cpp
  JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {
      JNIEnv* env = NULL;
      if (vm->GetEnv((void**)&env, JNI_VERSION_1_8) != JNI_OK) {
          return -1;
      }

      jclass clazz = env->FindClass("com/example/JNITest");
      if (clazz == NULL) {
          return -1;
      }

      jint method_count = sizeof(g_methods) / sizeof(g_methods[0]);
      if (env->RegisterNatives(clazz, g_methods, method_count) != JNI_OK) {
          return -1;
      }

      return JNI_VERSION_1_8;
  }
  ```

#### 步骤3：编译动态库（与静态注册一致）

```bash
# Linux下编译
gcc -fPIC -shared -I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux \
    jni/JNITestDynamicImpl.c -o libjnitest.so
```

#### 步骤4：运行Java程序（与静态注册一致）

输出结果：

```txt
1+2=3
From Dynamic C: Hello JNI
```

### 4. 动态注册的优缺点

| 优点                                  | 缺点                                  |
|---------------------------------------|---------------------------------------|
| 函数名灵活，无需遵循冗长格式          | 需手动编写方法签名，易出错（需用`javap -s`验证） |
| 重构Java类/方法名时，仅需修改`JNINativeMethod`的`name`字段 | 实现稍复杂，需理解`JNI_OnLoad`和`RegisterNatives`的逻辑 |
| JVM直接通过映射查找函数，效率更高      | 注册失败时需手动排查（如类名、签名错误） |
| 适合大量`native`方法的场景（如框架开发） | 需确保`JNI_OnLoad`返回正确的JNI版本    |

### 5. 注意事项

1. **JNI版本兼容性**：`JNI_OnLoad`返回的版本需与JVM支持的版本匹配（如Java 8支持`JNI_VERSION_1_8`，Java 11支持`JNI_VERSION_1_10`），返回错误版本会导致动态库加载失败。
2. **方法签名正确性**：签名错误是动态注册最常见的问题，需通过`javap -s`生成正确签名（如`String`的签名是`Ljava/lang/String;`，末尾的`;`不可省略）。
3. **函数指针类型匹配**：`JNINativeMethod`的`fnPtr`需强制转换为`void*`，但C/C++函数的参数列表和返回值必须与Java`native`方法完全匹配（如Java方法是`int add(int, int)`，C函数必须是`jint (*)(JNIEnv*, jobject, jint, jint)`）。
4. **类名格式**：`FindClass`的参数需用`/`分隔包名（如`com/example/JNITest`），不可用`.`（否则会报`ClassNotFoundException`）。
5. **注册失败处理**：若`FindClass`或`RegisterNatives`失败，需返回`-1`，JVM会抛出`UnsatisfiedLinkError`，需通过日志或调试排查问题。

## 四、特殊场景的注册方式

除了静态和动态注册，还有一些针对特殊需求的扩展方式：

### 1. 动态注册多个类

若一个动态库需为多个Java类提供`native`方法，可在`JNI_OnLoad`中分别注册每个类：

```c
// 类1的映射
static const JNINativeMethod g_test1_methods[] = {
    {"foo", "()V", (void*)native_foo}
};
static const char* g_test1_class = "com/example/Test1";

// 类2的映射
static const JNINativeMethod g_test2_methods[] = {
    {"bar", "(I)J", (void*)native_bar}
};
static const char* g_test2_class = "com/example/Test2";

// 注册单个类的方法
static jint register_class(JNIEnv* env, const char* class_name, const JNINativeMethod* methods, jint count) {
    jclass clazz = (*env)->FindClass(env, class_name);
    if (clazz == NULL) return -1;
    return (*env)->RegisterNatives(env, clazz, methods, count);
}

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved) {
    JNIEnv* env = NULL;
    if ((*vm)->GetEnv(vm, (void**)&env, JNI_VERSION_1_8) != JNI_OK) {
        return -1;
    }

    // 注册类1
    if (register_class(env, g_test1_class, g_test1_methods, sizeof(g_test1_methods)/sizeof(g_test1_methods[0])) != JNI_OK) {
        return -1;
    }

    // 注册类2
    if (register_class(env, g_test2_class, g_test2_methods, sizeof(g_test2_methods)/sizeof(g_test2_methods[0])) != JNI_OK) {
        return -1;
    }

    return JNI_VERSION_1_8;
}
```

### 2. 延迟注册（按需注册）

动态注册默认在`JNI_OnLoad`中完成（库加载时），若需“调用`native`方法时再注册”（延迟加载），可通过以下方式：

1. Java层先调用一个“初始化”`native`方法（如`init()`）；
2. 在`init()`方法中调用`RegisterNatives`完成注册；
3. 后续调用其他`native`方法时，已完成注册。

示例：

```java
// Java层
public class JNIDelayTest {
    static {
        System.loadLibrary("jnidelay");
    }

    // 先调用init()完成注册
    public native void init();
    // 注册后才能调用的方法
    public native void doWork();

    public static void main(String[] args) {
        JNIDelayTest test = new JNIDelayTest();
        test.init(); // 初始化（注册）
        test.doWork(); // 调用已注册的方法
    }
}
```

C层实现：

```c
#include <jni.h>
#include <stdio.h>

// 待注册的方法
void native_doWork(JNIEnv* env, jobject thiz) {
    printf("Do work in native\n");
}

// 方法映射
static const JNINativeMethod g_methods[] = {
    {"doWork", "()V", (void*)native_doWork}
};
static const char* g_class_name = "com/example/JNIDelayTest";

// init方法：完成注册
JNIEXPORT void JNICALL Java_com_example_JNIDelayTest_init(JNIEnv* env, jobject thiz) {
    jclass clazz = (*env)->FindClass(env, g_class_name);
    if (clazz == NULL) {
        printf("Class not found\n");
        return;
    }

    jint method_count = sizeof(g_methods) / sizeof(g_methods[0]);
    if ((*env)->RegisterNatives(env, clazz, g_methods, method_count) == JNI_OK) {
        printf("Register success\n");
    } else {
        printf("Register failed\n");
    }
}
```

### 3. 静态注册与动态注册混用

一个动态库中可同时存在静态注册和动态注册的方法：

- 少量简单方法用静态注册（如`init()`）；
- 大量或需灵活修改的方法用动态注册（如业务逻辑方法）。

示例：`init()`用静态注册，`doWork()`用动态注册，在`init()`中完成`doWork()`的动态注册。

## 五、注册方式选择建议

| 场景                                  | 推荐注册方式                          |
|---------------------------------------|---------------------------------------|
| 小项目、`native`方法数量少（10个以内） | 静态注册（简单、易维护）              |
| 大项目、`native`方法数量多（10个以上） | 动态注册（高效、易重构）              |
| 需要灵活修改Java方法名/类名           | 动态注册（仅需修改`JNINativeMethod`） |
| 框架开发（需适配多个类）              | 动态注册（支持多类注册）              |
| 对性能要求高（如高频调用`native`方法） | 动态注册（避免JVM函数名匹配开销）     |

## 六、常见问题排查

1. **UnsatisfiedLinkError: no xxx in java.library.path**：动态库未找到，检查：
   - 库路径是否加入`java.library.path`（通过`-Djava.library.path=/path/to/lib`指定）；
   - 库文件名是否符合平台规范（Linux→`libxxx.so`，Windows→`xxx.dll`）。

2. **UnsatisfiedLinkError: com.example.JNITest.add(II)I**：方法未注册，检查：
   - 静态注册：函数名是否正确（包名、类名、方法名是否匹配）；
   - 动态注册：类名、方法名、方法签名是否正确，`RegisterNatives`是否成功。

3. **JNI ERROR (app bug): use of invalid jobject**：`jobject`被非法使用（如局部引用跨线程使用），检查：
   - 局部引用（如`jobject`、`jstring`）仅在当前线程、当前方法中有效，不可缓存到全局变量；
   - 需跨线程使用的对象，需创建全局引用（`NewGlobalRef`）并在使用后释放（`DeleteGlobalRef`）。

4. **JNI_OnLoad returned bad version (-1)**：`JNI_OnLoad`返回错误版本，检查：
   - 返回的JNI版本是否与JVM兼容（如Java 8需返回`JNI_VERSION_1_8`）；
   - `JNI_OnLoad`中是否有步骤失败（如`FindClass`返回`NULL`），导致返回`-1`。

通过以上内容，可全面掌握JNI的各种注册方式，结合实际场景选择合适的方式，并规避常见问题。

# Shadow 方案

Shadow是腾讯推出的一款高性能、高兼容性的插件化框架，主打“零反射”“低侵入”设计，尤其针对Android高版本（Android P+）的私有API限制和反射管控做了深度适配。其核心目标是在保证稳定性的前提下，实现插件的动态加载与四大组件的正常运行，广泛应用于腾讯系多款App（如手机QQ、腾讯视频等）。

## 一、Shadow的核心设计理念

Shadow的架构设计遵循“分层隔离”和“最小侵入”原则，将整体分为三大模块：  

- **宿主（Host）**：负责加载和管理插件，仅包含必要的框架代码（体积极小）。  
- **插件（Plugin）**：独立开发的功能模块，可打包为APK，无需提前安装。  
- **管理器（Manager）**：协调宿主与插件的交互，处理类加载、资源加载、组件生命周期等核心逻辑。  

与其他框架相比，Shadow的关键特点是：  

1. **尽量避免反射**：通过动态代理和公开API替代私有API反射，减少高版本适配风险。  
2. **插件进程隔离**：支持插件运行在独立进程或宿主进程，灵活控制资源占用。  
3. **完整的组件生命周期**：通过巧妙的代理机制，确保插件组件生命周期与系统行为一致。  

## 二、Shadow对四大组件的处理机制

Shadow对四大组件的处理核心是“代理转发+契约接口”，通过在宿主中预注册少量“桩组件”（Stub），结合动态代理拦截系统调用，实现插件组件的无注册运行。

### 1. Activity处理：“桩Activity+动态代理”双轨制

Activity是插件化中最复杂的组件（依赖AMS校验和生命周期管理），Shadow的处理分为**启动校验绕过**和**生命周期转发**两部分。

#### （1）绕过AMS的Manifest校验  

Android启动Activity时，AMS会校验该Activity是否在Manifest中注册。Shadow的解决方案是：  

- **宿主预注册桩Activity**：在宿主Manifest中注册一个特殊的桩Activity（`ShadowActivity`），作为所有插件Activity的“替身”。  
- **启动时替换Intent**：启动插件Activity时，Shadow会将Intent中的插件Activity类名（如`com.plugin.PluginActivity`）替换为桩Activity的类名，并将插件信息（插件包名、类名等）存入Intent的额外参数（`extras`）。  
- **AMS校验通过后还原**：当AMS校验通过并回调`ActivityThread`启动Activity时，Shadow通过动态代理`Instrumentation`（系统负责Activity生命周期的核心类），在`newActivity`方法中拦截，根据Intent中存储的插件信息，反射创建插件Activity实例，替代桩Activity。  

#### （2）生命周期管理  

Shadow定义了插件Activity必须实现的接口`PluginActivity`，包含`onCreate`、`onResume`等生命周期方法。桩Activity启动后，会通过该接口将自身的生命周期回调转发给插件Activity，确保：  

- 插件Activity能正常获取`Context`、`Window`等系统资源（通过桩Activity传递）。  
- 插件Activity的生命周期与系统行为完全同步（如旋转屏幕时的`onSaveInstanceState`回调）。  

#### （3）特殊场景处理  

- **主题适配**：插件Activity的主题会在启动时通过Intent传递给桩Activity，桩Activity动态应用主题，避免样式错乱。  
- **ForResult启动**：通过代理`startActivityForResult`和`onActivityResult`，确保插件Activity之间的返回值正确传递。  

### 2. Service处理：“代理Service+Binder转发”

Service的核心是跨进程通信（Binder）和生命周期管理，Shadow通过“宿主代理Service+插件Service反射实例”的方式实现。

#### （1）启动与绑定流程  

- 宿主Manifest中注册`ShadowService`作为代理，所有插件Service的`startService`、`bindService`请求都会路由到该代理。  
- 启动插件Service时，Intent中携带插件Service的类名和插件信息，代理Service接收后：  
  1. 通过插件类加载器反射创建插件Service实例。  
  2. 调用插件Service的`onCreate`、`onStartCommand`等生命周期方法。  
  3. 若为绑定请求（`bindService`），则将插件Service的`onBind`返回的Binder对象通过代理Service转发给客户端。  

#### （2）生命周期管理  

Shadow通过`ServiceLifecycleManager`统一管理插件Service的生命周期，确保：  

- 插件Service的`onDestroy`在代理Service销毁或插件卸载时被正确调用。  
- 多次启动同一插件Service时，仅创建一个实例（与系统Service的单例特性一致）。  

### 3. BroadcastReceiver处理：“静态转动态+自动注册/反注册”

BroadcastReceiver分为静态（Manifest注册）和动态（代码注册）两种，Shadow对静态广播做了特殊处理。

#### （1）静态广播动态化  

- 插件打包时，Shadow的编译插件会解析插件Manifest中的`<receiver>`标签，提取`action`、`category`、`receiver`类名等信息，生成一个配置文件（如`broadcast.json`）。  
- 插件加载时，宿主通过读取该配置文件，调用`Context.registerReceiver()`动态注册插件中的静态广播接收器（反射创建`Receiver`实例）。  

#### （2）动态广播兼容  

- 插件中通过`context.registerReceiver()`注册的动态广播可直接生效（无需额外处理）。  
- 插件卸载时，Shadow会自动调用`unregisterReceiver()`反注册所有动态注册的广播，避免内存泄漏。  

### 4. ContentProvider处理：“代理Provider+延迟初始化”

ContentProvider的特殊性在于：系统会在应用启动时自动初始化所有在Manifest中注册的Provider（早于`Application.onCreate`），而插件加载通常晚于这个时机。Shadow通过“代理+延迟加载”解决这一问题。

#### （1）代理Provider注册  

- 宿主Manifest中注册`ShadowContentProvider`，其`authority`为固定值（如`宿主包名.shadow.provider`），作为所有插件ContentProvider的入口。  
- 插件ContentProvider的`authority`需遵循约定格式：`插件包名.宿主包名.shadow.provider`，确保被代理Provider拦截。  

#### （2）延迟初始化与请求转发  

- 当外部调用`getContentResolver().query(Uri)`访问插件Provider时，代理Provider会先检查插件是否已加载：  
  - 若未加载，则触发插件加载流程（同步阻塞，确保后续操作有效）。  
  - 加载完成后，反射创建插件ContentProvider实例，调用其`onCreate`初始化。  
- 代理Provider将`query`、`insert`、`update`等请求转发给插件Provider，并返回结果。  

#### （3）跨进程访问支持  

通过`ContentProvider`的天然跨进程特性，插件Provider可被其他进程（包括宿主进程和其他插件进程）访问，代理Provider会自动处理进程间的数据序列化/反序列化。  

## 三、其他核心技术细节

### 1. 类加载机制：“双亲委派+插件隔离”

Shadow自定义`PluginClassLoader`，遵循双亲委派模型：  

- 优先使用宿主类加载器加载系统类和宿主类（避免类冲突）。  
- 插件类由`PluginClassLoader`加载，不同插件的类加载器相互独立（实现类隔离）。  
- 支持“宿主向插件暴露接口”：宿主通过`public`接口提供功能，插件依赖接口编译，运行时通过类加载器查找宿主实现类。  

### 2. 资源加载：“独立Resources+资源ID隔离”

- 插件资源加载：通过`AssetManager.addAssetPath(插件APK路径)`（公开API，非反射）创建插件独立的`Resources`对象，避免与宿主资源冲突。  
- 资源ID冲突解决：插件编译时，通过Gradle插件修改`aapt`参数，为插件资源ID添加固定偏移量（如+0x70000000），确保与宿主资源ID不重复。  

### 3. 高版本适配：“零反射+公开API替代”

针对Android P+对私有API和反射的限制（如`ActivityThread`、`AMS`等类的反射被禁止），Shadow的适配策略是：  

- 用动态代理替代反射：对`Instrumentation`、`IBinder`等公开接口使用动态代理，避免反射私有方法。  
- 基于公开API实现功能：例如通过`Context.createPackageContext`获取插件上下文，而非反射`ContextImpl`。  
- 版本分支适配：针对不同Android版本（如Android 10的`startActivity`参数变化），提供不同实现逻辑。  

## 四、Shadow与其他框架的对比

| 特性                | Shadow                          | VirtualAPK               | RePlugin                 |
|---------------------|---------------------------------|--------------------------|--------------------------|
| 反射依赖            | 极少（仅必要场景）              | 较多（依赖系统类反射）   | 中等                     |
| Android高版本适配   | 优秀（针对P+做专门优化）        | 一般（部分反射在高版本失效） | 较好（但依赖部分私有API） |
| 插件进程模型        | 支持独立进程/宿主进程           | 仅宿主进程               | 支持独立进程             |
| 类隔离              | 严格隔离（插件间类不互通）      | 弱隔离（可能类冲突）     | 严格隔离                 |
| 集成复杂度          | 中等（需接入编译插件）          | 较复杂                   | 简单（宿主仅需几行代码） |

## 五、总结

Shadow的核心优势在于**高兼容性**（尤其对Android高版本）和**稳定性**（减少反射带来的崩溃风险），通过“桩组件+动态代理+契约接口”的设计，在不侵入系统代码的前提下，实现了四大组件的完整功能。其“插件进程隔离”和“资源ID偏移”机制也使其在大型应用中表现优异，适合对稳定性要求高、需要长期维护的插件化场景。

# 解读

## 入门

- AOP 替换所有的Activity为ShadowActivity（这不是一个真正的Activity，只是一个普通类）
- Transform API 字节码编辑（得学习字节码知识基础）
- Binder通信原理，第一个Binder加载。（这里是插件化 Service部分需要的基础知识）
- android:multiprocess特性
- JavaPoet 自动生产java文件的框架
- LayoutInflater的设计
    >Android view加载会有一层缓存，导致同进程不能使用两个同名View使用LayoutInflater进行构造
- Javassist

## 设计原则

- Shadow设计原则是插件是宿主的一部分，所以Shadow可以与宿主同一个ClassLoader即随时调用宿主工程代码、也可以设置单独的ClassLoader即代码隔离，同时插件模块可以设定独立进程！比如设定清单文件中的`:process`。

### 结构

下面是源工程的结构介绍：

1. host ：宿主模块
2. plugin：插件模块。manager加载plugin前需要先加载完成runtime和loader。二者都是单独的apk。（按作者掘金博客评论区说述，Manager加载插件时，其实只需要加载一次runtime、loader就行，具体得确认下是否是这样）。runtime、loader作为插件的一部分放在插件模块，另一个原因是loader可以根据业务进行定制化处理。

    - runtime : 是一个单独的apk
    - loader : 是一个单独的apk

3. manager：Shadow全动态设计的精华，插件的管理类，是一个单独的apk，host模块中通过代码加载这个apk，然后再去加载插件！

## 结构说明（重点）

>学习Shadow框架及接入，要提前清楚Shadow的整体结构，会让你事半功倍的！

- 结构图示：待补充

- 文字说明：Shadow整体按功能分为三大块
  - 宿主（Host）：主APP，也是需要用户安装的apk
  - 插件管理者（Manager）：独立的apk，位于宿主进程中，宿主apk需要实现下载功能，下载并加载插件管理APK，通过插件管理者再进行插件的下载升级、并调用到`插件框架`。
  - 插件包（）：zip文件。包括：插件应用apk、插件框架（runtime.apk、loader.apk）、插件信息配置json文件

### 作者说

1. ContainerActivity，使用了反射将DexClassLoader设置到主进程。这也是全框架唯一一处通过反射加载类。按作者解释这一步其实可以不做，他们是因为业务对代码数、无侵入等要求，所以将ContainerActivity也动态化，放入宿主apk里了。

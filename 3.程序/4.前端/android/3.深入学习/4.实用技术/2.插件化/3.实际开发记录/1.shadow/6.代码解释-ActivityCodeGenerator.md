# 代码解释-ActivityCodeGenerator

## 1. 代理接口兼容问题原因及解决方案

```kotlin
 /**
         * 这个类集中解决一个问题的逻辑。问题Issue见https://github.com/Tencent/Shadow/issues/230
         *
         * 问题描述：
         * 一般情况下，一个类的方法签名中如果含有找不到的类，在这个类本身被new出来时是不会出错的。
         * JVM不会去检查一个类的所有方法的签名中涉及到的类是否都存在。只有当调用该方法时才会发现签名上的类找不到。
         *
         * 但是在com.tencent.shadow.core.loader.ShadowPluginLoader.getHostActivityDelegate中，
         * 将实现以接口类型返回时，涉及一种特殊情况，就是实现和接口不是由同一个ClassLoader加载的。
         * 在这种情况下，JVM会检查实现是否真的实现了接口的每一个方法定义。所以会去尝试加载接口上所有方法签名涉及的类。
         * 这会导致在低版本系统上尝试加载高版本引入的类，比如android.app.role.RoleManager是API29引入的，
         * 在API28的手机上就会出现LinkageError。
         *
         * 解决方案就是对于高版本API引入的类在生成代理转调相关代码时:在Delegate、ShadowActivityDelegate
         * 两个生成类中使用Object类型替代原本类型，在PluginContainerActivity中调用Delegate方法时强制类型转换，
         * 在ShadowActivityDelegate调用PluginActivity方法时也对参数进行强制类型转换。
         *
         * 这个方法中定义哪些类型对于低版本API是安全的，不需要采用上述方案。其余类型则采用上述方案。
         */
        private fun Class<*>.isSafeForLowApi(): Boolean {
            val safeType: List<String?> = listOf(
                android.app.Activity::class,
                android.app.Dialog::class,
                android.app.Fragment::class,
                android.content.ComponentName::class,
                android.content.Context::class,
                android.content.Intent::class,
                android.content.res.Configuration::class,
                android.content.res.Resources.Theme::class,
                android.content.res.Resources::class,
                android.graphics.Bitmap::class,
                android.graphics.Canvas::class,
                android.net.Uri::class,
                android.os.Bundle::class,
                android.util.AttributeSet::class,
                android.view.ActionMode.Callback::class,
                android.view.ActionMode::class,
                android.view.ContextMenu.ContextMenuInfo::class,
                android.view.ContextMenu::class,
                android.view.KeyEvent::class,
                android.view.Menu::class,
                android.view.MenuItem::class,
                android.view.MotionEvent::class,
                android.view.View::class,
                android.view.WindowManager.LayoutParams::class,
                android.view.accessibility.AccessibilityEvent::class,
                android.view.LayoutInflater::class
            ).map { it.java.canonicalName }

            return isPrimitive or
                    (isArray && componentType.isSafeForLowApi()) or
                    (canonicalName.startsWith("java.lang")) or
                    safeType.contains(canonicalName) // isPrimitive 是否是基本类型
        }
```

按注释解释，因为接口原因，jvm会对方法签名进行校验，从而可能出现版本兼容问题。作者解法：版本兼容的类型不做特殊处理，不兼容的类型在接口中的函数方法参数设定为Object，以强制类型转换方式调用。

## 2. javassist对于java版本的兼容问题记录

javassist 在java9以后的版本会有类加载问题，具体说明请查看：[javassist问题记录](../../../1.Hook/2.%E6%8F%92%E6%A1%A9/3.javassist/1.2.%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.md)

```kotlin
// 兼容javassist升级后的ClassPool#appendSystemPath()改动：
// https://github.com/jboss-javassist/javassist/commit/e41e0790c0cb073e9e2e30071afecfcdc4621d42
if (javassist.bytecode.ClassFile.MAJOR_VERSION < javassist.bytecode.ClassFile.JAVA_9) {
    //如果小于9，那么直接加ClassPath路径
    val cl = Thread.currentThread().contextClassLoader
    classPool.appendClassPath(LoaderClassPath(cl))
}
```

上面的解决方案，也是shadow作者给出的（👍🏻），其本质就是，根据不同版本，设置不同classPath来加载类，达成兼容效果。

# execution匹配规则

execution 是 AspectJ 中定义切入点表达式的核心，用于匹配特定的方法调用。基本语法为（问好字符表示为可选）：

```txt
execution(<修饰符模式>? <返回类型模式> <方法名模式>(<参数模式>) <异常模式>?)
```

## 匹配规则

1. **返回类型**：
   - 使用 `*` 匹配任意返回类型。
   - 指定具体的返回类型，如 `public`, `void`, `int` 等。

2. **方法名**：
   - 使用 `*` 匹配任意方法名。
   - 使用通配符 `*` 匹配方法名的任意部分，如 `*getName` 匹配所有以 `getName` 结尾的方法。
   - 匹配注解，可以通过`@`字符拼接注解全类名，或者可以使用`@annotation(这里传入注解全类名)`。

3. **参数模式**：
   - 使用 `(..)` 匹配任意数量和类型的参数。
   - 如果方法无参，那什么都不写就行。
   - 使用具体的参数类型列表，如 `(String, int)` 匹配接受字符串和整数作为参数的方法。
     > 参数尽量写全类名，避免匹配异常。比如：`String` 应该写为 `java.lang.String`

4. **异常模式**：
   - 用于匹配方法可能抛出的异常。

5. **修饰符模式**：
   - 可选，用于匹配特定的访问修饰符，如 `public`, `private`, `protected` 等。

6. **类和包匹配**：
   - 使用类名或包名来限定匹配的范围。
   - 使用 `..` 表示当前包及其所有子包。
      >简单说如果包有`..`，表示匹配任意层级的包

7. **组合 Pointcut 表达式**：
   - 使用逻辑运算符 `&&`, `||`, `!` 组合多个 Pointcut 表达式。

## 示例

1. **匹配任意公共方法**：

   ```java
   execution(public * *(..))
   ```

2. **匹配特定方法**：

   ```java
   execution(void com.example.MyClass.myMethod(String, int))
   execution(void com.example.MyClass.myMethod())//这是匹配无参的myMethond方法
   ```

3. **匹配特定类的所有方法**：

   ```java
   execution(* com.example.MyClass.*(..))
   ```

4. **匹配特定包下所有类的所有方法**：

   ```java
   execution(* com.example.mypackage..*.*(..))
   ```

5. **匹配特定包及其子包下所有类的所有方法**：

   ```java
   execution(* com.example.mypackage.**.*(..))
   ```

6. **匹配特定方法名的所有变体**：

   ```java
   execution(* *.getName(..))
   ```

7. **匹配特定参数的方法**：

   ```java
   execution(* *(Serializable, ..))
   ```

8. **匹配特定异常类型的所有方法**：

   ```java
   execution(* * throws IOException)
   ```

9. **组合使用 Pointcut 表达式**：

   ```java
   execution(* com.example.service..*.*(..)) && !execution(* com.example.service.*Test.*(..))
   ```

10. **使用注解限定匹配**：

    ```java
    execution(@com.example.MyAnnotation * *(..))//通过全注解类名匹配

    execution(@annotation(com.example.MyAnnotation))//通过@annotation方式
    ```

通过这些示例，你可以看到 `execution` 表达式的灵活性和强大功能。正确使用 `execution` 表达式可以帮助你精确地控制 AspectJ 中的切入点，实现复杂的 AOP 逻辑。

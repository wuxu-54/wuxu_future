#

## 执行错误

```java
private static void createPerson() throws  Exception{
        ClassPool pool = ClassPool.getDefault();

       CtClass person = pool.makeClass("com.wuxu.learn_javassist.Person");//创建空类

        //无参构造
        CtConstructor constructor =new CtConstructor(new CtClass[]{},person);
//        constructor.setBody("{System.out.println(\"Person Constructor\");}");
        person.addConstructor(constructor);
        //1.创建两个变量 int a,b
       CtField ctFieldA =  new CtField(pool.get("int"),"a",person);
       ctFieldA.setModifiers(Modifier.PUBLIC);
       person.addField(ctFieldA, CtField.Initializer.constant(10)); // 添加到类中，并设置默认值

       CtField ctFieldB =  new CtField(pool.get("int"),"b",person);
       ctFieldB.setModifiers(Modifier.PRIVATE);
       person.addField(ctFieldB,CtField.Initializer.constant(11));
        //2.创建变量的访问器和修改器
        CtMethod getAMethod = CtMethod.make("public String getA(){return a;}",person);
        person.addMethod(getAMethod);
        //3.生成类
//        person.setSuperclass(pool.get("java.lang.Object"));

        Class<?> clazz = person.toClass();//获取字节码
        Object obj = clazz.getDeclaredConstructor().newInstance();//创建类
        System.out.println(clazz.getMethod("getA").invoke(obj));
        System.out.println("执行完成！");
        person.writeFile(".");//保存到文件中
    }
```

`person.toClass()`执行遇到错误：

Unable to make protected final java.lang.Class java.lang.ClassLoader.defineClass(java.lang.String,byte[],int,int,java.security.ProtectionDomain) throws java.lang.ClassFormatError accessible: module java.base does not "opens java.lang" to unnamed module

原因：

在 Java 9 之前，类加载器的 `defineClass` 方法可以被反射访问并调用，用于动态定义类。但从 Java 9 开始，Java 引入了模块化系统，为了增强安全性和封装性，对模块之间的访问进行了严格的控制。`java.base` 模块默认不会将 `java.lang` 包开放给未命名模块（也就是没有使用模块声明文件 `module-info.java` 的代码），因此在使用反射访问 `defineClass` 方法时会抛出上述错误。

解决方案：

1. [Github-issue](https://github.com/jboss-javassist/javassist/issues/369)
2. [兼容javassist升级后的ClassPool#appendSystemPath()改动](https://github.com/jboss-javassist/javassist/commit/e41e0790c0cb073e9e2e30071afecfcdc4621d42)

---

### AI给出的其他解决方案

#### 1. 使用 `--add-opens` JVM 参数

在运行 Java 程序时，可以通过 `--add-opens` 参数来明确告诉 JVM 打开特定模块的特定包给指定的模块。对于未命名模块，可以使用 `--add-opens java.base/java.lang=ALL-UNNAMED` 来开放 `java.base` 模块的 `java.lang` 包给所有未命名模块。

以下是几种不同场景下添加该参数的示例：

**命令行运行**：

```sh
java --add-opens java.base/java.lang=ALL-UNNAMED -cp your-classpath YourMainClass
```

**IDE 中配置（以 IntelliJ IDEA 为例）**：

- 打开项目的运行配置（Run Configuration）。
- 在 `VM options` 字段中添加 `--add-opens java.base/java.lang=ALL-UNNAMED`。

**Maven 项目**：
在 `pom.xml` 中配置 `maven-surefire-plugin` 和 `maven-failsafe-plugin`（如果有使用），添加 `argLine` 配置：

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>3.0.0-M5</version>
            <configuration>
                <argLine>--add-opens java.base/java.lang=ALL-UNNAMED</argLine>
            </configuration>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-failsafe-plugin</artifactId>
            <version>3.0.0-M5</version>
            <configuration>
                <argLine>--add-opens java.base/java.lang=ALL-UNNAMED</argLine>
            </configuration>
        </plugin>
    </plugins>
</build>
```

#### 2. 使用模块化系统

如果你正在开发一个模块化的 Java 应用程序，可以在 `module-info.java` 文件中明确声明模块之间的依赖和访问权限。

假设你的项目模块名为 `your.module.name`，可以在 `module-info.java` 中添加如下内容：

```java
module your.module.name {
    requires java.base;
    // 开放对 java.lang 包的访问
    opens java.lang to javassist; 
}
```

这样可以确保你的模块能够合法地访问 `java.base` 模块的 `java.lang` 包中的类和方法。

#### 3. 检查 Javassist 版本

确保你使用的是与 Java 版本兼容的 Javassist 版本。较新的 Javassist 版本通常会对 Java 模块化系统有更好的支持，可能已经对这个问题进行了修复或优化。你可以尝试更新到最新的稳定版本。

通过以上方法，你应该能够解决由于 Java 模块化系统的访问限制导致的 `defineClass` 方法访问问题。

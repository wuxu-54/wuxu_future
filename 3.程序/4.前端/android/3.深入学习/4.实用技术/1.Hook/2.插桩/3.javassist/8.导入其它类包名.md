# 导入其他类包名

方式：

1. 手动导入，即通过字符串写入
2. 直接使用全类名，这样无需导入包

## 手动导入

在使用 `javassist` 生成类文件时，如果需要在生成的类中导入其他类的包名，可以通过修改生成类的源代码来实现。以下是详细的步骤和示例代码：

### 实现思路

在 `javassist` 中，虽然没有直接提供导入包名的方法，但可以通过在生成类的方法体或者类定义中使用全限定类名，或者在生成的源代码字符串中手动添加 `import` 语句来达到导入包的目的。

### 示例代码

```java
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.CtNewMethod;

import java.io.IOException;

public class JavassistImportExample {
    public static void main(String[] args) {
        try {
            // 获取 ClassPool 实例
            ClassPool pool = ClassPool.getDefault();

            // 创建新的 CtClass 对象
            CtClass cc = pool.makeClass("com.example.GeneratedClass");

            // 手动添加 import 语句到类的源代码
            StringBuilder classSource = new StringBuilder();
            classSource.append("package com.example;\n");
            classSource.append("import java.util.Date;\n");
            classSource.append("public class GeneratedClass {\n");

            // 创建一个使用导入类的方法
            CtMethod method = CtNewMethod.make(
                    "public void printCurrentDate() { " +
                            "Date now = new Date(); " +
                            "System.out.println(\"Current date: \" + now); " +
                            "}",
                    cc
            );

            // 将方法添加到类中
            cc.addMethod(method);

            // 完成类的源代码构建
            classSource.append(method.getMethodInfo().getDescriptor());
            classSource.append("}\n");

            // 将修改后的类写入文件
            cc.writeFile();

            System.out.println("Class generated successfully with import statement.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### 代码解释

1. **获取 `ClassPool` 实例**：通过 `ClassPool.getDefault()` 得到默认的 `ClassPool` 实例，用于管理和操作类的字节码。
2. **创建新的 `CtClass` 对象**：使用 `pool.makeClass("com.example.GeneratedClass")` 创建一个名为 `com.example.GeneratedClass` 的新类。
3. **手动添加 `import` 语句**：使用 `StringBuilder` 手动构建类的源代码，并添加 `import java.util.Date;` 语句，这样在生成的类中就会包含该导入语句。
4. **创建使用导入类的方法**：创建一个 `printCurrentDate` 方法，在方法中使用了导入的 `java.util.Date` 类。
5. **添加方法到类中**：调用 `cc.addMethod(method)` 将创建的方法添加到新类中。
6. **完成类的源代码构建**：将方法的描述信息添加到类的源代码中，并完成类的定义。
7. **写入文件**：使用 `cc.writeFile()` 将生成的类保存到文件系统。

### 注意事项

- **手动管理 `import` 语句**：由于 `javassist` 没有直接提供管理 `import` 语句的功能，所以需要手动在源代码中添加。确保 `import` 语句的正确性和完整性。
- **异常处理**：在使用 `javassist` 进行字节码操作时，可能会抛出各种异常，如 `NotFoundException`、`CannotCompileException` 等，需要进行适当的异常处理。

通过上述方法，你可以在使用 `javassist` 生成的类文件中导入其他类的包名。

---

## 非手动

除了手动添加 `import` 语句外，在 `javassist` 中并没有直接的 API 专门用于添加 `import` 语句到生成的类中，但可以利用一些间接的方式达成类似效果，以下为你详细介绍：

### 1. 使用全限定类名

在生成的代码里直接使用类的全限定名，这样就无需显式添加 `import` 语句。因为 Java 编译器在编译时能够根据全限定名找到对应的类。

#### 1.1 示例代码

```java
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.CtNewMethod;

import java.io.IOException;

public class JavassistFullyQualifiedNameExample {
    public static void main(String[] args) {
        try {
            ClassPool pool = ClassPool.getDefault();
            CtClass cc = pool.makeClass("com.example.GeneratedClass");

            // 创建一个使用全限定类名的方法
            CtMethod method = CtNewMethod.make(
                    "public void printDate() { " +
                            "java.util.Date now = new java.util.Date(); " +
                            "System.out.println(\"Current date: \" + now); " +
                            "}",
                    cc
            );

            cc.addMethod(method);
            cc.writeFile();
            System.out.println("Class generated successfully using fully qualified names.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

#### 1.2. 代码解释

在 `printDate` 方法里，直接使用了 `java.util.Date` 这个全限定类名来创建 `Date` 对象，这样即使没有 `import java.util.Date;` 语句，代码依然可以正常编译和运行。

### 2. 通过 `ClassPool` 引用类

`ClassPool` 能够帮助解析类名，在生成代码时使用 `CtClass` 对象来引用类，避免手动处理包名。

#### 2.1 示例代码

```java
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.CtNewMethod;

import java.io.IOException;

public class JavassistClassPoolReferenceExample {
    public static void main(String[] args) {
        try {
            ClassPool pool = ClassPool.getDefault();
            CtClass cc = pool.makeClass("com.example.GeneratedClass");

            // 获取 Date 类的 CtClass 对象
            CtClass dateClass = pool.get("java.util.Date");

            // 创建一个使用 CtClass 引用类的方法
            CtMethod method = CtNewMethod.make(
                    "public void printDate() { " +
                            dateClass.getName() + " now = new " + dateClass.getName() + "(); " +
                            "System.out.println(\"Current date: \" + now); " +
                            "}",
                    cc
            );

            cc.addMethod(method);
            cc.writeFile();
            System.out.println("Class generated successfully using ClassPool references.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

#### 2.2 代码解释

- 借助 `pool.get("java.util.Date")` 获取 `java.util.Date` 类的 `CtClass` 对象。
- 在方法体中运用 `dateClass.getName()` 来获取类的全限定名，以此引用该类。这样做的好处是，如果后续需要更改类名或者包名，只需修改 `pool.get()` 中的参数即可。

### 3. 结合模板引擎

可以使用模板引擎（如 Apache Velocity、Freemarker 等）来生成包含 `import` 语句的类源代码，再使用 `javassist` 处理生成的源代码。

#### 3.1 示例（使用 Apache Velocity 模板引擎）

```java
import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.CtNewMethod;
import org.apache.velocity.Template;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;

import java.io.IOException;
import java.io.StringWriter;
import java.util.Properties;

public class JavassistTemplateEngineExample {
    public static void main(String[] args) {
        try {
            // 初始化 Velocity 引擎
            Properties properties = new Properties();
            properties.setProperty("resource.loader", "class");
            properties.setProperty("class.resource.loader.class", "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader");
            VelocityEngine velocityEngine = new VelocityEngine(properties);
            velocityEngine.init();

            // 创建 Velocity 上下文
            VelocityContext context = new VelocityContext();
            context.put("packageName", "com.example");
            context.put("imports", "import java.util.Date;");
            context.put("methodBody", "Date now = new Date(); System.out.println(\"Current date: \" + now);");

            // 获取模板
            Template template = velocityEngine.getTemplate("class-template.vm");

            // 合并模板和上下文
            StringWriter writer = new StringWriter();
            template.merge(context, writer);
            String classSource = writer.toString();

            // 使用 javassist 处理生成的源代码
            ClassPool pool = ClassPool.getDefault();
            CtClass cc = pool.makeClass("com.example.GeneratedClass");
            CtMethod method = CtNewMethod.make(classSource, cc);
            cc.addMethod(method);
            cc.writeFile();
            System.out.println("Class generated successfully using a template engine.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

#### 3.2 模板文件 `class-template.vm`

```java
package $packageName;
$imports
public class GeneratedClass {
    public void printDate() {
        $methodBody
    }
}
```

#### 3.3 代码解释

- 运用 Apache Velocity 模板引擎生成包含 `import` 语句的类源代码。
- 把生成的源代码传递给 `javassist` 进行处理，生成最终的类文件。这种方式可以让代码结构更加清晰，便于维护和扩展。

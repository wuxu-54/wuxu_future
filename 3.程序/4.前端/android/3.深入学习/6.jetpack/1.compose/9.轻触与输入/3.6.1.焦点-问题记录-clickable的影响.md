# `clickable(true)`影响焦点获取

以下是关于 `clickable(true)` 如何影响焦点获取的**源码级解释和原理分析**。

---

## 🧠 一、`clickable(true)` 的本质行为

Jetpack Compose 中的 `clickable()` 是一个高阶修饰符，它封装了点击事件处理逻辑。其签名如下：

```kotlin
fun Modifier.clickable(
    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },
    indication: Indication? = rememberRipple(),
    enabled: Boolean = true,
    onClickLabel: String? = null,
    role: Role? = null,
    onClick: () -> Unit
): Modifier
```

当你调用：

```kotlin
Modifier.clickable(enabled = true, onClick = { ... })
```

Compose 会自动为该组件添加以下能力：

| 能力 | 是否启用 |
|------|----------|
| 点击交互 | ✅ 启用 |
| 可聚焦（focusable） | ✅ 自动启用 |
| 视觉反馈（如 Ripple） | ✅ 默认启用 |

---

## 🔍 二、为什么 `clickable(true)` 会导致组件自动变为可聚焦？

### 来看 Jetpack Compose 源码中的实现（伪代码简化版）

在 `Clickble.kt` 或 `Interaction.kt` 相关源码中可以看到：

```kotlin
val focusable = clickableNode.isFocusable // 判断是否应聚焦
if (focusable) {
    node.focusProperties {
        this.role = Role.Button // 或其它角色
    }
}
```

Jetpack Compose 内部会判断：
> 如果组件是可点击的（`clickable(true)`），并且没有显式设置 `.focusable(false)`，那么它将被系统自动标记为可聚焦。

也就是说，**只要你使用了 `clickable(true)`，Jetpack Compose 就会默认认为这个组件应该能接收焦点**，以便用户可以通过遥控器方向键选中它并按“OK”进行点击操作。

---

## 📌 三、焦点路径为何被打乱？

Android TV 上的方向键导航依赖于 UI 树中的 `focusable()` 组件顺序与位置关系。

假设你有如下结构：

```kotlin
Column {
    Text("A", modifier = Modifier.focusable())
    Text("B", modifier = Modifier.clickable(true, onClick = {}))
    Text("C", modifier = Modifier.focusable())
}
```

虽然 A 和 C 显式设置了 `focusable()`，但 B 因为加了 `clickable(true)`，也会变成可聚焦组件。

结果导致：

- **焦点路径变成：A → B → C**
- **而你预期可能是：A → C**

这就是所谓的“焦点跳转混乱”。

---

## 🛠️ 四、如何从源码角度规避这个问题？

Compose 提供了一种方式：**通过手动设置 `.focusable(false)` 来屏蔽自动聚焦行为**。

例如：

```kotlin
Text(
    text = "仅点击不聚焦",
    modifier = Modifier
        .clickable(true, onClick = {})
        .focusable(false)
)
```

这会告诉 Compose 引擎：
> “我允许点击，但不要让这个组件参与焦点路径。”

---

## 💡 五、源码层面的技术说明

Compose 在构建 UI 树时，会通过一系列的 `Modifier` 构建节点（Node）。其中：

- `clickable()` 会创建一个 `ClickableNode`
- 该 Node 会检查当前是否启用，并决定是否注册焦点属性

部分源码片段（来自 Compose 内部）：

```kotlin
internal class ClickableNode(...) : DelegatingNode(), FocusableNode {
    override val isFocusable: Boolean
        get() = enabled && role != null
}
```

所以：

- 当你设置 `clickable(true)` 并赋予了一个 `role`（如 Button）
- 或者未指定 `indication` 但保留了 `enabled = true`
- 那么这个组件就会被标记为 `isFocusable == true`

---

## ✅ 六、推荐做法（避免干扰焦点路径）

### ✅ 方法一：仅点击，不聚焦（推荐用于 Android TV）

```kotlin
Modifier.clickable(
    interactionSource = remember { MutableInteractionSource() },
    indication = null, // 移除视觉反馈
    onClick = {}
)
```

这样：

- 用户可以点击
- 但不会自动加入焦点路径

### ✅ 方法二：明确禁止聚焦（即使使用了 `clickable(true)`）

```kotlin
Modifier
    .clickable(true, onClick = {})
    .focusable(false)
```

---

## 📋 七、总结：`clickable(true)` 对焦点的影响机制

| 行为 | 是否触发 |
|------|----------|
| 自动添加 `focusable()` | ✅ 是 |
| 加入焦点导航路径 | ✅ 是 |
| 改变原有焦点顺序 | ✅ 是 |
| 影响 `up/down/left/right` 设置 | ✅ 是 |
| 可以手动屏蔽 | ✅ 是（通过 `.focusable(false)`） |

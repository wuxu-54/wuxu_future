# 开发 Android TV 应用

以下是使用 Jetpack Compose 开发 Android TV 应用的全面指南，结合核心知识点、最佳实践及常见问题解决方案整理而成：

---

## ⚙️ **一、开发环境配置**

1. **依赖库配置**  
   在 `build.gradle` 中添加 TV 专用 Compose 依赖：

   ```kotlin
   dependencies {
       implementation("androidx.tv:tv-foundation:1.0.0") // TV 专用组件库
       implementation("androidx.tv:tv-material:1.0.0")   // TV 版 Material 设计
   }
   ```

2. **AndroidManifest 关键配置**  
   在 `AndroidManifest.xml` 中声明 TV 特性：

   ```xml
   <activity
       android:name=".MainActivity"
       android:screenOrientation="landscape" <!-- TV 固定横屏 -->
       android:isGame="false" <!-- 非游戏应用 -->
       android:enableOnBackInvokedCallback="true"> <!-- Android 13+ 返回键支持 -->
       <intent-filter>
           <action android:name="android.intent.action.MAIN" />
           <category android:name="android.intent.category.LEANBACK_LAUNCHER" /> <!-- TV 主屏入口 -->
       </intent-filter>
   </activity>
   ```

---

## 🎯 **二、焦点管理（TV 应用核心）**

1. **基础焦点控制**  
   - 使用 `Modifier.focusable()` 使组件可聚焦。
   - 监听焦点变化：`Modifier.onFocusChanged { state -> ... }`。

   ```kotlin
   Button(
       onClick = {},
       modifier = Modifier
           .focusable()
           .onFocusChanged { state -> 
               isFocused = state.isFocused 
           }
   ) { ... }
   ```

2. **自定义焦点顺序**  
   通过 `FocusRequester` 和 `focusOrder` 定义导航链：

   ```kotlin
   val (item1, item2) = FocusRequester.createRefs()
   Row {
       Button(
           modifier = Modifier.focusOrder(item1) { next = item2 },
           onClick = {}
       )
       Button(
           modifier = Modifier.focusOrder(item2) { previous = item1 },
           onClick = {}
       )
   }
   ```

3. **方向键导航**  
   指定方向键的焦点跳转目标：

   ```kotlin
   Modifier.focusProperties {
       down = nextItemFocusRequester // 按下↓键跳转至 nextItem
       right = rightItemFocusRequester
   }
   ```

---

## 📺 **三、TV 专用组件**

1. **横向列表 (`LazyRow`)**  
   TV 应用主要使用横向布局，需配合焦点优化：

   ```kotlin
   LazyRow {
       items(items) { item ->
           Card(
               modifier = Modifier
                   .onFocusChanged { /* 处理焦点视觉反馈 */ }
                   .focusable()
           ) { ... }
       }
   }
   ```

2. **焦点视觉增强**  
   使用 `tv-material` 中的 `Card` 或 `Button`，默认提供放⼤效果和边框高亮：

   ```kotlin
   androidx.tv.material3.Card(
       onClick = {},
       modifier = Modifier.focusable()
   ) { ... }
   ```

---

## 🕹️ **四、导航与按键处理**

1. **物理按键监听**  
   使用 `Modifier.onKeyEvent` 处理遥控器按键：

   ```kotlin
   Modifier
       .focusable()
       .onKeyEvent { event ->
           if (event.key == Key.DirectionRight) {
               // 处理右键逻辑
               true // 事件已消费
           } else false
       }
   ```

2. **全局焦点管理**  
   通过 `FocusManager` 跨组件移动焦点：

   ```kotlin
   val focusManager = LocalFocusManager.current
   Button(onClick = { focusManager.moveFocus(FocusDirection.Next) }) {
       Text("跳至下一个焦点项")
   }
   ```

---

## ⚡ **五、性能优化技巧**

1. **避免焦点跳跃问题**  
   - 使用最新 Compose TV 版本（≥1.3.0），修复了早期版本的焦点跳跃 Bug。
   - 避免在 `LazyColumn/LazyRow` 的 `onFocusChanged` 中触发滚动逻辑。

2. **异步加载优化**  
   使用 `LaunchedEffect` 加载数据，避免阻塞 UI 线程：

   ```kotlin
   LaunchedEffect(Unit) {
       data = fetchData() // 后台数据加载
   }
   ```

---

## ⚠️ **六、常见问题解决**

1. **焦点丢失**  
   - 使用 `rememberSaveable` 保存焦点状态。
   - 重组后通过 `FocusRequester` 重新请求焦点：

     ```kotlin
     LaunchedEffect(key) {
         focusRequester.requestFocus()
     }
     ```

2. **TV 模拟器调试**  
   - 在 Android Studio 中创建 TV 模拟器（选择 Android TV 系统镜像）。
   - 真机调试需开启开发者模式并允许 ADB 连接。

3. **遥控器按键无响应**  
   检查组件是否添加 `focusable()` 并确保焦点链未中断。

---

## 📝 **七、完整示例：TV 首页布局**

```kotlin
@Composable
fun TvHomeScreen() {
    val focusManager = LocalFocusManager.current
    val movieList = remember { generateMovies() }
    val (featuredFocus, listFocus) = FocusRequester.createRefs()

    Column {
        // 顶部横幅
        BannerItem(
            modifier = Modifier.focusRequester(featuredFocus),
            onFocus = { /* 高亮处理 */ }
        )

        // 横向电影列表
        LazyRow(
            modifier = Modifier.focusRequester(listFocus),
            state = rememberLazyListState()
        ) {
            items(movieList) { movie ->
                MovieCard(
                    movie,
                    Modifier
                        .onFocusChanged { /* 缩放动画 */ }
                        .focusable()
                )
            }
        }
    }

    // 设置初始焦点顺序
    LaunchedEffect(Unit) {
        featuredFocus.requestFocus()
        focusManager.setFocusProperties {
            down = listFocus // 按↓键从横幅跳转到列表
        }
    }
}
```

---

## ✅ **最佳实践总结**

1. **设计规范**：遵循 [TV Design Guidelines](https://developer.android.com/design/tv)，确保字体/间距适配大屏。
2. **焦点反馈**：始终为焦点项提供视觉变化（缩放/边框）。
3. **测试覆盖**：使用 D-Pad 遥控器模拟所有导航路径。
4. **性能监控**：通过 Android Studio Profiler 检查重组次数和帧率。

> 更多实践案例可参考开源项目 [ComposeTv](https://github.com/UmairKhalid786/ComposeTv) 。遇到复杂焦点问题建议查看官方 [Compose TV Samples](https://github.com/android/tv-samples)。


# Compose 中的焦点

官网地址：<https://developer.android.google.cn/develop/ui/compose/touch-input/focus?hl=zh-cn>

## 一、焦点的核心概念

### 1. 焦点的作用

- 跟踪用户当前交互的组件，支持非触摸导航（如键盘、游戏控制器）。
- 确保界面元素按逻辑顺序响应导航操作（如Tab键、箭头键）。

### 2. 适用场景

- **ChromeOS**：通过实体键盘箭头键导航。
- **游戏场景**：使用连接的游戏控制器操作。
- **移动设备**：通过屏幕键盘循环切换焦点元素。

## 二、默认焦点遍历顺序规则

### 1. 层级概念

- **同级组件**：同一父容器内的组件（如`Column`或`Row`中的子元素）。
- **层级关系**：焦点遍历遵循“同级优先，再上下级切换”原则（如从子组件返回父容器，再进入下一个同级子组件）。

## **一、焦点管理基础概念**

### 1. **焦点的定义**

- **焦点**是指当前接收用户输入的 UI 元素。例如：
  - 输入框获得焦点时，用户输入的文本会发送到该输入框。
  - 按钮获得焦点时，用户的点击事件会触发其操作。
- 焦点可以通过以下方式转移：
  - **用户点击**（触摸屏）。
  - **方向键操作**（如 D-pad 或键盘）。
  - **代码控制**（通过 `FocusRequester` 或 `LocalFocusManager`）。

### 2. **焦点状态**

- 每个可获得焦点的 UI 元素都有一个 **焦点状态**，由 `FocusState` 表示：
  - `Focused`：元素当前拥有焦点。
  - `Unfocused`：元素未获得焦点。
- 开发者可以通过监听焦点状态变化（如 `onFocusChanged`）来执行特定逻辑。

### 3. **焦点顺序**

- **焦点顺序**决定了用户通过方向键移动焦点时的顺序。默认情况下：
  - 焦点顺序遵循元素在布局中的顺序（如 `Column` 的从上到下，`Row` 的从左到右）。
- 可通过 `Modifier.focusProperties` 自定义焦点顺序，支持以下方向：
  - **一维方向**：`next` 和 `previous`（适用于列表或线性布局）。
  - **二维方向**：`up`、`down`、`left`、`right`（适用于网格布局）。

---

## **二、焦点管理的核心 API**

### 1. **使元素可聚焦：`Modifier.focusable()`**

- 默认情况下，部分组件（如 `TextButton`）已支持焦点，但其他组件（如 `Box`）需要显式调用 `focusable()`。

   ```kotlin
   @Composable
   fun FocusableText() {
       Text(
           text = "Focusable Text",
           modifier = Modifier
               .size(200.dp)
               .background(Color.Blue)
               .focusable() // 使 Text 组件可获得焦点
       )
   }
   ```

### 2. **手动请求焦点：`FocusRequester`**

- 通过 `FocusRequester` 可以在代码中手动请求某个元素获得焦点。
- **步骤**：
     1. 创建焦点引用对象：

        ```kotlin
        val (first, second) = remember { FocusRequester.createRefs() }
        ```

     2. 将引用绑定到目标组件：

        ```kotlin
        Text("First", modifier = Modifier.focusRequester(first))
        Text("Second", modifier = Modifier.focusRequester(second))
        ```

     3. 在需要时请求焦点：

        ```kotlin
        LaunchedEffect(Unit) {
            first.requestFocus()
        }
        ```

### 3. **自定义焦点顺序：`Modifier.focusProperties`**

- 通过 `focusProperties` 可以覆盖默认的焦点顺序。例如：

     ```kotlin
     Modifier
         .focusRequester(first)
         .focusProperties {
             next = second // 设置下一个焦点目标为 second
         }
     ```

- 对于二维布局（如网格），可以指定方向：

     ```kotlin
     Modifier
         .focusRequester(fourth)
         .focusProperties {
             down = third  // 向下移动焦点到 third
             right = second // 向右移动焦点到 second
         }
     ```

### 4. **焦点管理器：`LocalFocusManager`**

- 通过 `LocalFocusManager` 可以全局控制焦点：
  - **清除焦点**（隐藏键盘）：

       ```kotlin
       val focusManager = LocalFocusManager.current
       focusManager.clearFocus()
       ```

  - **移动焦点到指定方向**：

       ```kotlin
       focusManager.moveFocus(FocusDirection.Down)
       ```

---

## **三、焦点管理的实际场景**

### 1. **表单输入的焦点转移**

- 在表单中，用户输入完一个字段后，可通过 `KeyboardActions` 将焦点移动到下一个字段并隐藏键盘：

     ```kotlin
     TextField(
         value = text,
         onValueChange = { text = it },
         keyboardActions = KeyboardActions(
             onNext = { focusManager.moveFocus(FocusDirection.Next) },
             onDone = { focusManager.clearFocus() }
         )
     )
     ```

### 2. **焦点组（Focus Group）**

- 在复杂布局中，可以将多个子元素组合成一个焦点组，确保焦点在组内移动而非跳转到其他组件：

     ```kotlin
     Row(modifier = Modifier.focusGroup()) {
         FilterChip("Option 1")
         FilterChip("Option 2")
         FilterChip("Option 3")
     }
     ```

### 3. **动态焦点顺序**

- 在网格布局中，可以通过 `focusProperties` 实现自定义的焦点导航逻辑，例如：

     ```kotlin
     LazyVerticalGrid(columns = GridCells.Fixed(4)) {
         items(chocolates) { item ->
             SweetsCard(
                 modifier = Modifier
                     .focusRequester(item.focusRequester)
                     .focusProperties {
                         down = item.nextRowFocusRequester
                         right = item.nextColumnFocusRequester
                     }
             )
         }
     }
     ```

---

## **四、焦点管理的注意事项**

1. **默认焦点行为**：
   - 部分组件（如 `Button`、`TextField`）默认可聚焦，无需显式调用 `focusable()`。
   - 自定义组件（如 `Box`）需要手动添加 `.focusable()`。

2. **焦点与布局的关系**：
   - 焦点顺序默认依赖布局结构。如果布局动态变化（如添加/移除组件），需重新绑定 `FocusRequester`。

3. **性能优化**：
   - 避免在不必要的组件上添加 `focusable()`，以减少焦点管理的开销。

4. **测试焦点逻辑**：
   - 使用方向键或无障碍工具（如 TalkBack）测试焦点转移是否符合预期。

5. **焦点修饰符顺序**：
    1. `.focusable()` 放在所有焦点相关配置的最后，它等同于建造者模式的build(),其之后的焦点相关配置都不会生效。
    2. `onFoucsChanged{}` 放在`.focusRequester()`之前，否则不会触发回调。

---

## **五、官方文档与资源**

- **官方焦点管理文档**：[Jetpack Compose 焦点管理](https://developer.android.com/develop/ui/compose/touch-input/focus)
- **焦点相关 API 参考**：
  - [FocusRequester](https://developer.android.com/reference/kotlin/androidx/compose/ui/focus/package-summary#FocusRequester)
  - [FocusProperties](https://developer.android.com/reference/kotlin/androidx/compose/ui/focus/package-summary#FocusProperties)

---

通过以上知识点，开发者可以灵活控制 Compose 中的焦点行为，实现更流畅的用户交互体验。如果需要更具体的代码示例或场景分析，可以进一步探讨！

# InteractionSource

在 Android Compose 中，`InteractionSource` 是一个核心接口，用于追踪和管理组件与用户之间的交互状态。它是实现自定义视觉反馈（如点击、悬停、焦点状态）的关键工具。以下是对 `InteractionSource` 的详细解析：

## 1. **基本概念**

`InteractionSource` 是一个接口，用于监听组件的各种交互状态变化，例如：

- **点击（Press）**：用户按下组件但未释放
- **焦点（Focus）**：组件获得或失去焦点
- **悬停（Hover）**：指针（如鼠标）悬停在组件上
- **拖动（Drag）**：用户正在拖动组件

常见的实现类有 `MutableInteractionSource`，它允许我们主动发射交互状态的变化。

## 2. **核心方法和属性**

```kotlin
interface InteractionSource {
    // 流：监听交互状态变化
    val interactions: Flow<Interaction>
    
    // 检查是否存在特定类型的交互
    suspend fun collectIsPressedAsState(): State<Boolean>
    suspend fun collectIsFocusedAsState(): State<Boolean>
    suspend fun collectIsHoveredAsState(): State<Boolean>
}
```

## 3. **常见交互类型**

Compose 内置了几种标准交互类型：

- `PressInteraction.Press`：按下状态
- `FocusInteraction.Focus`：焦点状态
- `HoverInteraction.Hover`：悬停状态
- `DragInteraction.Start`/`DragInteraction.Stop`：拖动状态

## 4. **如何使用 InteractionSource**

### 4.1 创建和使用 MutableInteractionSource

```kotlin
@Composable
fun CustomButton() {
    // 创建可变的交互源
    val interactionSource = remember { MutableInteractionSource() }
    
    // 收集按下状态
    val isPressed by interactionSource.collectIsPressedAsState()
    
    Box(
        modifier = Modifier
            .size(100.dp)
            .background(
                color = if (isPressed) Color.Red else Color.Blue
            )
            .clickable(
                interactionSource = interactionSource, // 关联交互源
                indication = null // 禁用默认涟漪效果
            ) { /* 点击事件 */ }
    )
}
```

### 4.2 自定义交互效果

```kotlin
@Composable
fun CustomFocusableBox() {
    val interactionSource = remember { MutableInteractionSource() }
    val isFocused by interactionSource.collectIsFocusedAsState()
    
    Box(
        modifier = Modifier
            .size(150.dp)
            .background(Color.Gray)
            .border(
                width = if (isFocused) 4.dp else 1.dp,
                color = if (isFocused) Color.Yellow else Color.Black
            )
            .focusable(
                interactionSource = interactionSource
            )
    )
}
```

### 4.3 监听多种交互状态

```kotlin
@Composable
fun MultiInteractionDemo() {
    val interactionSource = remember { MutableInteractionSource() }
    
    // 监听所有交互
    LaunchedEffect(interactionSource) {
        interactionSource.interactions.collect { interaction ->
            when (interaction) {
                is PressInteraction.Press -> Log.d("Interaction", "Pressed")
                is PressInteraction.Release -> Log.d("Interaction", "Released")
                is PressInteraction.Cancel -> Log.d("Interaction", "Press Cancelled")
                is FocusInteraction.Focus -> Log.d("Interaction", "Focused")
                is FocusInteraction.Unfocus -> Log.d("Interaction", "Unfocused")
                is HoverInteraction.Enter -> Log.d("Interaction", "Hover Enter")
                is HoverInteraction.Exit -> Log.d("Interaction", "Hover Exit")
            }
        }
    }
    
    Box(
        modifier = Modifier
            .size(100.dp)
            .background(Color.Blue)
            .clickable(interactionSource = interactionSource, indication = null) {}
            .focusable(interactionSource = interactionSource)
    )
}
```

## 5. **与 Modifier 的关系**

许多 Modifier 都接受 `InteractionSource` 参数，例如：

- `clickable`
- `focusable`
- `draggable`
- `pointerInput`

通过传递同一个 `InteractionSource` 实例给多个 Modifier，可以实现跨交互类型的状态共享。例如：

```kotlin
@Composable
fun CombinedInteractions() {
    val interactionSource = remember { MutableInteractionSource() }
    
    Box(
        modifier = Modifier
            .size(120.dp)
            .background(
                color = when {
                    interactionSource.collectIsPressedAsState().value -> Color.Red
                    interactionSource.collectIsFocusedAsState().value -> Color.Yellow
                    interactionSource.collectIsHoveredAsState().value -> Color.Green
                    else -> Color.Blue
                }
            )
            .clickable(interactionSource = interactionSource, indication = null) {}
            .focusable(interactionSource = interactionSource)
    )
}
```

## 6. **最佳实践**

1. **使用 remember 创建**：确保 `MutableInteractionSource` 在组合中保持唯一实例
2. **避免内存泄漏**：不要在组件外持有 `InteractionSource` 的引用
3. **自定义指示效果**：结合 `indication` 参数创建自定义视觉反馈
4. **状态去重**：如果需要在多个组件间共享交互状态，考虑使用单一 `InteractionSource`
5. **无障碍支持**：确保自定义交互效果符合无障碍标准

## 7. **在 TV 开发中的应用**

在 Android TV 开发中，`InteractionSource` 特别适用于：

- 焦点状态可视化（如黄色边框）
- 遥控器按键反馈
- 实现平滑的焦点过渡动画
- 自定义 TV 组件的交互行为

例如，在前面的 TV 焦点 demo 中，我们可以通过 `InteractionSource` 更精细地控制焦点状态：

```kotlin
@Composable
fun TvItemWithInteractionSource() {
    val interactionSource = remember { MutableInteractionSource() }
    val isFocused by interactionSource.collectIsFocusedAsState()
    
    Box(
        modifier = Modifier
            .size(200.dp)
            .background(if (isFocused) Color.Blue else Color.Gray)
            .scale(if (isFocused) 1.05f else 1.0f) // 焦点放大效果
            .tvClickable(interactionSource = interactionSource) { /* 点击事件 */ }
            .focusable(interactionSource = interactionSource)
    )
}
```

通过 `InteractionSource`，你可以实现更复杂、更精细的交互反馈效果，提升应用的用户体验。


# 了解手势 - Jetpack Compose 手势处理指南  

[原文地址](https://developer.android.google.cn/develop/ui/compose/touch-input/pointer-input/understand-gestures?hl=zh-cn)  

## 一、核心概念：手势系统基础  

### 1. 关键定义  

| 术语         | 描述                                                                 | 示例/对应API               |  
|--------------|----------------------------------------------------------------------|---------------------------|  
| **指针**     | 与应用交互的实体（如手指、触控笔、鼠标），通过`PointerType`枚举标识。 | `PointerType.Touch`/`Mouse` |  
| **指针事件** | 低级输入数据（如按下、移动、释放），封装于`PointerEvent`类中。        | `PointerEvent.type`（如`Down`）|  
| **手势**     | 高级交互行为（如点击、拖动），由一系列指针事件组合而成。              | `clickable`修饰符、自定义手势|  

### 2. 抽象级别分层  

Compose 提供三层手势处理抽象，按复杂度从低到高排列：  

1. **组件级**：内置手势支持（如`Button`自动处理点击，`LazyColumn`处理滚动）。  
2. **修饰符级**：预定义手势修饰符（如`clickable`、`draggable`），快速添加常见手势。  
3. **底层API**：`pointerInput`修饰符，自定义复杂手势（如长按、多点触控）。  

**选择原则**：优先使用高层抽象（组件级 > 修饰符级），仅在需要定制逻辑时使用底层API。  

## 二、组件级与修饰符级手势  

### 1. 组件级手势：开箱即用  

- **适用场景**：标准交互（如按钮点击、列表滚动、滑动删除）。  
- **优势**：自动包含语义信息、无障碍支持（如`Button`被TalkBack识别为按钮）、视觉反馈（如涟漪效果）。  
- **示例对比**：  

  ```kotlin
  // 组件级（Button）：自动添加语义和焦点支持  
  Button(onClick = {}) { Text("Click me!") }  
  // TalkBack反馈："Click me!, Button, double tap to activate"  

  // 修饰符级（Box+clickable）：需手动处理语义  
  Box(Modifier.clickable {}) { Text("Click me!") }  
  // TalkBack反馈："Click me!, double tap to activate"  
  ```

### 2. 预定义修饰符：快速添加手势  

| 修饰符          | 功能描述                                                                 | 典型场景                  |  
|-----------------|--------------------------------------------------------------------------|---------------------------|  
| `clickable`     | 处理单点触控点击、按下状态                                              | 通用点击区域              |  
| `draggable`     | 处理拖动手势（单轴或自由拖动）                                          | 可拖拽卡片、滑块手柄      |  
| `swipeable`     | 处理滑动手势（检测滑动方向和距离）                                      | 侧滑菜单、滑动删除        |  
| `transformable` | 处理多点触控变换（平移、缩放、旋转）                                    | 图片编辑器、手势缩放      |  
| `scrollable`    | 处理滚动手势（支持自定义滚动方向和边界）                                | 自定义滚动容器            |  

**特点**：除处理指针事件外，自动添加视觉反馈（如按下涟漪）、键盘支持和语义信息（如`Role.Button`）。  

## 三、自定义手势：`pointerInput` 修饰符  

### 1. 核心用法  

- **作用**：访问原始指针事件，实现复杂手势（如长按、组合键点击、三指手势）。  
- **关键组件**：  
  - `pointerInput`修饰符：接收键参数（如过滤条件），触发协程作用域。  
  - `awaitPointerEventScope`：协程作用域，用于等待指针事件。  
  - `awaitPointerEvent()`：挂起直到新事件发生，返回`PointerEvent`。  

**示例：监听原始指针事件**  

```kotlin
Box(Modifier.pointerInput(Unit) {  
    while (true) {  
        val event = awaitPointerEvent()  
        // 处理事件（如记录坐标、类型）  
    }  
})  
```

### 2. 手势检测器：简化自定义逻辑  

Compose 提供高层检测器，无需手动解析原始事件：  

| 检测器方法                | 功能描述                                                                 |  
|---------------------------|--------------------------------------------------------------------------|  
| `detectTapGestures`        | 检测点击、双击、长按时的事件                                            |  
| `detectDragGestures`       | 检测单轴或自由拖动手势                                                   |  
| `detectTransformGestures`  | 检测多点触控变换（平移、缩放、旋转）                                     |  
| `awaitFirstDown()`         | 等待指针按下事件                                                         |  
| `waitForUpOrCancellation`  | 等待指针释放或取消事件                                                   |  

**注意事项**：  

- 同一`pointerInput`中只能使用一个顶级检测器（如`detectTapGestures`和`detectDragGestures`不能共存）。  
- 需通过多个`pointerInput`实例添加多个手势监听器：  

  ```kotlin
  Box(  
      Modifier  
          .pointerInput(Unit) { detectTapGestures { /* 点击处理 */ } }  
          .pointerInput(Unit) { detectDragGestures { /* 拖动处理 */ } }  
  )  
  ```

### 3. 事件消耗与传播  

#### （1）事件消耗  

- **作用**：防止手势冲突（如子按钮点击时父列表项不响应）。  
- **方法**：调用`PointerInputChange.consume()`标记事件已处理，阻止父级响应。  

  ```kotlin
  awaitEachGesture {  
      val down = awaitFirstDown()  
      down.consume() // 消耗按下事件，父级不再处理  
      val up = waitForUpOrCancellation()  
      up?.consume() // 消耗释放事件  
  }  
  ```

#### （2）事件传播阶段  

1. **初始阶段（Initial Pass）**：事件从根节点流向子节点，父级可优先拦截事件（如父容器拦截长按时）。  
2. **主阶段（Main Pass）**：事件从子节点流向根节点，默认处理阶段（如子按钮优先响应点击）。  
3. **最终阶段（Final Pass）**：事件再次从根节点流向子节点，用于清理操作（如移除涟漪效果）。  

**示例：指定事件阶段**  

```kotlin
awaitPointerEvent(PointerEventPass.Initial) // 监听初始阶段事件  
```

## 四、事件调度与点击测试  

### 1. 点击测试（Hit Test）  

- **规则**：  
  - 指针按下时，系统从顶层到底层检测“命中”的可组合项（位于指针坐标内且支持输入）。  
  - 同级元素中，Z-index最高的元素优先接收事件（如重叠按钮中上层按钮优先响应）。  
- **自定义行为**：通过`PointerInputModifierNode`设置`sharePointerInputWithSiblings=true`，允许同级元素共享事件。  

### 2. 悬停事件处理  

- **规则**：悬停事件（如鼠标移动）直接发送到当前悬停的元素，无需点击测试，离开时立即停止发送。  

## 五、手势测试  

使用`composeTestRule`模拟手势操作：  

```kotlin
// 模拟滑动、点击手势  
composeTestRule.onNodeWithTag("MyList")  
    .performTouchInput {  
        swipeUp() // 向上滑动  
        swipeDown() // 向下滑动  
        click() // 点击  
    }  
```

## 六、流程图：手势处理全流程  

```mermaid
graph LR
    A[指针事件触发] --> B{抽象级别选择}
    B -->|组件级（如Button）| C[自动处理手势，包含语义/反馈]
    B -->|修饰符级（如clickable）| D[应用预定义修饰符，快速实现]
    B -->|底层API（pointerInput）| E[自定义手势逻辑]
    E --> F[使用检测器或原始事件处理]
    F --> G{需要多手势监听?}
    G -->|是| H[添加多个pointerInput实例]
    G -->|否| I[单检测器处理]
    C --> J[事件调度：按Z-index命中测试]
    D --> J
    E --> J
    J --> K[事件传播：初始阶段→主阶段→最终阶段]
    K --> L[事件消耗：consume()阻止冲突]
    L --> M[手势完成，触发回调]
```

## 七、最佳实践建议  

1. **优先使用高层抽象**：组件级和修饰符级已覆盖80%场景，避免过早使用底层API。  
2. **处理事件消耗**：在自定义手势中及时调用`consume()`，防止父级误响应。  
3. **无障碍考量**：组件级手势（如`Button`）自动支持TalkBack，自定义手势需手动添加语义（如`role = Role.Button`）。  
4. **测试覆盖**：使用`performTouchInput`模拟真实手势，确保交互逻辑正确。  

通过合理选择手势处理的抽象级别，结合事件消耗与传播机制，可在Compose中高效实现各类交互需求，同时保证性能和可访问性。

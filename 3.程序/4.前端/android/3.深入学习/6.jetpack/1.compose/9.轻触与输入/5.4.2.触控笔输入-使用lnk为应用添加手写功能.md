# 使用Lnk API 为应用添加手写功能

在 Android Jetpack Compose 中，通过 **Ink API** 实现触控笔功能需要结合其手势处理机制与墨迹渲染能力。以下是详细实现步骤与技术要点：

---

## 一、**环境配置与依赖**

1. **添加依赖**  
   引入 `androidx.graphics` 库（Ink API 所属的 Jetpack 组件），例如在 `build.gradle` 中添加：

   ```gradle
   dependencies {
       implementation "androidx.graphics:graphics:1.0.0-alphaXX" // 根据最新版本调整
   }
   ```

   需确保使用支持触控笔的 Android 设备或模拟器（Android 5.0+）。

2. **权限声明**  
   若需访问触控笔高级特性（如压力感应），在 `AndroidManifest.xml` 中添加：

   ```xml
   <uses-feature android:name="android.hardware.touchscreen" android:required="false" />
   <uses-feature android:name="android.hardware.faketouch" android:required="false" />
   ```

---

## 二、**触控笔事件处理**

Compose 通过 `Modifier.pointerInput` 捕获触控笔输入事件，并利用 **PointerInputEvent** 解析数据：

```kotlin
@Composable
fun InkCanvas() {
    val path = remember { Path() }
    Canvas(modifier = Modifier
        .fillMaxSize()
        .pointerInput(Unit) {
            awaitPointerEventScope {
                while (true) {
                    val event = awaitPointerEvent()
                    // 筛选触控笔事件（pointerType 为 "pen"）
                    event.changes.filter { it.type == PointerType.Stylus }.forEach { change ->
                        val position = change.position
                        when (change.pressed) {
                            true -> {
                                if (change.isFirst) path.moveTo(position.x, position.y)
                                else path.lineTo(position.x, position.y)
                            }
                            false -> path.reset()
                        }
                    }
                }
            }
        }
    ) {
        drawPath(path, color = Color.Black, style = Stroke(width = 4f))
    }
}
```

- **关键参数解析**：
  - `PointerType.Stylus`：过滤触控笔输入（区别于手指或鼠标）。
  - `position`：获取触控笔坐标。
  - `pressure`：压力值（0-1，需设备支持）。
  - `tiltX/Y`：倾斜角度（需设备支持）。

---

## 三、**集成 Ink API 高级功能**

Ink API 的核心优势在于 **低延迟渲染** 和 **笔画管理**。需结合其模块化设计优化上述基础实现：

### 1. **笔画管理与几何处理**

使用 `InkCanvas` 和 `Stroke` 类管理触控笔数据：

```kotlin
val inkCanvas = remember { InkCanvas() }
var currentStroke by remember { mutableStateOf<Stroke?>(null) }

Modifier.pointerInput(Unit) {
    detectTapGestures(
        onPress = { offset ->
            currentStroke = Stroke(
                brush = Brush.linearGradient(listOf(Color.Black, Color.Gray)),
                width = 4.dp.toPx()
            )
            inkCanvas.startStroke(currentStroke!!, offset)
        },
        onDrag = { change ->
            inkCanvas.addToStroke(currentStroke!!, change.position)
        },
        onRelease = {
            inkCanvas.endStroke(currentStroke!!)
        }
    )
}
```

- **功能说明**：
  - `startStroke`/`endStroke`：管理笔画生命周期。
  - `addToStroke`：实时追加触控点数据，支持动态渲染。

### 2. **低延迟优化**

通过 `AndroidComposeView` 的事件处理机制与 `PointerEventPass` 控制事件传递优先级，减少渲染延迟：

```kotlin
Modifier.pointerInput(Unit) {
    onPointerEvent(PointerEventPass.Initial) { event ->
        // 在 Initial 阶段预消费事件，避免子组件干扰
        if (event.type == PointerType.Stylus) event.consume()
    }
}
```

### 3. **笔刷与擦除功能**

通过 `Brush` 类定义触控笔样式，支持动态切换：

```kotlin
val penBrush = Brush.linearGradient(listOf(Color.Blue, Color.Cyan))
val eraserBrush = Brush.solid(Color.Transparent, blendMode = BlendMode.Clear)

var currentBrush by remember { mutableStateOf(penBrush) }

// 切换笔刷
Button(onClick = { currentBrush = eraserBrush }) {
    Text("切换橡皮擦")
}
```

---

## 四、**性能优化与兼容性**

1. **硬件加速**  
   启用 `Canvas` 的硬件加速层：

   ```kotlin
   Canvas(modifier = Modifier.graphicsLayer { compositingStrategy = CompositingStrategy.Offscreen })
   ```

2. **事件冲突处理**  
   通过 `PointerEventPass` 控制事件传递路径，避免多个手势监听器冲突：

   ```kotlin
   onPointerEvent(PointerEventPass.Main) { event ->
       if (event.isStylusEvent()) event.consume() // 主阶段消费事件
   }
   ```

3. **多设备适配**  
   检测触控笔支持状态，动态调整功能：

   ```kotlin
   val hasStylus = LocalContext.current.packageManager
       .hasSystemFeature(PackageManager.FEATURE_INPUT_STYLUS)
   ```

---

## 五、**实际案例：手写笔记应用**

1. **笔画历史记录**  
   使用 `Undo/Redo` 栈管理笔画数据：

   ```kotlin
   val undoStack = remember { mutableStateListOf<Stroke>() }
   val redoStack = remember { mutableStateListOf<Stroke>() }

   fun undo() {
       undoStack.removeLast().let { redoStack.add(it) }
   }
   ```

2. **压力敏感度映射**  
   根据 `pressure` 动态调整线条粗细：

   ```kotlin
   val strokeWidth = with(LocalDensity.current) {
       (4.dp.toPx() * change.pressure).coerceIn(2f, 8f)
   }
   ```

---

## 总结

在 Compose 中集成触控笔功能需结合 **Ink API** 的模块化设计与 Compose 手势系统：

1. 通过 `pointerInput` 捕获触控笔事件，解析坐标、压力等参数。
2. 利用 `InkCanvas` 和 `Stroke` 管理笔画数据，实现低延迟渲染。
3. 通过 `PointerEventPass` 优化事件传递逻辑，避免性能瓶颈。
4. 结合硬件加速与动态笔刷切换，提升用户体验。

完整实现可参考 [Jetpack Compose 官方手势文档](https://developer.android.com/jetpack/compose/gestures) 和 [Ink API 示例代码](https://github.com/android/graphics-samples)。

# 全局焦点选中框

在 Jetpack Compose 中实现全局焦点选中框效果，可以通过自定义 Modifier + 主题扩展的方式封装。以下是一个完整的解决方案，实现组件获得焦点时显示统一风格的选中框：

## 1. 创建全局焦点边框 Modifier

```kotlin
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.focusable
import androidx.compose.foundation.interaction.MutableInteractionSource
import androidx.compose.foundation.interaction.collectIsFocusedAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.composed
import androidx.compose.ui.draw.drawWithCache
import androidx.compose.ui.graphics.BlendMode
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Shape
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp

fun Modifier.focusBorder(
    focusedBorderWidth: Dp = 2.dp,
    unfocusedBorderWidth: Dp = 0.dp,
    focusedBorderColor: Color = Color.Blue,
    unfocusedBorderColor: Color = Color.Transparent,
    shape: Shape? = null,
    useAnimatedBorder: Boolean = true
): Modifier = composed {
    val interactionSource = remember { MutableInteractionSource() }
    val isFocused by interactionSource.collectIsFocusedAsState()
    
    val borderWidth = if (isFocused) focusedBorderWidth else unfocusedBorderWidth
    val borderColor = if (isFocused) focusedBorderColor else unfocusedBorderColor
    
    this
        .focusable(interactionSource = interactionSource)
        .then(
            if (useAnimatedBorder && isFocused) {
                Modifier.drawWithCache {
                    val stroke = Stroke(width = borderWidth.toPx())
                    onDrawBehind {
                        if (shape != null) {
                            drawPath(
                                path = shape.createOutline(size, layoutDirection, this).path,
                                color = borderColor,
                                style = stroke
                            )
                        } else {
                            drawRect(
                                brush = Brush.linearGradient(
                                    colors = listOf(
                                        borderColor.copy(alpha = 0.7f),
                                        borderColor,
                                        borderColor.copy(alpha = 0.7f)
                                    )
                                ),
                                style = stroke,
                                blendMode = BlendMode.SrcOver
                            )
                        }
                    }
                }
            } else {
                Modifier.border(borderWidth, borderColor, shape ?: androidx.compose.foundation.shape.RoundedCornerShape(4.dp))
            }
        )
}
```

## 2. 创建主题扩展 (统一全局样式)

```kotlin
// 定义焦点样式数据类
data class FocusBorderTheme(
    val borderWidth: Dp = 2.dp,
    val borderColor: Color = Color(0xFF4285F4),
    val shape: Shape = androidx.compose.foundation.shape.RoundedCornerShape(6.dp),
    val useAnimated: Boolean = true
)

// 创建主题扩展
val LocalFocusBorderTheme = staticCompositionLocalOf { FocusBorderTheme() }

@Composable
fun ProvidesFocusBorderTheme(
    theme: FocusBorderTheme = FocusBorderTheme(),
    content: @Composable () -> Unit
) {
    CompositionLocalProvider(LocalFocusBorderTheme provides theme) {
        content()
    }
}

// 全局焦点样式 Modifier
fun Modifier.defaultFocusBorder(): Modifier = composed {
    val theme = LocalFocusBorderTheme.current
    this.focusBorder(
        focusedBorderWidth = theme.borderWidth,
        focusedBorderColor = theme.borderColor,
        shape = theme.shape,
        useAnimatedBorder = theme.useAnimated
    )
}
```

## 3. 在应用入口设置全局主题

```kotlin
@Composable
fun MyApp() {
    ProvidesFocusBorderTheme(
        theme = FocusBorderTheme(
            borderColor = Color(0xFF00C853), // 自定义颜色
            borderWidth = 3.dp,
            shape = CutCornerShape(8.dp),
            useAnimated = true
        )
    ) {
        MaterialTheme {
            // 应用内容
            MainScreen()
        }
    }
}
```

## 4. 在组件中使用

```kotlin
@Composable
fun FocusableButton(text: String, onClick: () -> Unit) {
    Button(
        onClick = onClick,
        modifier = Modifier
            .defaultFocusBorder() // 使用全局样式
            .padding(8.dp)
    ) {
        Text(text)
    }
}

@Composable
fun FocusableTextField() {
    var text by remember { mutableStateOf("") }
    TextField(
        value = text,
        onValueChange = { text = it },
        modifier = Modifier
            .fillMaxWidth()
            .defaultFocusBorder() // 使用全局样式
            .padding(16.dp)
    )
}
```

## 5. 高级用法 - 自定义焦点效果

```kotlin
// 创建脉动动画焦点效果
fun Modifier.animatedPulseFocusBorder(): Modifier = composed {
    val interactionSource = remember { MutableInteractionSource() }
    val isFocused by interactionSource.collectIsFocusedAsState()
    val animatedAlpha by animateFloatAsState(
        targetValue = if (isFocused) 1f else 0f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = LinearEasing),
            repeatMode = RepeatMode.Reverse
        )
    )
    
    this.focusBorder(
        focusedBorderColor = Color.Red.copy(alpha = animatedAlpha),
        focusedBorderWidth = 4.dp,
        useAnimatedBorder = false
    )
}

// 在特定组件使用自定义效果
Button(
    modifier = Modifier.animatedPulseFocusBorder(),
    onClick = { /* ... */ }
) { /* ... */ }
```

## 实现原理说明

1. **焦点状态监听**：
   - 使用 `MutableInteractionSource` 跟踪组件焦点状态
   - `collectIsFocusedAsState` 将焦点状态转换为 Compose 状态

2. **动态边框渲染**：
   - 焦点状态变化时自动切换边框样式
   - 支持静态边框和动态绘制两种模式

3. **主题化设计**：
   - 通过 CompositionLocal 实现全局样式配置
   - 支持应用级统一覆盖和组件级自定义

4. **性能优化**：
   - 使用 `drawWithCache` 高效绘制动画边框
   - 仅在获得焦点时应用绘制逻辑

## 使用场景建议

| 场景 | 推荐方案 | 优势 |
|------|----------|------|
| 表单应用 | `defaultFocusBorder()` | 统一视觉风格 |
| 电视/遥控器应用 | `animatedPulseFocusBorder()` | 高可见性 |
| 需要特殊形状 | 自定义 shape 参数 | 灵活适配设计 |
| 性能敏感界面 | 设置 `useAnimated = false` | 减少绘制开销 |

此方案实现了全局统一的焦点视觉反馈，同时保留了组件级别的自定义能力，符合 Compose 的声明式设计理念，可无缝集成到现有 Compose 项目中。

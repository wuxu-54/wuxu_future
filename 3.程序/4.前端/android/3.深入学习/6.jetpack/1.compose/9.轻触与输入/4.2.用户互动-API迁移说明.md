
# 迁移到 Indication API 和 Ripple API

原地址：<https://developer.android.google.cn/develop/ui/compose/touch-input/user-interactions/migrate-indication-ripple?hl=zh-cn>

## 一、核心背景与行为变更

### 1. 变更原因

- 为提升 `Modifier.clickable` 等组件的合成性能，Android Jetpack Compose 引入新 API：
  - **`IndicationNodeFactory`**：替代旧版 `Indication#rememberUpdatedInstance`，优化渲染逻辑。
  - **`ripple()`**：替代 `rememberRipple()`，整合于 Material 库中，支持更高效的涟漪效果。
- **影响范围**：
  - Material 库版本：`material:1.7.0+`、`material3:1.3.0+`、`compose-material:1.4.0+`。
  - 不再查询 `LocalRippleTheme`，需通过新 API 配置涟漪样式。

### 2. 废弃与替换关系

| 废弃 API                | 替换方案                          | 适用场景                 |
|-------------------------|-----------------------------------|--------------------------|
| `Indication#rememberUpdatedInstance` | `IndicationNodeFactory`          | 自定义交互动画           |
| `rememberRipple()`      | `ripple()`（Material 库）         | 涟漪效果实现             |
| `RippleTheme`           | `RippleConfiguration`/主题级实现  | 全局或局部涟漪样式配置   |

## 二、迁移步骤与代码示例

### 1. 无需迁移的临时方案（旧行为回退）

#### 场景

- 需升级 Material 库版本，但暂未准备好迁移至新 API。

#### 实现

```kotlin
// 在 MaterialTheme 外层包裹 CompositionLocalProvider
CompositionLocalProvider(
    LocalUseFallbackRippleImplementation provides true // 启用旧版涟漪逻辑
) {
    MaterialTheme {
        App() // 应用组件
    }
}
```

#### 注意

- **临时性质**：此 API 将在未来版本移除，仅用于过渡。
- **性能影响**：回退至旧实现会导致性能下降，建议尽快完成迁移。

### 2. 从 `rememberRipple` 迁移至 `ripple()`

#### （1）使用 Material 库

##### 旧代码（废弃）

```kotlin
Box(
    Modifier.clickable(
        onClick = {},
        interactionSource = remember { MutableInteractionSource() },
        indication = rememberRipple() // 使用旧版涟漪
    )
)
```

##### 新代码（推荐）

```kotlin
Box(
    Modifier.clickable(
        onClick = {},
        interactionSource = remember { MutableInteractionSource() },
        indication = ripple() // 直接使用 Material 库的 ripple()
    )
)
```

##### 优势

- 无需 `remember` 修饰，可重复使用，减少内存分配。
- 自动继承 Material 主题的颜色和样式。

#### （2）自定义设计体系

##### 旧方式（基于 `RippleTheme`）

```kotlin
// 自定义 RippleTheme
private object CustomRippleTheme : RippleTheme {
    @Composable override fun defaultColor() = Color.Blue
    @Composable override fun rippleAlpha() = RippleAlpha(0.5f, 0.5f, 0f, 0f)
}

// 使用
CompositionLocalProvider(LocalRippleTheme provides CustomRippleTheme) {
    Button { /* ... */ }
}
```

##### 新方式（基于 `RippleConfiguration`）

```kotlin
// 自定义涟漪配置
@OptIn(ExperimentalMaterialApi::class)
private val CustomRippleConfig = RippleConfiguration(
    color = Color.Blue,
    rippleAlpha = RippleAlpha(0.5f, 0.5f, 0f, 0f) // 自定义透明度
)

// 使用
CompositionLocalProvider(LocalRippleConfiguration provides CustomRippleConfig) {
    Button { /* ... */ }
}
```

### 3. 从 `RippleTheme` 迁移的高级场景

#### （1）停用特定组件的涟漪

##### 旧代码

```kotlin
// 通过 RippleTheme 设为透明
CompositionLocalProvider(LocalRippleTheme provides DisabledRippleTheme) {
    Button { /* 无涟漪 */ }
}

private object DisabledRippleTheme : RippleTheme {
    @Composable override fun defaultColor() = Color透明
    @Composable override fun rippleAlpha() = RippleAlpha(0f, 0f, 0f, 0f)
}
```

##### 新代码

```kotlin
// 传递 null 禁用涟漪
CompositionLocalProvider(LocalRippleConfiguration provides null) {
    Button { /* 无涟漪 */ }
}
```

#### （2）全局更改应用涟漪样式

##### 旧方式

```kotlin
// 全局设置 RippleTheme
MaterialTheme {
    CompositionLocalProvider(LocalRippleTheme provides AppRippleTheme) {
        App()
    }
}
```

##### 新方式（基于主题扩展）

```kotlin
// 在 MaterialTheme 中自定义涟漪逻辑
@Composable
fun AppTheme(content: @Composable () -> Unit) {
    MaterialTheme(
        // 自定义涟漪通过 Ripple API 实现
        ripple = { interactionSource, enabled ->
            ripple(
                color = MaterialTheme.colorScheme.primary,
                enabled = enabled,
                interactionSource = interactionSource
            )
        },
        content = content
    )
}
```

### 4. 从 `Indication` 迁移至 `IndicationNodeFactory`

#### 核心概念

- **`IndicationNodeFactory`**：继承自 `Indication`，用于创建 `DelegatableNode`，替代旧版 `IndicationInstance` 的渲染逻辑。
- **优势**：将交互逻辑与渲染节点解耦，提升性能。

#### 迁移步骤

##### （1）修改 `IndicationInstance` 为 `DrawModifierNode`

###### 旧代码（`IndicationInstance`）

```kotlin
private class ScaleIndicationInstance : IndicationInstance {
    // 交互动画逻辑
    override fun ContentDrawScope.drawIndication() { /* 绘制缩放效果 */ }
}
```

###### 新代码（`DrawModifierNode`）

```kotlin
private class ScaleIndicationNode(interactionSource: InteractionSource) :
    Modifier.Node(), DrawModifierNode {
    
    private val animatedScale = Animatable(1f)
    
    init {
        // 直接在节点内处理交互事件
        interactionSource.interactions.collectLatest { interaction ->
            when (interaction) {
                is PressInteraction.Press -> animatedScale.animateTo(0.9f)
                else -> animatedScale.animateTo(1f)
            }
        }
    }
    
    override fun ContentDrawScope.draw() {
        scale(animatedScale.value) { drawContent() } // 绘制缩放效果
    }
}
```

##### （2）创建 `IndicationNodeFactory` 工厂类

```kotlin
object ScaleIndicationFactory : IndicationNodeFactory {
    override fun create(interactionSource: InteractionSource): DelegatableNode {
        return ScaleIndicationNode(interactionSource) // 创建节点实例
    }
}

// 使用工厂类
Modifier.clickable(
    interactionSource = remember { MutableInteractionSource() },
    indication = ScaleIndicationFactory // 直接传递工厂实例
)
```

## 三、流程图：迁移路径决策

```mermaid
graph LR
A[开始迁移] --> B{是否使用 Material 库?}
B -->|是| C[直接替换 rememberRipple 为 ripple()]
B -->|否| D[自定义 IndicationNodeFactory 或 RippleConfiguration]
E[是否需要全局涟漪配置?] --> F{是} --> G[扩展 MaterialTheme.ripple 参数]
E -->|否| H[局部使用 LocalRippleConfiguration]
I[是否处理自定义交互动画?] --> J{是} --> K[迁移 Indication 至 IndicationNodeFactory]
I -->|否| L[完成迁移]
```

## 四、最佳实践与注意事项

1. **优先使用 Material 库 API**：`ripple()` 已整合主题逻辑，避免重复造轮子。
2. **避免临时回退方案**：`LocalUseFallbackRippleImplementation` 仅用于过渡，长期使用会导致性能问题。
3. **自定义设计体系**：通过 `createRippleModifierNode()` 函数构建主题感知的涟漪效果，确保与设计系统一致。
4. **性能优化**：`IndicationNodeFactory` 通过直接操作渲染节点，减少 `remember` 调用，提升列表等动态场景的性能。

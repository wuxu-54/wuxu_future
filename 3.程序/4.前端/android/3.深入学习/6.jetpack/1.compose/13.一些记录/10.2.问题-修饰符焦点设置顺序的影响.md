# 焦点设置顺序导致组件形变

问题：当组件获取焦点后圆形变成方形
>也就是记住一点：修饰符要严格顺序，避免影响ui效果

## 答

问题分析：  
在 Compose 中，当组件获取焦点后圆形变成方形，通常是由于 **边框绘制顺序** 和 **裁剪区域** 的冲突导致的。原因在于：

1. `border` 修饰符在 `clip` 之前应用，导致边框被裁剪
2. 焦点状态变化时边框重绘，但裁剪区域未正确应用
3. 边框宽度过大，导致矩形边框覆盖了圆形形状

### 解决方案（修复后代码）

```kotlin
Modifier
    .width(60.dp)
    .height(60.dp)
    .clip(CircleShape)  // 先裁剪形状
    .border(5.dp, focusedColor, CircleShape)  // 使用相同形状的边框
    .onFocusChanged {
        focusedColor = if (it.isFocused) Color.Red else Color.White
    }
    .focusRequester(focusRequester)
```

### 关键修改说明

1. **调整修饰符顺序**：

   ```kotlin
   // 错误顺序：边框在裁剪之前
   .border(...).clip(...)
   
   // 正确顺序：先裁剪再添加相同形状的边框
   .clip(CircleShape)
   .border(5.dp, focusedColor, CircleShape)  // 关键：边框使用相同形状
   ```

2. **为边框指定相同形状**：

   ```kotlin
   // 修改前（矩形边框）：
   .border(5.dp, focusedColor)
   
   // 修改后（圆形边框）：
   .border(5.dp, focusedColor, CircleShape)
   ```

3. **使用.dp扩展简化**：

   ```kotlin
   // 更简洁的写法
   .width(60.dp)  // 替代 60.toDp()
   .height(60.dp)
   ```

### 完整可运行示例

```kotlin
@Composable
fun FocusableCircleButton() {
    val focusRequester = remember { FocusRequester() }
    var focusedColor by remember { mutableStateOf(Color.White) }
    
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color.LightGray)
            .padding(32.dp),
        contentAlignment = Center
    ) {
        Box(
            modifier = Modifier
                .size(60.dp)
                .clip(CircleShape)
                .background(Color.Gray)  // 背景色
                .border(5.dp, focusedColor, CircleShape)  // 圆形边框
                .onFocusChanged {
                    focusedColor = if (it.isFocused) Color.Red else Color.White
                }
                .focusRequester(focusRequester)
                .focusable()  // 确保可获取焦点
                .clickable { focusRequester.requestFocus() }
        )
    }

    // 自动获取焦点（可选）
    LaunchedEffect(Unit) {
        focusRequester.requestFocus()
    }
}
```

### 替代方案：使用自定义绘制（更灵活）

```kotlin
@Composable
fun FocusableCircleWithCustomBorder() {
    val focusRequester = remember { FocusRequester() }
    var focusedColor by remember { mutableStateOf(Color.White) }
    
    Canvas(
        modifier = Modifier
            .size(60.dp)
            .onFocusChanged {
                focusedColor = if (it.isFocused) Color.Red else Color.White
            }
            .focusRequester(focusRequester)
            .focusable()
            .clickable { focusRequester.requestFocus() }
    ) {
        // 绘制圆形背景
        drawCircle(Color.Gray, radius = size.minDimension / 2)
        
        // 绘制圆形边框（焦点状态变化时更新）
        drawCircle(
            color = focusedColor,
            radius = size.minDimension / 2 - 2.dp.toPx(),
            style = Stroke(width = 4.dp.toPx())
        )
    }
}
```

### 常见问题及解决方案

| 问题现象 | 原因 | 解决方案 |
|---------|------|---------|
| 焦点时变成方形 | 矩形边框覆盖圆形 | 使用 `border(width, color, shape)` 指定形状 |
| 边框显示不完整 | 边框在裁剪前绘制 | 调整修饰符顺序：先 `clip` 后 `border` |
| 焦点变化无效果 | 缺少 `.focusable()` | 添加 `.focusable()` 修饰符 |
| 边框模糊 | 尺寸非整数像素 | 使用 `dp` 单位，避免 `toDp()` 转换 |

### 最佳实践建议

1. **形状一致性**：当使用 `clip()` 时，对应的 `border()` 应使用相同的形状参数
2. **状态管理**：焦点状态变化时，避免改变组件尺寸（只改变颜色/边框）
3. **调试工具**：使用布局检查器查看修饰符应用顺序：

   ```kotlin
   .debugInspectorInfo { 
       name = "FocusableCircle" 
   }
   ```

4. **焦点反馈**：添加动画效果使焦点变化更平滑：

   ```kotlin
   .border(
       width = animateDpAsState(if (isFocused) 5.dp else 0.dp).value,
       color = animateColorAsState(focusedColor).value,
       shape = CircleShape
   )
   ```

通过以上修改，可以确保组件在获取焦点时保持圆形形状，同时显示红色的选中边框，实现预期的焦点视觉效果。

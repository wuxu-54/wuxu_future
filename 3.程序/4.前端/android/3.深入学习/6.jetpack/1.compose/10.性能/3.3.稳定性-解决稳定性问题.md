
# 解决稳定性问题

原地址：<https://developer.android.google.cn/develop/ui/compose/performance/stability/fix?hl=zh-cn>

## 流程图

```mermaid
graph LR
A[诊断稳定性问题] --> B{是否需修复?}
B -->|是| C[尝试启用强劲跳过模式]
C --> D{是否解决?}
D -->|是| E[完成]
D -->|否| F[使类完全不可变]
F --> G{是否解决?}
G -->|是| E
G -->|否| H[使用不可变集合替代普通集合]
H --> I{是否解决?}
I -->|是| E
I -->|否| J[使用@Stable或@Immutable注解类]
J --> K{是否解决?}
K -->|是| E
K -->|否| L[处理集合中类的不稳定性]
L --> M[使用稳定性配置文件/不可变集合/自定义包装类]
M --> N{是否解决?}
N -->|是| E
N -->|否| O[处理多模块架构问题]
O --> P[配置文件/启用编译器/封装类]
P --> Q{是否解决?}
Q -->|是| E
Q -->|否| R[检查是否过度优化可组合项跳过]
```

## 详细知识点总结

### 一、启用强劲跳过

- **作用**：允许跳过参数不稳定的可组合项，是修复稳定性问题的最简单方法。
- **实现**：通过强制跳过模式（需参考官方文档“强制跳过”章节）。
- **适用场景**：初步排查稳定性问题时优先尝试。

### 二、将类设为不可变

- **核心原则**：确保类的所有属性为`val`（不可变），且属性类型本身不可变。
  - 基元类型（如`String`、`Int`）天然不可变。
  - 可变属性需使用Compose状态（如`mutableStateOf`）。
- **定义**：
  - **不可变**：实例创建后属性值永不更改，方法无副作用。
  - **稳定**：允许可变，但需通过Compose状态管理可观察性。

### 三、不可变集合

- **问题**：Compose编译器无法确定普通集合（`List`/`Map`/`Set`）是否不可变，默认标记为不稳定。
- **解决方案**：使用`kotlinx不可变集合`（如`ImmutableSet`/`ImmutableList`），编译器会识别其不可变性。
  - **示例**：

    ```kotlin
    // 不稳定集合
    val tags: Set<String> 

    // 改为不可变集合
    val tags: ImmutableSet<String> = persistentSetOf()
    ```

### 四、使用@Stable或@Immutable注解

- **作用**：向编译器声明类的稳定性（但不改变类的实际可变性）。
- **风险**：错误注解可能导致重组异常（类似Kotlin的`!!`运算符，需谨慎使用）。
- **示例**：

  ```kotlin
  @Immutable
  data class Snack(...) // 标记为不可变
  ```

### 五、集合中带注解的类处理

- **问题**：即使类被注解为稳定，`List<StableClass>`仍会被编译器标记为不稳定。
- **解决方案**：
  1. **稳定性配置文件**：将`kotlin.collections.*`加入配置文件，强制编译器视为稳定（需谨慎，可能破坏协定）。
  2. **不可变集合**：使用`ImmutableList<Snack>`替代普通`List`。
  3. **自定义包装类**：

     ```kotlin
     @Immutable
     data class SnackCollection(val snacks: List<Snack>) // 封装列表到稳定类中
     ```

### 六、稳定性配置文件

- **作用**：在编译时指定哪些类视为稳定（如第三方库类`LocalDateTime`）。
- **格式**：纯文本文件，支持类名、单通配符（`*`）、双通配符（`**`）和注释。

  ```conf
  # 示例配置
  java.time.LocalDateTime        # 单个类
  com.datalayer.*                # 包下所有类
  com.datalayer.**               # 包及子模块所有类
  com.exampleGenericClass<*,_>   # 泛型类型（仅第一个参数）
  ```

- **Gradle配置**：

  ```kotlin
  composeCompiler {
      stabilityConfigurationFile = rootProject.layout.projectDirectory.file("stability_config.conf")
  }
  ```

### 七、多模块架构问题

- **原因**：当数据层模块未使用Compose编译器时，界面层引用的数据类可能被视为不稳定。
- **解决方案**：
  1. 将数据类添加到稳定性配置文件。
  2. 在数据层模块启用Compose编译器（仅需依赖Compose运行时，非UI模块）。
  3. 在界面层封装数据类为专用稳定类。

### 八、注意事项：并非所有可组合项都需可跳过

- **避免场景**：
  1. 重组频率低或不重组的组件。
  2. 仅调用可跳过组件的父组件（无额外收益）。
  3. 参数多且`equals`开销大的组件（检查参数变更成本可能高于重组成本）。
- **建议**：避免过早优化，优先保证逻辑正确性，仅对性能瓶颈组件优化跳过能力。

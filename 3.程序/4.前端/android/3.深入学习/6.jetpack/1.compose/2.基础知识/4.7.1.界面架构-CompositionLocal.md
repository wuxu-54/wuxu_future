# CompositionLocal

在 Jetpack Compose 中，**`CompositionLocal`** 是一种用于在组件树中隐式传递数据的机制，允许跨层级共享数据，而无需显式通过组件参数逐层传递。它特别适用于全局或跨组件共享的上下文信息（如主题、配置、导航等）。以下是 `CompositionLocal` 的详细解析：

---

## 一、核心概念

### 1. **作用**

- **隐式数据传递**：允许深层嵌套的组件直接访问上层定义的数据，无需中间组件显式传递。
- **减少参数污染**：避免在中间组件中声明无关参数，简化代码结构。
- **动态上下文管理**：支持在组件树的不同层级覆盖数据，实现灵活的上下文配置。

### 2. **与显式参数传递的对比**

| 方式 | 显式参数传递 | CompositionLocal |
|------|--------------|-------------------|
| **场景** | 数据仅在少数直接子组件使用 | 数据被多个深层组件共享 |
| **代码冗余** | 中间组件需声明参数 | 中间组件无需参与传递 |
| **维护性** | 依赖关系明确 | 隐式依赖需谨慎管理 |

---

## 二、创建与使用

### 1. **定义 CompositionLocal**

使用 `compositionLocalOf` 或 `staticCompositionLocalOf` 创建：

```kotlin
// 定义主题相关的 CompositionLocal
val LocalTheme = compositionLocalOf { Theme.Light }

// 定义静态 CompositionLocal（高性能，需手动管理重组）
val LocalStaticConfig = staticCompositionLocalOf { Config.Default }
```

- **`compositionLocalOf`**：当提供的值变化时，依赖它的组件会自动重组。
- **`staticCompositionLocalOf`**：更高效，但需手动处理重组（适用于极少变化的值）。

### 2. **提供值（Providing Values）**

在组件树的上层通过 `CompositionLocalProvider` 提供值：

```kotlin
@Composable
fun App() {
    CompositionLocalProvider(
        LocalTheme provides Theme.Dark, // 提供主题
        LocalStaticConfig provides Config.Production
    ) {
        MainScreen()
    }
}
```

### 3. **消费值（Consuming Values）**

在子组件中通过 `current` 属性获取值：

```kotlin
@Composable
fun ThemedButton() {
    val theme = LocalTheme.current // 获取当前主题
    Button(
        colors = ButtonDefaults.buttonColors(backgroundColor = theme.primary),
        onClick = { /* ... */ }
    ) {
        Text("Submit", color = theme.onPrimary)
    }
}
```

---

## 三、使用场景

### 1. **主题管理**

```kotlin
// 定义主题数据类
data class AppTheme(
    val primary: Color,
    val onPrimary: Color,
    val typography: Typography
)

// 创建 CompositionLocal
val LocalAppTheme = compositionLocalOf { 
    AppTheme(
        primary = Color.Blue,
        onPrimary = Color.White,
        typography = Typography.Default
    )
}

// 在根布局提供主题
@Composable
fun App() {
    val darkTheme = remember { isSystemInDarkTheme() }
    val theme = if (darkTheme) DarkTheme else LightTheme
    CompositionLocalProvider(LocalAppTheme provides theme) {
        Content()
    }
}

// 在子组件中使用
@Composable
fun Content() {
    val theme = LocalAppTheme.current
    Text("Hello", style = theme.typography.h1)
}
```

### 2. **导航控制器传递**

```kotlin
val LocalNavController = compositionLocalOf<NavHostController> { 
    error("NavController not provided!") 
}

@Composable
fun App() {
    val navController = rememberNavController()
    CompositionLocalProvider(LocalNavController provides navController) {
        NavHost(navController, startDestination = "home") {
            composable("home") { HomeScreen() }
            composable("detail") { DetailScreen() }
        }
    }
}

@Composable
fun HomeScreen() {
    val navController = LocalNavController.current
    Button(onClick = { navController.navigate("detail") }) {
        Text("Go to Detail")
    }
}
```

---

## 四、高级用法

### 1. **动态覆盖值**

在组件树的不同层级覆盖 `CompositionLocal` 的值：

```kotlin
@Composable
fun Parent() {
    CompositionLocalProvider(LocalTheme provides Theme.Dark) {
        Child() // 使用 Dark 主题
    }
}

@Composable
fun Child() {
    CompositionLocalProvider(LocalTheme provides Theme.Light) {
        Grandchild() // 覆盖为 Light 主题
    }
}
```

### 2. **与 `remember` 结合管理状态**

```kotlin
val LocalUserSession = compositionLocalOf<UserSession?> { null }

@Composable
fun AuthWrapper() {
    val userSession = remember { loadUserSession() }
    CompositionLocalProvider(LocalUserSession provides userSession) {
        if (userSession != null) MainApp() else LoginScreen()
    }
}

@Composable
fun ProfileScreen() {
    val userSession = LocalUserSession.current ?: return
    Text("Welcome ${userSession.username}")
}
```

---

## 五、`compositionLocalOf` vs `staticCompositionLocalOf`

| 特性 | `compositionLocalOf` | `staticCompositionLocalOf` |
|------|----------------------|----------------------------|
| **重组行为** | 值变化时自动触发依赖组件重组 | 不自动触发重组，需手动管理 |
| **性能** | 适用于频繁变化的值 | 更高效，适用于静态或极少变化的值 |
| **使用场景** | 主题、动态配置 | 环境标志、全局常量 |

---

## 六、最佳实践

1. **避免过度使用**  
   - 仅在数据需要跨多层级传递时使用，避免滥用导致隐式依赖混乱。

2. **明确默认值**  
   - 为 `compositionLocalOf` 提供合理的默认值，或在文档中说明必须显式提供值。

3. **命名规范**  
   - 使用 `Local` 前缀命名（如 `LocalTheme`），提高代码可读性。

4. **结合 ViewModel**  
   - 对于需要业务逻辑的数据，优先通过 `ViewModel` 管理，而非直接依赖 `CompositionLocal`。

---

## 七、常见问题

### **问题 1：未提供值导致崩溃**

```kotlin
// 错误：未提供 LocalTheme 的值
CompositionLocalProvider(/* 未设置 LocalTheme */) {
    ThemedButton() // 使用默认值，若未设置会崩溃
}

// 解决：确保提供默认值或强制上层提供
val LocalTheme = compositionLocalOf { 
    error("Theme must be provided") // 强制要求上层提供
}
```

### **问题 2：错误的值覆盖**

```kotlin
// 错误：意外覆盖父级的值
CompositionLocalProvider(LocalTheme provides Theme.Light) {
    // 此处会覆盖外层的 Theme.Dark
    ChildComponent()
}

// 解决：明确层级覆盖意图，添加注释说明
```

---

## 总结

`CompositionLocal` 是 Jetpack Compose 中管理隐式上下文的强大工具，适用于主题、导航、全局配置等场景。其核心价值在于减少组件参数传递的冗余，但需谨慎使用以避免隐式依赖导致的维护性问题。关键要点：

- **适用场景**：跨层级共享数据，中间组件不关心该数据时。
- **性能优化**：根据数据变化频率选择 `compositionLocalOf` 或 `staticCompositionLocalOf`。
- **最佳实践**：明确默认值、合理命名、避免滥用。

# Composable函数

## 注意

Compose 运行在主线程上，但其设计之初就考虑到了多线程处理，无法保证将来会继续使用单线程模型。因此，您应始终编写可组合项，就像它们可以在多个线程上运行一样。

```kotlin
@Composable
fun ButtonRow() {
    MyFancyNavigation {
        StartScreen()
        MiddleScreen()
        EndScreen()
    }
}
```

如果您看一下可组合函数的代码，可能会认为这些代码按其出现的顺序运行。但不能保证一定如此。如果某个可组合函数包含对其他可组合函数的调用，这些函数可以按任何顺序运行。Compose 可以选择识别出某些界面元素的优先级高于其他界面元素，因而首先绘制这些元素。

---

以下是关于 **Composable 函数** 的基础概念、核心特性和使用规范的详细解析，帮助您掌握 Jetpack Compose 中 UI 组件的构建方式：

## **1. 什么是 Composable 函数？**

- **定义**：用 `@Composable` 注解标记的 Kotlin 函数，用于声明 UI 组件的结构和行为。
- **核心理念**：通过函数式编程描述界面，**状态变化驱动 UI 更新**（声明式编程）。

---

## **2. 基础语法与结构**

### **基本模板**

```kotlin
@Composable
fun ComponentName(parameter: Type) { // 可接收参数
    // 调用其他 Composable 函数构建 UI
    Text(text = "Hello, $parameter!")
}
```

### **关键特点**

- **无显式返回值**：通过调用其他 Composable 函数（如 `Button`, `Column`）生成 UI，而非返回 View 对象。
- **命名规范**：采用 Pascal 命名法（首字母大写），区别于普通函数。
- **参数设计**：
  - 通过参数传递数据（如文本、状态）。
  - 推荐使用**不可变数据**（避免副作用）。

---

## **3. Composable 函数的特性**

### **(1) 幂等性（Idempotent）**

- **定义**：无论调用多少次，函数对相同输入始终生成相同 UI。
- **要求**：
  - 避免在函数内修改全局变量或外部状态。
  - 若需状态管理，必须通过 `remember` 或参数传递。

### **(2) 重组敏感性**

- **自动响应状态变化**：当函数内部依赖的状态（如 `mutableStateOf`）或输入参数变化时，触发重组。
- **局部刷新**：仅更新受影响的 UI 部分，而非整个组件。

### **(3) 层级化结构**

- **树形嵌套**：通过函数调用顺序隐式定义 UI 层级，类似 XML 布局的 ViewGroup：

  ```kotlin
  @Composable
  fun ProfileCard() {
      Column {
          Image(/*...*/)
          Text(/*...*/)
          Button(/*...*/)
      }
  }
  ```

---

## **4. 状态管理与参数传递**

### **(1) 状态内嵌（Stateful 组件）**

```kotlin
@Composable
fun Counter() {
    val count = remember { mutableStateOf(0) } // 状态定义在组件内部
    Button(onClick = { count.value++ }) {
        Text("Clicked ${count.value} times")
    }
}
```

### **(2) 状态提升（Stateless 组件）**

- **最佳实践**：将状态通过参数传入，提升组件可复用性：

  ```kotlin
  @Composable
  fun Counter(count: Int, onIncrement: () -> Unit) { // 状态由外部控制
      Button(onClick = onIncrement) {
          Text("Clicked $count times")
      }
  }

  // 父组件管理状态
  @Composable
  fun Parent() {
      val count = remember { mutableStateOf(0) }
      Counter(count.value, onIncrement = { count.value++ })
  }
  ```

---

## **5. 常见使用规则**

### **(1) 避免副作用**

- **禁止操作**：
  - 在 Composable 中直接发起网络请求。
  - 修改全局变量或数据库。
- **替代方案**：使用 `LaunchedEffect` 或 `ViewModel` 处理异步逻辑。

### **(2) 合理拆分组件**

- **避免臃肿**：将复杂 UI 拆分为多个小 Composable 函数。

  ```kotlin
  @Composable
  fun UserProfile(user: User) {
      Column {
          ProfileHeader(user.name, user.avatar)
          ProfileDetails(user.email, user.bio)
      }
  }
  ```

### **(3) 参数设计原则**

- **优先使用不可变数据**：传递 `String`、`Int` 或 `data class` 而非可变对象。
- **回调函数**：通过 Lambda 处理交互事件（如 `onClick: () -> Unit`）。

---

## **6. 调试与分析工具**

- **重组计数**：使用 Android Studio 的 **Layout Inspector** 或第三方插件（如 **Recomposition Counter**）监控重组次数。
- **代码检查**：开启 Compose 的静态代码分析（如 `@Composable` 函数命名检查）。

---

## **7. 常见问题与解决**

### **问题 1：组件无法更新**

- **原因**：未正确使用 `mutableStateOf` 或 `remember`。
- **修复**：确保状态变量被 `remember` 包裹，且通过 `.value` 修改值。

### **问题 2：预览不显示**

- **原因**：函数未添加 `@Preview` 或依赖缺失。
- **修复**：检查是否引入 `androidx.compose.ui:ui-tooling` 依赖。

### **问题 3：性能低下**

- **原因**：过度重组或未拆分复杂组件。
- **优化**：使用 `derivedStateOf` 或 `key` 减少重组范围。

---

## **总结**

- **核心原则**：幂等性、状态驱动、函数式组合。
- **关键技巧**：状态提升、组件拆分、副作用隔离。
- **下一步**：学习状态管理（`ViewModel` + `Flow`）和高级布局（`ConstraintLayout`）。

掌握 Composable 函数的基础后，即可高效构建灵活且高性能的 Compose UI。

# 状态提升

在 Jetpack Compose 中，**状态提升（State Hoisting）** 是构建可复用、可测试组件的核心模式。它通过将状态从子组件移动到父组件，实现 UI 与状态的解耦。以下是状态提升的深度解析：

---

## 一、状态提升的核心原则

1. **单向数据流**  
   - 状态只能通过父组件修改
   - 子组件通过参数接收状态，通过回调通知状态变更
   - 数据流动：父组件 → 子组件（只读） → 事件 → 父组件 → 新状态 → 子组件更新

2. **单一数据源**  
   - 每个 UI 元素的状态只在一个位置维护
   - 避免状态重复和不同步问题

3. **无状态组件优先**  
   - 子组件不持有状态，只负责展示和事件传递
   - 父组件决定如何管理状态（可以是 ViewModel、remember 等）

---

## 二、基础实现模式

### 1. 未提升状态（有状态组件）

```kotlin
@Composable
fun StatefulButton() {
    val count = remember { mutableStateOf(0) }
    Button(onClick = { count.value++ }) {
        Text("Clicked ${count.value} times")
    }
}
```

**问题**：组件无法复用，状态逻辑与 UI 耦合

### 2. 提升状态后（无状态组件）

```kotlin
// 子组件（无状态）
@Composable
fun StatelessButton(
    count: Int,           // 状态通过参数传入
    onClick: () -> Unit   // 事件通过回调通知
) {
    Button(onClick = onClick) {
        Text("Clicked $count times")
    }
}

// 父组件（管理状态）
@Composable
fun ParentComponent() {
    val (count, setCount) = remember { mutableStateOf(0) }
    StatelessButton(
        count = count,
        onClick = { setCount(count + 1) }
    )
}
```

**优势**：组件可复用，状态逻辑集中管理

---

## 三、状态提升的典型场景

### 1. 表单输入控制

```kotlin
// 子组件
@Composable
fun InputField(
    value: String,
    onValueChange: (String) -> Unit
) {
    TextField(
        value = value,
        onValueChange = onValueChange
    )
}

// 父组件
@Composable
fun FormScreen() {
    var username by remember { mutableStateOf("") }
    var password by remember { mutableStateOf("") }

    Column {
        InputField(username, { username = it })
        InputField(password, { password = it })
    }
}
```

### 2. 列表项选中状态

```kotlin
// 子组件
@Composable
fun SelectableItem(
    item: String,
    isSelected: Boolean,
    onSelectionChange: (Boolean) -> Unit
) {
    Row(
        modifier = Modifier
            .clickable { onSelectionChange(!isSelected) }
    ) {
        Checkbox(
            checked = isSelected,
            onCheckedChange = null // 由父组件控制
        )
        Text(item)
    }
}

// 父组件
@Composable
fun ItemList(items: List<String>) {
    val selectedItems = remember { mutableStateSetOf<String>() }

    LazyColumn {
        items(items) { item ->
            SelectableItem(
                item = item,
                isSelected = selectedItems.contains(item),
                onSelectionChange = { selected ->
                    if (selected) selectedItems.add(item)
                    else selectedItems.remove(item)
                }
            )
        }
    }
}
```

---

## 四、多层级状态提升策略

### 1. 跨组件状态共享

```kotlin
// 状态定义在最近的公共父组件
@Composable
fun ComplexForm() {
    var formState by remember { mutableStateOf(FormState()) }

    Column {
        PersonalInfoSection(
            state = formState.personalInfo,
            onUpdate = { newInfo ->
                formState = formState.copy(personalInfo = newInfo)
            }
        )
        
        AddressSection(
            state = formState.address,
            onUpdate = { newAddress ->
                formState = formState.copy(address = newAddress)
            }
        )
    }
}

// 子组件层级
@Composable
fun PersonalInfoSection(
    state: PersonalInfo,
    onUpdate: (PersonalInfo) -> Unit
) {
    // 继续向下传递状态...
}
```

### 2. 结合 ViewModel 的状态提升

```kotlin
class FormViewModel : ViewModel() {
    private val _formState = mutableStateOf(FormState())
    val formState: State<FormState> = _formState

    fun updatePersonalInfo(newInfo: PersonalInfo) {
        _formState.value = _formState.value.copy(
            personalInfo = newInfo
        )
    }
}

@Composable
fun FormScreen(viewModel: FormViewModel = viewModel()) {
    val formState by viewModel.formState

    PersonalInfoSection(
        state = formState.personalInfo,
        onUpdate = { viewModel.updatePersonalInfo(it) }
    )
}
```

---

## 五、最佳实践与优化技巧

### 1. 提升原则

| 决策因素 | 说明 |
|---------|------|
| **作用域** | 状态应提升到所有使用它的组件的最低公共父级 |
| **复用性** | 需要复用的组件必须是无状态的 |
| **测试需求** | 无状态组件更易进行单元测试 |

### 2. 性能优化

```kotlin
// 使用 key 控制重组
@Composable
fun ItemList(items: List<Item>) {
    LazyColumn {
        items(
            items = items,
            key = { it.id } // 设置唯一标识
        ) { item ->
            // ...
        }
    }
}

// 延迟读取状态
val currentValue by remember { derivedStateOf {
    // 复杂计算逻辑
}}
```

### 3. 事件处理模式

```kotlin
// 使用密封类定义事件
sealed interface FormEvent {
    data class NameChanged(val value: String) : FormEvent
    data class EmailChanged(val value: String) : FormEvent
    object Submit : FormEvent
}

// 统一事件处理
fun handleEvent(event: FormEvent) {
    when (event) {
        is FormEvent.NameChanged -> updateName(event.value)
        // 其他事件处理...
    }
}
```

---

## 六、常见问题解决方案

### 1. 过度提升问题

**现象**：组件层次过深导致状态传递繁琐  
**解决**：  

- 合理划分组件层级
- 对密切相关的状态使用数据类封装
- 对复杂场景使用状态管理工具（如 ViewModel + StateFlow）

### 2. 状态同步问题

**现象**：多个组件显示不一致的状态  
**解决**：  

- 确保单一数据源
- 使用深度拷贝（`copy()`）避免对象引用问题
- 对集合类型使用不可变集合

### 3. 性能瓶颈

**现象**：频繁状态更新导致界面卡顿  
**优化**：  

- 使用 `derivedStateOf` 处理派生状态
- 通过 `remember` 缓存计算结果
- 对列表使用 `LazyColumn`/`LazyRow`

---

## 七、状态提升 vs 状态下沉

| 模式 | 特点 | 适用场景 |
|------|------|----------|
| **状态提升** | 父组件控制状态<br/>子组件无状态 | 需要复用组件<br/>需要集中管理状态 |
| **状态下沉** | 子组件自己管理状态 | 独立功能模块<br/>无需共享的状态 |

---

## 八、实战建议

1. **逐步重构**：  
   - 从有状态组件开始开发
   - 在需要复用时进行状态提升

2. **分层管理**：  

   ```kotlin
   // UI 层组件（无状态）
   @Composable
   fun MyComponent(state: MyState, onEvent: (MyEvent) -> Unit)

   // 状态管理层（ViewModel）
   class MyViewModel : ViewModel() {
       private val _state = mutableStateOf(MyState())
       val state: State<MyState> = _state

       fun handleEvent(event: MyEvent) {
           // 业务逻辑处理...
       }
   }
   ```

3. **调试工具**：  
   - 使用 `RecompositionCount` 检查过度重组
   - 通过 `Layout Inspector` 分析组件树

通过合理运用状态提升，可以构建出高度可维护、可测试的 Compose UI 架构。关键是要在组件复用性、状态可控性和代码复杂度之间找到平衡。

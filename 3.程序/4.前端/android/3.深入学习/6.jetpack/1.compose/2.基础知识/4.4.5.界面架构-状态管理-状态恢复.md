# 状态恢复（State Restoration）

在 Android 应用开发中，**状态恢复（State Restoration）** 是确保应用在配置变更（如屏幕旋转）、系统回收（进程被终止后重建）等场景下保持用户体验一致性的关键技术。以下是状态恢复的全面解析：

---

## 一、状态恢复的场景分类

| 场景 | 状态恢复需求 | 典型解决方案 |
|------|-------------|--------------|
| **配置变更**（Configuration Change）<br>（屏幕旋转、语言切换等） | 需要保留当前界面状态 | ViewModel + `remember` |
| **进程死亡后恢复**（Process Death）<br>（系统回收资源后重建应用） | 需要持久化关键状态 | `SavedStateHandle` + `rememberSaveable` |
| **返回栈导航恢复**（Back Stack） | 恢复上一个页面的状态 | Navigation Component 自动处理 |

---

## 二、配置变更状态恢复

### 1. 使用 ViewModel

```kotlin
class MyViewModel : ViewModel() {
    private val _counter = mutableStateOf(0)
    val counter: State<Int> = _counter

    fun increment() {
        _counter.value++
    }
}

@Composable
fun CounterScreen() {
    val viewModel: MyViewModel = viewModel()
    val count by viewModel.counter
    
    Button(onClick = { viewModel.increment() }) {
        Text("Count: $count")
    }
}
```

**特点**：  

- ViewModel 生命周期与 Activity/Fragment 分离
- 在配置变更时自动保留状态
- **无法** 在进程死亡后恢复

### 2. 使用 `remember`

```kotlin
@Composable
fun RememberExample() {
    // remember 仅在配置变更时保持状态
    var text by remember { mutableStateOf("") }
    TextField(value = text, onValueChange = { text = it })
}
```

**限制**：  

- 仅适用于同一 Composable 的重组
- 无法在进程死亡后恢复

---

## 三、进程死亡状态恢复

### 1. 使用 `rememberSaveable`

```kotlin
@Composable
fun SaveableExample() {
    // 自动处理 Bundle 保存/恢复
    var text by rememberSaveable { mutableStateOf("") }
    
    // 自定义恢复逻辑
    var list by rememberSaveable(
        saver = listSaver(
            save = { it.toList() },
            restore = { it.toMutableList() }
        )
    ) { mutableStateOf(mutableListOf("Item")) }
}
```

**实现原理**：  

- 通过 `Bundle` 系统自动序列化/反序列化
- 支持的数据类型：  
  - 基本类型（Int, String 等）  
  - Parcelable 对象  
  - 自定义 Saver 实现

### 2. 结合 ViewModel + SavedStateHandle

```kotlin
class SavedStateViewModel(
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    companion object {
        private const val KEY_COUNTER = "counter"
        private const val KEY_TEXT = "text"
    }

    // 基本类型自动处理
    val counter = savedStateHandle.getStateFlow(KEY_COUNTER, 0)
    
    // 复杂对象需要自定义转换
    val text = savedStateHandle.getStateFlow(KEY_TEXT, "")

    fun updateCounter(newValue: Int) {
        savedStateHandle[KEY_COUNTER] = newValue
    }

    fun updateText(newText: String) {
        savedStateHandle[KEY_TEXT] = newText
    }
}

// 在 Composable 中使用
@Composable
fun SavedStateExample() {
    val viewModel: SavedStateViewModel = viewModel()
    val counter by viewModel.counter.collectAsState()
    val text by viewModel.text.collectAsState()
    
    // UI 组件...
}
```

**关键点**：  

- `SavedStateHandle` 本质是持久化的 `Bundle`
- 数据会保存到磁盘，可存活于进程死亡
- 使用 `getStateFlow` 转换为 Compose 友好的状态流

---

## 四、复杂对象的状态恢复

### 1. 实现 Parcelable

```kotlin
@Parcelize
data class UserSettings(
    val darkMode: Boolean,
    val fontSize: Int
) : Parcelable

// 在 ViewModel 中使用
savedStateHandle["settings"] = UserSettings(true, 16)
```

### 2. 自定义 Saver（非 Parcelable 对象）

```kotlin
class CustomObject(val id: String, val data: Map<String, Any>)

val CustomObjectSaver = listSaver<CustomObject, Any>(
    save = { listOf(it.id, it.data) },
    restore = { CustomObject(it[0] as String, it[1] as Map<String, Any>) }
)

@Composable
fun CustomObjectRestore() {
    var obj by rememberSaveable(stateSaver = CustomObjectSaver) {
        mutableStateOf(CustomObject("1", emptyMap()))
    }
}
```

---

## 五、导航状态恢复

### 1. Navigation Component 自动恢复

```kotlin
// nav_graph.xml 中定义
<navigation 
    android:id="@+id/nav_graph"
    app:startDestination="@id/mainScreen">
    
    <fragment
        android:id="@+id/mainScreen"
        android:name="com.example.MainFragment"
        />
</navigation>
```

**特性**：  

- 返回栈中的 Fragment/Composable 会自动恢复状态
- 结合 ViewModel 实现跨页面状态保持

### 2. 保存滚动位置

```kotlin
val listState = rememberLazyListState()

// 自动保存到 SavedStateHandle
val savedStateHandle = rememberSaveable(saver = LazyListState.Saver) {
    mutableStateOf(LazyListState())
}
```

---

## 六、最佳实践与调试技巧

### 1. 状态恢复策略选择

| 数据类型 | 推荐方案 | 注意事项 |
|---------|----------|----------|
| 简单 UI 状态 | `rememberSaveable` | 适用于独立组件 |
| 业务关键数据 | ViewModel + SavedStateHandle | 需要持久化到磁盘 |
| 大型数据集 | 本地数据库/SharedPreferences | 避免 Bundle 大小限制 |

### 2. 调试工具

```kotlin
// 开启状态恢复日志
adb shell setprop log.tag.SavedState VERBOSE

// 检查 Bundle 内容
Log.d("SavedState", savedStateHandle.keys().joinToString())
```

### 3. 常见问题解决

**问题：状态未正确恢复**  

- 检查数据类型是否可序列化
- 验证 Saver 实现是否正确
- 确保没有直接修改 `Bundle` 中的集合

**问题：恢复后界面闪烁**  

- 使用 `LaunchedEffect` 加载初始状态

```kotlin
LaunchedEffect(Unit) {
    if (initialStateLoaded) return@LaunchedEffect
    loadInitialState()
}
```

---

## 七、高级场景：跨进程状态恢复

### 1. 使用 `PersistentBundle`

```kotlin
// 在 Application 类中初始化
class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()
        PersistentBundle.setup(this)
    }
}

// 存储/读取数据
PersistentBundle.put("user_token", "abc123")
val token = PersistentBundle.get<String>("user_token")
```

### 2. 结合 WorkManager 定期备份

```kotlin
val backupRequest = PeriodicWorkRequestBuilder<BackupWorker>(
    24, TimeUnit.HOURS
).build()

WorkManager.getInstance(context).enqueue(backupRequest)
```

---

## 八、性能优化

### 1. 按需恢复

```kotlin
// 延迟加载大资源
val imageBitmap by rememberSaveable(
    saver = BitmapSaver(), // 自定义图片保存器
    init = { mutableStateOf(null) }
)

if (imageBitmap == null) {
    LaunchedEffect(Unit) {
        imageBitmap = loadFromCacheOrNetwork()
    }
}
```

### 2. 状态压缩

```kotlin
// 使用 Protobuf 序列化
val compressedState = rememberSaveable(
    saver = object : Saver<MyState, ByteArray> {
        override fun save(value: MyState) = 
            value.toByteArray() // 自定义压缩
        
        override fun restore(value: ByteArray) = 
            MyState.parseFrom(value)
    }
) { mutableStateOf(MyState()) }
```

---

## 九、安全注意事项

### 1. 敏感数据加密

```kotlin
val encryptedText = rememberSaveable(
    saver = object : Saver<String, String> {
        override fun save(value: String) = 
            encrypt(value) // 使用 Android Keystore
        
        override fun restore(value: String) = 
            decrypt(value)
    }
) { mutableStateOf("") }
```

### 2. 避免存储以下内容

- 用户密码（应使用 Token）
- 未加密的支付信息
- 大尺寸 Bitmap（应存储路径引用）

---

通过合理运用这些状态恢复技术，可以确保用户在不同场景下获得连续一致的使用体验。关键要根据数据类型、重要性、性能要求选择最适合的恢复策略，同时注意安全性和代码可维护性。

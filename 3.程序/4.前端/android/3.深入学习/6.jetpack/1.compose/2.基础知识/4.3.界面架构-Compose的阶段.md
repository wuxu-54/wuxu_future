# Compose的阶段

在 Jetpack Compose 中，UI 的构建和更新过程被划分为 **三个阶段（Phases）**，这种分层设计是 Compose 高性能的核心机制。以下是各阶段的详细解析：

---

## 一、Compose 的三大核心阶段

| 阶段 | 职责 | 触发条件 | 优化目标 |
|------|------|----------|----------|
| **组合（Composition）** | 生成 UI 树（描述界面结构） | 状态变化时 | 最小化重组范围 |
| **布局（Layout）** | 测量和定位 UI 元素 | 组合结果变化或父布局要求 | 减少测量次数 |
| **绘制（Drawing）** | 将元素渲染到屏幕 | 布局结果变化或动画进行时 | 避免过度绘制 |

---

## 二、阶段详解与工作原理

### 1. **组合阶段（Composition）**

- **作用**：  
  将 Composable 函数转换为 **UI 树**（由 `LayoutNode` 构成的树形结构），记录每个节点的类型、属性和状态。
  
- **关键机制**：  
  - **智能重组（Smart Recompose）**：  
    仅更新受状态变化影响的 Composable，跳过未变化部分。  

    ```kotlin
    @Composable
    fun Counter() {
        var count by remember { mutableStateOf(0) }
        // 仅当 count 变化时重组 Text
        Text("Count: $count") 
    }
    ```

  - **稳定性标记**：  
    通过 `@Stable` 或 `@Immutable` 注解帮助编译器优化重组逻辑。

- **调试工具**：  
  使用 `CompositionTracer` 或 Layout Inspector 查看重组次数。

### 2. **布局阶段（Layout）**

- **作用**：  
  计算每个 UI 元素的 **位置和尺寸**，分为两步：  
  1. **测量（Measure）**：确定子元素的尺寸  
  2. **布局（Place）**：确定子元素的位置  

- **自定义布局示例**：  

  ```kotlin
  @Composable
  fun CustomLayout() {
      Layout(
          content = { /* 子组件 */ },
          measurePolicy = { measurables, constraints ->
              // 测量逻辑
              val placeables = measurables.map { it.measure(constraints) }
              // 计算布局尺寸
              layout(width, height) {
                  // 定位子元素
                  placeables.forEach { it.place(x, y) }
              }
          }
      )
  }
  ```

- **性能优化**：  
  - 使用 `IntrinsicSize` 优化预测量（如 `Row`/`Column` 的 `width = IntrinsicSize.Max`）  
  - 避免深层嵌套布局（减少测量传递）

### 3. **绘制阶段（Drawing）**

- **作用**：  
  将布局后的 UI 元素实际渲染到屏幕上，包括：  
  - 绘制形状（如矩形、圆形）  
  - 渲染文本  
  - 处理阴影、渐变等效果  

- **自定义绘制示例**：  

  ```kotlin
  Canvas(modifier = Modifier.size(100.dp)) {
      drawCircle(Color.Red, radius = 50.dp.toPx())
  }
  ```

- **优化策略**：  
  - 使用 `drawWithCache` 复用绘制资源  
  - 避免在绘制过程中触发重组（如动态修改绘制参数时使用 `LaunchedEffect`）

---

## 三、阶段间的协作流程

1. **初始流程**：  
   **组合 → 布局 → 绘制**  
   （首次构建 UI 树并渲染）

2. **更新流程**：  
   - **状态变化** → 触发 **组合阶段**（生成新 UI 树）  
   - **UI 树差异比对** → 确定需要更新的 **布局节点**  
   - 仅更新变化的节点 → 进入 **布局阶段** → **绘制阶段**

---

## 四、高级阶段控制技巧

### 1. 跳过不必要的阶段

- **跳过重组**：  
  使用 `@NonRestartableComposable` 注解（慎用）或稳定参数减少重组。

  ```kotlin
  @Composable
  @NonRestartableComposable
  fun StableComponent(data: StableData) { /*...*/ }
  ```

- **跳过布局/绘制**：  
  使用 `Modifier.drawWithContent{}` 控制绘制条件：

  ```kotlin
  Box(modifier = Modifier
      .size(100.dp)
      .drawWithContent {
          if (shouldDraw) {
              drawContent() // 按条件绘制
          }
      }
  )
  ```

### 2. 阶段间状态传递

- **在布局阶段访问组合信息**：  
  使用 `LayoutModifier`：

  ```kotlin
  modifier = object : LayoutModifier {
      fun MeasureScope.measure(...) {
          val context = LocalContext.current // 可访问组合阶段信息
          // 测量逻辑...
      }
  }
  ```

### 3. 性能监控

- **基准测试工具**：  
  使用 `ComposeBenchmarkRule` 测量各阶段耗时：

  ```kotlin
  @Test
  fun benchmarkComposePhases() {
      composeTestRule.benchmarkRecomposition {
          // 触发重组操作
      }
  }
  ```

---

## 五、阶段与副作用的交互

| 副作用 API | 触发阶段 | 注意事项 |
|------------|----------|----------|
| `LaunchedEffect` | 组合阶段 | 避免在布局/绘制阶段启动协程 |
| `DisposableEffect` | 组合阶段 | 清理操作可能延迟到下一帧 |
| `drawWithCache` | 绘制阶段 | 资源分配需考虑线程安全 |

---

## 六、常见问题与优化

### **问题 1：过度重组（Too Many Recompositions）**

- **检测**：使用重组计数器或 `debug` 模式  
- **解决**：  
  - 拆分细粒度 Composable  
  - 使用 `remember` 缓存计算结果  

  ```kotlin
  val filteredList = remember(list, query) {
      list.filter { it.contains(query) }
  }
  ```

### **问题 2：布局抖动（Layout Thrashing）**

- **现象**：频繁触发布局阶段导致卡顿  
- **优化**：  
  - 使用 `SubcomposeLayout` 延迟加载复杂部分  
  - 避免在布局阶段修改状态

### **问题 3：过度绘制（Overdraw）**

- **检测**：开发者选项中的 **"Show GPU Overdraw"**  
- **解决**：  
  - 使用 `Modifier.clipToBounds()` 限制绘制区域  
  - 减少不必要的背景色设置

---

## 总结

Jetpack Compose 的三阶段架构通过以下方式实现高性能 UI：  

1. **组合阶段**：智能重组减少计算量  
2. **布局阶段**：单次测量优化和自定义布局控制  
3. **绘制阶段**：GPU 加速与绘制缓存  

开发者应重点关注：  

- **重组优化**：通过状态管理和组件拆分减少无效重组  
- **布局性能**：避免嵌套过深，合理使用固有特性测量  
- **绘制效率**：复用绘制资源，控制绘制范围  

通过理解各阶段的行为，可以更精准地定位性能瓶颈并实施优化策略。

# `ViewModel` 管理状态

在 Android Jetpack Compose 中，使用 `ViewModel` 管理状态是实现业务逻辑与 UI 解耦的最佳实践。以下是完整的实现方式和原理分析：

---

## 一、ViewModel 管理状态的优势

1. **生命周期感知**：状态在配置变更（如屏幕旋转）时不会丢失
2. **业务逻辑集中**：将数据操作、网络请求等封装在 ViewModel 中
3. **多组件共享**：多个 Composable 可以安全地访问同一状态源
4. **可测试性**：方便进行单元测试和 UI 测试

---

## 二、基础实现方式

### 1. 定义 ViewModel

```kotlin
class CounterViewModel : ViewModel() {
    // 私有可变状态
    private val _count = mutableStateOf(0)
    // 对外暴露不可变状态
    val count: State<Int> get() = _count

    fun increment() {
        _count.value++
    }
    
    fun reset() {
        _count.value = 0
    }
}
```

### 2. 在 Composable 中使用

```kotlin
@Composable
fun CounterScreen(
    viewModel: CounterViewModel = viewModel()
) {
    val currentCount by viewModel.count
    
    Column {
        Text("Count: $currentCount")
        Button(onClick = { viewModel.increment() }) {
            Text("Increment")
        }
        Button(onClick = { viewModel.reset() }) {
            Text("Reset")
        }
    }
}
```

---

## 三、进阶实践（推荐架构）

### 1. 使用 UI State 封装

```kotlin
// 定义状态类
data class LoginState(
    val username: String = "",
    val password: String = "",
    val isLoading: Boolean = false,
    val errorMessage: String? = null
)

class LoginViewModel : ViewModel() {
    private val _uiState = mutableStateOf(LoginState())
    val uiState: State<LoginState> = _uiState

    fun onUsernameChanged(newValue: String) {
        _uiState.value = _uiState.value.copy(
            username = newValue,
            errorMessage = null
        )
    }

    fun onPasswordChanged(newValue: String) {
        _uiState.value = _uiState.value.copy(
            password = newValue,
            errorMessage = null
        )
    }

    fun submitLogin() {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            try {
                // 调用 repository 执行登录逻辑
                loginRepository.login(
                    _uiState.value.username,
                    _uiState.value.password
                )
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    errorMessage = null
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    errorMessage = e.message
                )
            }
        }
    }
}
```

### 2. 事件驱动架构

```kotlin
// 使用密封类定义事件
sealed class LoginEvent {
    data class UsernameChanged(val value: String) : LoginEvent()
    data class PasswordChanged(val value: String) : LoginEvent()
    object Submit : LoginEvent()
}

class LoginViewModel : ViewModel() {
    // ... 状态定义同上
    
    fun handleEvent(event: LoginEvent) {
        when (event) {
            is LoginEvent.UsernameChanged -> onUsernameChanged(event.value)
            is LoginEvent.PasswordChanged -> onPasswordChanged(event.value)
            LoginEvent.Submit -> submitLogin()
        }
    }
}

// 在 Composable 中使用
@Composable
fun LoginScreen(viewModel: LoginViewModel = viewModel()) {
    val state by viewModel.uiState
    
    Column {
        TextField(
            value = state.username,
            onValueChange = { viewModel.handleEvent(LoginEvent.UsernameChanged(it)) }
        )
        TextField(
            value = state.password,
            onValueChange = { viewModel.handleEvent(LoginEvent.PasswordChanged(it)) }
        )
        if (state.isLoading) {
            CircularProgressIndicator()
        } else {
            Button(onClick = { viewModel.handleEvent(LoginEvent.Submit) }) {
                Text("Login")
            }
        }
        state.errorMessage?.let { 
            Text(text = it, color = Color.Red)
        }
    }
}
```

---

## 四、状态分层架构

### 1. 分层结构

```txt
UI Layer (Compose)
  ↑↓
ViewModel (UI State + 事件处理)
  ↑↓
Domain Layer (Use Cases)
  ↑↓
Data Layer (Repositories + Data Sources)
```

### 2. 各层职责

| 层级 | 职责 | 示例 |
|------|------|------|
| **UI 层** | 展示 UI 状态<br/>收集用户事件 | Composable 组件 |
| **ViewModel** | 管理 UI 状态<br/>协调业务逻辑 | 转换 Domain 层数据为 UI State |
| **Domain 层** | 封装业务规则<br/>组合数据源 | `LoginUseCase` |
| **数据层** | 数据获取与持久化 | `UserRepository` |

---

## 五、关键配置和依赖

### 1. Gradle 依赖

```gradle
// build.gradle (module)
dependencies {
    implementation "androidx.lifecycle:lifecycle-viewmodel-compose:2.6.2"
    implementation "androidx.lifecycle:lifecycle-runtime-compose:2.6.2"
}
```

### 2. 状态保存（进程死亡恢复）

```kotlin
class MyViewModel(
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    companion object {
        private const val KEY_COUNT = "count"
    }

    private val _count = savedStateHandle.getStateFlow(KEY_COUNT, 0)
    val count: StateFlow<Int> = _count

    fun increment() {
        savedStateHandle[KEY_COUNT] = _count.value + 1
    }
}
```

---

## 六、最佳实践

### 1. 状态管理原则

- **不可变性**：对外暴露只读状态（`State<T>`）
- **单一数据源**：每个 UI 元素的状态只有一个来源
- **单向数据流**：UI → 事件 → ViewModel → 更新状态 → UI 刷新

### 2. 性能优化技巧

```kotlin
// 使用 derivedStateOf 处理派生状态
val showScrollToTop by remember {
    derivedStateOf {
        listState.firstVisibleItemIndex > 5
    }
}

// 使用 remember 缓存计算结果
val filteredList = remember(key1 = searchQuery) {
    originalList.filter { it.contains(searchQuery) }
}
```

### 3. 测试策略

```kotlin
class LoginViewModelTest {
    @get:Rule
    val rule = InstantTaskExecutorRule()

    @Test
    fun `username 修改应更新状态`() {
        val viewModel = LoginViewModel()
        viewModel.handleEvent(LoginEvent.UsernameChanged("new_user"))
        assertEquals("new_user", viewModel.uiState.value.username)
    }
}
```

---

## 七、常见错误解决方案

### 1. 状态未更新

- **原因**：直接修改 `State.value` 而未触发重组
- **修复**：始终通过 `copy()` 或新对象创建新状态

### 2. 内存泄漏

- **现象**：ViewModel 持有已销毁的 Composable 引用
- **预防**：使用 `viewModelScope` 管理协程，避免直接引用 UI 组件

### 3. 过度重组

- **检测**：使用 Layout Inspector 的 Recomposition Counts
- **优化**：使用 `remember` 和 `derivedStateOf` 减少无效重组

---

## 八、扩展方案

### 1. 使用 StateFlow

```kotlin
class MyViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(MyState())
    val uiState: StateFlow<MyState> = _uiState

    // 在 Compose 中收集：
    val state by viewModel.uiState.collectAsState()
}
```

### 2. 结合 Hilt 依赖注入

```kotlin
@HiltViewModel
class MyViewModel @Inject constructor(
    private val repository: MyRepository
) : ViewModel() {
    // ...
}
```

通过 ViewModel 管理状态，可以实现清晰的架构分层、更好的可维护性和可测试性。建议结合具体业务场景选择最适合的状态管理策略。

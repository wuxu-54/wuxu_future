# Jetpack Compose 状态管理

状态管理主要涉及核心概念：

1. 什么是状态
2. 状态管理工具或API
3. 状态提升
4. 状态恢复

---

以下是关于 **Jetpack Compose 状态管理** 的全面解析，涵盖基础概念、核心机制、最佳实践及高级用法，帮助您系统掌握状态驱动的 UI 开发范式。

---

## **1. 状态管理基础**

### **1.1 什么是状态（State）？**

- **定义**：驱动 UI 变化的动态数据（如用户输入、网络请求结果、界面可见性等）。
- **核心特性**：
  - **可变性**：状态值可随时间变化。
  - **响应式**：状态变化自动触发 UI 重组（Recomposition）。
- **示例**：

  ```kotlin
  var count by remember { mutableStateOf(0) } // 定义状态
  Button(onClick = { count++ }) { Text("Count: $count") }
  ```

### **1.2 状态管理目标**

- **单一数据源（Single Source of Truth）**：确保同一状态在应用中只存在一个权威来源。
- **状态共享**：跨组件、跨层级共享状态。
- **状态隔离**：避免无关组件间的状态耦合。

---

## **2. 状态管理工具与 API**

### **2.1 `mutableStateOf` 与 `remember`**

- **`mutableStateOf`**：创建可观察的状态对象，值变化时触发重组。
- **`remember`**：在重组间保持状态，避免重复初始化。

  ```kotlin
  val count = remember { mutableStateOf(0) } // 基本用法
  // 简写（通过委托）：
  var count by remember { mutableStateOf(0) }
  ```

- **其他方式**：

    |场景|托管方式|
    |:-|:-|
    |简单组件|使用 remember 在组件内部管理|
    |复杂逻辑/跨组件共享|通过 ViewModel 或自定义状态容器管理|
    |需要持久化/恢复|使用 SavedStateHandle 或 rememberSaveable|

### **2.2 状态提升（State Hoisting）**

- **定义**：将状态移至调用方（父组件），通过参数和回调传递（实现无状态组件）。
- **优点**：提高组件复用性，集中管理状态。

  ```kotlin
  @Composable
  fun Counter(count: Int, onIncrement: () -> Unit) { // 无状态子组件
      Button(onClick = onIncrement) { Text("Count: $count") }
  }

  @Composable
  fun Parent() { // 状态由父组件管理
      var count by remember { mutableStateOf(0) }
      Counter(count, onIncrement = { count++ })
  }
  ```

### **2.3 状态作用域与生命周期**

- **`remember(key)`**：根据 `key` 值重置状态，适合条件分支或列表项。

  ```kotlin
  var selectedTab by remember(tabId) { mutableStateOf(defaultTab) } // tabId 变化时重置
  ```

- **`rememberSaveable`**：在配置变更（如屏幕旋转）时自动保存状态。

  ```kotlin
  var text by rememberSaveable { mutableStateOf("") } // 自动保存到 Bundle
  ```

---

## **3. 分层状态管理**

### **3.1 局部状态（Local State）**

- **适用场景**：组件内部临时状态（如按钮高亮、动画进度）。
- **工具**：`remember` + `mutableStateOf`。

### **3.2 全局状态（Global State）**

- **适用场景**：跨组件共享的状态（如用户登录信息、主题设置）。
- **工具**：
  - **`CompositionLocal`**：通过隐式传递全局状态。

    ```kotlin
    val LocalTheme = compositionLocalOf { Theme.Light } // 定义
    CompositionLocalProvider(LocalTheme provides DarkTheme) { // 提供值
        ChildComponent() // 子组件通过 LocalTheme.current 获取
    }
    ```

  - **状态容器（ViewModel）**：结合 Android 架构组件管理复杂业务逻辑。

    ```kotlin
    class MyViewModel : ViewModel() {
        val data: StateFlow<List<Item>> = repository.getData().stateIn(viewModelScope)
    }

    @Composable
    fun MyScreen(viewModel: MyViewModel = viewModel()) {
        val items by viewModel.data.collectAsState()
        ItemList(items)
    }
    ```

---

## **4. 高级状态管理**

### **4.1 派生状态（Derived State）**

- **定义**：基于其他状态计算得出的状态，使用 `derivedStateOf` 优化性能。

  ```kotlin
  val listState = rememberLazyListState()
  val showScrollToTop by remember {
      derivedStateOf { listState.firstVisibleItemIndex > 0 }
  } // 仅当条件变化时重组
  ```

### **4.2 状态快照（Snapshot）**

- **底层机制**：Compose 通过快照系统跟踪状态变化，确保原子性更新。
- **手动控制**：使用 `Snapshot.withMutableSnapshot` 批量更新多个状态。

### **4.3 状态映射与转换**

- **`produceState`**：将异步数据流转换为 Compose 状态。

  ```kotlin
  val data by produceState<Result<Data>>(initialValue = Result.Loading) {
      val response = repository.fetchData()
      value = Result.Success(response)
  }
  ```

---

## **5. 副作用管理与状态安全**

### **5.1 副作用（Side Effect）**

- **定义**：在 Composable 函数中执行的非 UI 操作（如网络请求、数据库写入）。
- **管理工具**：
  - **`LaunchedEffect`**：执行协程任务，依赖变化时重启。

    ```kotlin
    LaunchedEffect(userId) { // userId 变化时重新加载
        loadUserData(userId)
    }
    ```

  - **`DisposableEffect`**：处理资源清理（如注册/反注册监听器）。

    ```kotlin
    DisposableEffect(key) {
        val listener = { /* ... */ }
        addListener(listener)
        onDispose { removeListener(listener) }
    }
    ```

### **5.2 状态安全与幂等性**

- **规则**：
  - 避免在 Composable 中直接修改外部状态。
  - 确保 Composable 函数多次执行结果一致（幂等性）。
- **错误示例**：

  ```kotlin
  @Composable
  fun BadExample() {
      var count = 0 // 错误！未使用 remember，每次重组都会重置
      Button(onClick = { count++ }) { Text("Count: $count") }
  }
  ```

---

## **6. 状态恢复与持久化**

### **6.1 保存状态到 Bundle**

- **`rememberSaveable`**：自动处理简单类型和 `Parcelable` 对象。
- **自定义 Saver**：通过 `Saver` 实现复杂对象的保存与恢复。

  ```kotlin
  data class User(val name: String, val age: Int)

  val userSaver = listSaver<User, Any>(
      save = { listOf(it.name, it.age) },
      restore = { User(it[0] as String, it[1] as Int) }
  )

  val user = rememberSaveable(stateSaver = userSaver) { mutableStateOf(User("", 0)) }
  ```

### **6.2 状态持久化到本地存储**

- **结合 DataStore 或 Room**：将状态保存到本地数据库或文件。

  ```kotlin
  val preferences = remember { dataStore.data }
  val theme by preferences.collectAsState(initial = Theme.Light)
  ```

---

## **7. 状态管理最佳实践**

1. **最小化状态作用域**：将状态提升到足够高的层级，但不要过度提升。
2. **优先使用不可变数据**：传递 `State<T>` 而非直接暴露 `MutableState<T>`。
3. **分离 UI 状态与业务逻辑**：通过 ViewModel 或 UseCase 处理业务逻辑。
4. **避免状态冗余**：使用派生状态代替存储重复数据。
5. **性能监控**：使用 Android Studio 的 **Recomposition Count** 工具优化过度重组。

---

## **8. 常见问题与解决方案**

### **问题 1：状态重置**

- **原因**：未正确使用 `remember` 或 `rememberSaveable`。
- **解决**：检查作用域，确保状态在正确位置初始化。

### **问题 2：列表项状态错乱**

- **原因**：未为动态列表项设置唯一 `key`。
- **解决**：

  ```kotlin
  LazyColumn {
      items(items, key = { it.id }) { item -> ItemRow(item) }
  }
  ```

### **问题 3：异步更新导致状态不一致**

- **原因**：在协程中直接修改状态，未考虑组件生命周期。
- **解决**：使用 `LaunchedEffect` + `rememberUpdatedState` 捕获最新状态：

  ```kotlin
  val currentData by rememberUpdatedState(data)
  LaunchedEffect(Unit) {
      delay(1000)
      processData(currentData) // 使用最新值
  }
  ```

---

## **总结**

- **核心原则**：状态驱动 UI、单向数据流、最小作用域。
- **关键工具**：`mutableStateOf`、`remember`、ViewModel、`derivedStateOf`。
- **高级技巧**：状态快照、自定义 Saver、副作用隔离。
- **下一步**：探索 Compose 与 `Flow`、`Hilt`、`Room` 的深度集成，构建完整应用架构。

通过系统掌握状态管理，您将能够构建高效、健壮的 Compose 应用。建议结合官方文档和实战项目深化理解。

# 可组合项（Composable）的生命周期

在 Jetpack Compose 中，**可组合项（Composable）的生命周期** 与传统的 Android 视图（如 Activity/Fragment）不同，其核心围绕 **重组（Recomposition）** 机制展开。以下是其生命周期的完整解析：

---

## 一、Composable 生命周期的三个阶段

| 阶段 | 触发条件 | 行为特点 | 典型应用场景 |
|------|----------|----------|-------------|
| **初始组合（Initial Composition）** | 首次添加到 UI 树 | 执行完整的组合过程 | 初始化状态、启动一次性操作 |
| **重组（Recomposition）** | 依赖的状态变化 | 仅更新变化的部分 | 响应式 UI 更新 |
| **拆卸（Disposal）** | 从 UI 树中移除 | 清理资源（如协程、监听器） | 取消网络请求、释放内存 |

---

## 二、生命周期与关键 API 的关系

### 1. `remember`：状态持久化

```kotlin
@Composable
fun Counter() {
    // 值在重组中保留，拆卸时重置
    val count = remember { mutableStateOf(0) }
}
```

- **生命周期**：跨越多次重组，直到 Composable 被拆卸

### 2. `LaunchedEffect`：副作用管理

```kotlin
@Composable
fun TimerDisplay() {
    var time by remember { mutableStateOf(0) }
    
    LaunchedEffect(Unit) { // 仅在初始组合启动
        while (true) {
            delay(1000)
            time++
        }
    }
}
```

- **生命周期**：  
  - **启动**：进入组合时触发  
  - **取消**：离开组合时自动取消协程  
  - **重启**：若 `key` 参数变化（如 `LaunchedEffect(key)`）

### 3. `DisposableEffect`：资源清理

```kotlin
@Composable
fun SensorListener() {
    val sensorManager = remember { getSystemService(SENSOR_SERVICE) as SensorManager }
    
    DisposableEffect(Unit) {
        val listener = { /* 传感器回调 */ }
        sensorManager.registerListener(listener, ...)
        
        onDispose { // 拆卸时执行清理
            sensorManager.unregisterListener(listener)
        }
    }
}
```

---

## 三、生命周期的核心特性

### 1. **智能重组（Smart Recompose）**

- **优化策略**：  
  - 仅更新受状态变化影响的 Composable  
  - 通过 `@Stable` 和 `@Immutable` 注解提示编译器优化

```kotlin
@Stable
data class UserState(val name: String, val age: Int)

@Composable
fun UserProfile(user: UserState) {
    // 当 user 的任一属性变化时重组
}
```

### 2. **状态快照（State Snapshot）**

- **原理**：  
  Compose 在重组前记录状态快照，若重组被中断，可回滚到之前的状态  
- **意义**：  
  确保 UI 状态的一致性，避免中间状态泄露

---

## 四、生命周期感知的副作用管理

| API | 适用场景 | 生命周期行为 |
|-----|----------|--------------|
| **`LaunchedEffect`** | 协程副作用（如网络请求） | 随 Composable 的进入/退出启动/取消 |
| **`DisposableEffect`** | 需要清理的资源（如监听器） | 在拆卸时触发 `onDispose` |
| **`SideEffect`** | 与非 Compose 代码同步状态 | 每次成功重组后执行 |
| **`rememberCoroutineScope`** | 手动控制协程生命周期 | 作用域与 Composable 的生命周期绑定 |

---

## 五、调试与分析工具

### 1. **重组计数器（Recomposition Counts）**

```kotlin
// 在开发模式下启用
@Composable
fun DebugView() {
    val recomposeCount = remember { mutableStateOf(0) }
    SideEffect { recomposeCount.value++ }
    Text("Recomposed ${recomposeCount.value} times")
}
```

### 2. **Layout Inspector**

- 查看 Composable 的实时层次结构  
- 分析重组范围和高频更新的组件

---

## 六、最佳实践

### 1. **避免过度重组**

- 使用 `remember` 缓存计算结果：

  ```kotlin
  val filteredList = remember(list) {
      list.filter { it.contains(query) }
  }
  ```

- 使用 `derivedStateOf` 处理派生状态：

  ```kotlin
  val showButton by remember {
      derivedStateOf { scrollState.value > 100 }
  }
  ```

### 2. **合理拆分 Composable**

- **细粒度组件**：将频繁变化的部分拆分为独立 Composable  
- **稳定参数**：避免传递易变对象（如 Lambda 表达式），使用 `@Stable` 标记稳定类型

---

## 七、常见问题与解决方案

### 问题 1：协程重复启动

**现象**：每次重组都发起新的网络请求  
**解决**：使用 `LaunchedEffect` + 正确的 `key`：

```kotlin
LaunchedEffect(userId) { // 仅在 userId 变化时重启
    fetchUserData(userId)
}
```

### 问题 2：内存泄漏

**现象**：拆卸后未释放资源（如监听器）  
**解决**：使用 `DisposableEffect`：

```kotlin
DisposableEffect(Unit) {
    val listener = { ... }
    addListener(listener)
    onDispose { removeListener(listener) }
}
```

---

## 总结

Jetpack Compose 的生命周期管理以 **状态驱动** 和 **智能重组** 为核心，开发者需关注：

1. **状态与重组的关联**：通过合理设计状态结构减少无效重组  
2. **副作用管理**：使用 `LaunchedEffect`、`DisposableEffect` 等 API 确保资源安全  
3. **性能优化**：利用 `remember` 和 `derivedStateOf` 提升重组效率  

掌握这些原则，可构建出高性能、易维护的声明式 UI。

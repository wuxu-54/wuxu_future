# 重组（Recomposition）

以下是关于 **Jetpack Compose 重组（Recomposition）** 的详细解析，涵盖触发机制、优化策略及底层原理：

---

## **1. 重组的基本概念**

- **定义**：当 `State`（状态）发生变化时，Compose 重新执行相关的 `@Composable` 函数，更新 UI 的过程。
- **核心目标**：最小化 UI 更新的范围，仅刷新受状态变化影响的部分，而非整个界面。

---

## **2. 触发重组的条件**

- **状态变化**：只有被 `remember` 或 `mutableStateOf` 包装的变量发生值变化时，才会触发重组。
- **输入参数变化**：若 Composable 函数的参数值发生改变，会触发重组。
- **强制重组**：通过调用 `invalidate()` 或修改 `MutableState` 的值（即使新值与旧值相同）强制触发。

---

## **3. 重组的作用域**

- **智能跳过**：Compose 通过比较输入参数和状态依赖，自动跳过未变化的部分。
- **重组的最小化**：重组作用域是代码块级别的，而非整个函数。例如：

  ```kotlin
  @Composable
  fun MyComponent() {
      val counter = remember { mutableStateOf(0) }
      Text("Count: ${counter.value}")  // 仅当 counter 变化时，此 Text 重组
      Button(onClick = { counter.value++ }) { 
          Text("Increment")            // 此 Button 不会因 counter 变化而重组
      }
  }
  ```

---

## **4. 重组的关键机制**

### **(1) 位置记忆（Positional Memoization）**

- Compose 通过代码位置和调用顺序生成唯一标识（Key），记录组件的状态。
- 若组件在重组后位置不变，则复用状态；若位置变化（如列表顺序调整），则状态可能丢失。

### **(2) 状态读取追踪**

- 在重组过程中，Compose 自动跟踪哪些状态被读取，并建立依赖关系。  
- 示例：

  ```kotlin
  val count = remember { mutableStateOf(0) }
  Text("Count: ${count.value}")  // 重组仅在此处读取 count 时触发
  ```

### **(3) 稳定类型（Stable Types）**

- 若 Composable 的参数类型是稳定的（如基本类型、不可变数据类），Compose 可安全跳过重组。
- 使用 `@Stable` 注解标记自定义类型，告知编译器其稳定性。

---

## **5. 优化重组性能**

### **(1) 使用 `derivedStateOf`**

- 将多个状态合并为一个派生状态，减少不必要的重组：

  ```kotlin
  val listState = rememberLazyListState()
  val showButton by remember {
      derivedStateOf { listState.firstVisibleItemIndex > 0 }
  } // 仅当条件变化时触发重组
  ```

### **(2) 使用 `key` 函数**

- 在列表或条件分支中，为动态生成的组件添加唯一标识，避免状态错乱：

  ```kotlin
  LazyColumn {
      items(items, key = { it.id }) { item ->  // 通过唯一 id 标识列表项
          ItemRow(item)
      }
  }
  ```

### **(3) 避免在 Composable 中执行耗时操作**

- 将复杂计算移至 `LaunchedEffect` 或 `ViewModel` 中：

  ```kotlin
  val data by remember { 
      derivedStateOf { heavyCalculation() }  // 错误！应在后台执行
  }
  ```

### **(4) 限制重组范围**

- 通过状态提升（State Hoisting）将状态移至最小必要的作用域：

  ```kotlin
  @Composable
  fun Parent() {
      var state by remember { mutableStateOf(0) }
      Child(state = state)  // 仅 Child 重组，Parent 其他部分不受影响
  }
  ```

---

## **6. 重组中的副作用管理**

- **副作用**：重组过程中可能重复执行的操作（如网络请求、动画）。
- **解决方案**：
  - 使用 `LaunchedEffect`：处理单次或依赖变化的异步任务。
  - 使用 `SideEffect`：在每次重组后执行（但需谨慎使用）。
  - 使用 `DisposableEffect`：处理需要清理的资源（如监听器）。

---

## **7. 常见误区与注意事项**

1. **避免在条件分支中改变状态依赖**  
   错误示例：

   ```kotlin
   if (condition) {
       val data = remember { fetchData() } // 条件变化时可能丢失状态
   }
   ```

2. **避免在 Composable 中修改全局变量**  
   重组可能多次调用函数，导致非幂等操作。

3. **列表项的 `key` 缺失**  
   导致动态列表的项状态混乱（如滚动位置、输入框内容）。

---

## **总结**

- **重组机制**：通过状态依赖追踪和智能作用域跳过，实现高效 UI 更新。  
- **优化核心**：减少不必要的重组范围，合理管理副作用，确保组件稳定性。  
- **调试工具**：使用 Android Studio 的 **Layout Inspector** 或 **Recomposition Count** 插件监控重组次数。

理解重组原理是优化 Compose 性能的关键，建议结合官方文档和实际项目实践深化理解。

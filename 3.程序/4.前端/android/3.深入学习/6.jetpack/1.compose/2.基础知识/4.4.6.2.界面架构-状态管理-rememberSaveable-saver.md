# Saver

在 Jetpack Compose 中，`Saver` 是 **状态保存与恢复的核心接口**，用于定义如何将任意对象转换为可序列化的形式（如 `Bundle` 可存储的类型）。它的核心作用是为 `rememberSaveable` 提供自定义的序列化策略，解决以下问题：

---

## 一、Saver 的核心概念

| 概念 | 说明 |
|------|------|
| **作用** | 将复杂对象转换为可保存的格式（如 `List<Any?>`） |
| **核心方法** | `save(value: T): S`（对象 → 可序列化形式）<br>`restore(saved: S): T?`（可序列化形式 → 对象） |
| **设计目的** | 让开发者自定义非 `Parcelable` 对象的保存逻辑 |

---

## 二、Saver 的工作原理

### 1. 保存流程（Save）

```kotlin
val saver: Saver<MyObject, List<Any?>> = Saver(
    save = { obj -> listOf(obj.name, obj.age) }, // 转换为可序列化形式
    restore = { list -> MyObject(list[0] as String, list[1] as Int) }
)

// 内部实现伪代码
fun saveToBundle(value: MyObject) {
    val savedValue = saver.save(value) // 转换为 List<Any?>
    bundle.putSerializable("key", savedValue) // 存入 Bundle
}
```

- **关键点**：  
  - 必须确保 `save` 的输出类型是 `Bundle` 可存储的（如 `Int`, `String`, `List<Any?>` 等）  
  - 转换后的数据结构需能完全还原原始对象

### 2. 恢复流程（Restore）

```kotlin
// 进程重建后从 Bundle 恢复
val savedValue = bundle.getSerializable("key") as List<Any?>

// 使用 Saver 恢复对象
val restoredObject = saver.restore(savedValue) ?: defaultValue
```

- **匹配机制**：  
  - 通过 `restore` 方法将保存的数据还原为原始对象  
  - 若恢复失败（如类型不匹配），返回 `null` 触发默认值初始化

---

## 三、Saver 的两种实现方式

### 1. **自动 Saver（AutoSaver）**

- **适用场景**：对象已实现 `Parcelable` 或属于基本类型  
- **示例**：

  ```kotlin
  // 自动处理 Parcelable 对象
  data class User(val name: String, val age: Int) : Parcelable

  @Composable
  fun AutoSaveExample() {
      var user by rememberSaveable { mutableStateOf(User("Alice", 25)) }
  }
  ```

### 2. **自定义 Saver**

- **适用场景**：处理不可序列化的复杂对象  
- **实现模式**：

  ```kotlin
  data class Settings(val darkMode: Boolean, val fontSize: Int)

  // 步骤 1：定义 Saver
  val SettingsSaver = Saver<Settings, List<Any?>>(
      save = { settings ->
          listOf(settings.darkMode, settings.fontSize)
      },
      restore = { savedList ->
          Settings(
              darkMode = savedList[0] as Boolean,
              fontSize = savedList[1] as Int
          )
      }
  )

  // 步骤 2：应用 Saver
  @Composable
  fun CustomSaveExample() {
      var settings by rememberSaveable(stateSaver = SettingsSaver) {
          mutableStateOf(Settings(false, 16))
      }
  }
  ```

---

## 四、Saver 的底层实现原理

### 1. 与 `Bundle` 的交互

- **保存时**：Compose 调用 `Saver.save()` 将对象转换为 `List<Any?>` → 存入 `Bundle`  
- **恢复时**：从 `Bundle` 取出 `List<Any?>` → 调用 `Saver.restore()` 还原对象

### 2. 序列化限制

| 限制项 | 说明 | 解决方案 |
|-------|------|----------|
| **Bundle 大小限制** | 默认最大 1MB | 避免保存大对象，改用本地存储 |
| **类型兼容性** | 必须支持 Android 的 `Parcel` 机制 | 使用 `Parcelable` 或自定义 Saver |
| **版本兼容性** | 类结构变化会导致恢复失败 | 实现版本控制或迁移逻辑 |

---

## 五、高级技巧与调试

### 1. 嵌套 Saver

```kotlin
data class UserProfile(val user: User, val settings: Settings)

val UserProfileSaver = Saver<UserProfile, List<Any?>>(
    save = { profile ->
        listOf(
            with(UserSaver) { save(profile.user) }, // 使用 User 的 Saver
            with(SettingsSaver) { save(profile.settings) }
        )
    },
    restore = { savedList ->
        UserProfile(
            user = UserSaver.restore(savedList[0] as List<Any?>)!!,
            settings = SettingsSaver.restore(savedList[1] as List<Any?>)!!
        )
    }
)
```

### 2. 调试 Saver

```kotlin
// 打印保存后的数据结构
val debugSaver = Saver<MyObject, List<Any?>>(
    save = { obj ->
        val saved = listOf(obj.name, obj.age)
        Log.d("SaverDebug", "Saved: $saved")
        saved
    },
    restore = { /* ... */ }
)
```

---

## 六、最佳实践

1. **优先使用 `Parcelable`**：  
   - 对频繁使用的数据类实现 `Parcelable`，避免重复编写 Saver  
2. **保持 Saver 简单**：  
   - 转换后的数据结构层级不宜过深，避免性能损耗  
3. **版本兼容性处理**：  

   ```kotlin
   restore = { savedList ->
       when (savedList.size) {
           2 -> Settings(savedList[0] as Boolean, savedList[1] as Int)
           3 -> Settings(savedList[0] as Boolean, savedList[1] as Int, savedList[2] as String)
           else -> null // 处理旧版本数据
       }
   }
   ```

---

## 七、Saver 与其他机制的对比

| 机制 | 特点 | 适用场景 |
|------|------|----------|
| **`rememberSaveable` + Saver** | 灵活自定义，需手动实现转换逻辑 | 复杂对象的状态恢复 |
| **`SavedStateHandle`** | 自动处理基本类型，依赖 ViewModel | 业务逻辑与状态管理结合 |
| **`Parcelable`** | Android 原生支持，性能优化 | 高频使用的数据类 |

通过合理设计 Saver，可以实现对任意复杂对象的持久化保存与恢复，是构建健壮 Compose 应用的关键技术之一。

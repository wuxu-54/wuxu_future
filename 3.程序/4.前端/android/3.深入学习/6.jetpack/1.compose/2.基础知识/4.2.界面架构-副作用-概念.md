# 副作用（Side-Effect）

在 Jetpack Compose 中，**副作用（Side-Effect）** 是指那些需要在可组合函数范围之外执行的操作（如网络请求、数据库访问、事件监听等）。由于 Compose 的声明式特性，副作用的处理需要特殊机制来保证安全性和生命周期管理。以下是 Compose 副作用的完整解析：

---

## 一、副作用的核心概念

| **特性** | **说明** |
|----------|----------|
| **定义** | 影响 Composable 之外的系统状态或资源（如文件操作、协程启动） |
| **挑战** | 需与 Composable 的生命周期（重组、拆卸）同步，避免内存泄漏 |
| **管理原则** | 通过 Effect API 将副作用与 UI 状态绑定 |

---

## 二、核心 Effect API 详解

### 1. **`LaunchedEffect` - 协程副作用**

**用途**：启动一个协程任务（如网络请求、动画）

```kotlin
@Composable
fun TimerDisplay() {
    var time by remember { mutableStateOf(0) }
    
    // key 变化时重启协程
    LaunchedEffect(key1 = Unit) { 
        while (isActive) { // 协程作用域与 Composable 生命周期绑定
            delay(1000)
            time++
        }
    }
}
```

**生命周期**：

- **启动**：进入组合时
- **取消**：离开组合或 key 变化时
- **重启**：当 `key` 参数变化时

### 2. **`DisposableEffect` - 需清理的副作用**

**用途**：注册和释放资源（如监听器、传感器）

```kotlin
@Composable
fun LocationTracker() {
    val context = LocalContext.current
    var location by remember { mutableStateOf("") }
    
    DisposableEffect(Unit) {
        val locationClient = LocationClient(context)
        val listener = { newLoc -> location = newLoc }
        
        locationClient.addListener(listener) // 注册监听
        
        onDispose { 
            locationClient.removeListener(listener) // 清理
        }
    }
}
```

**生命周期**：

- `onDispose` 在 Composable 拆卸时触发

### 3. **`SideEffect` - 同步状态到外部系统**

**用途**：与非 Compose 代码同步状态（如 Analytics 埋点）

```kotlin
@Composable
fun TrackScreenView(screenName: String) {
    val analytics = remember { AnalyticsService() }
    
    SideEffect {
        analytics.trackScreenView(screenName) // 每次重组后执行
    }
}
```

**特点**：

- 每次成功重组后执行
- 无生命周期感知（不自动取消）

### 4. **`rememberCoroutineScope` - 手动控制协程**

**用途**：用户交互触发的异步操作（如按钮点击）

```kotlin
@Composable
fun DownloadButton() {
    val scope = rememberCoroutineScope()
    var progress by remember { mutableStateOf(0) }
    
    Button(onClick = {
        scope.launch { // 手动管理协程
            downloadFile().collect { progress = it }
        }
    }) {
        Text("Download (${progress}%)")
    }
}
```

**生命周期**：

- 协程作用域与 Composable 生命周期绑定

---

## 三、副作用管理的最佳实践

### 1. **Key 的正确使用**

```kotlin
// 根据 userId 变化重启协程
LaunchedEffect(key1 = userId) {
    fetchUserData(userId)
}
```

### 2. **避免无限重组**

```kotlin
// 错误：在重组中直接修改状态 → 导致无限循环
var count by remember { mutableStateOf(0) }
LaunchedEffect(Unit) {
    count++ // 触发重组 → 再次执行 → 死循环
}

// 正确：使用 key 控制执行频率
LaunchedEffect(key1 = count) { /* ... */ }
```

### 3. **资源清理模式**

```kotlin
DisposableEffect(key) {
    val resource = allocateResource()
    
    onDispose { 
        releaseResource(resource) 
    }
}
```

---

## 四、常见问题与解决方案

### **问题 1：副作用重复执行**

**现象**：每次重组都发起新请求  
**解决**：检查 `LaunchedEffect` 的 key 是否稳定：

```kotlin
LaunchedEffect(key1 = stableId) { // 使用稳定标识
    fetchData()
}
```

### **问题 2：内存泄漏**

**现象**：Composable 卸载后未释放资源  
**解决**：确保所有资源在 `onDispose` 中清理：

```kotlin
DisposableEffect(Unit) {
    val listener = { ... }
    addListener(listener)
    onDispose { removeListener(listener) } // 必须清理
}
```

### **问题 3：状态不一致**

**现象**：副作用中使用旧状态  
**解决**：使用最新状态引用：

```kotlin
LaunchedEffect(key1 = query) {
    // 使用 snapshotFlow 捕获最新状态
    snapshotFlow { query }
        .collect { latestQuery ->
            search(latestQuery)
        }
}
```

---

## 五、高级场景

### 1. **跨 Composable 副作用协调**

```kotlin
// 共享 ViewModel 中的状态
class SharedViewModel : ViewModel() {
    private val _data = MutableStateFlow("")
    val data: StateFlow<String> = _data
    
    fun loadData() { /* ... */ }
}

@Composable
fun ScreenA(viewModel: SharedViewModel = viewModel()) {
    LaunchedEffect(Unit) {
        viewModel.loadData() // 触发数据加载
    }
}

@Composable
fun ScreenB(viewModel: SharedViewModel = viewModel()) {
    val data by viewModel.data.collectAsState()
    Text(data)
}
```

### 2. **自定义 Effect API**

```kotlin
@Composable
fun CustomEffect(
    effectKey: Any?,
    onStart: () -> Unit,
    onDispose: () -> Unit
) {
    DisposableEffect(effectKey) {
        onStart()
        onDispose { onDispose() }
    }
}

// 使用
CustomEffect(
    effectKey = userId,
    onStart = { trackUser(userId) },
    onDispose = { stopTracking(userId) }
)
```

---

## 六、调试工具

### 1. **重组计数器**

```kotlin
@Composable
fun RecompositionCounter() {
    val count = remember { mutableStateOf(0) }
    SideEffect { count.value++ }
    Text("Recomposed ${count.value} times")
}
```

### 2. **日志追踪**

```kotlin
LaunchedEffect(key1 = query) {
    Log.d("Effect", "Start search: $query")
    try {
        search(query)
    } finally {
        Log.d("Effect", "End search: $query")
    }
}
```

---

## 总结

Jetpack Compose 的副作用管理遵循以下核心原则：

1. **生命周期绑定**：副作用必须与 Composable 的进入/退出同步  
2. **资源安全**：确保所有资源在拆卸时释放  
3. **状态一致性**：避免在副作用中使用过期状态  

通过合理使用 `LaunchedEffect`、`DisposableEffect` 等 API，可以构建出安全高效的响应式 UI。对于复杂场景，建议结合 `ViewModel` 和状态容器（如 `StateFlow`）进行分层管理。

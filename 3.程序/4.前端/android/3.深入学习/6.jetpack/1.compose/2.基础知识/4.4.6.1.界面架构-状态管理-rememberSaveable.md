# rememberSaveable

在 Jetpack Compose 中，`rememberSaveable` 是用于在 **配置变更（如屏幕旋转）** 和 **进程死亡后重建** 时恢复状态的关键 API。以下是其核心用法和注意事项：

---

## 一、基础用法

### 1. 保存基本数据类型

```kotlin
@Composable
fun BasicExample() {
    // 自动支持 Bundle 可保存类型（Int, String, Boolean 等）
    var count by rememberSaveable { mutableStateOf(0) }
    var text by rememberSaveable { mutableStateOf("") }

    Column {
        Button(onClick = { count++ }) {
            Text("Count: $count")
        }
        TextField(value = text, onValueChange = { text = it })
    }
}
```

- **特性**：数据会自动通过 `Bundle` 序列化/反序列化
- **支持类型**：基本类型、`Parcelable` 对象、`@Serializable` 对象等

---

## 二、自定义对象保存

### 1. 实现 Parcelable

```kotlin
@Parcelize
data class User(val name: String, val age: Int) : Parcelable

@Composable
fun ParcelableExample() {
    var user by rememberSaveable { mutableStateOf(User("Alice", 25)) }
    
    Button(onClick = { user = user.copy(age = user.age + 1) }) {
        Text("${user.name} is ${user.age} years old")
    }
}
```

### 2. 使用自定义 Saver（非 Parcelable 对象）

```kotlin
data class Settings(val darkMode: Boolean, val fontSize: Int)

// 创建自定义 Saver
val SettingsSaver = listSaver<Settings, Any>(
    save = { listOf(it.darkMode, it.fontSize) },
    restore = { Settings(it[0] as Boolean, it[1] as Int) }
)

@Composable
fun CustomSaverExample() {
    var settings by rememberSaveable(stateSaver = SettingsSaver) {
        mutableStateOf(Settings(false, 16))
    }
    
    Switch(
        checked = settings.darkMode,
        onCheckedChange = { settings = settings.copy(darkMode = it) }
    )
}
```

---

## 三、集合类型处理

### 1. 简单列表

```kotlin
@Composable
fun ListExample() {
    var list by rememberSaveable { mutableStateOf(listOf("A", "B")) }
    
    LazyColumn {
        items(list) { item ->
            Text(item)
        }
    }
}
```

- **要求**：列表元素必须是 `Parcelable` 或基本类型

### 2. 复杂列表（自定义 Saver）

```kotlin
data class Task(val id: Int, val title: String)

val TaskListSaver = listSaver<List<Task>, Any>(
    save = { taskList -> taskList.map { listOf(it.id, it.title) } },
    restore = { savedList -> 
        savedList.map { Task(it[0] as Int, it[1] as String) } 
)

@Composable
fun TaskList() {
    var tasks by rememberSaveable(stateSaver = TaskListSaver) {
        mutableStateOf(emptyList<Task>())
    }
}
```

---

## 四、高级配置

### 1. 多参数初始化

```kotlin
@Composable
fun MultiArgExample() {
    var state by rememberSaveable(
        saver = MyCustomSaver, // 自定义 Saver
        key = "MyKey"          // 可选：自定义保存键
    ) {
        mutableStateOf(MyState(initialValue = 10))
    }
}
```

### 2. 与 `LaunchedEffect` 配合（异步恢复）

```kotlin
@Composable
fun AsyncRestoreExample() {
    var data by rememberSaveable { mutableStateOf<List<Data>?>(null) }

    LaunchedEffect(Unit) {
        if (data == null) {
            data = loadFromNetwork() // 首次加载或恢复失败时重新获取
        }
    }
}
```

---

## 五、与 `remember` 的对比

| 特性                | `remember`            | `rememberSaveable`          |
|---------------------|-----------------------|-----------------------------|
| **作用范围**         | 重组期间保持状态       | 跨进程死亡保持状态           |
| **存储位置**         | 内存                  | Bundle（磁盘）               |
| **适用场景**         | 临时 UI 状态          | 需要持久化的关键状态         |
| **数据类型限制**     | 无                    | 需可序列化                  |

---

## 六、常见问题解决方案

### 1. **状态未恢复**

- **检查项**：
  - 确认对象实现了 `Parcelable` 或配置了正确的 `Saver`
  - 验证 `Bundle` 大小未超出限制（默认 1MB）
  - 使用 `adb shell dumpsys activity services` 检查保存状态

### 2. **类型转换异常**

```kotlin
// 错误示例：未正确处理类型转换
val BadSaver = listSaver<Settings, Any>(
    restore = { Settings(it[0], it[1]) } // 缺少类型转换
)

// 正确写法：
restore = { Settings(it[0] as Boolean, it[1] as Int) }
```

### 3. **性能优化**

- **延迟恢复大对象**：

  ```kotlin
  var bitmap by rememberSaveable {
      mutableStateOf<Bitmap?>(null)
  }
  
  if (bitmap == null) {
      LaunchedEffect(Unit) {
          bitmap = loadCompressedBitmap() // 异步加载压缩后的图片
      }
  }
  ```

---

## 七、最佳实践

1. **分层管理**：

   ```kotlin
   // UI 层使用 rememberSaveable
   @Composable
   fun MyComponent() {
       var uiState by rememberSaveable { mutableStateOf(UiState()) }
   }
   
   // 业务层使用 ViewModel + SavedStateHandle
   class MyViewModel(savedStateHandle: SavedStateHandle) : ViewModel() {
       val uiState = savedStateHandle.getStateFlow("key", initialState)
   }
   ```

2. **安全存储**：

   ```kotlin
   // 敏感数据加密保存
   val secureSaver = Saver<String, String>(
       save = { encrypt(it) },
       restore = { decrypt(it) }
   )
   
   var token by rememberSaveable(stateSaver = secureSaver) {
       mutableStateOf("")
   }
   ```

---

通过合理使用 `rememberSaveable`，可以确保关键 UI 状态在应用的生命周期中持久化，同时保持代码的简洁性。对于复杂场景，建议结合 `ViewModel` 的 `SavedStateHandle` 实现更完善的状态恢复机制。


# Activity的导航

在 Jetpack Compose 中，**Activity 的导航方式发生了显著变化**，核心逻辑从「多 Activity 跳转」转向「单 Activity + 可组合项（Composable）管理」，传统基于 `Intent` 的 Activity 导航退化为补充方案。以下是具体变化及对比：

## 一、传统 Activity 导航（Intent 方式）的保留与限制

### 1. **仍可用，但不推荐**

- **用法**：通过 `LocalContext.current.startActivity(intent)` 启动新 Activity，与传统开发一致。
- **场景**：仅用于 **混合开发**（如从 Compose 跳转到原生 Activity）或 **跨应用跳转**，不建议用于应用内页面切换。
- **缺点**：
  - 每次跳转创建新 Activity，资源消耗大，状态难管理。
  - 无法利用 Compose 的声明式特性（如自动状态恢复、动画过渡）。
- **示例**：

     ```kotlin
     @Composable
     fun ComposeScreen() {
         val context = LocalContext.current
         Button(onClick = {
             val intent = Intent(context, NativeActivity::class.java)
             context.startActivity(intent)
         }) {
             Text("跳转到原生 Activity")
         }
     }
     ```

### 2. **返回数据的变化**

- 传统 `startActivityForResult` 需配合 `ActivityResultLauncher`，但在 Compose 中更推荐通过 **回调或 ViewModel 共享状态** 实现数据回传。

## 二、Compose 推荐的导航方式：单 Activity + Navigation-Compose

### 1. **核心变化：Activity 仅作为宿主**

- **单 Activity 架构**：整个应用只需一个 Activity，所有页面由可组合项（@Composable）承载，通过 `NavHost` 在同一个 Activity 内切换界面。
- **优势**：
  - 减少 Activity 实例创建，提升性能。
  - 统一管理导航状态（如返回栈、深层链接）。
  - 无缝集成 Compose 的重组特性（如配置变更时自动恢复状态）。

### 2. **关键组件**

- **`NavController`**：通过 `rememberNavController()` 创建，管理导航逻辑（跳转、回退）。
- **`NavHost`**：定义导航图，关联 `NavController` 和可组合项，指定起始页面（`startDestination`）。
- **`composable`**：注册可组合项的路由（如 `composable("home") { HomeScreen() }`）。

### 3. **示例：单 Activity 内的导航**

   ```kotlin
   // MainActivity 仅设置 Content
   class MainActivity : AppCompatActivity() {
       override fun onCreate(savedInstanceState: Bundle?) {
           super.onCreate(savedInstanceState)
           setContent {
               AppNavHost() // 所有页面在 NavHost 内切换
           }
       }
   }

   @Composable
   fun AppNavHost() {
       val navController = rememberNavController()
       NavHost(navController, startDestination = "splash") {
           composable("splash") { SplashScreen(navController) }
           composable("home") { HomeScreen(navController) }
       }
   }

   @Composable
   fun SplashScreen(navController: NavController) {
       Button(onClick = { navController.navigate("home") }) {
           Text("跳转到主页")
       }
   }
   ```

## 三、混合场景：Compose 与 Activity 的互操作

### 1. **从 Compose 跳转到 Activity**

- 仍需 `Intent`，但推荐**仅用于无法用 Compose 实现的场景**（如系统设置页）。
- **示例**：

     ```kotlin
     @Composable
     fun ComposeToActivity() {
         val context = LocalContext.current
         Button(onClick = {
             context.startActivity(Intent(context, LegacyActivity::class.java))
         }) {
             Text("跳转到旧 Activity")
         }
     }
     ```

### 2. **从 Activity 跳回 Compose**

- Activity 需通过 `NavHostFragment` 集成 Compose 导航，利用 `NavController` 跳转回 Compose 页面。
- **示例**（在原生 Activity 中）：

     ```kotlin
     class LegacyActivity : AppCompatActivity() {
         override fun onCreate(savedInstanceState: Bundle?) {
             super.onCreate(savedInstanceState)
             setContentView(R.layout.activity_legacy)
             val navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment) as NavHostFragment
             val navController = navHostFragment.navController
             findViewById<Button>(R.id.btn_back).setOnClickListener {
                 navController.navigate("home") // 跳转回 Compose 主页
             }
         }
     }
     ```

## 四、导航逻辑的本质变化

| **维度**         | **传统 Activity 导航**                | **Compose 导航（单 Activity）**          |
|------------------|---------------------------------------|------------------------------------------|
| **页面单位**      | Activity（重量级组件）                | 可组合项（轻量级函数）                   |
| **状态管理**      | 依赖 Activity 生命周期                | 依赖 `NavBackStackEntry` 和 ViewModel     |
| **参数传递**      | Intent.putExtra（有限类型）           | 路由参数（如 `navigate("user/123")`）+ SavedStateHandle |
| **返回栈控制**    | 系统自动管理（按返回键销毁 Activity）  | 显式控制（`popUpTo`、`launchSingleTop`）  |
| **动画支持**      | 需自定义 Activity 切换动画            | 内置 `AnimatedContent` 或导航过渡动画     |

## 五、最佳实践建议

1. **优先使用 Navigation-Compose**：应用内所有页面跳转通过 `NavHost` 管理，避免新增 Activity。
2. **单 Activity 架构**：减少组件冗余，利用 Compose 的状态恢复能力（如 `saveState = true`）。
3. **混合场景慎用 Intent**：仅在必要时（如调用系统功能）使用 Activity 跳转，其余场景用可组合项替代。
4. **参数传递避坑**：避免在路由中传递复杂对象，改用 ID 加载数据（见 Google 官方文档推荐）。

## 总结：导航方式的核心演进

Compose 彻底改变了 Activity 的导航逻辑——**Activity 从「页面载体」退化为「应用容器」**，页面切换由轻量级的可组合项和 `NavHost` 完成。传统 Intent 跳转仅作为兼容方案存在，新开发的 Compose 应用应完全拥抱单 Activity + Navigation-Compose 的范式，以获得更好的性能、状态管理和开发体验。

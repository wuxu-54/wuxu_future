
# 高级动画示例:手势

原地址：<https://developer.android.google.cn/develop/ui/compose/animation/advanced?hl=zh-cn>

## 一、处理触摸事件与动画的核心原则

1. **用户互动优先级**：触摸事件发生时，需中断正在播放的动画，确保用户操作即时响应。
2. **关键组件**：
   - `Animatable<Type>`：用于表示可动画化的值（如位置、偏移量），支持动画中断和速度保持。
   - `pointerInput`修饰符：处理触摸事件，配合协程实现异步事件监听。
   - `VelocityTracker`：跟踪拖动事件的速度，用于计算投掷动画的衰减。

## 二、点按事件驱动的动画示例

### 1. 功能说明

点击屏幕时，圆形组件通过动画平滑移动到点击位置，若动画未完成时再次点击，会中断当前动画并启动新动画。

### 2. 核心代码分析

```kotlin
@Composable fun Gesture() {
    val offset = remember { Animatable(Offset.Zero, Offset.VectorConverter) } // 初始化偏移量动画对象
    
    Box(
        modifier = Modifier.fillMaxSize()
            .pointerInput(Unit) { // 触摸事件处理
                coroutineScope {
                    while (true) {
                        awaitPointerEventScope {
                            val position = awaitFirstDown().position // 等待首次按下事件并获取位置
                            launch {
                                offset.animateTo(position) // 动画过渡到点击位置，自动中断旧动画
                            }
                        }
                    }
                }
            }
    ) {
        Circle(modifier = Modifier.offset { offset.value.toIntOffset() }) // 根据动画值更新位置
    }
}

private fun Offset.toIntOffset() = IntOffset(x.roundToInt(), y.roundToInt()) // 类型转换辅助函数
```

### 3. 关键逻辑

- `awaitFirstDown()`：阻塞当前协程，直至检测到新的按下事件。
- `animateTo(targetValue)`：启动动画到目标值，若当前有动画正在运行，会立即中断并以当前速度转向新目标。

### 4. 流程图

```mermaid
flowchart TD
    A[检测到点按事件] --> B[获取点击位置]
    B --> C[调用offset.animateTo(新位置)]
    C --> D{是否有正在运行的动画?}
    D -->|是| E[中断旧动画，保持速度]
    D -->|否| F[直接启动新动画]
    E --> G[动画过渡到新位置]
    F --> G
```

## 三、滑动关闭（Swipe to Dismiss）实现

### 1. 功能说明

通过拖动元素实现滑动关闭效果：缓慢滑动时元素自动回弹，快速滑动时元素消失并触发关闭回调。

### 2. 核心代码分析

```kotlin
fun Modifier.swipeToDismiss(onDismissed: () -> Unit): Modifier = composed {
    val offsetX = remember { Animatable(0f) } // 水平偏移动画对象
    
    pointerInput(Unit) {
        val decay = splineBasedDecay<Float>(this) // 速度衰减计算器
        coroutineScope {
            while (true) {
                val velocityTracker = VelocityTracker() // 速度跟踪器
                
                offsetX.stop() // 停止当前动画，拦截用户输入
                
                awaitPointerEventScope {
                    val pointerId = awaitFirstDown().id // 记录触摸点ID
                    horizontalDrag(pointerId) { change ->
                        // 拖动过程中实时更新偏移量（不使用动画，直接快照）
                        launch { offsetX.snapTo(offsetX.value + change.positionChange().x) }
                        velocityTracker.addPosition(change.uptimeMillis, change.position) // 记录速度数据
                    }
                }
                
                // 计算拖动速度和目标偏移量
                val velocity = velocityTracker.calculateVelocity().x
                val targetOffsetX = decay.calculateTargetValue(offsetX.value, velocity)
                
                // 更新动画边界（限制滑动范围）
                offsetX.updateBounds(lowerBound = -size.width.toFloat(), upperBound = size.width.toFloat())
                
                launch {
                    if (targetOffsetX.abs() <= size.width) {
                        // 速度不足，滑回原点
                        offsetX.animateTo(0f, initialVelocity = velocity)
                    } else {
                        // 速度足够，执行衰减动画并触发关闭
                        offsetX.animateDecay(velocity, decay)
                        onDismissed()
                    }
                }
            }
        }
    }.offset { IntOffset(offsetX.value.roundToInt(), 0) } // 应用偏移
}
```

### 3. 关键逻辑

- `offsetX.stop()`：在触摸开始时停止动画，确保用户拖动操作优先。
- `snapTo(value)`：直接将动画值设置为目标值，用于实时响应用户拖动。
- `VelocityTracker`+`splineBasedDecay`：计算拖动速度和衰减轨迹，判断元素是回弹还是消失。
- `animateDecay(velocity, decay)`：根据速度和衰减模型执行投掷动画，模拟惯性滑动。

### 4. 流程图

```mermaid
flowchart TD
    A[检测到拖动事件] --> B[调用offsetX.stop()停止动画]
    B --> C[拖动过程中调用snapTo更新实时偏移]
    C --> D[拖动结束，计算拖动速度velocity]
    D --> E[计算目标偏移量targetOffsetX]
    E --> F{targetOffsetX绝对值 > 屏幕宽度?}
    F -->|是| G[执行animateDecay衰减动画，触发onDismissed]
    F -->|否| H[执行animateTo滑回原点]
```

## 四、核心API总结

| API名称                | 作用描述                                                                 |
|-------------------------|--------------------------------------------------------------------------|
| `Animatable.animateTo`   | 启动动画到目标值，中断正在运行的动画并保持速度                           |
| `Animatable.stop()`      | 停止动画，冻结当前值                                                     |
| `Animatable.snapTo()`    | 直接设置动画值，不执行动画过渡                                           |
| `Animatable.animateDecay`| 根据速度和衰减模型执行惯性动画                                           |
| `VelocityTracker`        | 跟踪触摸事件的位置和时间，用于计算拖动速度                               |
| `splineBasedDecay`       | 基于样条曲线的衰减计算器，用于模拟物理滑动的减速效果                     |

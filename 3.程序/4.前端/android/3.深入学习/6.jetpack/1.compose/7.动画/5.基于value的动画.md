
# 基于价值的动画  

原地址：<https://developer.android.google.cn/develop/ui/compose/animation/value-based?hl=zh-cn>  

## 一、高级动画 API  

### 1. `animate*AsState`：单值动画  

**功能**：为单个值（如 `Float`、`Color`、`Dp` 等）创建动画，自动管理动画过程（中断、平滑过渡）。  
**核心特点**：  

- 只需提供目标值，系统自动处理动画逻辑（基于 `Animatable` 实现）。  
- 支持自定义动画规格（`AnimationSpec`，如弹簧、补间）。  
- 适用于简单属性动画（如透明度、尺寸、位置）。  

**示例：Alpha 动画**  

```kotlin  
var enabled by remember { mutableStateOf(true) }  
val animatedAlpha by animateFloatAsState(if (enabled) 1f else 0.5f)  
Box(modifier = Modifier.graphicsLayer { alpha = animatedAlpha })  
```  

**支持类型**：  

- 基础类型：`Float`、`Color`、`Dp`、`Offset` 等。  
- 自定义类型：通过 `animateValueAsState` + `TwoWayConverter` 扩展。  

### 2. `Transition`：多属性同步动画  

**功能**：管理多个动画状态，实现多属性同步过渡（如尺寸、颜色、阴影同时变化）。  
**核心用法**：  

1. **定义状态**（如枚举类型）：  

   ```kotlin  
   enum class BoxState { Collapsed, Expanded }  
   ```  

2. **创建过渡**：  

   ```kotlin  
   var currentState by remember { mutableStateOf(BoxState.Collapsed) }  
   val transition = updateTransition(currentState, label = "box-state")  
   ```  

3. **定义子动画**：  

   ```kotlin  
   val size by transition.animateDp { state ->  
       if (state == BoxState.Expanded) 128.dp else 64.dp  
   }  
   val color by transition.animateColor { state ->  
       if (state == BoxState.Expanded) Color.Red else Color.Gray  
   }  
   ```  

4. **组合动画规格**：  

   ```kotlin  
   val color by transition.animateColor(  
       transitionSpec = { spring(stiffness = 50f) }, // 自定义过渡规格  
       label = "color"  
   ) { state -> ... }  
   ```  

**高级用法**：  

- **子过渡**：通过 `createChildTransition` 拆分复杂动画逻辑。  
- **与 `AnimatedVisibility/AnimatedContent` 结合**：将过渡状态绑定到显隐或内容切换动画。  

### 3. `rememberInfiniteTransition`：无限循环动画  

**功能**：创建永久运行的循环动画（如呼吸效果、颜色渐变）。  
**示例：无限颜色循环**  

```kotlin  
val infiniteTransition = rememberInfiniteTransition()  
val color by infiniteTransition.animateColor(  
    initialValue = Color.Red,  
    targetValue = Color.Green,  
    animationSpec = infiniteRepeatable(tween(1000), RepeatMode.Reverse)  
)  
Box(modifier = Modifier.background(color))  
```  

## 二、低级动画 API  

### 1. `Animatable`：基于协程的单值控制  

**功能**：手动控制单个值的动画（支持中断、自定义起始值），适用于手势驱动或复杂交互。  
**核心方法**：  

- `animateTo(targetValue, spec)`：平滑过渡到目标值（挂起函数）。  
- `snapTo(value)`：立即跳转至目标值（无动画）。  
- `animateDecay(initialVelocity)`：衰减动画（如滑动惯性）。  

**示例：协程驱动的颜色动画**  

```kotlin  
val color = remember { Animatable(Color.Gray) }  
LaunchedEffect(enable) {  
    color.animateTo(if (enable) Color.Green else Color.Red)  
}  
Box(modifier = Modifier.background(color.value))  
```  

### 2. `Animation`：底层动画引擎  

**功能**：手动管理动画时间（适用于自定义动画逻辑，如帧同步控制）。  
**子类型**：  

- **`TargetBasedAnimation`**：基于目标值的动画（需指定起始/结束值）。  
- **`DecayAnimation`**：衰减动画（基于初始速度，如滑动减速）。  

**示例：手动控制帧动画**  

```kotlin  
val anim = remember { TargetBasedAnimation(tween(200), Float.VectorConverter, 200f, 1000f) }  
LaunchedEffect(anim) {  
    var playTime = 0L  
    do {  
        playTime = withFrameNanos { it }  
        val value = anim.getValueFromNanos(playTime)  
        // 更新界面  
    } while (playTime < anim.spec.durationNanos)  
}  
```  

## 三、封装与复用  

### 1. 过渡逻辑抽离  

**场景**：复杂组件中分离动画逻辑，提高复用性。  
**实现方式**：  

```kotlin  
// 封装过渡数据  
class TransitionData(  
    val color: State<Color>,  
    val size: State<Dp>  
)  

@Composable  
fun updateTransitionData(state: BoxState): TransitionData {  
    val transition = updateTransition(state)  
    val color = transition.animateColor { ... }  
    val size = transition.animateDp { ... }  
    return remember(transition) { TransitionData(color, size) }  
}  

// 使用封装的过渡  
@Composable  
fun AnimatingBox(state: BoxState) {  
    val data = updateTransitionData(state)  
    Box(modifier = Modifier.background(data.color).size(data.size))  
}  
```  

## 四、流程图（mermaid）  

```mermaid  
graph LR  
A[基于价值的动画] --> B[高级API]  
A --> C[低级API]  
B --> D[animate*AsState<br>单值动画]  
B --> E[Transition<br>多属性同步]  
B --> F[rememberInfiniteTransition<br>无限循环]  
C --> G[Animatable<br>协程驱动单值]  
C --> H[Animation<br>底层时间控制]  
E --> I[子过渡(createChildTransition)]  
E --> J[与AnimatedVisibility结合]  
G --> K[animateTo/snapTo/animateDecay]  
H --> L[TargetBasedAnimation<br>目标驱动]  
H --> M[DecayAnimation<br>衰减驱动]  
```  

## 五、核心对比  

| **API**                | **适用场景**                          | **控制粒度**       | **典型用法**                  |  
|------------------------|---------------------------------------|--------------------|-------------------------------|  
| `animate*AsState`       | 简单单值动画（如透明度、尺寸）        | 自动              | 按钮点击反馈、组件显隐过渡    |  
| `Transition`           | 多属性同步动画（如尺寸+颜色+位置）    | 状态驱动          | 组件展开/收缩、复杂交互状态  |  
| `rememberInfiniteTransition` | 循环动画（如呼吸效果、加载指示器）  | 自动循环          | 无限重复的视觉反馈           |  
| `Animatable`           | 手势驱动动画（如拖拽、滑动惯性）      | 手动（协程）      | 自定义手势交互、投掷效果      |  
| `Animation`            | 自定义帧动画、底层时间控制            | 底层（手动）      | 特殊动画效果、性能优化场景    |  

通过选择合适的 API，可在开发效率与控制精度之间取得平衡，满足从简单到复杂的动画需求。

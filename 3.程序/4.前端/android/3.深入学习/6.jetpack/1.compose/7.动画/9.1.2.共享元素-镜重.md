
# 镜重

在 Android Compose 的共享元素转换（Shared Element Transitions）中，**镜重**可理解为**作用域匹配**与**边界对齐**的核心机制，用于确保不同界面的共享元素在过渡时实现视觉无缝衔接。以下是关键概念与实践总结：

## 一、镜重的本质：作用域与键的协同匹配  

### 1. **作用域（Scope）的核心作用**  

- **`SharedTransitionLayout`**：作为根布局，创建`SharedTransitionScope`作用域，标记共享元素的有效范围。  
- **`AnimatedVisibilityScope`**：由`AnimatedContent`或`AnimatedVisibility`提供，控制元素显隐与动画的时间轴同步。  

**示例结构**：  

```kotlin  
SharedTransitionLayout { // 提供 SharedTransitionScope  
    AnimatedContent(showDetail) { targetState ->  
        // 不同状态的可组合项需在同一作用域内  
        if (targetState) DetailScreen(scope = this) else ListScreen(scope = this)  
    }  
}  
```

### 2. **唯一键（Key）的唯一性原则**  

- **目的**：通过`rememberSharedContentState(key)`为共享元素分配唯一标识，确保跨界面匹配。  
- **最佳实践**：  
  - 使用`数据类`而非字符串（避免键冲突）：  

    ```kotlin  
    data class SharedKey(val id: String, val type: String)  
    rememberSharedContentState(key = SharedKey("item_1", "image"))  
    ```  

  - 列表场景需附加项ID：  

    ```kotlin  
    items(list) { item ->  
        Image(modifier = Modifier.sharedElement(rememberSharedContentState(key = "item_${item.id}_image")))  
    }  
    ```

## 二、镜重的实现要点：修饰符与边界管理  

### 1. **修饰符顺序的黄金法则**  

- **尺寸无关修饰符**（如`padding`、`clip`）应位于`sharedElement`**之前**，参与边界计算。  
- **尺寸相关修饰符**（如`size`、`aspectRatio`）应位于`sharedElement`**之后**，避免布局跳跃。  

**正确顺序示例**：  

```kotlin  
Box(  
    Modifier  
        .padding(16.dp)       // 非尺寸修饰符（前置）  
        .sharedElement(...)   // 共享元素标记  
        .size(100.dp)         // 尺寸修饰符（后置）  
        .clip(RoundedCornerShape(8.dp)) // 非尺寸修饰符（前置）  
)  
```

### 2. **边界模式（`resizeMode`）选择**  

| 模式                | 行为描述                                                                 | 适用场景               |  
|---------------------|--------------------------------------------------------------------------|------------------------|  
| `ScaleToBounds`     | 缩放元素以填充目标边界（不重排内容，适合文本）                             | 字体大小/颜色变化      |  
| `RemeasureToBounds` | 按目标尺寸重新测量布局（触发布局重排，适合图片）                           | 图片尺寸/宽高比变化    |  

**文本过渡推荐**：  

```kotlin  
Modifier.sharedBounds(resizeMode = SharedTransitionScope.ResizeMode.ScaleToBounds())  
```

## 三、镜重的作用域传递策略  

### 1. **参数传递（推荐）**  

直接将作用域作为参数传入子组件，避免嵌套层级冲突：  

```kotlin  
@Composable  
fun ListItem(  
    sharedScope: SharedTransitionScope,  
    animScope: AnimatedVisibilityScope,  
    item: Item  
) {  
    Image(  
        modifier = Modifier  
            .sharedElement(  
                state = rememberSharedContentState(key = item.id),  
                animatedVisibilityScope = animScope // 关联显隐作用域  
            ),  
        painter = item.painter  
    )  
}  
```

### 2. **组合本地（CompositionLocal）**  

在深层嵌套布局中通过`CompositionLocal`共享作用域：  

```kotlin  
val LocalSharedScope = compositionLocalOf<SharedTransitionScope> {  
    error("No SharedTransitionScope provided")  
}  

SharedTransitionLayout {  
    CompositionLocalProvider(LocalSharedScope provides this) {  
        NestedScreen() // 子组件通过 LocalSharedScope.current 访问  
    }  
}  
```

## 四、镜重常见问题与解决方案  

### 1. **边界不匹配导致的跳跃**  

- **原因**：两侧界面的修饰符顺序或尺寸计算不一致。  
- **解决方案**：  
  - 确保共享元素的修饰符顺序一致（如`padding → sharedElement → size`）。  
  - 使用`requiredSize()`强制固定尺寸：  

    ```kotlin  
    Modifier  
        .sharedElement(...)  
        .requiredSize(if (isDetail) 200.dp else 100.dp) // 固定尺寸，避免重排  
    ```

### 2. **作用域冲突（如多层 AnimatedContent）**  

- **原因**：嵌套的`AnimatedContent`覆盖了父级作用域。  
- **解决方案**：通过参数传递而非隐式作用域，或使用`CompositionLocal`显式指定：  

  ```kotlin  
  // 显式传递作用域，避免嵌套覆盖  
  SharedTransitionLayout { parentScope ->  
      AnimatedContent {  
          AnimatedContent { childScope ->  
              Item(sharedScope = parentScope, animScope = childScope)  
          }  
      }  
  }  
  ```

## 五、镜重与导航集成：跨页面共享元素  

在`NavHost`中使用共享元素时，需将`SharedTransitionLayout`作为根布局，并传递作用域到路由组件：  

```kotlin  
SharedTransitionLayout { sharedScope ->  
    NavHost(navController, startDestination = "list") {  
        composable("list") {  
            ListScreen(  
                onItemClick = { id ->  
                    navController.navigate("detail/$id") {  
                        // 携带共享元素键（需与详情页匹配）  
                        popUpTo("list") { inclusive = true }  
                    }  
                },  
                sharedScope = sharedScope // 传递根作用域  
            )  
        }  
        composable("detail/{id}") { backStackEntry ->  
            DetailScreen(  
                id = backStackEntry.arguments?.getString("id"),  
                sharedScope = sharedScope // 使用同一作用域  
            )  
        }  
    }  
}  
```

## 六、总结：镜重的核心目标  

**镜重的本质是确保共享元素在不同界面的视觉连续性**，通过以下手段实现：  

1. **唯一键**：精准匹配元素身份（避免“张冠李戴”）。  
2. **作用域**：统一动画时间轴与布局范围（避免“各自为战”）。  
3. **修饰符与边界**：控制布局计算顺序与尺寸变化模式（避免“布局跳跃”）。  

通过合理管理镜重机制，可在 Compose 中实现如列表到详情页的丝滑过渡，提升用户体验的空间感知与交互流畅度。

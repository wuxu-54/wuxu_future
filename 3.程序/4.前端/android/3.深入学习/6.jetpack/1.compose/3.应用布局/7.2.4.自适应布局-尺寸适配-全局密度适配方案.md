# 尺寸适配-保证与设计稿相同

>仍是采用原来android尺寸适配的代码修改Denisty的方式

在 Jetpack Compose 中实现屏幕适配并确保尺寸与设计稿一致，核心思路是**动态修改 `density` 值**（今日头条适配方案），使不同设备的屏幕宽度（或高度）在逻辑上等于设计稿的宽度（或高度），从而直接使用设计稿中的 DP 值。以下是具体方案及实现步骤：

---

## ⚙️ 一、适配原理

1. **默认 DP 的局限性**：  
   Android 通过公式 `px = dp × density` 转换单位，但不同设备的 `density` 由厂商设定（如 1080px 屏幕可能为 360dp 或 411dp），导致相同 DP 值在不同设备上占据屏幕比例不同。
2. **修改 density 值**：  
   - 若设计稿宽度为 360dp，设备实际宽度为 `widthPixels`（px）。  
   - 计算新 `density = widthPixels / 360`，使设备逻辑宽度恒为 360dp，此时直接使用设计稿的 DP 值即可完美还原。

---

## 🛠 二、Compose 实现步骤（以竖屏为例）

以下代码集成到主题（`Theme`）中，全局生效：

```kotlin
@Composable
fun MyAppTheme(
    designWidth: Dp = 360.dp, // 设计稿宽度（单位：dp）
    content: @Composable () -> Unit
) {
    val context = LocalContext.current
    val displayMetrics = context.resources.displayMetrics
    val widthPixels = displayMetrics.widthPixels.toFloat()
    val fontScale = LocalDensity.current.fontScale // 保留系统字体缩放

    // 计算新 density：屏幕宽度（px）/ 设计稿宽度（dp）
    val newDensity = widthPixels / designWidth.value

    CompositionLocalProvider(
        LocalDensity provides Density(
            density = newDensity, 
            fontScale = fontScale // 避免影响 SP 单位
        )
    ) {
        MaterialTheme(content = content)
    }
}
```

**使用方式**：

```kotlin
MyAppTheme(designWidth = 360.dp) { // 与设计稿宽度一致
    Surface {
        Text("适配文本", fontSize = 16.sp) // 直接使用设计稿尺寸
        Box(Modifier.size(180.dp)) // 占据屏幕一半宽度
    }
}
```

---

## 🔧 三、横竖屏适配优化

根据屏幕方向动态选择基准（宽度或高度）：

```kotlin
val config = LocalConfiguration.current
val isPortrait = config.orientation == Configuration.ORIENTATION_PORTRAIT
val designSize = DpSize(360.dp, 640.dp) // 设计稿尺寸

// 竖屏以宽度为基准，横屏以高度为基准
val newDensity = if (isPortrait) {
    widthPixels / designSize.width.value
} else {
    heightPixels / designSize.height.value
}
```

---

## ⚠️ 四、注意事项

1. **字体缩放（SP 单位）**：  
   保留 `fontScale` 避免影响系统字体大小设置。
2. **第三方库影响**：  
   修改全局 `density` 可能使三方库 UI 变形，可通过 `CompositionLocalProvider` 限定作用域或恢复默认 `density` 隔离。
3. **折叠屏/多窗口适配**：  
   使用 `WindowSizeClass` 响应窗口尺寸变化，为不同尺寸（Compact/Medium/Expanded）提供独立设计稿尺寸：

   ```kotlin
   val windowSize = rememberWindowSizeClass()
   val designSize = when (windowSize.widthSizeClass) {
       WindowWidthSizeClass.Compact -> DpSize(360.dp, 640.dp) // 小屏
       else -> DpSize(480.dp, 800.dp) // 中/大屏
   }
   ```

4. **备用方案（不修改 density）**：  
   - **`BoxWithConstraints`**：根据实时尺寸动态调整布局：

     ```kotlin
     BoxWithConstraints {
         if (maxWidth < 600.dp) { /* 小屏布局 */ }
         else { /* 大屏布局 */ }
     }
     ```

   - **按比例缩放**：手动计算 DP 值（不推荐，增加复杂度）。

---

## 📊 五、方案对比

| **方案**               | **优点**                          | **缺点**                          | **适用场景**              |
|-------------------------|-----------------------------------|-----------------------------------|---------------------------|
| **修改 density**        | 直接使用设计稿 DP 值，代码简洁    | 影响全局，可能干扰三方库          | 常规应用，设计稿尺寸固定  |
| **BoxWithConstraints**  | 精准控制局部布局，无副作用        | 需手动编写响应式逻辑              | 复杂布局或多形态设备      |
| **WindowSizeClass**     | 原生支持折叠屏/分屏               | 需预定义多套尺寸                  | 适配大屏或折叠屏          |

---

## ✅ 六、最佳实践

1. **设计稿规范**：  
   - 统一使用 **DP 单位** 标注尺寸（如 Figma 设置为 360x640dp）。
2. **代码实施**：  
   - 在根 Composable（如 `Theme`）中修改 `LocalDensity`。
   - 横竖屏分离计算基准值。
3. **测试验证**：  
   - 在屏幕宽度差异大的设备（如 360dp 与 411dp）上检查元素占比是否与设计稿一致。

> 💡 通过动态重置 `density`，Compose 的屏幕适配成本显著低于传统 View 系统（无需多套 `dimens` 文件），且能精准还原设计效果。若遇到复杂场景（如混合原生 View），可结合 `BoxWithConstraints` 局部适配。

# Jetpack Compose 屏幕适配与字体处理完全指南

本文整合屏幕适配的核心知识，特别聚焦字体大小（FontSize）处理，涵盖设计稿单位解读、适配方案、横竖屏处理及最佳实践。

## 一、设计稿单位解析与转换

公式：

1. 设计稿基准密度density = 屏幕宽度（px）/ 设计稿宽度（dpi）

### 1. 设计稿单位解读

| 单位 | 含义 | 代码对应 | 适配要求 |
|------|------|----------|----------|
| **sp** | 缩放无关像素 | `16.sp` | 直接使用 |
| **dp** | 密度无关像素 | `16.dp` | 布局使用 |
| **px** | 物理像素 | 需转换 | 必须转换 |

### 2. px 到 sp 的转换原理

```txt
sp = px / (设备密度因子)
```

- **基准密度**：MDPI (160dpi) = 1.0
- 常见密度比例：
  - HDPI: 1.5x
  - XHDPI: 2.0x
  - XXHDPI: 3.0x

### 3. 转换工具函数

```kotlin
object DesignConverter {
    // 设计稿基准密度 (默认XHDPI)
    var designDensity: Float = 2f 
    
    // px转sp
    @Composable
    fun pxToSp(px: Int): TextUnit {
        return (px / designDensity).sp
    }
    
    // px转dp (用于布局)
    @Composable
    fun pxToDp(px: Int): Dp {
        return (px / designDensity).dp
    }
    
    // 响应式sp转换 (考虑屏幕方向)
    @Composable
    fun responsiveSp(px: Int): TextUnit {
        val config = LocalConfiguration.current
        val baseDp = if (config.orientation == ORIENTATION_LANDSCAPE) {
            config.screenHeightDp.toFloat()
        } else {
            config.screenWidthDp.toFloat()
        }
        val scale = baseDp / 360f // 设计稿基准宽度
        return (px / designDensity * scale).sp
    }
}
```

## 二、字体适配四大方案

### 1. 全局密度适配方案（推荐）

本方案采用修改密度，`CompositionLocalProvider`可以控制变化作用域，其中`fontScale`是字体缩放因子，不要修改，否则影响用户设置的字体缩放配置

```kotlin
@Composable
fun ScreenAdapter(
    designWidth: Float = 360f, // 设计稿宽度
    designHeight: Float = 640f, // 设计稿高度
    content: @Composable () -> Unit
) {
    val config = LocalConfiguration.current
    val displayMetrics = LocalContext.current.resources.displayMetrics
    
    val (baseSize, isLandscape) = remember(config) {
        val landscape = config.orientation == ORIENTATION_LANDSCAPE
        val size = if (landscape) designHeight else designWidth //最小宽度
        size to landscape
    }
    
    val density = displayMetrics.widthPixels / baseSize
    val fontScale = LocalDensity.current.fontScale
    
    CompositionLocalProvider(
        LocalDensity provides Density(
            density = density, 
            fontScale = fontScale // 保留用户设置
        )
    ) {
        content()
    }
}

// 使用
ScreenAdapter {
    Text("适配文本", fontSize = 16.sp) // 直接使用设计稿sp值
}
```

### 2. 扩展函数动态计算尺寸方案（设计稿给px时）

```kotlin
// 使用前面定义的DesignConverter
Text("标题", fontSize = DesignConverter.pxToSp(32))
```

### 3. 主题集成方案

```kotlin
@Immutable
data class AppTypography(
    val titleSp: TextUnit = 18.sp,
    val bodySp: TextUnit = 14.sp,
    val captionSp: TextUnit = 12.sp
) {
    // px转换方法
    @Composable
    fun titlePx(px: Int) = DesignConverter.pxToSp(px)
}

@Composable
fun AppTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val typography = AppTypography()
    
    MaterialTheme(
        typography = Typography(
            h5 = TextStyle(fontSize = typography.titleSp),
            body1 = TextStyle(fontSize = typography.bodySp)
        ),
        content = {
            ScreenAdapter { // 组合全局适配
                ProvideTextStyle(MaterialTheme.typography.body1) {
                    content()
                }
            }
        }
    )
}
```

### 4. em单位相对调整

```kotlin
Text(
    text = "主标题",
    fontSize = 18.sp,
    style = TextStyle(
        fontSize = 1.2.em // 子文本比父文本大20%
    )
)
```

## 三、横竖屏适配策略

### 1. 动态基准尺寸

```kotlin
val config = LocalConfiguration.current
val isLandscape = config.orientation == ORIENTATION_LANDSCAPE
val designBase = if (isLandscape) 640f else 360f // 不同方向不同基准
```

### 2. 字体响应式缩放

```kotlin
@Composable
fun AdaptiveText(
    text: String,
    pxSize: Int, // 设计稿px值
    modifier: Modifier = Modifier
) {
    val config = LocalConfiguration.current
    val density = LocalDensity.current.density
    
    val fontSize = remember(config) {
        val baseDp = if (config.orientation == ORIENTATION_LANDSCAPE) {
            config.screenHeightDp.toFloat()
        } else {
            config.screenWidthDp.toFloat()
        }
        val scale = baseDp / 360f
        (pxSize * scale / DesignConverter.designDensity).sp
    }
    
    Text(text, fontSize = fontSize, modifier = modifier)
}
```

## 四、最佳实践与测试

### 1. 开发规范

- **设计师**：提供基准设备参数（分辨率 + DPI）
- **开发者**：创建DesignConverter统一管理转换
- **团队**：建立设计系统文档（字体、间距规范）

### 2. 全面测试方案

```kotlin
// 1. 不同设备密度测试
@Preview(device = "spec:width=360dp,height=640dp,dpi=160") // MDPI
@Preview(device = "spec:width=360dp,height=640dp,dpi=480") // XXHDPI

// 2. 字体缩放测试
@Preview(fontScale = 1.0f)
@Preview(fontScale = 1.5f)
@Preview(fontScale = 2.0f)

// 3. 横竖屏测试
@Preview(name = "Portrait", widthDp = 360, heightDp = 640)
@Preview(name = "Landscape", widthDp = 640, heightDp = 360)

// 4. 暗色模式测试
@Preview(uiMode = Configuration.UI_MODE_NIGHT_NO)
@Preview(uiMode = Configuration.UI_MODE_NIGHT_YES)

@Composable
fun ComprehensivePreview() {
    AppTheme {
        Column {
            Text("标准sp文本", fontSize = 16.sp)
            Text("转换px文本", fontSize = DesignConverter.pxToSp(32))
            AdaptiveText("响应式文本", pxSize = 24)
        }
    }
}
```

### 3. 性能优化

```kotlin
// 使用remember减少重复计算
val fontSize = remember(key1 = config.orientation) {
    calculateFontSize(config)
}
```

## 五、常见问题解决方案

### Q1：设计稿未提供基准密度？

```kotlin
// 步骤1：假设主流XHDPI(2.0)
DesignConverter.designDensity = 2f

// 步骤2：在真实设备上验证
// 步骤3：按需调整系数
```

### Q2：第三方组件不适配？

```kotlin
// 方案1：包裹在适配上下文中
ScreenAdapter {
    ThirdPartyComponent()
}

// 方案2：单独缩放
Box {
    ThirdPartyComponent()
    
    // 覆盖字体样式
    ProvideTextStyle(LocalTextStyle.current.copy(fontSize = 14.sp)) {
        Text("覆盖文本")
    }
}
```

### Q3：平板设备特殊处理？

```kotlin
val isTablet = config.screenWidthDp >= 600
val fontSize = if (isTablet) {
    (baseSize * 1.2).sp
} else {
    baseSize.sp
}
```

## 六、总结：适配黄金法则

1. **单位处理**：
   - 设计稿sp → 直接使用`.sp`
   - 设计稿px → 通过`DesignConverter.pxToSp()`转换

2. **全局方案**：

   ```kotlin
   ScreenAdapter { /* 内容 */ } // 包裹根组件
   ```

3. **响应式设计**：
   - 横竖屏不同基准
   - 平板特殊处理
   - 使用`em`相对单位

4. **测试覆盖**：
   - 设备密度
   - 字体缩放
   - 屏幕方向
   - 暗色模式

5. **性能优化**：
   - 使用`remember`缓存计算
   - 避免重复转换

通过系统化实施这些方案，您的Compose应用将在各种设备和设置下保持完美的视觉表现，同时提供优秀的无障碍体验。

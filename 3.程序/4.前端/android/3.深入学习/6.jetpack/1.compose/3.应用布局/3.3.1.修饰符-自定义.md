
# Compose è‡ªå®šä¹‰ä¿®é¥°ç¬¦å¼€å‘æŒ‡å— ğŸ› ï¸

## ä¸€ã€è‡ªå®šä¹‰ä¿®é¥°ç¬¦æ ¸å¿ƒæ¦‚å¿µ

### ï¼ˆä¸€ï¼‰ç»„æˆéƒ¨åˆ†

1. **ä¿®é¥°ç¬¦å·¥å‚**ï¼šæ‰©å±•`Modifier`çš„å‡½æ•°ï¼Œæä¾›é“¾å¼è°ƒç”¨APIï¼ˆå¦‚`Modifier.myModifier()`ï¼‰ã€‚
2. **ä¿®é¥°ç¬¦å…ƒç´ **ï¼šå®ç°å…·ä½“é€»è¾‘çš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œåˆ†ä¸ºä¸¤ç§å®ç°æ–¹å¼ï¼š
   - **ç»„åˆç°æœ‰ä¿®é¥°ç¬¦**ï¼šé€šè¿‡ç°æœ‰ä¿®é¥°ç¬¦ç»„åˆå®ç°ï¼ˆç®€å•åœºæ™¯ï¼‰ã€‚
   - **ä½¿ç”¨`Modifier.Node`**ï¼šåº•å±‚APIï¼Œæ”¯æŒè‡ªå®šä¹‰æµ‹é‡ã€ç»˜åˆ¶ã€äº¤äº’ç­‰å¤æ‚é€»è¾‘ã€‚

### ï¼ˆäºŒï¼‰å®ç°æ–¹å¼å¯¹æ¯”

| æ–¹å¼                | é€‚ç”¨åœºæ™¯                     | æ€§èƒ½       | å¤æ‚åº¦ |
|---------------------|------------------------------|------------|--------|
| é“¾æ¥ç°æœ‰ä¿®é¥°ç¬¦      | ç®€å•æ ·å¼ç»„åˆï¼ˆå¦‚åœ†è§’+èƒŒæ™¯ï¼‰   | é«˜         | ä½     |
| å¯ç»„åˆé¡¹ä¿®é¥°ç¬¦å·¥å‚  | éœ€è¦åŠ¨ç”»æˆ–ç»„åˆæœ¬åœ°å˜é‡       | ä¸­ï¼ˆéœ€æ³¨æ„é‡ç»„å¼€é”€ï¼‰ | ä¸­     |
| `Modifier.Node`      | è‡ªå®šä¹‰æµ‹é‡ã€ç»˜åˆ¶ã€æ‰‹åŠ¿ç­‰     | æœ€é«˜       | é«˜     |

## äºŒã€å¿«é€Ÿå…¥é—¨ï¼šé“¾æ¥ç°æœ‰ä¿®é¥°ç¬¦

### ï¼ˆä¸€ï¼‰åŸºç¡€ç”¨æ³•

å°†å¤šä¸ªç°æœ‰ä¿®é¥°ç¬¦å°è£…ä¸ºä¸€ä¸ªå¤åˆä¿®é¥°ç¬¦ï¼Œç®€åŒ–é‡å¤ä»£ç ã€‚

```kotlin
// ç»„åˆpaddingã€clipã€backgroundä¸ºè‡ªå®šä¹‰ä¿®é¥°ç¬¦
fun Modifier.myCard(modifier: Modifier = Modifier, color: Color) = this
    .then(modifier)
    .padding(16.dp)
    .clip(RoundedCornerShape(8.dp))
    .background(color)
```

### ï¼ˆäºŒï¼‰ä¼˜åŠ¿ä¸é™åˆ¶

- **ä¼˜åŠ¿**ï¼šå¼€å‘æˆæœ¬ä½ï¼Œå¤ç”¨æ€§é«˜ã€‚
- **é™åˆ¶**ï¼šæ— æ³•å®ç°æµ‹é‡/ç»˜åˆ¶çº§åˆ«çš„è‡ªå®šä¹‰é€»è¾‘ã€‚

## ä¸‰ã€è¿›é˜¶ç”¨æ³•ï¼šå¯ç»„åˆé¡¹ä¿®é¥°ç¬¦å·¥å‚

### ï¼ˆä¸€ï¼‰å®ç°å¸¦çŠ¶æ€çš„ä¿®é¥°ç¬¦

åˆ©ç”¨ComposeçŠ¶æ€æœºåˆ¶ï¼ˆå¦‚`animate*AsState`ï¼‰å®ç°åŠ¨æ€æ•ˆæœã€‚

```kotlin
@Composable
fun Modifier.fade(enabled: Boolean): Modifier {
    val alpha by animateFloatAsState(if (enabled) 0.5f else 1.0f)
    return this.then(Modifier.graphicsLayer { this.alpha = alpha })
}
```

### ï¼ˆäºŒï¼‰æ³¨æ„äº‹é¡¹

1. **ç»„åˆæœ¬åœ°å˜é‡ä½œç”¨åŸŸ**ï¼š
   - ç»„åˆæœ¬åœ°å˜é‡åœ¨ä¿®é¥°ç¬¦åˆ›å»ºæ—¶è§£æï¼Œè€Œéä½¿ç”¨æ—¶ï¼ˆå¯èƒ½å¯¼è‡´é¢„æœŸå¤–è¡Œä¸ºï¼‰ã€‚
   - **è§£å†³æ–¹æ¡ˆ**ï¼šæ”¹ç”¨`Modifier.Node`åœ¨ä½¿ç”¨ä½ç½®è§£æã€‚
2. **æ€§èƒ½å¼€é”€**ï¼š
   - æ¯æ¬¡é‡ç»„éƒ½ä¼šè°ƒç”¨å¯ç»„åˆå·¥å‚ï¼Œé¢‘ç¹é‡ç»„åœºæ™¯éœ€è°¨æ…ï¼ˆå¦‚åˆ—è¡¨é¡¹ï¼‰ã€‚

## å››ã€é«˜çº§ç”¨æ³•ï¼šä½¿ç”¨`Modifier.Node`

### ï¼ˆä¸€ï¼‰æ ¸å¿ƒä¸‰è¦ç´ 

```mermaid
graph LR
    A[ä¿®é¥°ç¬¦å·¥å‚] --> B[åˆ›å»ºModifierNodeElement]
    B --> C[å®ä¾‹åŒ–Modifier.Node]
    C --> D[å®ç°å…·ä½“é€»è¾‘ï¼ˆæµ‹é‡/ç»˜åˆ¶/äº¤äº’ï¼‰]
```

#### 1. `Modifier.Node`ï¼šé€»è¾‘å®ç°

```kotlin
// ç»˜åˆ¶åœ†å½¢çš„Nodeï¼ˆå®ç°DrawModifierNodeï¼‰
private class CircleNode(var color: Color) : DrawModifierNode, Modifier.Node() {
    override fun ContentDrawScope.draw() {
        drawCircle(color, size = size) // sizeä¸ºçˆ¶å®¹å™¨å°ºå¯¸
        drawContent() // ç»˜åˆ¶å­å†…å®¹
    }
}
```

#### 2. `ModifierNodeElement`ï¼šèŠ‚ç‚¹ç®¡ç†

```kotlin
// ç®¡ç†CircleNodeçš„åˆ›å»ºå’Œæ›´æ–°
private data class CircleElement(val color: Color) : ModifierNodeElement<CircleNode>() {
    override fun create() = CircleNode(color)
    override fun update(node: CircleNode, element: CircleElement) {
        node.color = element.color // ä»…æ›´æ–°é¢œè‰²ï¼Œå¤ç”¨èŠ‚ç‚¹å®ä¾‹
    }
}
```

#### 3. ä¿®é¥°ç¬¦å·¥å‚ï¼šæš´éœ²API

```kotlin
// æä¾›é“¾å¼è°ƒç”¨æ¥å£
fun Modifier.circle(color: Color) = this.then(CircleElement(color))
```

### ï¼ˆäºŒï¼‰å¸¸è§åº”ç”¨åœºæ™¯

#### 1. **é›¶å‚æ•°ä¿®é¥°ç¬¦**ï¼ˆå›ºå®šå†…è¾¹è·ï¼‰

```kotlin
fun Modifier.fixedPadding() = this.then(FixedPaddingElement)

private object FixedPaddingElement : ModifierNodeElement<FixedPaddingNode>() {
    override fun create() = FixedPaddingNode()
    override fun update(node: FixedPaddingNode, element: FixedPaddingElement) {}
}

class FixedPaddingNode : LayoutModifierNode {
    private val PADDING = 16.dp
    override fun MeasureScope.measure(measurable: Measurable, constraints: Constraints): MeasureResult {
        val placeable = measurable.measure(constraints.offset(-PADDING.roundToPx()))
        return layout(placeable.width + 2*PADDING.roundToPx(), placeable.height + 2*PADDING.roundToPx()) {
            placeable.place(PADDING.roundToPx(), PADDING.roundToPx())
        }
    }
}
```

#### 2. **ç›‘å¬ç»„åˆæœ¬åœ°å˜é‡**ï¼ˆåŠ¨æ€é¢œè‰²èƒŒæ™¯ï¼‰

```kotlin
class DynamicBackgroundNode : DrawModifierNode, CompositionLocalConsumerModifierNode {
    override fun ContentDrawScope.draw() {
        val color = currentValueOf(LocalContentColor) // åœ¨ä½¿ç”¨ä½ç½®è§£æç»„åˆæœ¬åœ°å˜é‡
        drawRect(color.copy(alpha = 0.5f))
        drawContent()
    }
}

fun Modifier.dynamicBackground() = this.then(DynamicBackgroundElement)
```

#### 3. **åŠ¨ç”»ä¿®é¥°ç¬¦**ï¼ˆé¢œè‰²æ·¡å…¥æ·¡å‡ºï¼‰

```kotlin
class AnimatedCircleNode(color: Color) : DrawModifierNode, Modifier.Node() {
    private val alpha = Animatable(1f)
    init {
        coroutineScope.launch {
            alpha.animateTo(0f, infiniteRepeatable(tween(1000), RepeatMode.Reverse))
        }
    }
    override fun ContentDrawScope.draw() {
        drawCircle(color, alpha = alpha.value)
        drawContent()
    }
}
```

#### 4. **çŠ¶æ€å…±äº«**ï¼ˆç‚¹å‡»æ¶Ÿæ¼ªæ•ˆæœï¼‰

```kotlin
class ClickableWithRippleNode : DelegatingNode() {
    private val interactionData = InteractionData()
    val focusableNode = delegate(FocusableNode(interactionData))
    val rippleNode = delegate(IndicationNode(interactionData, RippleIndication()))
}
```

#### 5. **åœç”¨è‡ªåŠ¨å¤±æ•ˆ**ï¼ˆç²¾ç»†æ§åˆ¶é‡ç»˜ï¼‰

```kotlin
class SmartInvalidateNode(var color: Color, var size: IntSize) : DrawModifierNode {
    override val shouldAutoInvalidate: Boolean get() = false // å…³é—­è‡ªåŠ¨å¤±æ•ˆ

    fun updateColor(newColor: Color) {
        if (color != newColor) {
            color = newColor
            invalidateDraw() // ä»…é‡ç»˜
        }
    }

    fun updateSize(newSize: IntSize) {
        if (size != newSize) {
            size = newSize
            invalidateMeasurement() // ä»…é‡æ–°æµ‹é‡
        }
    }
}
```

## äº”ã€æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ

### ï¼ˆä¸€ï¼‰é¿å…è¿‡åº¦é‡ç»„

- **åæ¨¡å¼**ï¼šåœ¨å¯ç»„åˆå·¥å‚ä¸­åˆ›å»ºçŠ¶æ€å¯¹è±¡ï¼ˆæ¯æ¬¡é‡ç»„éƒ½ä¼šé‡æ–°åˆ›å»ºï¼‰ã€‚

  ```kotlin
  @Composable
  fun Modifier.inefficientModifier() = this.then(Modifier.clickable { /*...*/ }) // æ¯æ¬¡é‡ç»„åˆ›å»ºæ–°clickableèŠ‚ç‚¹
  ```

- **æœ€ä½³å®è·µ**ï¼šæå–ä¸å˜ä¿®é¥°ç¬¦ï¼Œé¿å…åœ¨å¯ç»„åˆå‡½æ•°å†…åˆ›å»ºèŠ‚ç‚¹ã€‚

  ```kotlin
  val staticModifier = Modifier.clickable { /*...*/ } // æå‡åˆ°ç»„åˆå¤–ï¼Œé¿å…é‡å¤åˆ›å»º
  @Composable
  fun EfficientComposable() {
      Box(modifier = staticModifier.then(Modifier.alpha(0.5f)))
  }
  ```

### ï¼ˆäºŒï¼‰æ­£ç¡®å®ç°`equals`å’Œ`hashCode`

- ä½¿ç”¨æ•°æ®ç±»è‡ªåŠ¨ç”Ÿæˆï¼ˆæ¨èï¼‰ï¼š

  ```kotlin
  private data class CircleElement(val color: Color) : ModifierNodeElement<CircleNode>() { /*...*/ }
  ```

- æ‰‹åŠ¨å®ç°ï¼ˆéæ•°æ®ç±»åœºæ™¯ï¼‰ï¼š

  ```kotlin
  override fun equals(other: Any?): Boolean = other is CircleElement && other.color == color
  override fun hashCode(): Int = color.hashCode()
  ```

### ï¼ˆä¸‰ï¼‰ä¼˜å…ˆä½¿ç”¨ç°æœ‰ä¿®é¥°ç¬¦

- åœ¨å®ç°è‡ªå®šä¹‰ä¿®é¥°ç¬¦å‰ï¼Œæ£€æŸ¥æ˜¯å¦å¯é€šè¿‡ç°æœ‰ä¿®é¥°ç¬¦ç»„åˆå®ç°ï¼ˆå¦‚`graphicsLayer`+`clip`å®ç°åœ†è§’ï¼‰ã€‚

## å…­ã€æ€»ç»“ï¼šé€‰æ‹©åˆé€‚çš„å®ç°æ–¹å¼

| éœ€æ±‚åœºæ™¯                     | æ¨èæ–¹å¼                   | ç¤ºä¾‹åœºæ™¯                          |
|------------------------------|----------------------------|-----------------------------------|
| ç®€å•æ ·å¼ç»„åˆ                 | é“¾æ¥ç°æœ‰ä¿®é¥°ç¬¦             | ç»Ÿä¸€å¡ç‰‡æ ·å¼ï¼ˆpadding+backgroundï¼‰|
| éœ€è¦åŠ¨ç”»æˆ–ç»„åˆæœ¬åœ°å˜é‡       | å¯ç»„åˆé¡¹ä¿®é¥°ç¬¦å·¥å‚         | åŠ¨æ€é€æ˜åº¦ã€åŸºäºä¸»é¢˜çš„é¢œè‰²       |
| è‡ªå®šä¹‰æµ‹é‡/ç»˜åˆ¶/æ‰‹åŠ¿         | `Modifier.Node`            | åœ†å½¢è£å‰ªã€è‡ªå®šä¹‰å¸ƒå±€ã€æ‹–åŠ¨æ’åº   |
| é«˜æ€§èƒ½è¦æ±‚ï¼ˆå¦‚åˆ—è¡¨é¡¹ï¼‰       | `Modifier.Node`            | å¤æ‚åˆ—è¡¨é¡¹åŠ¨ç”»ã€æ‰‹åŠ¿äº¤äº’         |

é€šè¿‡åˆç†é€‰æ‹©å®ç°æ–¹å¼ï¼Œç»“åˆComposeçš„çŠ¶æ€ç®¡ç†å’Œæ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼Œå¯é«˜æ•ˆåˆ›å»ºçµæ´»ä¸”é«˜æ€§èƒ½çš„è‡ªå®šä¹‰ä¿®é¥°ç¬¦ã€‚æ¨èä»ç®€å•ç»„åˆå¼€å§‹ï¼Œé€æ­¥è¿‡æ¸¡åˆ°`Modifier.Node`å®ç°å¤æ‚é€»è¾‘ï¼Œå¹¶åˆ©ç”¨å®˜æ–¹æ–‡æ¡£å’ŒCodelabç¤ºä¾‹åŠ æ·±ç†è§£ã€‚

# 总结两种方式

屏幕适配的核心是根据设计稿的基准尺寸和屏幕实际尺寸，动态调整 `density`，从而使 UI 元素在不同屏幕上保持一致的视觉效果。

## 方式1：修改屏幕的密度

### 1. **确定设计稿基准尺寸**

- 设计稿的宽度和高度，例如：1920px * 1089px。
- 基准宽度（通常是 dp 单位），例如：360dp。

### 2. **计算屏幕的 `density`**

- 根据屏幕的实际宽度或高度（以像素为单位）和设计稿的基准宽度，计算新的 `density`。
- 公式：
  - 竖屏：`density = 屏幕宽度(px) / 基准宽度(dp)`
  - 横屏：`density = 屏幕高度(px) / 基准宽度(dp)`

### 3. **动态设置 `Density`**

- 使用 `CompositionLocalProvider` 提供新的 `Density`，以覆盖默认的屏幕密度。
- 示例代码：

     ```kotlin
     @Composable
     fun AppTheme(content: @Composable () -> Unit) {
         val context = LocalContext.current
         val displayMetrics = context.resources.displayMetrics
         val widthPixels = displayMetrics.widthPixels.toFloat()
         val heightPixels = displayMetrics.heightPixels.toFloat()
         val fontScale = LocalDensity.current.fontScale

         val config = LocalConfiguration.current
         val isPortrait = config.orientation == Configuration.ORIENTATION_PORTRAIT

         val newDensity = if (isPortrait) {
             widthPixels / 360
         } else {
             heightPixels / 360
         }

         CompositionLocalProvider(
             LocalDensity provides Density(
                 density = newDensity,
                 fontScale = fontScale
             )
         ) {
             content()
         }
     }
     ```

### 4. **px转换为dp、sp**

compose使用过程中，都是Dp单位，而设计稿都是px值，所以需要进行转换。咱们上面已经处理了新的密度，那么只需要使用系统工具将px转换为dp、sp

```kotlin
@Composable
fun Float.toDp(): Dp {
   return  pxToDp(this, LocalContext.current.resources.displayMetrics).dp 
}

@Composable
fun Float.toSp(): Float {
    return pxToSp(this, LocalContext.current.resources.displayMetrics)
}
```

## 方式2：动态计算出dp值

注意，如果使用这种方式

### 1. **转换设计稿单位**

- 将设计稿中的 px 转换为 dp 或 sp。
- 示例代码：

     ```kotlin
     @Composable
     fun Int.fromDesign(): Dp {
         val ratio = if (LocalConfiguration.current.orientation == Configuration.ORIENTATION_PORTRAIT) {
             LocalConfiguration.current.screenWidthDp / 360f
         } else {
             LocalConfiguration.current.screenHeightDp / 360f
         }
         val designDensity = 480 / 160
         val oldDp = this / designDensity
         return (oldDp * ratio).dp
     }
     ```

### 2. **应用到 UI 元素**

- 在布局中使用动态计算的 dp 或 sp 值。
- 示例：

     ```kotlin
     Modifier
         .width(82.fromDesign())
         .height(82.fromDesign())
     ```

## **注意事项**

- 确保适配逻辑支持竖屏和横屏。
- 避免硬编码 px 值，尽量使用动态计算的 dp 或 sp。
- 测试不同分辨率和屏幕尺寸，确保适配效果一致。

通过以上步骤，可以实现基于设计稿的屏幕适配逻辑，确保 UI 在不同设备上显示一致。

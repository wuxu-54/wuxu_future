# FontSize单独说明

>开发时通过前两种屏幕适配，修改了密度，但字体大小一直不能做到设计稿的原值大小，本文再说明下原理。

在 Jetpack Compose 中实现屏幕适配时，字体大小（`FontSize`）的处理是核心环节之一，需结合单位选择、缩放机制及适配策略综合设计。以下从原理、方案到实践详细解析：

---

## ⚙️ 一、字体适配的基本原理

Compose 中字体尺寸通过 `TextUnit` 表示，支持 `sp`（可缩放像素）和 `em`（相对单位），**不支持直接使用 `dp`**。原因在于：

- **`sp` 单位**：基于系统密度缩放，同时受用户设置的字体大小偏好（如系统辅助功能中的字体缩放）影响。
- **`em` 单位**：相对于父文本样式的大小（如 `1.5.em` 表示父文本大小的 1.5 倍），适合局部相对调整。
- **禁用 `dp`**：避免固定尺寸无视用户字体偏好，导致无障碍访问问题。

> 💡 关键公式：  
> 物理像素转换：`px = sp × density × fontScale`  
> 其中 `density` 为屏幕密度系数，`fontScale` 为用户字体缩放系数。

---

## 📏 二、`sp` 单位的适配实践

### 1. **直接使用设计稿标注值**

   ```kotlin
   Text(text = "标题", fontSize = 16.sp) // 直接按设计稿标注的 sp 值使用
   ```

- 优点：简单直观，自动响应系统字体设置变化。
- 局限：依赖设计稿基准尺寸（如 360dp 宽），需全局调整 `density` 以保证布局与字体同步缩放。

### 2. **全局修改 `LocalDensity` 适配**

   通过动态计算 `density` 值，使屏幕总宽度等于设计稿宽度，同时保留 `fontScale` 以尊重用户设置：

   ```kotlin
   val designWidth = 360f // 设计稿基准宽度（dp）
   val displayMetrics = LocalContext.current.resources.displayMetrics
   val density = displayMetrics.widthPixels / designWidth // 计算新 density

   CompositionLocalProvider(
       LocalDensity provides Density(density, LocalDensity.current.fontScale)
   ) {
       // 子组件内所有 sp 值按新 density 缩放
       Text(text = "适配文本", fontSize = 16.sp) 
   }
   ```

- **效果**：设计稿中的 `16.sp` 在不同宽度屏幕上物理尺寸一致。
- **横竖屏处理**：根据方向切换基准尺寸（竖屏用宽度，横屏可改用高度）：

     ```kotlin
     val isLandscape = configuration.orientation == ORIENTATION_LANDSCAPE
     val baseSize = if (isLandscape) designHeight else designWidth
     ```

### 3. **集成到主题**

   将适配逻辑封装至 `MaterialTheme`，避免重复代码：

   ```kotlin
   MaterialTheme(
       // ...其他参数
       content = {
           CompositionLocalProvider(LocalDensity provides customDensity) {
               content()
           }
       }
   )
   ```

---

## 🔄 三、`em` 单位的应用场景

`em` 用于**相对父文本的尺寸调整**，适合局部样式微调：

```kotlin
Text(
    text = "主标题",
    fontSize = 20.sp,
    style = TextStyle(fontSize = 1.2.em) // 子文本为父文本的 1.2 倍
)
```

- **特点**：
  - 不受全局 `density` 影响，仅依赖父文本的绝对大小。
  - 忽略系统字体缩放（`fontScale`），适合固定比例设计（如图标文字）。

---

## 🔧 四、其他适配方案与字体处理

### 1. **第三方库方案（如今日头条适配）**

   通过扩展函数转换设计稿尺寸：

   ```kotlin
   fun Number.toSp(): TextUnit {
       val scaledPx = (toFloat() * (displayMetrics.widthPixels / designWidth))
       return (scaledPx / displayMetrics.scaledDensity).sp
   }
   // 使用
   Text(text = "文本", fontSize = 16.toSp())
   ```

- **优点**：精准还原设计稿，避免全局修改 `density` 对第三方库的影响。
- **缺点**：需为每个字体单独转换，侵入性强。

### 2. **`fontScale` 的注意事项**

- 系统 `fontScale` 可通过 `LocalDensity.current.fontScale` 获取，**不应手动覆盖**，否则会破坏无障碍支持。
- 测试时可用 `@Preview(fontScale = 1.5f)` 预览大字体效果。

---

## ⚠️ 五、常见问题与优化策略

1. **横竖屏字体不一致**  
   动态切换基准尺寸（竖屏用宽度 `360dp`，横屏用高度 `640dp`），确保重计算 `density`。

2. **多单位转换关系**  

   | 单位 | 转换依据                | 适用场景              |
   |------|-------------------------|---------------------|
   | `sp` | 密度 + 用户字体设置     | 全局文本            |
   | `em` | 父文本大小              | 局部相对调整        |
   | `dp` | 不应用于字体            | 不推荐              |

3. **避免 `TextUnit.Unspecified`**  
   明确指定单位（`sp` 或 `em`），防止未定义行为。

---

## 💎 总结：字体适配推荐方案

1. **全局方案**：修改 `LocalDensity` 的 `density` 值（保留 `fontScale`），直接使用设计稿 `sp` 值。  
2. **局部方案**：  
   - 相对调整用 `em`。
   - 独立组件用扩展函数转换（如 `16.toSp()`）。  
3. **测试**：覆盖不同字体缩放系数（`fontScale=1.0~2.0`）及屏幕方向。  

> 通过组合全局密度适配与单位特性，可兼顾设计还原度与系统无障碍要求，实现真正的“完美适配”。

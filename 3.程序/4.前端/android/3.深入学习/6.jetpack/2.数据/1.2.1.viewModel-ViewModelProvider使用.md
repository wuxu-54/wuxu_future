# 使用ViewModelProvider

`ViewModelProvider` 是 Android Jetpack 架构组件中的一个核心类，用于管理 `ViewModel` 的生命周期和实例化。以下是它的使用详解以及背后的设计思想：

总结就是：提供ViewModel，内部有默认的Factory（实现Factory接口，最终是反射通过无参构造创建实例）、CreationExtras（提供额外的扩展能力，通过携带额外参数，比如此ViewModel的key、Application实例等，方便用于构建ViewModel）。

---

## **使用详解**

1. **基本使用**：
   - `ViewModelProvider` 用于在 `Activity` 或 `Fragment` 中获取 `ViewModel` 实例。
   - 它确保 `ViewModel` 的实例在配置变化（如屏幕旋转）时得以保留。

```kotlin
val viewModel = ViewModelProvider(this).get(MyViewModel::class.java)
```

2. **自定义 `ViewModel` 工厂**：
   - 如果 `ViewModel` 的构造函数需要参数，可以通过自定义 `ViewModelProvider.Factory` 来创建。

```kotlin
class MyViewModelFactory(private val repository: MyRepository) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(MyViewModel::class.java)) {
            return MyViewModel(repository) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

// 使用自定义工厂
val factory = MyViewModelFactory(myRepository)
val viewModel = ViewModelProvider(this, factory).get(MyViewModel::class.java)
```

3. **作用域管理**：
   - `ViewModel` 的生命周期与 `ViewModelStoreOwner`（如 `Activity` 或 `Fragment`）绑定。
   - 通过 `ViewModelStore`，`ViewModelProvider` 确保 `ViewModel` 在同一作用域内是单例。

---

## **设计思想**

1. **配置变化的状态保留**：
   - Android 的 `Activity` 和 `Fragment` 在配置变化（如屏幕旋转）时会被销毁并重新创建。
   - `ViewModel` 的设计目标是让数据在配置变化时得以保留，而无需重新加载或计算。

2. **作用域绑定**：
   - `ViewModel` 的生命周期与 `ViewModelStoreOwner` 绑定，确保在同一作用域内共享数据。
   - 通过 `ViewModelStore`，可以在 `Activity` 或 `Fragment` 的生命周期内复用 `ViewModel`。

3. **灵活的工厂模式**：
   - `ViewModelProvider.Factory` 提供了灵活的方式来创建 `ViewModel`，支持依赖注入和参数化构造。
   - 这种设计使得 `ViewModel` 的创建逻辑可以根据需求定制。

4. **线程安全**：
   - `ViewModelProviderImpl` 使用了锁机制（如 `SynchronizedObject`）来确保线程安全，避免多线程环境下的竞争问题。

5. **扩展性**：
   - `ViewModelProvider` 支持多种创建方式（如 `AndroidViewModelFactory` 和 `NewInstanceFactory`），并通过 `CreationExtras` 提供额外的扩展能力。

---

## **为什么设计复杂**

1. **兼容性**：
   - 需要兼容不同的 `ViewModel` 类型（如普通 `ViewModel` 和 `AndroidViewModel`）。
   - 需要支持多种创建方式（无参构造、有参构造、依赖注入等）。

2. **生命周期管理**：
   - `ViewModel` 的生命周期需要与 `Activity` 或 `Fragment` 的生命周期绑定，同时支持配置变化的状态保留。

3. **线程安全**：
   - 在多线程环境下，`ViewModel` 的创建和存储需要保证一致性。

4. **扩展性和灵活性**：
   - 提供了 `Factory` 和 `CreationExtras` 等机制，允许开发者根据需求定制 `ViewModel` 的创建逻辑。

5. **跨平台支持**：
   - `ViewModelProvider` 的设计考虑了 Kotlin Multiplatform 的支持，部分逻辑被抽象为 `expect/actual`。

---

## 更深入理解

`ViewModelProvider` 的设计思想和实现细节可以从以下几个方面更深入地分析：

---

### **1. 配置变化的状态保留**

在 Android 中，`Activity` 和 `Fragment` 的生命周期会受到配置变化（如屏幕旋转）的影响，导致它们被销毁并重新创建。为了避免重新加载或计算数据，`ViewModel` 的设计目标是让数据在配置变化时得以保留。

- **实现方式**：
  - `ViewModelStore` 是核心组件，它通过 `map` 存储 `ViewModel` 实例，并确保这些实例在配置变化时不会被销毁。
  - `ViewModelProvider` 通过 `ViewModelStoreOwner`（如 `Activity` 或 `Fragment`）获取 `ViewModelStore`，从而实现状态的持久化。

---

### **2. 作用域绑定**

`ViewModel` 的生命周期与 `ViewModelStoreOwner` 绑定，确保在同一作用域内共享数据。

- **设计细节**：
  - `ViewModelStore` 的 `put` 方法会替换旧的 `ViewModel` 并调用其 `clear` 方法，确保资源被正确释放。
  - `ViewModelProviderImpl` 使用 `key` 来标识 `ViewModel`，从而支持在同一作用域内复用。

---

### **3. 工厂模式的灵活性**

`ViewModelProvider.Factory` 提供了灵活的方式来创建 `ViewModel`，支持依赖注入和参数化构造。

- **设计细节**：
  - 默认工厂（如 `NewInstanceFactory`）使用无参构造创建 `ViewModel`。
  - 自定义工厂（如 `HomeViewModelFactory`）可以根据需求传递参数或依赖。
  - `CreationExtras` 提供额外的扩展能力，例如传递 `Application` 实例。

---

### **4. 线程安全**

在多线程环境下，`ViewModel` 的创建和存储需要保证一致性。

- **实现方式**：
  - `ViewModelProviderImpl` 使用 `SynchronizedObject` 和 `synchronized` 方法确保线程安全。
  - 通过锁机制避免竞争条件，确保 `ViewModel` 的创建和存储是原子操作。

---

### **5. 扩展性**

`ViewModelProvider` 的设计支持多种场景和平台。

- **设计细节**：
  - 支持 `AndroidViewModel` 和普通 `ViewModel` 的创建。
  - 提供 `AndroidViewModelFactory`，专门处理需要 `Application` 的 `ViewModel`。
  - 通过 `expect/actual` 关键字支持 Kotlin Multiplatform。

---

### **6. 为什么设计复杂**

`ViewModelProvider` 的复杂性源于以下需求：

- **兼容性**：需要支持多种 `ViewModel` 类型和创建方式。
- **生命周期管理**：确保 `ViewModel` 的生命周期与 `ViewModelStoreOwner` 绑定，同时支持配置变化的状态保留。
- **线程安全**：避免多线程环境下的竞争问题。
- **扩展性**：提供灵活的工厂模式和扩展能力，满足不同场景的需求。

---

总结来说，`ViewModelProvider` 的设计是为了在 Android 应用中实现高效的状态管理，同时兼顾生命周期绑定、线程安全和扩展性。这种设计虽然复杂，但能够很好地解决实际开发中的问题。

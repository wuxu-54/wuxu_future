# GridLayoutManager跨列

遇到一个需要实现多列并存的效果，之前不了解，突然听同事说GridlayoutManager有这样一个api可以避免跨列的问题。

## 实现

以下是如何在 `RecyclerView` 中使用 `GridLayoutManager` 来设置单列和多列并存的解决思路：

**解决思路**：

1. 使用 `GridLayoutManager` 来管理 `RecyclerView` 的布局。
2. 根据不同的位置或数据项，动态设置 `GridLayoutManager` 的跨列数（`spanSize`），使得某些项可以跨越多列，而其他项只占一列。
3. 实现 `GridLayoutManager.SpanSizeLookup` 的 `getSpanSize` 方法，该方法会根据位置返回每个项应占据的列数。

**示例代码**：

```java
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.GridLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.ViewGroup;
import android.widget.TextView;


public class MainActivity extends AppCompatActivity {
    private RecyclerView recyclerView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        recyclerView = findViewById(R.id.recyclerView);
        GridLayoutManager layoutManager = new GridLayoutManager(this, 3); // 假设初始为 3 列
        recyclerView.setLayoutManager(layoutManager);

        // 设置SpanSizeLookup
        layoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {
            @Override
            public int getSpanSize(int position) {
                // 假设第 0 项跨 3 列，其余项占 1 列
                if (position == 0) {
                    return 3;
                } else {
                    return 1;
                }
            }
        });

        recyclerView.setAdapter(new MyAdapter());
    }


    private class MyAdapter extends RecyclerView.Adapter<MyAdapter.MyViewHolder> {
        @Override
        public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
            TextView textView = new TextView(MainActivity.this);
            textView.setLayoutParams(new RecyclerView.LayoutParams(
                    RecyclerView.LayoutParams.MATCH_PARENT,
                    RecyclerView.LayoutParams.WRAP_CONTENT));
            return new MyViewHolder(textView);
        }

        @Override
        public void onBindViewHolder(MyViewHolder holder, int position) {
            holder.textView.setText("Item " + position);
        }

        @Override
        public int getItemCount() {
            return 10; // 假设有 10 个数据项
        }


        public class MyViewHolder extends RecyclerView.ViewHolder {
            TextView textView;


            public MyViewHolder(TextView itemView) {
                super(itemView);
                textView = itemView;
            }
        }
    }
}
```

**代码解释**：

- `GridLayoutManager layoutManager = new GridLayoutManager(this, 3);`：创建一个 `GridLayoutManager`，初始列数为 3。
- `layoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {...});`：为 `GridLayoutManager` 设置 `SpanSizeLookup`，该对象的 `getSpanSize` 方法会根据位置决定每个项占据的列数。
  - `if (position == 0) { return 3; } else { return 1; }`：这里定义了位置为 0 的项跨 3 列，其余位置的项跨 1 列。
- `recyclerView.setLayoutManager(layoutManager);`：将 `GridLayoutManager` 应用到 `RecyclerView` 上。
- `recyclerView.setAdapter(new MyAdapter());`：为 `RecyclerView` 设置适配器，在 `MyAdapter` 中创建和绑定 `ViewHolder`，这里简单地使用 `TextView` 作为 `ViewHolder` 展示文本。

**更复杂的使用场景**：

- 可以根据数据的类型或某些条件来动态调整 `getSpanSize` 的返回值，例如：

```java
layoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {
    @Override
    public int getSpanSize(int position) {
        // 假设数据项是一个对象列表，根据对象的类型来确定跨列数
        if (getData().get(position).isHeader()) {
            return 3;
        } else {
            return 1;
        }
    }
});
```

这里假设 `getData()` 方法返回一个对象列表，`isHeader()` 是对象的一个方法，用来判断是否为头部元素。

**布局文件示例**：

```xml
<?xml version="1.0" encoding="utf-8"?>
<android.support.v7.widget.RecyclerView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/recyclerView"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity" />
```

通过这种方式，可以灵活地在 `RecyclerView` 中实现单列和多列并存的布局效果，适用于各种复杂的列表布局需求，例如，实现类似瀑布流布局中包含头部元素跨多列的效果，或者不同类别元素占据不同列数的布局。

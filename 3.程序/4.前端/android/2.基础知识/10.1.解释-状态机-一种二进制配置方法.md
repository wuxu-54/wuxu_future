
# 一种巧用二进制表示状态的方式

```kotlin
@Retention(AnnotationRetention.SOURCE)
@IntDef(
    ClientState.STATE_PREPARE,
    ClientState.STATE_UNINITIALIZED,
    ClientState.STATE_INITIALIZING,
    ClientState.STATE_INITIALIZED,
    ClientState.STATE_CLIENT_CONNECTED,
    ClientState.STATE_DEV_APP_ID_REGISTER_COMPLETE,
    ClientState.STATE_DEV_DEVICE_ID_REGISTER_COMPLETE,
    ClientState.STATE_USER_REGISTER_COMPLETE
)
annotation class ClientState {
    companion object {
        //0000 0000
        const val STATE_PREPARE = 0X00
        //0000 0001
        const val STATE_UNINITIALIZED = 0X1
        //0000 0010
        const val STATE_INITIALIZING = 0X2
        //0000 0100
        const val STATE_INITIALIZED = 0X4
        //0000 1000
        const val STATE_CLIENT_CONNECTED = 0X8
        //0001 0000
        const val STATE_DEV_APP_ID_REGISTER_COMPLETE = 0X10
        //0010 0000
        const val STATE_DEV_DEVICE_ID_REGISTER_COMPLETE = 0X20
        //0100 0000
        const val STATE_USER_REGISTER_COMPLETE = 0X40
    }
}

/**
 * 与某个状态合并
 */
fun Int.merge(@ClientState state: Int):Int{
    return this or state
}
/**
 * 是否包括某一状态
 */
fun Int.hasState(@ClientState state: Int):Boolean{
    return (this and state) != 0
}

/**
 * 移除某个状态
 */
fun Int.rmStatus(@ClientState state: Int):Int{
    return this and state.inv()
}
···

解释：`0X40` 是16进制的表示，其转换为十进制是64，转换为二进制则是`0100 0000`，通过`or`运算，可以与之前的状态进行合并。

例如：`0X40` or `0X1`  结果的二进制为：`0100 0001`

# 自定义view绘制刷新

自定义view时，要明确：

1. `requestLayout`本身不触发`onDraw`。
2. `invalidate()` 仅做`onDraw（）`，不会调用 `onMeasure()`。

## `requestLayout`不触发`onDraw`

- requestLayout() 会从root到底部，重新测量，执行omMeasure()，内部算法并不会百分百触发onDraw()，所以如果onDraw()中需要重新绘制，那么需要调用invalidate()

## 具体说明

在 Android 中，调用 `requestLayout()` **不一定会 100% 触发 `invalidate()`**（即触发重绘）。两者的关系和触发条件如下：

### 1. **`requestLayout()` 的核心作用**

- **重新触发测量（measure）和布局（layout）**：当视图的尺寸或位置需要更新时（例如内容变化、父容器尺寸变化），调用 `requestLayout()` 会向上传递到 `ViewRootImpl`，安排一次完整的遍历（traversal），执行 `measure()` → `layout()` 流程。
- **不直接触发绘制**：`requestLayout()` 本身**不标记脏区域**，因此不会自动触发 `invalidate()`。

### 2. **何时会触发 `invalidate()`？**

#### 情况一：布局过程中位置/尺寸变化

如果 `layout()` 执行后，视图的边界（`left`, `top`, `right`, `bottom`）发生变化：

- 系统**自动调用 `invalidate()`** 标记旧区域和新区域为脏区，触发重绘。
- **原因**：位置变化意味着视图在屏幕上的显示区域改变，必须重绘。

#### 情况二：手动调用 `invalidate()`

如果开发者明确在代码中调用 `invalidate()`，或在某些自定义 View 的逻辑中触发了它。

#### 情况三：内容变化但布局不变

如果视图尺寸/位置未变，但内容变化（例如文字更新），此时：

- 需手动调用 `invalidate()` 触发重绘。
- 若只调 `requestLayout()` 但布局结果未变，**不会触发重绘**。

### 3. **不会触发 `invalidate()` 的示例**

```java
// 情况：视图尺寸/位置未变化
public void updateContentWithoutResize() {
    setText("New Text"); // 内容变化
    requestLayout(); // 触发 measure/layout
}

// 在 onMeasure() 或 onLayout() 中：
@Override
protected void onMeasure(int widthSpec, int heightSpec) {
    // 如果测量结果与上次相同（尺寸未变）
    setMeasuredDimension(previousWidth, previousHeight); 
    // 此时不会触发 invalidate()
}
```

### 4. **总结：触发关系**

| 场景                                | 是否触发 `invalidate()` | 原因                                                                 |
|-------------------------------------|-------------------------|----------------------------------------------------------------------|
| 布局后视图边界改变                  | ✅ 是                   | 系统自动标记脏区域（旧位置 + 新位置）                                |
| 布局后视图边界未改变                | ❌ 否                   | 无位置变化，无需重绘                                                |
| 仅内容变化且未手动调用 `invalidate()` | ❌ 否                   | `requestLayout()` 不处理内容重绘                                    |
| 显式调用 `invalidate()`             | ✅ 是                   | 主动标记脏区域                                                      |

### 5. **最佳实践**

- **需要重绘内容但布局不变时**：直接调用 `invalidate()`（更高效）。
- **布局可能变化时**：调用 `requestLayout()`，系统会根据边界变化自动决定是否重绘。
- **同时需要布局和重绘**：可同时调用两者，但通常 `requestLayout()` 在边界变化时会自动触发重绘。

```java
// 推荐写法
void updateView() {
    if (needsLayout) {
        requestLayout(); // 可能自动触发 invalidate()
    } else if (needsRedraw) {
        invalidate(); // 仅重绘
    }
}
```

> **关键结论**：`requestLayout()` 不是 `invalidate()` 的充分条件。是否触发重绘取决于**布局结果是否导致视图边界变化**，或是否显式调用了 `invalidate()`。

---

## `invalidate()` 不会调用 `onMeasure()`

在 Android 中，`invalidate()` 和 `onMeasure()` 是视图渲染流程中的两个关键环节，但它们的触发关系需要具体分析：

### **1. `invalidate()` 的作用**

- **触发重绘**：`invalidate()` 会标记视图为「需要重绘」，触发 `onDraw()` 回调，但**不会触发 `onMeasure()`**。
- **适用场景**：当视图的外观发生变化（如颜色、透明度）但尺寸不变时，使用 `invalidate()`。

### **2. 触发 `onMeasure()` 的条件**

`onMeasure()` 只会在以下情况被调用：

1. **视图首次加载**：系统需要测量尺寸以布局视图。
2. **父容器要求重新布局**：父容器调用 `requestLayout()`。
3. **视图自身要求重新测量**：视图主动调用 `requestLayout()`。

### **3. 为什么 `invalidate()` 不触发 `onMeasure()`？**

- **性能优化**：频繁测量会导致布局抖动（layout thrashing），影响性能。
- **明确分工**：
  - `invalidate()`：仅重绘（`onDraw()`）。
  - `requestLayout()`：触发测量（`onMeasure()`）和布局（`onLayout()`）。

### **4. 如何同时触发测量和重绘？**

如果需要强制重新测量尺寸，应调用 `requestLayout()`：

```kotlin
view.requestLayout() // 触发 onMeasure() 和 onLayout()
view.invalidate()    // 触发 onDraw()（可选，requestLayout() 可能间接触发）
```

### **5. 示例场景**

#### **场景1：仅修改文本内容**

```kotlin
textView.text = "新文本" // 内容变化但尺寸不变，自动调用 invalidate()
```

- **结果**：仅触发 `onDraw()`，不触发 `onMeasure()`。

#### **场景2：动态修改视图宽高**

```kotlin
// 方式一：通过 LayoutParams 修改尺寸
val params = view.layoutParams
params.width = 200
view.layoutParams = params // 自动调用 requestLayout()

// 方式二：直接请求重新布局
view.requestLayout()
```

- **结果**：触发 `onMeasure()` 和 `onLayout()`，最终触发 `onDraw()`。

### **6. 注意事项**

- **避免过度调用**：频繁调用 `requestLayout()` 会导致性能问题。
- **视图状态依赖**：在 `onMeasure()` 中避免依赖未初始化的状态（如 `getWidth()` 在测量前为 0）。

### **总结**

- **`invalidate()`**：用于外观变化，不触发测量。
- **`requestLayout()`**：用于尺寸变化，触发完整的测量-布局-绘制流程。

合理使用这两个方法，可以避免不必要的测量和重绘，提升应用性能。

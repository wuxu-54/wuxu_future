# Rxjava

以下是 RxJava 的核心 API 和常用操作符的总结，适用于 RxJava 2/3 版本。内容按功能分类，帮助你快速查找和使用。

[TOC]

---

## **核心类**

1. **`Observable<T>`**  
   支持背压（Backpressure）的**冷数据流**，可发射 0 或多个数据项，完成或错误事件。
2. **`Flowable<T>`**  
   支持背压的**热/冷数据流**，适用于高频率数据源（如传感器数据）。
3. **`Single<T>`**  
   发射单个数据或错误事件（如网络请求结果）。
4. **`Maybe<T>`**  
   可能发射一个数据、完成或错误事件（适用于可能无结果的操作）。
5. **`Completable`**  
   只关心操作成功或失败，不发射数据（如文件保存操作）。
6. **`Subject<T>`**  
   既是观察者又是被观察者，常用子类：`PublishSubject`, `BehaviorSubject`, `ReplaySubject`。

---

## **创建操作符**

| 操作符 | 说明 | 示例 |
|--------|------|------|
| `create()` | 自定义数据流创建 | `Observable.create(emitter -> { ... })` |
| `just()` | 直接发射指定数据项 | `Observable.just("A", "B")` |
| `fromIterable()` | 从集合/数组发射数据 | `Observable.fromIterable(list)` |
| `interval()` | 定时发射递增数字 | `Observable.interval(1, TimeUnit.SECONDS)` |
| `range()` | 发射范围内的整数序列 | `Observable.range(1, 5)` |
| `defer()` | 延迟创建，每次订阅生成新 Observable | `Observable.defer(() -> Observable.just(time))` |
| `empty()` | 立即完成的无数据流 | `Observable.empty()` |
| `error()` | 立即发射错误事件 | `Observable.error(new Exception())` |

---

## **转换操作符**

| 操作符 | 说明 | 示例 |
|--------|------|------|
| `map()` | 一对一转换数据 | `.map(s -> s.length())` |
| `flatMap()` | 一对多转换并合并结果 | `.flatMap(s -> Observable.fromArray(s.split("")))` |
| `concatMap()` | 有序的 `flatMap` | 保证顺序的转换 |
| `switchMap()` | 取消前一个未完成的流 | 用于搜索联想词等场景 |
| `buffer()` | 收集数据到缓冲区 | `.buffer(5)` 收集5个数据为一组 |
| `scan()` | 累积计算 | `.scan((sum, num) -> sum + num)` |
| `groupBy()` | 按条件分组数据 | `.groupBy(item -> item % 2 == 0)` |

---

## **过滤操作符**

| 操作符 | 说明 | 示例 |
|--------|------|------|
| `filter()` | 按条件过滤数据 | `.filter(num -> num > 10)` |
| `take()` | 取前 N 项数据 | `.take(3)` |
| `skip()` | 跳过前 N 项数据 | `.skip(2)` |
| `distinct()` | 去重 | `.distinct()` |
| `debounce()` | 防抖动，等待指定时间后发射 | `.debounce(300, TimeUnit.MILLISECONDS)` |
| `throttleFirst()` | 节流，取时间段内的第一个数据 | `.throttleFirst(1, TimeUnit.SECONDS)` |

---

## **组合操作符**

| 操作符 | 说明 | 示例 |
|--------|------|------|
| `zip()` | 多流数据按序合并 | `Observable.zip(obs1, obs2, (a, b) -> a + b)` |
| `merge()` | 合并多流，按时间顺序发射 | `Observable.merge(obs1, obs2)` |
| `concat()` | 顺序拼接多个 Observable | `Observable.concat(obs1, obs2)` |
| `combineLatest()` | 任一流发射数据时合并最新值 | 用于实时计算场景 |
| `startWith()` | 在流开头插入数据项 | `.startWith("Start")` |

---

## **错误处理**

| 操作符 | 说明 | 示例 |
|--------|------|------|
| `onErrorReturn()` | 发生错误时返回默认值 | `.onErrorReturn(e -> "default")` |
| `onErrorResumeNext()` | 错误时切换备用 Observable | `.onErrorResumeNext(backupObs)` |
| `retry()` | 重试指定次数 | `.retry(3)` |
| `retryWhen()` | 根据条件重试 | 自定义重试逻辑（如延迟重试） |

---

## **背压（Backpressure）策略**

用于 `Flowable` 处理生产者-消费者速度不匹配：

- `MISSING`：无策略，需手动处理。
- `BUFFER`：缓存所有数据（可能 OOM）。
- `DROP`：丢弃无法处理的数据。
- `LATEST`：保留最新数据。
- `ERROR`：直接抛出 `MissingBackpressureException`。

示例：

```java
Flowable.interval(1, TimeUnit.MILLISECONDS)
    .onBackpressureBuffer(100) // 缓冲100个数据
    .observeOn(Schedulers.io())
    .subscribe(...);
```

---

## **线程调度（Schedulers）**

| 调度器 | 说明 |
|--------|------|
| `Schedulers.io()` | I/O 密集型任务（网络、文件操作） |
| `Schedulers.computation()` | CPU 密集型计算（默认线程数=CPU核心数） |
| `Schedulers.newThread()` | 每次创建新线程 |
| `Schedulers.single()` | 单一线程顺序执行 |
| `Schedulers.trampoline()` | 当前线程排队执行 |
| `AndroidSchedulers.mainThread()` | Android 主线程（需 RxAndroid） |

使用示例：

```java
observable
    .subscribeOn(Schedulers.io()) // 指定订阅线程
    .observeOn(AndroidSchedulers.mainThread()) // 指定观察线程
    .subscribe(...);
```

---

## **工具类**

1. **`Disposable`**  
   用于取消订阅，避免内存泄漏：

   ```java
   Disposable disposable = observable.subscribe(...);
   disposable.dispose(); // 取消订阅
   ```

2. **`CompositeDisposable`**  
   批量管理订阅：

   ```java
   CompositeDisposable composite = new CompositeDisposable();
   composite.add(disposable1);
   composite.clear(); // 取消所有订阅
   ```

---

## **其他实用操作符**

- **`doOnNext()`**：在每次发射数据时执行副作用。
- **`doOnError()`**：错误发生时执行操作。
- **`doOnComplete()`**：流完成时执行操作。
- **`toList()`**：收集所有数据到 List。
- **`toMap()`**：将数据转换为 Map。

---

## **最佳实践**

1. **避免内存泄漏**：及时取消订阅（如使用 `CompositeDisposable`）。
2. **合理选择 Observable 类型**：根据场景选择 `Observable`、`Flowable` 或 `Single`。
3. **线程控制**：明确指定 `subscribeOn` 和 `observeOn`。
4. **背压处理**：高频数据流使用 `Flowable` 并选择合适的策略。

---

## **资源**

- **官方文档**：[RxJava GitHub](https://github.com/ReactiveX/RxJava)
- **操作符决策树**：[ReactiveX 文档](http://reactivex.io/documentation/operators.html)
- **RxJava 与 Kotlin**：使用 `RxKotlin` 简化语法。

---

## 流程图

以下是 RxJava 的核心 API 调用流程和操作符链式调用的**文本化流程图表示**，结合代码示例和关键步骤说明，帮助你理解数据流的执行顺序和逻辑。

---

### **1. 核心调用流程（Observable 生命周期）**

从创建到订阅的完整流程：

```text
[Observable 创建] → [操作符链式处理] → [订阅观察者] → [事件发射] → [终止]
           │                │               │            │
           │                │               │            ├── onNext(data)
           │                │               │            ├── onError(throwable)
           │                │               │            └── onComplete()
           │                │               └── 订阅后触发数据流
           │                └── 操作符按顺序处理数据（如 map、filter）
           └── 通过 create/just/from 等操作符初始化
```

#### **示例代码流程**

```java
Observable.create(emitter -> {       // 1. 创建 Observable
    emitter.onNext("A");
    emitter.onNext("B");
    emitter.onComplete();
})
.map(s -> s.toLowerCase())           // 2. 转换操作符
.filter(s -> s.equals("a"))          // 3. 过滤操作符
.subscribe(                          // 4. 订阅观察者
    s -> System.out.println("收到数据: " + s), // onNext
    e -> System.out.println("错误: " + e),    // onError
    () -> System.out.println("完成")          // onComplete
);
```

---

### **2. 操作符链式调用流程图（以 map + filter 为例）**

```text
                  +-----------------+
Observable 发射数据 → | map 转换处理 | → | filter 过滤 | → 观察者接收结果
                  +-----------------+     +-----------+
                        │                     │
                        │                     ├── 符合条件的数据 → 传递给下游
                        │                     └── 不符合条件的数据 → 被丢弃
                        └── 将原始数据转换为新类型
```

---

### **3. 线程调度流程图（subscribeOn + observeOn）**

```text
+----------------+        +-------------------+        +-------------------+
| 数据源生产线程     |        | 中间操作处理线程      |        | 观察者消费线程       |
| (io 线程)       |        | (computation 线程) |        | (main 线程)      |
+----------------+        +-------------------+        +-------------------+
         ↓                         ↓                           ↓
Observable.create(...)      .subscribeOn(Schedulers.io)   .observeOn(AndroidSchedulers.mainThread)
         ↓                         ↓                           ↓
数据发射在 io 线程 → map/flatMap 在 computation 线程 → 最终结果在主线程处理
```

#### **关键点**

- `subscribeOn` 定义数据源生产线程（多次调用只有第一次生效）。
- `observeOn` 切换后续操作和观察者的线程（每次调用都会切换）。

---

### **4. 组合操作符流程图（zip + merge）**

#### **zip 操作符**

```text
Observable1: --A-----------B-----------C--->  
Observable2: --1-----2-----3-----4-----5--->  
zip 结果:     --A1----B2----C3---------------->
```

**规则**：按顺序一一合并，任一流完成则终止。

#### **merge 操作符**

```text
Observable1: --A-----B-----C-----D----->
Observable2: --1--2--3--4--5---------->
merge 结果:  --A-1-2-B-3-4-C-5---D----->
```

**规则**：按时间顺序合并数据，不保证顺序。

---

### **5. 背压处理流程图（Flowable + onBackpressureBuffer）**

```text
快速生产者（如 interval(1ms)） → 缓冲区（buffer） → 慢速消费者（如主线程处理）
       │                              │
       ├── 当缓冲区满时：根据策略处理溢出数据（如丢弃/保留最新）
       └── 消费者按自身速度消费缓冲区数据
```

#### **示例代码**

```java
Flowable.interval(1, TimeUnit.MILLISECONDS)
    .onBackpressureBuffer(100)      // 缓冲区大小 100
    .observeOn(Schedulers.io())     // 消费者在 io 线程
    .subscribe(data -> {
        Thread.sleep(10);           // 模拟慢速消费
        System.out.println(data);
    });
```

---

### **6. 错误处理流程图（onErrorResumeNext）**

```text
主 Observable 发射数据 → 发生错误 → 切换到备用 Observable → 继续发射数据
           │                     │
           ├── 正常流程           └── 错误处理逻辑
```

#### **错误处理流程图-示例代码**

```java
Observable.create(emitter -> {
    emitter.onNext("A");
    emitter.onError(new Exception("错误"));
})
.onErrorResumeNext(throwable -> {   // 发生错误时切换备用流
    return Observable.just("B", "C");
})
.subscribe(
    data -> System.out.println(data), // 输出 A → B → C
    e -> System.out.println("不会触发")
);
```

---

### **7. 取消订阅流程图（Disposable）**

```text
订阅 Observable → 返回 Disposable 对象 → 调用 dispose() → 中断数据流
           │                              │
           └── 未取消时正常接收数据         └── 后续数据不再发射
```

#### **取消订阅流程图-示例代码**

```java
Disposable disposable = Observable.interval(1, TimeUnit.SECONDS)
    .subscribe(data -> System.out.println(data));

// 3 秒后取消订阅
Thread.sleep(3000);
disposable.dispose();  // 停止接收数据
```

---

### **总结**

1. **链式调用顺序**：操作符按代码书写顺序依次执行。
2. **线程切换**：通过 `subscribeOn` 和 `observeOn` 明确线程分工。
3. **错误传递**：错误会向下游传递，直到被捕获或导致订阅终止。
4. **背压控制**：使用 `Flowable` + 策略处理生产者-消费者速度不匹配问题。

如果需要更具体的流程图（如某个操作符的详细逻辑），可以进一步说明！

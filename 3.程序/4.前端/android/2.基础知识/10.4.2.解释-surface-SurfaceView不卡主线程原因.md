# Android SurfaceView 为什么不卡主线程

在Android开发中，SurfaceView是一个特殊的视图组件，它被设计用来处理视频流、游戏渲染或者其他需要频繁更新的图形界面。SurfaceView之所以不会阻塞主线程，是因为它采用了独特的设计和工作机制：

1. **双缓冲机制**：SurfaceView内部使用了双缓冲机制，这意味着它有两个缓冲区，一个用于当前显示，另一个用于内容的绘制。当绘制完成后，SurfaceView会进行缓冲区的交换，这样可以避免直接在显示的缓冲区上绘制，从而减少画面的闪烁和卡顿。

2. **独立的绘制线程**：SurfaceView拥有一个专门的绘制线程，称为`SurfaceHolder.Callback`的`surfaceChanged`方法。这个线程独立于UI线程，专门负责处理SurfaceView的绘制任务。当有新的绘制内容时，这个线程会被唤醒并执行绘制操作，然后将结果更新到SurfaceView上。这样，即使绘制操作比较耗时，也不会影响主线程的运行，因为所有的绘制工作都在单独的线程中完成。

3. **SurfaceFlinger服务**：在Android系统中，`SurfaceFlinger`服务负责管理所有屏幕显示相关的任务。当SurfaceView的绘制线程完成绘制后，它会通过SurfaceFlinger将新的图像数据推送到显示屏上。SurfaceFlinger服务高效地处理这些图像数据，并确保它们能够及时地显示在屏幕上，而不需要UI线程的参与。

4. **优化的锁机制**：SurfaceView使用了一种优化的锁机制来确保线程安全。它通过`SurfaceHolder`对象来管理对Surface的访问，确保在任何时候只有一个线程能够对Surface进行绘制操作。这种机制避免了多线程同时访问Surface导致的竞态条件，同时也减少了线程间的上下文切换，提高了整体的效率。

5. **适当的资源回收**：SurfaceView在不再需要的时候会及时释放资源，比如释放绘制用的Bitmap对象。这样可以避免内存泄漏，减少对系统资源的占用，从而减轻主线程的负担。

总的来说，SurfaceView通过上述机制确保了即使在进行复杂的绘制操作时，也不会对主线程造成负担，从而避免了卡顿和阻塞的现象。这种设计使得SurfaceView非常适合用于需要高性能绘制的应用程序，如游戏、视频播放等场景。

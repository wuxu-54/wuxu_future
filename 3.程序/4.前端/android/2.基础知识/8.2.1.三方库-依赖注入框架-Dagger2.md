# Dagger2

Dagger2（实际应为**Dagger2**）是一款由Google维护的依赖注入框架，主要用于Java和Android开发中解耦对象之间的依赖关系。它通过编译时生成代码实现高效的依赖注入，避免了运行时反射的性能开销，同时提高了代码的可维护性和可测试性。以下是其核心概念和使用方法的详细解析：

## 一、核心概念与原理

1. **依赖注入（DI）**  
   依赖注入是一种设计模式，通过外部传入的方式为对象提供其依赖的实例，而非由对象自身创建。例如，类A依赖类B的实例，传统方式是在A内部通过`new B()`创建，而依赖注入则通过外部将B的实例注入到A中。

2. **关键注解**  
   - **`@Inject`**：标记需要注入的字段、构造函数或方法。被注解的构造函数会生成对应的工厂类，用于创建实例。  
   - **`@Module`**：类似“工厂”，通过`@Provides`注解的方法提供依赖对象。常用于处理第三方库或无法直接使用`@Inject`的类。  
   - **`@Component`**：作为桥梁，连接`@Module`和需要注入的类。通过`inject()`方法将依赖注入目标对象，并管理依赖关系。  
   - **`@Singleton`**：限定依赖对象的作用域为单例，确保全局唯一实例。

3. **工作流程**  
   - 编译器扫描`@Inject`和`@Module`注解，生成`Component`的实现类（如`DaggerXXXComponent`）。  
   - 在目标类中通过`Component`的`inject()`方法完成依赖注入。  
   - 依赖查找优先级：`@Module`的`@Provides`方法 > `@Inject`构造函数。

## 二、基础使用示例

### 1. 环境配置

在项目的`build.gradle`中添加依赖：

```gradle
// 项目级 build.gradle
classpath 'com.google.dagger:dagger-compiler:2.x'

// 模块级 build.gradle
implementation 'com.google.dagger:dagger:2.x'
annotationProcessor 'com.google.dagger:dagger-compiler:2.x'
```

### 2. 简单依赖注入

- **定义依赖类**：

  ```java
  public class Student {
      @Inject
      public Student() {} // 构造函数注入
  }
  ```

- **定义Component**：

  ```java
  @Component
  public interface AppComponent {
      void inject(MainActivity activity); // 注入目标类
  }
  ```

- **使用依赖**：

  ```java
  public class MainActivity extends AppCompatActivity {
      @Inject
      Student student; // 注入字段

      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          DaggerAppComponent.builder().build().inject(this); // 触发注入
          // 使用 student 实例
      }
  }
  ```

### 3. 使用Module处理第三方库

- **定义Module**：

  ```java
  @Module
  public class AppModule {
      @Provides
      Gson provideGson() { // 提供第三方库实例
          return new Gson();
      }
  }
  ```

- **关联Component与Module**：

  ```java
  @Component(modules = AppModule.class)
  public interface AppComponent {
      void inject(MainActivity activity);
  }
  ```

- **注入第三方库**：

  ```java
  public class MainActivity extends AppCompatActivity {
      @Inject
      Gson gson; // 注入Gson实例
  }
  ```

## 三、进阶特性

1. **作用域与单例**  
   使用`@Singleton`注解标记`Component`和`@Provides`方法，确保依赖对象全局唯一：

   ```java
   @Singleton
   @Component(modules = AppModule.class)
   public interface AppComponent {
       void inject(App app);
   }

   @Module
   public class AppModule {
       @Provides
       @Singleton
       Context provideContext(App app) {
           return app.getApplicationContext();
       }
   }
   ```

2. **子组件（SubComponent）**  
   通过子组件实现依赖的层级管理，避免父组件暴露过多细节：

   ```java
   @Subcomponent(modules = ActivityModule.class)
   public interface ActivityComponent {
       void inject(MainActivity activity);
   }

   @Component(modules = AppModule.class)
   public interface AppComponent {
       ActivityComponent activityComponent(); // 暴露子组件工厂方法
   }
   ```

3. **限定符（Qualifier）**  
   当同一类型有多个实现时，使用`@Qualifier`区分：

   ```java
   @Qualifier
   @Retention(RetentionPolicy.RUNTIME)
   public @interface Named {
       String value();
   }

   @Module
   public class AppModule {
       @Provides
       @Named("apiKey")
       String provideApiKey() {
           return "prod_key";
       }

       @Provides
       @Named("debugKey")
       String provideDebugApiKey() {
           return "debug_key";
       }
   }
   ```

   在注入时指定限定符：

   ```java
   @Inject
   @Named("apiKey")
   String apiKey;
   ```

## 四、与其他框架的对比

1. **Dagger2 vs. Dagger1**  
   - **性能**：Dagger2通过编译时生成代码，避免反射，性能更优。  
   - **调试**：生成的代码可直接调试，而Dagger1依赖反射难以追踪。

2. **Dagger2 vs. Hilt**  
   Hilt是Dagger2针对Android的简化封装，提供更简洁的API和自动绑定组件生命周期的能力。但Dagger2仍适用于复杂依赖场景或非Android项目。

## 五、常见问题与最佳实践

1. **依赖循环**  
   避免组件间相互依赖，可通过拆分模块或使用接口解耦。

2. **测试优化**  
   使用`@Test`注解的`Component`替代生产环境组件，注入模拟对象：

   ```java
   @TestComponent(modules = TestModule.class)
   public interface TestComponent {
       void inject(MyTest test);
   }
   ```

3. **代码可读性**  
   合理命名`Module`和`Component`，例如`AppModule`、`ActivityComponent`，清晰表达职责。

## 六、总结

Dagger2通过编译时生成代码实现高效的依赖注入，显著降低了组件间的耦合度，提升了代码的可维护性和可测试性。其核心注解（`@Inject`、`@Module`、`@Component`）和作用域管理机制为复杂项目提供了强大的依赖管理能力。尽管学习曲线较陡峭，但掌握后能极大提高开发效率和代码质量。建议结合官方文档和实际项目逐步实践，深入理解其设计思想和使用场景。

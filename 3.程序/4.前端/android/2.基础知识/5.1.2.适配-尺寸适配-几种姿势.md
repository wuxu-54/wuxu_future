# 尺寸适配的几种姿势

在 Android 开发中，尺寸适配是确保 UI 在不同屏幕尺寸和密度设备上一致性的关键。以下是几种主流的适配方式及其优缺点：
>个人建议：通常采用今日头条方案，但对于系统ui有高度依赖的不适用。其他情况使用最小限定符就可以。鸿洋的AutoSize代码入侵性太高，不建议。

## **1. 传统方案：dp + 资源限定符**

通过 `dp`（设备独立像素）和 `sp`（用于文字）作为尺寸单位，结合不同分辨率的资源文件夹：

```txt
res/
  values/         # 默认值
  values-hdpi/    # 高密度屏幕
  values-xhdpi/   # 超高密度屏幕
  values-xxhdpi/  # 超超高密度屏幕
```

**优点**：官方原生支持，简单易用  
**缺点**：需维护多套资源，无法覆盖所有设备

## **2. 百分比布局（Percent Support Library）**

通过百分比指定宽高和边距：

```xml
<androidx.percentlayout.widget.PercentRelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ImageView
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_widthPercent="50%"  <!-- 宽度为父容器的50% -->
        app:layout_heightPercent="30%" <!-- 高度为父容器的30% -->
        app:layout_marginTopPercent="10%" />
</androidx.percentlayout.widget.PercentRelativeLayout>
```

**优点**：简单直观，适合固定比例布局  
**缺点**：已停止维护，推荐使用 ConstraintLayout

## **3. ConstraintLayout 约束布局**

通过相对定位和约束关系实现自适应：

```xml
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ImageView
        android:id="@+id/image"
        android:layout_width="0dp"  <!-- 宽度由约束决定 -->
        android:layout_height="150dp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="自适应文本"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toBottomOf="@id/image"
        app:layout_constraintVertical_bias="0.5" /> <!-- 垂直位置比例 -->
</androidx.constraintlayout.widget.ConstraintLayout>
```

**优点**：官方推荐，灵活高效，减少嵌套  
**缺点**：复杂布局的约束关系调试较繁琐

## **4. 最小宽度限定符（Smallest Width）**

通过 `sw<N>dp` 为不同最小宽度设备提供特定资源：

```txt
res/
  layout/           # 默认布局
  layout-sw600dp/   # 平板（最小宽度600dp）
  layout-sw720dp/   # 更大平板（最小宽度720dp）
```

**优点**：适配不同屏幕尺寸的有效方式  
**缺点**：需为每种尺寸维护单独布局

## **5. 布局别名（Layout Alias）**

通过资源别名统一管理不同尺寸的布局：

```xml
<!-- values/layouts.xml -->
<resources>
    <item name="main_layout" type="layout">@layout/main_phone</item>
</resources>

<!-- values-sw600dp/layouts.xml -->
<resources>
    <item name="main_layout" type="layout">@layout/main_tablet</item>
</resources>
```

**优点**：简化布局引用，提高可维护性  
**缺点**：需额外创建别名文件

## **6. 动态计算（Runtime Calculation）**

通过代码动态计算尺寸：

```java
// 获取屏幕尺寸
DisplayMetrics metrics = new DisplayMetrics();
getWindowManager().getDefaultDisplay().getMetrics(metrics);
int screenWidth = metrics.widthPixels;

// 动态设置控件宽度为屏幕的1/3
View view = findViewById(R.id.targetView);
ViewGroup.LayoutParams params = view.getLayoutParams();
params.width = screenWidth / 3;
view.setLayoutParams(params);
```

**优点**：精准控制，适合复杂动态布局  
**缺点**：代码量增加，维护成本高

## **7. 第三方库方案**

- **AutoSize**（鸿洋）：<https://github.com/JessYanCoding/AndroidAutoSize>  
  通过字节跳动的适配方案，自动转换尺寸单位。

- **ScreenMatch**：<https://github.com/ladingwu/ScreenMatch>  
  基于设计稿尺寸自动生成适配文件。

- **ConstraintLayout**：官方推荐的约束布局库，内置百分比支持。

## **8. 今日头条适配方案**

通过修改系统密度（Density）实现适配：

```java
public class Density {
    private static float sNoncompatDensity;
    private static float sNoncompatScaledDensity;

    public static void setDensity(final Application application, final float designWidthInDp) {
        final DisplayMetrics displayMetrics = application.getResources().getDisplayMetrics();
        
        if (sNoncompatDensity == 0) {
            sNoncompatDensity = displayMetrics.density;
            sNoncompatScaledDensity = displayMetrics.scaledDensity;
            
            // 监听系统字体变化
            application.registerComponentCallbacks(new ComponentCallbacks() {
                @Override
                public void onConfigurationChanged(Configuration newConfig) {
                    if (newConfig != null && newConfig.fontScale > 0) {
                        sNoncompatScaledDensity = application.getResources().getDisplayMetrics().scaledDensity;
                    }
                }

                @Override
                public void onLowMemory() {}
            });
        }
        
        // 计算目标密度
        final float targetDensity = displayMetrics.widthPixels / designWidthInDp;
        final float targetScaledDensity = targetDensity * (sNoncompatScaledDensity / sNoncompatDensity);
        final int targetDensityDpi = (int) (160 * targetDensity);
        
        // 应用新的密度
        displayMetrics.density = targetDensity;
        displayMetrics.scaledDensity = targetScaledDensity;
        displayMetrics.densityDpi = targetDensityDpi;
        
        final DisplayMetrics activityDisplayMetrics = application.getResources().getDisplayMetrics();
        activityDisplayMetrics.density = targetDensity;
        activityDisplayMetrics.scaledDensity = targetScaledDensity;
        activityDisplayMetrics.densityDpi = targetDensityDpi;
    }
}
```

**优点**：只需一套设计稿尺寸，无需多套资源  
**缺点**：可能影响系统组件和第三方库的显示

## **选择建议**

- **简单应用**：ConstraintLayout + dp + 资源限定符  
- **复杂项目**：ConstraintLayout + Smallest Width + 动态计算  
- **快速适配**：第三方库（如 AutoSize）  
- **追求极致**：今日头条方案 + 自定义 View

无论选择哪种方案，都建议在多种设备上进行测试，确保 UI 显示一致性。

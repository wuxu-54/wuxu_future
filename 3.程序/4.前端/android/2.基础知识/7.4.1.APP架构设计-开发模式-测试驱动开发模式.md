# 测试驱动开发（TDD）

在Android中实践测试驱动开发（TDD）的核心是“**先写测试，再实现功能**”，遵循“红-绿-重构”（Red-Green-Refactor）循环。从无到有搭建TDD流程，需结合需求拆解、测试环境配置、单元测试编写、Mock数据设计等步骤。
>一种开发思想，保证代码质量。

以下是具体实现指南：

## **一、前提：明确需求与拆分测试点**

TDD的起点是**清晰的需求**。需将需求拆解为“可测试的最小功能单元”，每个单元对应一个或多个测试用例。

举例：假设需求是“实现一个登录功能，验证用户名和密码的合法性，返回登录结果”，可拆分为以下测试点：

1. 用户名为空时，登录失败，提示“用户名不可为空”；
2. 密码为空时，登录失败，提示“密码不可为空”；
3. 用户名或密码错误时，登录失败，提示“账号或密码错误”；
4. 用户名和密码正确时，登录成功，返回用户信息。

## **二、搭建测试环境**

在Android项目中，需配置单元测试和Mock工具的依赖。在`app/build.gradle`中添加以下依赖（以最新版本为例）：

```groovy
android {
    // ...
    testOptions {
        unitTests {
            includeAndroidResources = true // 允许测试访问Android资源
            returnDefaultValues = true    // 对未Mock的Android类返回默认值
        }
    }
}

dependencies {
    // 1. 单元测试框架（JUnit 4/5）
    testImplementation 'junit:junit:4.13.2'
    
    // 2. Mock工具（Mockito，用于模拟依赖）
    testImplementation 'org.mockito:mockito-core:4.8.1'
    testImplementation 'org.mockito:mockito-inline:4.8.1' // 支持final类/方法的Mock
    
    // 3. 模拟Android环境（Robolectric，解决纯JVM无法运行Android类的问题）
    testImplementation 'org.robolectric:robolectric:4.10.3'
    
    // 4. 断言工具（可选，使断言更易读）
    testImplementation 'org.hamcrest:hamcrest:2.2'
}
```

同步项目后，Android Studio会自动识别`src/test/java`（本地单元测试，运行在JVM）和`src/androidTest/java`（仪器化测试，运行在设备）目录。TDD的单元测试优先放在`src/test/java`。

## **三、第一步：编写单元测试（Red阶段）**

根据拆分的测试点，先编写**失败的单元测试**（红阶段）。核心是：**测试对象是什么？依赖哪些外部组件？如何用Mock隔离依赖？**

以“登录功能”为例，假设架构采用“Presenter层（或ViewModel）+ 数据层（Repository）”：

- **测试对象**：`LoginPresenter`（处理登录逻辑）；
- **依赖**：`UserRepository`（获取用户数据，可能涉及网络或本地存储，需Mock）；
- **交互**：Presenter调用Repository的`login(username, password)`方法，根据返回结果更新UI状态。

### 1. 定义接口与测试骨架

先定义核心接口（无需实现），作为测试的依据：

```java
// 数据层：用户仓库接口（定义登录方法）
public interface UserRepository {
    // 登录方法：返回Result（成功时包含User，失败时包含错误信息）
    Result<User> login(String username, String password);
}

// 结果封装类（成功/失败状态）
public sealed class Result<T> {
    public static final class Success<T> extends Result<T> {
        public final T data;
        public Success(T data) { this.data = data; }
    }
    public static final class Failure<T> extends Result<T> {
        public final String errorMsg;
        public Failure(String errorMsg) { this.errorMsg = errorMsg; }
    }
}

// 登录Presenter（待实现的测试对象）
public class LoginPresenter {
    private final UserRepository repository;
    private LoginView view; // 视图接口（回调UI更新）

    public LoginPresenter(UserRepository repository) {
        this.repository = repository;
    }

    public void attachView(LoginView view) { this.view = view; }

    // 待实现的登录逻辑
    public void login(String username, String password) {
        // 空实现（测试会先失败）
    }
}

// 视图接口（回调UI）
public interface LoginView {
    void showLoading();
    void hideLoading();
    void showSuccess(User user);
    void showError(String msg);
}
```

### 2. 编写单元测试用例

在`src/test/java/包名`下创建`LoginPresenterTest`，使用Mockito模拟`UserRepository`和`LoginView`，验证不同输入下的逻辑是否正确：

```java
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import static org.mockito.Mockito.*;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.CoreMatchers.equalTo;

// 启用Mockito注解（@Mock）
@RunWith(MockitoJUnitRunner.class)
public class LoginPresenterTest {

    // Mock依赖：UserRepository（无需真实实现）
    @Mock
    private UserRepository mockRepository;

    // Mock视图接口（验证UI回调）
    @Mock
    private LoginView mockView;

    // 测试对象：LoginPresenter
    private LoginPresenter presenter;

    // 测试前初始化
    @Before
    public void setup() {
        // 初始化Presenter，注入Mock的Repository
        presenter = new LoginPresenter(mockRepository);
        // 绑定Mock的View
        presenter.attachView(mockView);
    }

    // 测试点1：用户名空 -> 登录失败，提示“用户名不可为空”
    @Test
    public void login_withEmptyUsername_shouldShowError() {
        // 执行登录（用户名为空）
        presenter.login("", "123456");

        // 验证：不调用Repository（本地校验即可），直接显示错误
        verify(mockRepository, never()).login(anyString(), anyString());
        verify(mockView).showError("用户名不可为空");
    }

    // 测试点2：密码空 -> 登录失败，提示“密码不可为空”
    @Test
    public void login_withEmptyPassword_shouldShowError() {
        presenter.login("testUser", "");

        verify(mockRepository, never()).login(anyString(), anyString());
        verify(mockView).showError("密码不可为空");
    }

    // 测试点3：账号密码错误（Repository返回失败）-> 显示错误信息
    @Test
    public void login_withInvalidCredentials_shouldShowError() {
        // 准备Mock数据：Repository返回失败（错误信息“账号或密码错误”）
        when(mockRepository.login("testUser", "wrongPwd"))
            .thenReturn(new Result.Failure<>("账号或密码错误"));

        // 执行登录
        presenter.login("testUser", "wrongPwd");

        // 验证：显示加载 -> 调用Repository -> 隐藏加载 -> 显示错误
        verify(mockView).showLoading();
        verify(mockRepository).login("testUser", "wrongPwd");
        verify(mockView).hideLoading();
        verify(mockView).showError("账号或密码错误");
    }

    // 测试点4：账号密码正确（Repository返回成功）-> 显示用户信息
    @Test
    public void login_withValidCredentials_shouldShowSuccess() {
        // 准备Mock数据：Repository返回成功（用户信息）
        User mockUser = new User("testUser", "test@example.com");
        when(mockRepository.login("testUser", "correctPwd"))
            .thenReturn(new Result.Success<>(mockUser));

        // 执行登录
        presenter.login("testUser", "correctPwd");

        // 验证：显示加载 -> 调用Repository -> 隐藏加载 -> 显示成功
        verify(mockView).showLoading();
        verify(mockRepository).login("testUser", "correctPwd");
        verify(mockView).hideLoading();
        verify(mockView).showSuccess(mockUser);
    }
}
```

此时运行测试，所有用例都会**失败**（红阶段），因为`LoginPresenter.login()`是空实现。

## **四、第二步：实现功能代码（Green阶段）**

根据测试用例，实现`LoginPresenter.login()`的逻辑，确保测试通过：

```java
public class LoginPresenter {
    // ... （省略构造器和attachView，同前）

    public void login(String username, String password) {
        // 1. 本地校验：用户名或密码为空
        if (username.isEmpty()) {
            view.showError("用户名不可为空");
            return;
        }
        if (password.isEmpty()) {
            view.showError("密码不可为空");
            return;
        }

        // 2. 显示加载
        view.showLoading();

        // 3. 调用Repository登录
        Result<User> result = repository.login(username, password);

        // 4. 处理结果
        view.hideLoading();
        if (result instanceof Result.Success) {
            User user = ((Result.Success<User>) result).data;
            view.showSuccess(user);
        } else {
            String errorMsg = ((Result.Failure<User>) result).errorMsg;
            view.showError(errorMsg);
        }
    }
}
```

再次运行测试，所有用例应**通过**（绿阶段）。

## **五、第三步：重构代码（Refactor阶段）**

优化代码结构（如抽取重复逻辑、简化条件判断），同时保持测试通过。例如，将本地校验逻辑抽取为单独方法：

```java
public class LoginPresenter {
    // ...

    public void login(String username, String password) {
        // 抽取本地校验
        String validateError = validateInput(username, password);
        if (validateError != null) {
            view.showError(validateError);
            return;
        }

        view.showLoading();
        Result<User> result = repository.login(username, password);
        view.hideLoading();

        if (result instanceof Result.Success) {
            view.showSuccess(((Result.Success<User>) result).data);
        } else {
            view.showError(((Result.Failure<User>) result).errorMsg);
        }
    }

    // 抽取的校验方法
    private String validateInput(String username, String password) {
        if (username.isEmpty()) return "用户名不可为空";
        if (password.isEmpty()) return "密码不可为空";
        return null;
    }
}
```

重构后重新运行测试，确保功能不受影响。

## **六、Mock数据的设计原则**

在TDD中，Mock数据（如`UserRepository`的返回结果）需遵循以下原则：

1. **隔离依赖**：Mock掉所有外部依赖（网络、数据库、系统服务等），确保测试只关注当前单元（如Presenter的逻辑）。
2. **覆盖边界场景**：除了正常数据，还需Mock异常场景（如网络超时、空数据、错误格式等）。
3. **保持简洁**：Mock数据只需包含测试所需的最小字段（如`User`只需`username`，无需冗余字段）。
4. **与真实数据结构一致**：Mock数据的格式应与真实场景一致（如字段名、类型），避免测试通过但实际运行出错。

## **七、扩展：TDD流程的循环与自动化**

1. **小步迭代**：每次只针对一个测试点编写测试和实现，避免一次性处理复杂逻辑。
2. **持续集成**：将测试集成到CI流程（如GitHub Actions、Jenkins），每次提交代码自动运行测试，确保功能不退化。
3. **逐步完善**：随着需求迭代，新增测试用例→实现功能→重构，形成闭环。

## **总结**

Android TDD从无到有的核心步骤：  

1. **拆需求**：将功能拆分为可测试的小单元；  
2. **搭环境**：配置JUnit、Mockito、Robolectric等工具；  
3. **写测试**：基于需求编写失败的单元测试（红），用Mock隔离依赖；  
4. **实现功能**：编写代码使测试通过（绿）；  
5. **重构**：优化代码，保持测试通过。  

通过这种方式，可在开发早期发现问题，同时保证代码的可测试性和灵活性。

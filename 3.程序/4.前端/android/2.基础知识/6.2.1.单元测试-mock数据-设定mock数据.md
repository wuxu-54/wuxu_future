# mock

在 Android 开发中，设置 Mock 数据是测试和开发过程中的重要环节，特别是在后端接口尚未完成或需要隔离网络依赖的情况下。以下是几种最佳做法和实现方式：

## **1. 使用接口隔离数据源**

**核心思想**：通过接口抽象数据源，实现生产环境和测试环境的分离。

```kotlin
// 定义数据接口
interface UserDataSource {
    suspend fun getUsers(): List<User>
}

// 生产环境实现（依赖真实 API）
class RemoteUserDataSource(private val apiService: ApiService) : UserDataSource {
    override suspend fun getUsers(): List<User> = apiService.fetchUsers()
}

// Mock 实现（用于测试和开发）
class MockUserDataSource : UserDataSource {
    override suspend fun getUsers(): List<User> = listOf(
        User(id = 1, name = "Alice"),
        User(id = 2, name = "Bob")
    )
}
```

## **2. 构建可配置的依赖注入**

使用 Koin、Hilt 或 Dagger 等依赖注入框架，根据环境切换数据源：

```kotlin
// Koin 示例
val appModule = module {
    single<UserDataSource> {
        if (BuildConfig.DEBUG) {
            MockUserDataSource() // 开发环境使用 Mock
        } else {
            RemoteUserDataSource(get()) // 生产环境使用真实 API
        }
    }
}
```

## **3. 使用 JSON 文件存储 Mock 数据**

将复杂的 Mock 数据存储在 `assets` 目录下的 JSON 文件中，便于维护和复用：

```kotlin
// assets/users.json
[
  {"id": 1, "name": "Alice"},
  {"id": 2, "name": "Bob"}
]

// 读取 JSON 文件的工具函数
suspend fun loadMockUsers(context: Context): List<User> {
    val json = context.assets.open("users.json").bufferedReader().use { it.readText() }
    return Gson().fromJson(json, Array<User>::class.java).toList()
}
```

## **4. 使用 MockWebServer 模拟网络请求**

对于 Retrofit 等网络库，使用 `MockWebServer` 可以精确控制请求和响应：

```kotlin
// 测试代码示例
val mockServer = MockWebServer()

// 配置模拟响应
val mockResponse = MockResponse()
    .setResponseCode(200)
    .setBody("""[{"id":1,"name":"Alice"}]""")
mockServer.enqueue(mockResponse)

// 创建使用 MockWebServer 的 Retrofit 实例
val retrofit = Retrofit.Builder()
    .baseUrl(mockServer.url("/"))
    .addConverterFactory(GsonConverterFactory.create())
    .build()

// 执行请求测试
val apiService = retrofit.create(ApiService::class.java)
val users = apiService.getUsers()
```

## **5. 使用注解或构建变体**

通过 Gradle 构建变体（Build Variants）或自定义注解，在编译时切换数据源：

```kotlin
// build.gradle.kts
android {
    buildTypes {
        debug {
            buildConfigField("Boolean", "USE_MOCK_DATA", "true")
        }
        release {
            buildConfigField("Boolean", "USE_MOCK_DATA", "false")
        }
    }
}

// 使用 BuildConfig 控制
if (BuildConfig.USE_MOCK_DATA) {
    // 使用 Mock 数据
} else {
    // 使用真实数据
}
```

## **6. 使用测试替身（Test Doubles）**

在单元测试中，使用 `Mockito` 或 Kotlin 的 `object` 关键字创建轻量级的 Mock 对象：

```kotlin
// Mockito 示例
val mockApiService = mock(ApiService::class.java)
`when`(mockApiService.getUsers()).thenReturn(
    listOf(User(id = 1, name = "Mock User"))
)

// 或使用 Kotlin object
object MockApiService : ApiService {
    override suspend fun getUsers(): List<User> = listOf(
        User(id = 1, name = "Test User")
    )
}
```

## **7. 使用数据生成库**

对于复杂的测试数据，使用库如 `Faker` 自动生成随机但符合业务规则的数据：

```kotlin
// 添加依赖
implementation 'com.github.javafaker:javafaker:1.0.2'

// 生成随机用户数据
val faker = Faker()
val user = User(
    id = faker.number().randomNumber(),
    name = faker.name().fullName(),
    email = faker.internet().emailAddress()
)
```

## **最佳实践总结**

1. **分层隔离**：通过接口抽象数据源，实现生产和测试环境的解耦。
2. **配置化管理**：使用依赖注入或构建变体动态切换数据源。
3. **文件化存储**：复杂的 Mock 数据存储在 JSON 文件中，便于维护。
4. **精确模拟**：对于网络请求，优先使用 `MockWebServer` 模拟完整的 HTTP 响应。
5. **测试专用**：单元测试中使用轻量级的测试替身，避免依赖外部资源。

通过这些方法，可以高效地管理 Mock 数据，提高开发效率和测试覆盖率。

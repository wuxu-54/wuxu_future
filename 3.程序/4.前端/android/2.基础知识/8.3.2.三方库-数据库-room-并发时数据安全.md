# 并发时数据安全

在 Android Room 中处理并发写入操作时，为避免数据冲突和保证数据一致性，可以采用以下策略：

## **1. 使用 Room 内置冲突处理策略**

在 `@Insert`、`@Update` 或 `@Delete` 注解中指定 `onConflict` 参数：

```kotlin
@Dao
interface UserDao {
    // 冲突时替换旧数据
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUser(user: User)

    // 冲突时忽略新数据（静默失败）
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insertUserIfNotExists(user: User)

    // 冲突时抛出异常（默认行为）
    @Insert(onConflict = OnConflictStrategy.ABORT)
    suspend fun insertUserStrict(user: User)
}
```

## **2. 使用事务保证原子性**

通过 `@Transaction` 注解确保一组操作的原子性，避免部分更新：

```kotlin
@Dao
interface UserDao {
    @Transaction
    suspend fun updateUserAndLog(userId: Int, newName: String) {
        updateUserName(userId, newName)
        insertLog(Log(userId, "Name updated"))
    }

    @Query("UPDATE user SET name = :newName WHERE id = :userId")
    suspend fun updateUserName(userId: Int, newName: String)

    @Insert
    suspend fun insertLog(log: Log)
}
```

## **3. 实现手动锁机制**

对于需要更严格控制的场景，使用 `Mutex` 或 `ReentrantLock`：

```kotlin
class UserRepository(private val userDao: UserDao) {
    private val writeMutex = Mutex()

    suspend fun safeInsertUser(user: User) {
        writeMutex.withLock {
            userDao.insertUser(user)
        }
    }
}
```

## **4. 乐观锁（版本控制）**

通过 `@Version` 注解实现乐观锁，检测并处理并发修改：

```kotlin
@Entity
data class User(
    @PrimaryKey val id: Int,
    var name: String,
    @Version var version: Int = 0
)

// DAO 方法
@Update
suspend fun updateUser(user: User): Int // 返回更新的行数（0 表示版本冲突）
```

处理版本冲突：

```kotlin
suspend fun updateUserName(userId: Int, newName: String) {
    var retryCount = 0
    val maxRetries = 3

    while (retryCount < maxRetries) {
        val user = userDao.getUser(userId)
        user.name = newName
        
        val updatedRows = userDao.updateUser(user)
        if (updatedRows > 0) {
            return // 更新成功
        }
        
        // 冲突发生，重试
        retryCount++
    }
    
    throw ConcurrentUpdateException("更新失败：多次冲突")
}
```

## **5. 原子操作（CAS）**

对于简单更新，使用带条件的原子查询：

```kotlin
@Dao
interface UserDao {
    // 原子性地增加年龄（无需先查询）
    @Query("UPDATE user SET age = age + 1 WHERE id = :userId AND age = :expectedAge")
    suspend fun incrementAgeIfMatch(userId: Int, expectedAge: Int): Int
}
```

## **6. 批量操作优化**

使用批量操作减少锁竞争：

```kotlin
@Dao
interface UserDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(users: List<User>)
}
```

## **7. 测试并发场景**

使用 `CountDownLatch` 测试多线程写入：

```kotlin
@Test
fun testConcurrentInserts() = runBlocking {
    val dao = database.userDao()
    val latch = CountDownLatch(10)
    val scope = CoroutineScope(Dispatchers.Default)

    repeat(10) { i ->
        scope.launch {
            try {
                dao.insertUser(User(id = i, name = "User$i"))
            } finally {
                latch.countDown()
            }
        }
    }

    latch.await()
    assertEquals(10, dao.getAllUsers().size)
}
```

## **8. 高级场景：多进程共享数据库**

启用多进程无效化机制：

```kotlin
Room.databaseBuilder(...)
    .enableMultiInstanceInvalidation() // 跨进程通知数据库变更
    .build()
```

## **最佳实践总结**

1. **优先使用内置策略**：通过 `onConflict` 处理常见冲突。
2. **事务保护**：对关联操作使用 `@Transaction`。
3. **锁与同步**：使用 `Mutex` 或 `ReentrantLock` 处理复杂场景。
4. **乐观锁**：对敏感数据使用 `@Version` 注解。
5. **原子查询**：避免"查询-修改-写入"循环，直接使用带条件的更新。
6. **性能优化**：批量操作替代多次单条写入。

通过组合这些策略，可以有效处理 Room 数据库中的并发写入问题，确保数据一致性和应用稳定性。

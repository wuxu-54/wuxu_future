# **Repository** 和 **Data Source**

在 Android 的数据层（Data Layer）架构中，**Repository** 和 **Data Source** 是两个核心概念，它们的职责和设计目的有明显区别，但又紧密协作。以下是详细解释：

## **1. 定义与核心职责**

### **Data Source（数据源）**

- **职责**：负责与具体的数据存储（如网络、数据库、文件等）进行交互，提供底层数据访问能力。
- **特点**：
  - **单一数据源**：通常只处理一种数据来源（如网络 API 或本地数据库）。
  - **原子操作**：提供基础的数据读写方法（如 `getUserById(id: Int)`、`saveUser(user: User)`）。
  - **无业务逻辑**：仅关注数据的获取和存储，不包含业务规则。

### **Repository（仓库）**

- **职责**：作为数据的统一入口，协调多个 Data Source，处理数据冲突、缓存策略和数据转换。
- **特点**：
  - **数据整合**：从多个 Data Source 获取数据并统一处理（如优先使用本地缓存，否则从网络获取）。
  - **业务逻辑**：包含与数据相关的业务规则（如数据持久化策略、脏数据处理）。
  - **领域模型转换**：将 Data Source 的原始数据转换为应用的领域模型。

## **2. 协作流程**

```txt
UI/UseCase → Repository → Data Source(s)
```

- **UI 或 UseCase** 通过调用 **Repository** 的方法获取数据。
- **Repository** 根据需求选择合适的 **Data Source**（如本地数据库或网络 API）。
- **Data Source** 返回原始数据，**Repository** 可能会对数据进行转换、缓存或合并。

## **3. 示例代码**

### **Data Source 接口与实现**

```kotlin
// 网络数据源接口
interface UserRemoteDataSource {
    suspend fun fetchUsers(): List<UserNetworkModel>
}

// 本地数据源接口
interface UserLocalDataSource {
    suspend fun getUsers(): List<UserEntity>
    suspend fun saveUsers(users: List<UserEntity>)
}

// 网络数据源实现（如 Retrofit 调用）
class UserRemoteDataSourceImpl(private val apiService: UserApi) : UserRemoteDataSource {
    override suspend fun fetchUsers(): List<UserNetworkModel> = apiService.getUsers()
}

// 本地数据源实现（如 Room 数据库）
class UserLocalDataSourceImpl(private val userDao: UserDao) : UserLocalDataSource {
    override suspend fun getUsers(): List<UserEntity> = userDao.getAll()
    override suspend fun saveUsers(users: List<UserEntity>) = userDao.insertAll(users)
}
```

### **Repository 实现**

```kotlin
class UserRepositoryImpl(
    private val remoteDataSource: UserRemoteDataSource,
    private val localDataSource: UserLocalDataSource,
    private val networkMapper: NetworkMapper, // 网络模型 → 领域模型
    private val entityMapper: EntityMapper // 实体 → 领域模型
) : UserRepository {

    override suspend fun getUsers(): List<User> {
        return try {
            // 1. 优先从本地获取
            val localUsers = localDataSource.getUsers()
            if (localUsers.isNotEmpty()) {
                entityMapper.mapToDomainList(localUsers)
            } else {
                // 2. 本地无数据，从网络获取
                val networkUsers = remoteDataSource.fetchUsers()
                // 3. 转换为实体并保存到本地
                val entities = networkMapper.mapToEntityList(networkUsers)
                localDataSource.saveUsers(entities)
                // 4. 返回领域模型
                entityMapper.mapToDomainList(entities)
            }
        } catch (e: Exception) {
            // 错误处理逻辑
            emptyList()
        }
    }
}
```

## **4. 关键区别对比**

| **维度**         | **Repository**                          | **Data Source**                       |
|------------------|------------------------------------------|---------------------------------------|
| **数据来源**      | 整合多个 Data Source                     | 单一数据来源（网络、本地等）          |
| **业务逻辑**      | 包含（如缓存策略、数据合并）             | 不包含                                |
| **数据模型**      | 使用领域模型（Domain Model）             | 使用原始模型（如 NetworkModel、Entity）|
| **设计模式**      | 实现 **单一数据源原则**（对上层提供统一接口）| 实现 **单一职责原则**（专注特定数据源）|
| **调用方式**      | 被 UI 层或 UseCase 直接调用               | 通过 Repository 间接调用              |

## **5. 为什么要分离？**

1. **关注点分离**：
   - Data Source 专注于数据读写，Repository 专注于数据协调。
   - 降低代码耦合，提高可维护性。

2. **测试便利**：
   - 可以轻松替换 Data Source 为 Mock 实现，测试 Repository 的逻辑。

3. **灵活性**：
   - 当数据源变化（如从 REST API 切换到 GraphQL）时，只需修改对应的 Data Source，不影响 Repository。

4. **缓存策略**：
   - Repository 可以实现复杂的缓存逻辑（如内存缓存、本地数据库缓存），而 Data Source 只需提供基础操作。

## **总结**

- **Data Source** 是底层的数据访问工具，负责与具体存储交互。
- **Repository** 是数据层的门面（Facade），负责协调数据来源、处理业务逻辑，并为上层提供统一的数据接口。

通过这种分层设计，Android 应用可以实现更清晰的架构、更好的可测试性和可维护性。

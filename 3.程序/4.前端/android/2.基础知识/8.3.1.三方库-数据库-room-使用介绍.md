# room

>数据知识可以看[MySQL-基础知识](/3.程序/3.后端/数据库/MySQL/2.基础知识/)

以下是 Android Room 数据库的详细使用指南，包含从基础配置到高级功能的完整流程。Room 是 Android Jetpack 的一部分，提供了 SQLite 数据库的抽象层，简化了数据库操作并支持 LiveData、Kotlin Coroutines 等特性。

## **一、添加依赖**

在 `build.gradle` 中添加 Room 依赖（Kotlin 项目）：

```groovy
def room_version = "2.5.2" // 最新稳定版本

dependencies {
    // 核心依赖
    implementation "androidx.room:room-runtime:$room_version"
    kapt "androidx.room:room-compiler:$room_version" // Java 项目使用 annotationProcessor
    
    // Kotlin 扩展
    implementation "androidx.room:room-ktx:$room_version"
    
    // 可选：用于 RxJava 支持
    implementation "androidx.room:room-rxjava3:$room_version"
    
    // 可选：用于测试
    testImplementation "androidx.room:room-testing:$room_version"
}
```

## **二、定义数据模型（Entity）**

使用 `@Entity` 注解定义数据库表结构：

```kotlin
// UserEntity.kt
@Entity(tableName = "users")
data class UserEntity(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    @ColumnInfo(name = "first_name") val firstName: String,
    @ColumnInfo(name = "last_name") val lastName: String,
    val age: Int,
    val email: String,
    
    // 可选：忽略字段不存储到数据库
    @Ignore val tempData: String = ""
)
```

**复合主键**：

```kotlin
@Entity(
    tableName = "user_roles",
    primaryKeys = ["userId", "roleId"] // 复合主键
)
data class UserRole(
    val userId: Long,
    val roleId: Long,
    val assignedAt: Long
)
```

**索引与外键**：

```kotlin
@Entity(
    tableName = "books",
    indices = [Index(value = ["authorId"])], // 为 authorId 添加索引
    foreignKeys = [
        ForeignKey(
            entity = UserEntity::class,
            parentColumns = ["id"],
            childColumns = ["authorId"],
            onDelete = ForeignKey.CASCADE // 级联删除
        )
    ]
)
data class Book(
    @PrimaryKey val id: Long,
    val title: String,
    val authorId: Long
)
```

## **三、定义数据访问对象（DAO）**

使用 `@Dao` 注解定义数据库操作接口：

```kotlin
// UserDao.kt
@Dao
interface UserDao {
    // 查询所有用户
    @Query("SELECT * FROM users")
    fun getAllUsers(): List<UserEntity>
    
    // 带条件查询
    @Query("SELECT * FROM users WHERE age > :minAge")
    fun getUsersOlderThan(minAge: Int): List<UserEntity>
    
    // 插入单个用户
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUser(user: UserEntity): Long // 返回插入的 ID
    
    // 插入多个用户
    @Insert
    suspend fun insertAll(users: List<UserEntity>)
    
    // 更新用户
    @Update
    suspend fun updateUser(user: UserEntity): Int // 返回受影响的行数
    
    // 删除用户
    @Delete
    suspend fun deleteUser(user: UserEntity): Int // 返回受影响的行数
    
    // 自定义查询（返回 LiveData）
    @Query("SELECT * FROM users ORDER BY age DESC")
    fun getUsersByAge(): LiveData<List<UserEntity>>
    
    // 聚合查询
    @Query("SELECT COUNT(*) FROM users")
    suspend fun getUserCount(): Int
}
```

**关联查询（JOIN）**：

```kotlin
// 返回自定义数据结构
data class UserWithBooks(
    @Embedded val user: UserEntity,
    @Relation(
        parentColumn = "id",
        entityColumn = "authorId",
        entity = Book::class
    )
    val books: List<Book>
)

@Query("SELECT * FROM users")
fun getUsersWithBooks(): LiveData<List<UserWithBooks>>
```

## **四、定义数据库类**

使用 `@Database` 注解定义数据库：

```kotlin
// AppDatabase.kt
@Database(
    entities = [UserEntity::class, Book::class],
    version = 1,
    exportSchema = true // 导出数据库模式（默认保存在 build 目录下）
)
@TypeConverters(Converters::class) // 注册类型转换器
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
    abstract fun bookDao(): BookDao
    
    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null
        
        fun getInstance(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "app_database"
                )
                .addCallback(object : RoomDatabase.Callback() {
                    override fun onCreate(db: SupportSQLiteDatabase) {
                        super.onCreate(db)
                        // 数据库创建时执行（第一次初始化）
                    }
                    
                    override fun onOpen(db: SupportSQLiteDatabase) {
                        super.onOpen(db)
                        // 数据库打开时执行
                    }
                })
                .fallbackToDestructiveMigration() // 版本升级时破坏性迁移（删除重建）
                .build()
                
                INSTANCE = instance
                instance
            }
        }
    }
}
```

## **五、类型转换器（TypeConverters）**

处理自定义类型（如 Date、Enum 等）：

```kotlin
// Converters.kt
class Converters {
    @TypeConverter
    fun fromTimestamp(value: Long?): Date? {
        return value?.let { Date(it) }
    }
    
    @TypeConverter
    fun dateToTimestamp(date: Date?): Long? {
        return date?.time
    }
    
    @TypeConverter
    fun toUserType(value: String): UserType {
        return UserType.valueOf(value)
    }
    
    @TypeConverter
    fun fromUserType(type: UserType): String {
        return type.name
    }
}
```

## **六、数据库迁移（Migrations）**

当数据库版本升级时，使用 `Migration` 类保留数据：

```kotlin
// 从版本 1 到 2 的迁移
val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("ALTER TABLE users ADD COLUMN phone TEXT")
    }
}

// 从版本 2 到 3 的迁移
val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("CREATE TABLE IF NOT EXISTS `books` (" +
            "`id` INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, " +
            "`title` TEXT, " +
            "`authorId` INTEGER NOT NULL, " +
            "FOREIGN KEY(`authorId`) REFERENCES `users`(`id`) ON DELETE CASCADE" +
            ")")
    }
}

// 在数据库构建时添加迁移
val instance = Room.databaseBuilder(
    context.applicationContext,
    AppDatabase::class.java,
    "app_database"
)
.addMigrations(MIGRATION_1_2, MIGRATION_2_3) // 添加所有迁移
.build()
```

## **七、在应用中使用 Room**

### 1. **初始化数据库**

```kotlin
class MyApplication : Application() {
    val database: AppDatabase by lazy {
        Room.databaseBuilder(
            applicationContext,
            AppDatabase::class.java,
            "app_database"
        )
        .build()
    }
}
```

### 2. **在 ViewModel 中使用 DAO**

```kotlin
class UserViewModel(application: Application) : AndroidViewModel(application) {
    private val userDao = (application as MyApplication).database.userDao()
    val allUsers: LiveData<List<UserEntity>> = userDao.getUsersByAge()
    
    // 插入用户（在协程中执行）
    fun insertUser(user: UserEntity) {
        viewModelScope.launch {
            userDao.insertUser(user)
        }
    }
}
```

### 3. **在 Activity/Fragment 中观察数据**

```kotlin
class UserListActivity : AppCompatActivity() {
    private lateinit var viewModel: UserViewModel
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_user_list)
        
        viewModel = ViewModelProvider(this).get(UserViewModel::class.java)
        viewModel.allUsers.observe(this) { users ->
            // 更新 UI
            userAdapter.submitList(users)
        }
    }
}
```

## **八、高级功能**

### 1. **事务处理**

```kotlin
@Dao
interface UserDao {
    @Transaction
    suspend fun insertUserAndLog(user: UserEntity) {
        insertUser(user)
        // 其他操作
    }
}
```

### 2. **RxJava 支持**

```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getUsersFlowable(): Flowable<List<UserEntity>>
    
    @Insert
    fun insertUserCompletable(user: UserEntity): Completable
}
```

### 3. **测试 Room DAO**

```kotlin
@RunWith(AndroidJUnit4::class)
class UserDaoTest {
    private lateinit var database: AppDatabase
    private lateinit var userDao: UserDao
    
    @Before
    fun setUp() {
        val context = InstrumentationRegistry.getInstrumentation().targetContext
        database = Room.inMemoryDatabaseBuilder(context, AppDatabase::class.java)
            .allowMainThreadQueries() // 仅用于测试
            .build()
        userDao = database.userDao()
    }
    
    @After
    fun tearDown() {
        database.close()
    }
    
    @Test
    fun insertAndGetUser() = runBlocking {
        val user = UserEntity(firstName = "John", lastName = "Doe", age = 30)
        val id = userDao.insertUser(user)
        
        val loadedUser = userDao.getUserById(id)
        assertEquals("John", loadedUser.firstName)
    }
}
```

## **九、性能优化**

1. **批量操作**：使用 `insertAll()` 而非多次调用 `insert()`
2. **索引优化**：为经常查询的字段添加索引
3. **延迟初始化**：使用 `by lazy` 延迟创建数据库实例
4. **避免 UI 线程操作**：使用协程或 RxJava 在后台线程执行数据库操作
5. **预填充数据库**：使用 `createFromAsset()` 或 `createFromFile()` 加载预填充数据

## **十、常见问题**

1. **找不到实现类**：  
   - 确保添加了 `room-compiler` 依赖
   - 检查 `@Database` 注解的实体类列表是否正确
   - 执行 Clean Project 和 Rebuild Project

2. **数据未更新**：  
   - 确保在 DAO 方法中使用 `suspend` 关键字（协程）
   - 使用 LiveData 或 Flow 自动监听数据变化

3. **迁移失败**：  
   - 确保所有 Migration 类正确实现
   - 使用 `fallbackToDestructiveMigration()` 作为临时解决方案（开发阶段）

通过以上步骤，你可以全面掌握 Android Room 的使用方法，从基础的数据库操作到高级的关联查询和迁移管理。Room 结合 Kotlin 协程和 LiveData，能让你高效地构建数据驱动的 Android 应用。

---

## 使用 KSP 替代 KAPT（可选优化）

KSP（Kotlin Symbol Processing）是 Kotlin 官方的注解处理工具，性能优于 KAPT。可以按如下方式配置：

```groovy
plugins {
    id 'com.google.devtools.ksp' version '1.8.22-1.0.9'
}

dependencies {
    implementation "androidx.room:room-runtime:$room_version"
    ksp "androidx.room:room-compiler:$room_version"
    implementation "androidx.room:room-ktx:$room_version"
}
```

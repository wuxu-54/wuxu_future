# Parcel

Android中的Parcel是一个高效的容器，主要用于存储和传输序列化数据。以下是对Android中Parcel的详细解释，包括其常用API及功能：

## 一、Parcel概述

Parcel在Android系统中扮演着重要角色，特别是在进程间通信（IPC）中。它作为数据的载体，允许在不同进程或组件间高效地传输数据。Parcel不仅支持基本数据类型的存储，还支持复杂对象（如实现了Parcelable接口的类）的存储。

## 二、Parcel的常用API及解释

1. **基本数据类型的读写**

   * **writeXXX()方法**：用于将基本数据类型（如int、long、float、double、boolean、char等）写入Parcel。
   * **readXXX()方法**：用于从Parcel中读取基本数据类型。

   这些方法的命名规则非常直观，例如writeInt()用于写入int类型的数据，readInt()用于读取int类型的数据。

2. **数组的读写**

   * **writeBooleanArray()、readBooleanArray()**：用于读写boolean类型的数组。
   * **writeByteArray()、readByteArray()**：用于读写byte类型的数组。
   * **writeCharArray()、readCharArray()**：用于读写char类型的数组。
   * **writeDoubleArray()、readDoubleArray()**：用于读写double类型的数组。
   * **writeFloatArray()、readFloatArray()**：用于读写float类型的数组。
   * **writeIntArray()、readIntArray()**：用于读写int类型的数组。
   * **writeLongArray()、readLongArray()**：用于读写long类型的数组。
   * **writeStringArray()、readStringArray()**：用于读写String类型的数组。

   此外，Parcel还提供了createXXXArray()方法用于创建新数组。

3. **Parcelable对象的读写**

   * **writeParcelable()、readParcelable()**：用于读写实现了Parcelable接口的复杂对象。
   * **writeParcelableArray()、readParcelableArray()**：用于读写Parcelable对象数组。

   这些方法允许将复杂对象及其数组序列化为Parcel中的数据，以便在进程间传输。

4. **Bundles的读写**

   * **writeBundle()、readBundle()**：用于读写Bundles对象。Bundles是一种类型安全的Map型容器，可用于存储任何不同类型的数据。

5. **Active Objects的读写**

   * **writeStrongBinder()、readStrongBinder()**：用于读写IBinder对象。IBinder是Android跨进程通讯的基础，这些方法允许将IBinder对象序列化到Parcel中并在进程间传输。
   * **writeFileDescriptor()、readFileDescriptor()**：用于读写FileDescriptor对象。FileDescriptor代表了原始的Linux文件描述符，这些方法允许将文件描述符序列化到Parcel中并在进程间传输。

6. **其他方法**

   * **setDataPosition()**：设置读取数据的偏移量。这允许在读取数据时从Parcel的任意位置开始。
   * **dataPosition()**：获取当前读取数据的偏移量。
   * **dataSize()**：获取Parcel中数据的总大小（以字节为单位）。
   * **writeToParcel()**：这是Parcelable接口中的一个方法，用于将对象的数据写入Parcel。
   * **createFromParcel()**：这是Parcelable.Creator接口中的一个方法，用于从Parcel中创建对象的实例。

## 三、使用注意事项

* Parcel不是一般目的的序列化机制。它被设计用于高性能的IPC传输，因此不适合将Parcel写入永久化存储中。
* 在使用writeXXX()和readXXX()方法时，需要注意数据类型的匹配和偏移量的共用。如果数据类型不匹配或偏移量设置不正确，可能会导致数据读取错误。
* Parcelable接口的实现类需要提供一个CREATOR常量来创建对象实例。这个常量是必需的，因为Android框架在反序列化Parcelable对象时会使用它。

综上所述，Parcel是Android中一个非常重要的类，它提供了高效的数据存储和传输机制。通过掌握其常用API和使用注意事项，可以开发出更加高效和稳定的Android应用程序。

---

## `writeXXX()`和`readXXX()`的原理

Parcel中的`writeXXX()`和`readXXX()`方法用于数据的序列化和反序列化，其原理主要基于Parcel的内存存储机制和偏移量的管理。以下是对这两个方法原理的详细解释：

### 一、Parcel的内存存储机制

1. **基本数据类型存储**：
   * Parcel以32位（4字节）为基本存储单位。对于小于或等于32位的数据类型（如boolean、char、int等），它们将直接占用一个32位的存储空间。
   * 对于大于32位的数据类型（如long、float、double以及字符串和数组等），它们将占用更多的存储空间，但存储空间的分配仍然是4字节的倍数。

2. **内存对齐**：
   * Parcel的内存存储机制与C语言中的结构体内存对齐类似。这意味着在存储数据时，会考虑数据的对齐要求，以确保数据的正确读取。

### 二、偏移量的管理

1. **偏移量的概念**：
   * 偏移量是指当前读写位置与Parcel对象起始位置之间的距离。在Parcel中，每次调用`writeXXX()`方法写入数据时，偏移量都会相应地增加。同样地，每次调用`readXXX()`方法读取数据时，偏移量也会相应地减少。

2. **偏移量的设置与获取**：
   * 可以通过`setDataPosition()`方法设置Parcel对象的偏移量，以便从特定的位置开始读取数据。
   * 可以通过`dataPosition()`方法获取当前Parcel对象的偏移量。

### 三、writeXXX()和readXXX()方法的原理

> 个人理解，有点像c++中的结构体，其计算内存就是用偏移量加上变量本身内存。

1. **writeXXX()方法的原理**：
   * 当调用`writeXXX()`方法时，Parcel会根据要写入的数据类型分配相应的存储空间。
   * 数据被写入到Parcel的当前偏移量位置，并更新偏移量以指向下一个空闲的存储空间。

2. **readXXX()方法的原理**：
   * 当调用`readXXX()`方法时，Parcel会根据当前偏移量位置读取相应的数据类型。
   * 读取数据后，偏移量会减少相应的字节数，以指向下一个待读取的数据位置。

### 四、注意事项

* 在使用`writeXXX()`和`readXXX()`方法时，需要确保数据类型的匹配。如果写入的数据类型与读取的数据类型不匹配，可能会导致数据读取错误或异常。
* 偏移量的管理非常重要。如果设置不当，可能会导致数据读取不完整或读取到错误的数据。
* Parcel不是一种通用的序列化机制，它主要用于高性能的IPC传输。因此，在将Parcel用于其他场景（如持久化存储）时需要谨慎考虑。

综上所述，Parcel中的`writeXXX()`和`readXXX()`方法通过管理内存存储机制和偏移量来实现数据的序列化和反序列化。在使用这些方法时，需要注意数据类型的匹配和偏移量的管理。

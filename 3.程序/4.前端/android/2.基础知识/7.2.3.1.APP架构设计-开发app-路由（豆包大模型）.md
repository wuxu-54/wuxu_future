# 豆包大模型-路由协议设计

## Android 路由库设计方案（RouterX）

### 一、核心设计目标

1. **统一跳转协议**：支持 Activity、Fragment、Web、API 四种目标类型，通过统一 URL 格式描述路由。
2. **组件化支持**：模块化注册路由，跨模块无依赖跳转。
3. **参数灵活传递**：支持基础类型、Parcelable、Serializable 及自定义参数格式。
4. **安全与容错**：路由校验、参数校验、异常捕获与回调机制。
5. **扩展性**：可插拔的处理器架构，方便后续扩展新目标类型。

### 二、路由协议规范（URL 格式）

```txt
scheme://host/path?queryParams#fragment
```

| 部分       | 说明                                                                 | 示例（Activity）                     | 示例（Fragment）                   | 示例（Web）                        | 示例（API）                        |
|------------|----------------------------------------------------------------------|--------------------------------------|------------------------------------|------------------------------------|------------------------------------|
| **scheme** | 协议头，固定为 `approuter`                                           | approuter                            | approuter                          | approuter                          | approuter                          |
| **host**   | 模块名（组件化场景），如 `main`、`user`、`web`                       | main                                 | user                               | web                                | api                                |
| **path**   | 目标类型 + 具体路径：<br>`/activity`、`/fragment`、`/web`、`/api`     | /activity/LoginActivity               | /fragment/UserProfileFragment       | /web/<https://www.example.com>       | /api/user/getUserInfo              |
| **query**  | 参数列表，包含目标类名、参数、附加选项（如 RequestCode、Flags）     | class=com.example.LoginActivity&...   | class=com.example.UserFragment&...  | url=<https://www.example.com&>...     | method=GET&params=...              |
| **fragment** | 预留扩展字段（暂不使用）                                             | -                                    | -                                  | -                                  | -                                  |

### 三、核心组件设计

### 1. 路由实体类（RouteEntity）

```java
public class RouteEntity {
    String scheme;       // 协议头（固定 approuter）
    String host;         // 模块名
    String path;         // 目标类型（activity/fragment/web/api） + 具体路径
    String targetClass;  // 目标类名（Activity/Fragment 全类名，Web 为完整 URL，API 为接口名）
    Bundle params;       // 通用参数（支持 Parcelable/Serializable）
    int requestCode;     // Activity 跳转 RequestCode
    int flags;           // Activity Flags（如 SINGLE_TOP）
    boolean isWebInApp;  // Web 是否在应用内打开（默认 false，即调用外部浏览器）
    // 其他扩展字段（如 API 回调接口）
}
```

### 2. 路由解析器（RouteParser）

- **功能**：将 URL 字符串解析为 `RouteEntity`，校验格式合法性。
- **核心逻辑**：

  ```java
  public RouteEntity parse(String url) {
      Uri uri = Uri.parse(url);
      RouteEntity entity = new RouteEntity();
      // 校验 scheme
      if (!uri.getScheme().equals("approuter")) throw new RouteException("Invalid scheme");
      entity.scheme = uri.getScheme();
      entity.host = uri.getHost();
      entity.path = uri.getPath();
      // 解析目标类型（path 以 / 分隔，第一个字段为类型）
      String[] pathSegments = uri.getPathSegments().toArray(new String[0]);
      if (pathSegments.length < 2) throw new RouteException("Invalid path");
      entity.targetType = pathSegments[1]; // activity/fragment/web/api
      entity.targetPath = uri.getPath().substring(uri.getPath().indexOf("/", 2)); // 具体路径
      // 解析 query 参数（使用 Uri.Builder 或手动拆分）
      entity.params = parseQueryParams(uri.getQuery());
      return entity;
  }
  ```

### 3. 路由注册表（RouteRegistry）

- **功能**：存储模块注册的路由映射（`Map<String, RouteHandler>`），支持模块化注册。
- **注册方式**：
  - **注解注册**（组件化场景）：通过编译时注解（如 AutoService）生成注册代码。
  - **手动注册**：`RouteRegistry.register("main/activity/LoginActivity", new ActivityHandler());`
- **数据结构**：`ConcurrentHashMap<String, RouteHandler>`（键为 `host/path` 组合）。

### 4. 路由处理器（RouteHandler）

- **接口定义**：

  ```java
  public interface RouteHandler {
      void handle(Context context, RouteEntity entity);
  }
  ```

- **具体实现**：
  - **ActivityHandler**：启动 Activity，支持带参数和 RequestCode：

    ```java
    public void handle(Context context, RouteEntity entity) {
        Intent intent = new Intent(context, Class.forName(entity.targetClass));
        intent.putExtras(entity.params);
        intent.setFlags(entity.flags);
        if (context instanceof Activity) {
            ((Activity) context).startActivityForResult(intent, entity.requestCode);
        } else {
            context.startActivity(intent);
        }
    }
    ```

  - **FragmentHandler**：创建 Fragment 实例并附加到指定容器（需调用方提供容器 ID）：

    ```java
    public void handle(Context context, RouteEntity entity) {
        Fragment fragment = (Fragment) Class.forName(entity.targetClass).newInstance();
        fragment.setArguments(entity.params);
        // 需调用方自行添加到 Activity 容器中，例如：
        // fragmentManager.beginTransaction().add(containerId, fragment).commit();
    }
    ```

  - **WebHandler**：根据 `isWebInApp` 决定使用 WebView 或外部浏览器：

    ```java
    public void handle(Context context, RouteEntity entity) {
        if (entity.isWebInApp) {
            // 在应用内 WebView 打开（需传入 WebView 容器或 Activity）
            WebViewActivity.launch(context, entity.targetClass); // targetClass 为完整 URL
        } else {
            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(entity.targetClass));
            context.startActivity(intent);
        }
    }
    ```

  - **APIHandler**：执行 API 功能（支持同步/异步，需定义回调接口）：

    ```java
    public void handle(Context context, RouteEntity entity) {
        // 示例：通过 Retrofit 调用 API
        String method = entity.params.getString("method");
        Map<String, String> apiParams = entity.params.getParcelable("apiParams");
        ApiService apiService = RetrofitClient.create(ApiService.class);
        Call<Response> call = apiService.invoke(method, apiParams);
        call.enqueue(new Callback<Response>() {
            @Override
            public void onResponse(Call<Response> call, Response<Response> response) {
                // 回调处理（通过 entity 传递的回调接口或全局监听）
            }
        });
    }
    ```

### 5. 路由核心类（RouterX）

- **单例入口**：

  ```java
  public class RouterX {
      private static RouterX instance;
      private RouteParser parser;
      private RouteRegistry registry;

      private RouterX() {
          parser = new RouteParser();
          registry = RouteRegistry.getInstance();
      }

      public static RouterX getInstance() {
          if (instance == null) {
              synchronized (RouterX.class) {
                  instance = new RouterX();
              }
          }
          return instance;
      }

      // 核心跳转方法
      public void jump(Context context, String url, OnRouteCallback callback) {
          try {
              RouteEntity entity = parser.parse(url);
              RouteHandler handler = registry.findHandler(entity.host + entity.path);
              if (handler == null) {
                  callback.onError(new RouteException("Route not found"));
                  return;
              }
              handler.handle(context, entity);
              callback.onSuccess();
          } catch (Exception e) {
              callback.onError(e);
          }
      }
  }
  ```

### 四、参数传递方案

1. **基础参数**：通过 URL Query 传递，如 `?key=value`，支持 String、Int、Boolean 等。
2. **复杂参数**：使用 JSON 序列化（如 `params={"name":"John","age":25}`），或通过 `Bundle` 传递 Parcelable/Serializable 对象。
3. **Activity 特化参数**：
   - `requestCode`：用于 startActivityForResult。
   - `flags`：设置 Activity 启动标志（如 FLAG_ACTIVITY_NEW_TASK）。

### 五、组件化集成

1. **模块注册**：
   - 每个模块在 `AndroidManifest.xml` 中声明路由（或通过注解），编译时生成 `RouteModule` 类，自动注册到 `RouteRegistry`。

   ```java
   // 示例：模块 A 注册 Activity 路由
   @Route(path = "main/activity/LoginActivity", handler = ActivityHandler.class)
   public class LoginActivity extends AppCompatActivity { ... }
   ```

2. **跨模块调用**：
   - 无需依赖目标模块，直接通过 RouterX 跳转：

   ```java
   RouterX.getInstance().jump(context, "approuter://main/activity/LoginActivity?name=Alice");
   ```

### 六、错误处理与回调

1. **异常类型**：
   - `RouteException`：路由未找到、格式错误、参数解析失败等。
   - `ClassNotFoundException`：目标类不存在。
2. **回调接口**：

   ```java
   public interface OnRouteCallback {
       void onSuccess();
       void onError(Exception e);
   }
   ```

3. **全局错误监听**：可注册全局监听器处理未捕获的路由异常。

### 七、性能优化

1. **路由表缓存**：使用 HashMap 存储路由映射，查找时间复杂度 O(1)。
2. **类加载优化**：通过注解在编译期生成目标类的 Class 对象缓存，避免运行时反射耗时。
3. **参数校验**：在注册阶段校验目标类合法性，提前暴露错误。

### 八、使用示例

### 1. 跳转 Activity

```java
String url = "approuter://main/activity/LoginActivity?class=com.example.LoginActivity&name=Bob&age=30";
RouterX.getInstance().jump(context, url, new OnRouteCallback() {
    @Override
    public void onSuccess() {
        // 跳转成功
    }
    @Override
    public void onError(Exception e) {
        // 处理错误
    }
});
```

### 2. 打开 Fragment（需调用方提供容器 ID）

```java
String url = "approuter://user/fragment/UserProfileFragment?class=com.example.UserProfileFragment&userId=123";
RouterX.getInstance().jump(context, url, ...);
// 调用方获取 Fragment 后添加到容器：
FragmentManager fm = getSupportFragmentManager();
fm.beginTransaction().add(R.id.container, fragment).commit();
```

### 3. 跳转 Web

```java
// 应用内打开
String webUrl = "approuter://web/web?url=https://www.example.com&isWebInApp=true";
// 外部浏览器打开（默认）
String webUrl = "approuter://web/web?url=https://www.example.com";
RouterX.getInstance().jump(context, webUrl, ...);
```

### 4. 执行 API

```java
String apiUrl = "approuter://api/api/user/getUserInfo?method=GET&params={"userId":123}";
RouterX.getInstance().jump(context, apiUrl, new OnRouteCallback() {
    @Override
    public void onSuccess() {
        // API 调用成功（异步场景需在 Handler 中处理）
    }
});
```

### 九、扩展与维护

1. **新增目标类型**：实现 `RouteHandler` 接口并注册到路由表。
2. **协议升级**：兼容旧版 URL 格式，通过版本号（如 `scheme://v1/host/path`）平滑过渡。
3. **调试工具**：提供路由可视化工具，查看注册的路由列表和跳转日志。

通过以上设计，RouterX 路由库实现了统一的跨模块跳转协议，支持多种目标类型，兼顾灵活性、性能与组件化需求，适用于中大型 Android 项目的模块化开发。

---

## 实现 RouteHandler 接口并注册到路由表

### 1. 实现 RouteHandler 接口

在前面的设计中，`RouteHandler` 是一个接口，用于处理不同类型的路由跳转逻辑。下面我们详细介绍如何实现这个接口并应用到不同的目标类型（Activity、Fragment、Web、API）。

```java
// 定义 RouteHandler 接口
public interface RouteHandler {
    void handle(Context context, RouteEntity entity);
}
```

以下是针对不同目标类型的具体实现：

#### ActivityHandler

```java
import android.content.Context;
import android.content.Intent;
import android.app.Activity;

public class ActivityHandler implements RouteHandler {
    @Override
    public void handle(Context context, RouteEntity entity) {
        try {
            Intent intent = new Intent(context, Class.forName(entity.targetClass));
            intent.putExtras(entity.params);
            intent.setFlags(entity.flags);
            if (context instanceof Activity) {
                ((Activity) context).startActivityForResult(intent, entity.requestCode);
            } else {
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                context.startActivity(intent);
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

#### FragmentHandler

```java
import android.content.Context;
import android.os.Bundle;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentManager;
import androidx.fragment.app.FragmentTransaction;

public class FragmentHandler implements RouteHandler {
    @Override
    public void handle(Context context, RouteEntity entity) {
        try {
            Fragment fragment = (Fragment) Class.forName(entity.targetClass).newInstance();
            fragment.setArguments(entity.params);
            if (context instanceof androidx.fragment.app.FragmentActivity) {
                FragmentManager fm = ((androidx.fragment.app.FragmentActivity) context).getSupportFragmentManager();
                FragmentTransaction ft = fm.beginTransaction();
                // 这里需要调用方传入容器 ID，假设为 R.id.fragment_container
                ft.replace(R.id.fragment_container, fragment);
                ft.commit();
            }
        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

#### WebHandler

```java
import android.content.Context;
import android.content.Intent;
import android.net.Uri;

public class WebHandler implements RouteHandler {
    @Override
    public void handle(Context context, RouteEntity entity) {
        if (entity.isWebInApp) {
            // 在应用内 WebView 打开
            Intent intent = new Intent(context, WebViewActivity.class);
            intent.putExtra("url", entity.targetClass);
            context.startActivity(intent);
        } else {
            Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(entity.targetClass));
            context.startActivity(intent);
        }
    }
}
```

#### APIHandler

```java
import android.content.Context;
import java.util.Map;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;

public class APIHandler implements RouteHandler {
    @Override
    public void handle(Context context, RouteEntity entity) {
        String baseUrl = "https://example.com/"; // 替换为实际的 API 基础 URL
        Retrofit retrofit = new Retrofit.Builder()
               .baseUrl(baseUrl)
               .addConverterFactory(GsonConverterFactory.create())
               .build();
        ApiService apiService = retrofit.create(ApiService.class);
        String method = entity.params.getString("method");
        Map<String, String> apiParams = (Map<String, String>) entity.params.getSerializable("apiParams");
        Call<ApiResponse> call = apiService.invoke(method, apiParams);
        call.enqueue(new Callback<ApiResponse>() {
            @Override
            public void onResponse(Call<ApiResponse> call, Response<ApiResponse> response) {
                if (response.isSuccessful()) {
                    // 处理成功响应
                } else {
                    // 处理失败响应
                }
            }

            @Override
            public void onFailure(Call<ApiResponse> call, Throwable t) {
                // 处理请求失败
            }
        });
    }
}
```

### 2. 注册到路由表

`RouteRegistry` 负责存储路由映射，以下是如何将上述实现的 `RouteHandler` 注册到路由表的示例：

```java
import java.util.concurrent.ConcurrentHashMap;

public class RouteRegistry {
    private static RouteRegistry instance;
    private ConcurrentHashMap<String, RouteHandler> routeMap;

    private RouteRegistry() {
        routeMap = new ConcurrentHashMap<>();
    }

    public static RouteRegistry getInstance() {
        if (instance == null) {
            synchronized (RouteRegistry.class) {
                instance = new RouteRegistry();
            }
        }
        return instance;
    }

    public void register(String route, RouteHandler handler) {
        routeMap.put(route, handler);
    }

    public RouteHandler findHandler(String route) {
        return routeMap.get(route);
    }
}
```

注册示例：

```java
RouteRegistry registry = RouteRegistry.getInstance();
registry.register("main/activity/LoginActivity", new ActivityHandler());
registry.register("user/fragment/UserProfileFragment", new FragmentHandler());
registry.register("web/web", new WebHandler());
registry.register("api/api/user/getUserInfo", new APIHandler());
```

### 协议升级：兼容旧版 URL 格式，通过版本号

### 1. 新版 URL 格式设计

为了实现协议升级并兼容旧版 URL 格式，我们在 URL 中引入版本号，新的 URL 格式如下：

```txt
scheme://v<version>/host/path?queryParams#fragment
```

例如：

```txt
approuter://v2/main/activity/LoginActivity?class=com.example.LoginActivity&name=Bob&age=30
```

### 2. 路由解析器的升级

`RouteParser` 需要进行升级以支持版本号的解析，并根据版本号进行不同的处理。

```java
import android.net.Uri;

public class RouteParser {
    public RouteEntity parse(String url) {
        Uri uri = Uri.parse(url);
        RouteEntity entity = new RouteEntity();
        // 校验 scheme
        if (!uri.getScheme().equals("approuter")) {
            throw new RouteException("Invalid scheme");
        }
        entity.scheme = uri.getScheme();

        // 解析版本号
        String[] hostSegments = uri.getHost().split("/");
        if (hostSegments.length > 0 && hostSegments[0].startsWith("v")) {
            entity.version = Integer.parseInt(hostSegments[0].substring(1));
        } else {
            entity.version = 1; // 默认版本号为 1
        }

        if (hostSegments.length > 1) {
            entity.host = hostSegments[1];
        } else {
            entity.host = uri.getHost();
        }

        entity.path = uri.getPath();
        // 解析目标类型（path 以 / 分隔，第一个字段为类型）
        String[] pathSegments = uri.getPathSegments().toArray(new String[0]);
        if (pathSegments.length < 2) {
            throw new RouteException("Invalid path");
        }
        entity.targetType = pathSegments[1]; // activity/fragment/web/api
        entity.targetPath = uri.getPath().substring(uri.getPath().indexOf("/", 2)); // 具体路径
        // 解析 query 参数（使用 Uri.Builder 或手动拆分）
        entity.params = parseQueryParams(uri.getQuery());
        return entity;
    }

    private Bundle parseQueryParams(String query) {
        Bundle params = new Bundle();
        if (query != null) {
            String[] pairs = query.split("&");
            for (String pair : pairs) {
                int idx = pair.indexOf("=");
                if (idx > 0) {
                    params.putString(pair.substring(0, idx), pair.substring(idx + 1));
                }
            }
        }
        return params;
    }
}
```

### 3. 路由处理器的版本兼容性处理

在 `RouteHandler` 的实现中，可以根据 `RouteEntity` 中的版本号进行不同的处理。例如，在 `ActivityHandler` 中：

```java
import android.content.Context;
import android.content.Intent;
import android.app.Activity;

public class ActivityHandler implements RouteHandler {
    @Override
    public void handle(Context context, RouteEntity entity) {
        try {
            Intent intent = new Intent(context, Class.forName(entity.targetClass));
            intent.putExtras(entity.params);
            intent.setFlags(entity.flags);
            if (entity.version == 1) {
                // 旧版处理逻辑
            } else if (entity.version == 2) {
                // 新版处理逻辑
            }
            if (context instanceof Activity) {
                ((Activity) context).startActivityForResult(intent, entity.requestCode);
            } else {
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                context.startActivity(intent);
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

通过以上步骤，我们实现了 `RouteHandler` 接口的具体实现并将其注册到路由表，同时通过引入版本号实现了协议升级，兼容旧版 URL 格式。这样在后续的开发中，可以根据不同的版本号对路由处理逻辑进行灵活调整。

---

## 原有设计方案基础上支持“打开某个 App”

在原有设计方案基础上，若需要支持“打开某个 App”（包括第三方 App 或系统应用），可以通过扩展路由协议和新增处理器实现。以下是具体方案：

### 一、扩展路由协议（新增目标类型 `/app`）

#### 1. URL 格式定义

```txt
scheme://host/app?package=com.third.party.app&class=com.third.party.MainActivity&params=...
```

| 字段       | 说明                                                                 | 示例                                  |
|------------|----------------------------------------------------------------------|---------------------------------------|
| **targetType** | 固定为 `app`                                                         | `app`                                 |
| **package**  | 目标 App 的包名（必填）                                               | `com.third.party.app`                 |
| **class**    | 目标 App 的具体 Activity 类名（选填，若不填则打开包的主 Activity）   | `com.third.party.MainActivity`        |
| **params**   | 启动参数（通过 Intent 传递，支持 `Flags` 等）                        | `flags=0x10000000`                    |

### 二、新增路由处理器 `AppHandler`

#### 1. 实现 `RouteHandler` 接口

```java
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.Uri;

public class AppHandler implements RouteHandler {
    @Override
    public void handle(Context context, RouteEntity entity) {
        String packageName = entity.params.getString("package");
        String className = entity.params.getString("class");
        int flags = entity.params.getInt("flags", Intent.FLAG_ACTIVITY_NEW_TASK);

        if (packageName == null) {
            throw new RouteException("Package name is required for app route");
        }

        Intent intent = new Intent();
        if (className != null) {
            // 显式 Intent（指定包名 + 类名）
            intent.setClassName(packageName, className);
        } else {
            // 隐式 Intent（通过包名获取主 Activity）
            intent = context.getPackageManager().getLaunchIntentForPackage(packageName);
            if (intent == null) {
                // 若主 Activity 不存在，尝试通过包名构建空 Intent（部分系统应用可能适用）
                intent = new Intent(Intent.ACTION_MAIN);
                intent.addCategory(Intent.CATEGORY_LAUNCHER);
                intent.setPackage(packageName);
            }
        }

        // 检查是否存在可处理的 Activity
        PackageManager pm = context.getPackageManager();
        List<ResolveInfo> resolveInfos = pm.queryIntentActivities(intent, 0);
        if (resolveInfos.isEmpty()) {
            throw new RouteException("Target app not found: " + packageName);
        }

        // 添加启动参数
        intent.putExtras(entity.params); // 传递自定义参数
        intent.setFlags(flags);

        // 启动 App
        context.startActivity(intent);
    }
}
```

#### 2. 关键逻辑说明

- **显式/隐式 Intent**：
  - 若提供 `class` 参数，使用显式 Intent（精确启动指定 Activity）。
  - 若未提供 `class`，通过 `getLaunchIntentForPackage` 获取主 Activity（隐式 Intent）。
- **参数支持**：
  - `package`（必填）：目标 App 的包名（如 `com.tencent.weixin`）。
  - `class`（选填）：目标 Activity 全类名（如 `com.tencent.weixin.LauncherUI`）。
  - `flags`（选填）：Intent 标志位（如 `FLAG_ACTIVITY_CLEAR_TASK`）。

### 三、更新路由解析器 `RouteParser`

#### 1. 支持 `app` 类型解析

```java
// 在 parse 方法中，解析目标类型时新增对 "app" 的处理
if (pathSegments.length >= 2 && pathSegments[1].equals("app")) {
    entity.targetType = "app";
    // 解析 query 参数中的 package 和 class
    entity.params = parseQueryParams(uri.getQuery());
    String packageName = entity.params.getString("package");
    if (packageName == null) {
        throw new RouteException("Missing 'package' parameter for app route");
    }
    // 目标类名为包名（兼容原有 targetClass 设计，或新增字段，此处复用）
    entity.targetClass = packageName; 
}
```

### 四、注册新处理器到路由表

```java
// 在 RouteRegistry 中注册 AppHandler
RouteRegistry.getInstance().register("common/app", new AppHandler());
```

#### URL 示例

1. **打开微信（主界面）**：

   ```txt
   approuter://common/app?package=com.tencent.weixin
   ```

2. **打开支付宝指定 Activity**：

   ```txt
   approuter://common/app?package=com.eg.android.AlipayGphone&class=com.ali.user.mobile.login.ui.LoginActivity
   ```

3. **带启动参数**：

   ```txt
   approuter://common/app?package=com.example.targetapp&class=com.example.targetapp.LaunchActivity&param1=value1&flags=0x10000000
   ```

### 五、兼容性与错误处理

1. **包不存在处理**：
   - 通过 `PackageManager.queryIntentActivities` 检查目标 App 是否存在，不存在时抛出 `RouteException`，通过回调通知调用方：

     ```java
     if (resolveInfos.isEmpty()) {
         callback.onError(new RouteException("App not installed: " + packageName));
         return;
     }
     ```

2. **权限检查**：
   - 若目标 App 需要特定权限（如调用系统相机），建议在跳转前添加权限校验逻辑。

### 六、扩展设计考虑

1. **深层链接（Deep Link）支持**：
   - 对于支持 Deep Link 的 App，可在 URL 中添加 `deeplink` 参数（如 `deeplink=https://example.com/page`），通过 `Intent.setData(Uri)` 传递。
2. **回传结果支持**：
   - 若需要获取目标 App 返回结果（如登录后回调），可参考 Activity 的 `startActivityForResult` 逻辑，在 `AppHandler` 中支持回调注册。
3. **系统应用快捷方式**：
   - 支持通过 `ShortcutManager` 启动目标 App 的快捷方式（需 API 25+）。

通过以上扩展，原有路由库新增了对“打开 App”的支持，保持了统一的 URL 协议和处理器架构，同时兼容组件化和跨模块调用。

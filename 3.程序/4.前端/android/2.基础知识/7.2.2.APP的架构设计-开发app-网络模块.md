# 网络模块

在 Android 中设计一个可灵活替换底层网络框架的模块，推荐采用**策略模式 + 抽象工厂模式**的组合方案。这种设计允许你在不修改上层代码的情况下切换网络框架（如 Retrofit、OkHttp、Volley 等）。

## **核心设计思路**

1. **抽象接口层**：定义统一的网络请求 API，与具体实现解耦。
2. **策略模式**：将不同框架的实现封装为独立策略。
3. **工厂模式**：动态创建所需的策略实现。
4. **配置中心**：集中管理网络参数和全局配置。

## **代码实现示例**

### **1. 定义统一的网络请求接口**

```kotlin
// 网络请求接口
interface NetworkClient {
    suspend fun <T> execute(request: NetworkRequest): NetworkResponse<T>
    fun cancel(tag: String)
    fun cancelAll()
}

// 请求和响应模型
data class NetworkRequest(
    val url: String,
    val method: HttpMethod,
    val headers: Map<String, String> = emptyMap(),
    val params: Map<String, String> = emptyMap(),
    val body: Any? = null,
    val tag: String = UUID.randomUUID().toString()
)

sealed class NetworkResponse<out T> {
    data class Success<T>(val data: T) : NetworkResponse<T>()
    data class Error(val code: Int, val message: String, val error: Throwable? = null) : NetworkResponse<Nothing>()
}

enum class HttpMethod { GET, POST, PUT, DELETE }
```

### **2. 实现策略接口**

```kotlin
// 网络策略接口
interface NetworkStrategy {
    fun createClient(config: NetworkConfig): NetworkClient
}

// Retrofit 实现
class RetrofitStrategy : NetworkStrategy {
    override fun createClient(config: NetworkConfig): NetworkClient {
        return RetrofitNetworkClient(config)
    }
}

// OkHttp 实现
class OkHttpStrategy : NetworkStrategy {
    override fun createClient(config: NetworkConfig): NetworkClient {
        return OkHttpNetworkClient(config)
    }
}
```

### **3. 工厂模式创建策略**

```kotlin
// 网络客户端工厂
object NetworkClientFactory {
    fun createClient(strategy: NetworkStrategy, config: NetworkConfig): NetworkClient {
        return strategy.createClient(config)
    }
}

// 策略注册中心（可选）
object NetworkStrategyRegistry {
    private val strategies = mutableMapOf<String, NetworkStrategy>()

    fun registerStrategy(name: String, strategy: NetworkStrategy) {
        strategies[name] = strategy
    }

    fun getStrategy(name: String): NetworkStrategy? = strategies[name]
}
```

### **4. 配置中心**

```kotlin
// 网络配置
data class NetworkConfig(
    val baseUrl: String,
    val connectTimeout: Long = 30,
    val readTimeout: Long = 30,
    val writeTimeout: Long = 30,
    val interceptors: List<Interceptor> = emptyList(),
    val enableLogging: Boolean = true,
    // 其他配置参数...
)
```

### **5. 具体网络实现示例（Retrofit）**

```kotlin
class RetrofitNetworkClient(private val config: NetworkConfig) : NetworkClient {
    private val retrofit: Retrofit

    init {
        val okHttpClient = OkHttpClient.Builder()
            .connectTimeout(config.connectTimeout, TimeUnit.SECONDS)
            .readTimeout(config.readTimeout, TimeUnit.SECONDS)
            .writeTimeout(config.writeTimeout, TimeUnit.SECONDS)
            .apply {
                config.interceptors.forEach { addInterceptor(it) }
                if (config.enableLogging) {
                    addInterceptor(HttpLoggingInterceptor().apply {
                        level = HttpLoggingInterceptor.Level.BODY
                    })
                }
            }
            .build()

        retrofit = Retrofit.Builder()
            .baseUrl(config.baseUrl)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .addCallAdapterFactory(CoroutineCallAdapterFactory())
            .build()
    }

    override suspend fun <T> execute(request: NetworkRequest): NetworkResponse<T> {
        return try {
            // 这里使用 Retrofit 的动态代理或直接 OkHttp 请求
            val response = makeRetrofitCall(request)
            NetworkResponse.Success(response)
        } catch (e: Exception) {
            NetworkResponse.Error(-1, "Network error", e)
        }
    }

    // 其他方法实现...
}
```

### **6. 对外统一接口**

```kotlin
// 网络请求管理器
object NetworkManager {
    private lateinit var client: NetworkClient

    fun init(strategy: NetworkStrategy, config: NetworkConfig) {
        client = NetworkClientFactory.createClient(strategy, config)
    }

    suspend fun <T> execute(request: NetworkRequest): NetworkResponse<T> {
        return client.execute(request)
    }

    fun cancel(tag: String) {
        client.cancel(tag)
    }

    fun cancelAll() {
        client.cancelAll()
    }
}
```

## **使用示例**

```kotlin
// 初始化（通常在 Application 中）
NetworkManager.init(
    strategy = RetrofitStrategy(),
    config = NetworkConfig(
        baseUrl = "https://api.example.com/",
        enableLogging = BuildConfig.DEBUG
    )
)

// 发起请求
suspend fun fetchUser(userId: String): User? {
    val request = NetworkRequest(
        url = "users/$userId",
        method = HttpMethod.GET
    )
    
    return when (val response = NetworkManager.execute<User>(request)) {
        is NetworkResponse.Success -> response.data
        is NetworkResponse.Error -> {
            Log.e("Network", "Error: ${response.code} ${response.message}")
            null
        }
    }
}
```

## **替换框架的方法**

如果需要从 Retrofit 切换到 OkHttp，只需修改初始化代码：

```kotlin
// 切换为 OkHttp 实现
NetworkManager.init(
    strategy = OkHttpStrategy(),
    config = NetworkConfig(...)
)
```

## **优势总结**

1. **可扩展性**：新增网络框架只需实现 `NetworkStrategy` 接口。
2. **解耦上层代码**：业务层只依赖抽象接口，不关心具体实现。
3. **集中配置**：所有网络参数统一管理。
4. **易于测试**：可通过模拟 `NetworkClient` 进行单元测试。

通过这种设计，你可以在 Android 应用中灵活切换网络框架，同时保持代码的整洁和可维护性。

# 线程池创建消息队列示例

```kotlin
class Test{
    //执行函数
    private val mRunnable by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
        TaskRunnable(msgProcessor)
    }

    //创建线程池
    private val singleThreadPool by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
        val factory = PushThreadFactory()
        val pool = ThreadPoolExecutor(
            1, 1, 2000, TimeUnit.MILLISECONDS, LinkedBlockingQueue<Runnable>(1),
            ThreadPoolExecutor.DiscardOldestPolicy()
        )
        pool.threadFactory = factory
        pool
    }


    class TaskRunnable(private val msgProcessor: IMsgProcessor) : Runnable {
        //这个是消息队列，存、发消息
        private val msgQueue = LinkedBlockingQueue<MsgLocalBean>(1000)

        fun setMsg(msg: String?, @PushChannelType channel: Int) {
            if (!msg.isNullOrBlank()) {
                msgQueue.offer(MsgLocalBean(msg, channel))
            }
        }

        override fun run() {
            while (true) {
                try {
                    //这个队列为空会阻塞线程，当有数据时会取出数据
                    val msgLocalBean = msgQueue.take()
                    synchronized(this.javaClass) {
                        msgLocalBean?.let {
                            Log.d(TAG, "[process msg] ${Thread.currentThread().name}")
                            msgProcessor.receiveMsg(it.msg, it.channel)
                        }
                    }
                } catch (e: Exception) {
                    e.printStackTrace()
                } finally {
                    Log.d(TAG, "handleMsg mMsg 完成")
                }
            }
        }

        data class MsgLocalBean(val msg: String, @PushChannelType val channel: Int)
    }
}
```

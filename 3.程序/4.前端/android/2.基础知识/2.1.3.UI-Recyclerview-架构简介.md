# Android RecyclerView 源码详解与架构分析

## 一、RecyclerView 整体架构  

RecyclerView 是 Android 用于高效展示大量数据的核心控件，其设计遵循**职责分离原则**，通过模块化组件实现高扩展性和复用性。核心架构可概括为「1 个核心控件 + 5 大组件」，各组件通过接口交互，灵活解耦。

### 1.1 架构图（核心组件关系）  

```txt
┌─────────────────────────────────────────────────────────┐  
│                     RecyclerView (核心控件)             │  
├─────────┬───────────────┬──────────────┬───────────────┤  
│ Adapter │ LayoutManager │    Recycler  │ ItemAnimator  │  
└────┬────┴───────┬───────┴───────┬──────┴───────┬───────┘  
     │            │               │              │  
     ▼            ▼               ▼              ▼  
┌──────────┐ ┌──────────┐  ┌──────────────┐  ┌──────────┐  
│ViewHolder│ │ 子View布局 │  │ ViewHolder复用池 │  │ 动画效果 │  
└──────────┘ └──────────┘  └──────────────┘  └──────────┘  
        ▲                                            ▲  
        │                                            │  
┌───────┴───────┐                            ┌──────┴───────┐  
│   数据绑定    │                            │ 增删改动画    │  
└───────────────┘                            └───────────────┘  
```  

**核心组件职责**：  

- **RecyclerView**：核心容器，协调各组件工作，处理触摸事件、测量布局等。  
- **Adapter**：提供数据和 ViewHolder，是数据与 UI 的桥梁（`onCreateViewHolder` 创建、`onBindViewHolder` 绑定数据）。  
- **LayoutManager**：负责子 View 的测量、布局和滚动（如线性、网格、瀑布流布局）。  
- **Recycler**：管理 ViewHolder 的回收与复用（核心性能优化点）。  
- **ItemAnimator**：处理 Item 增删改时的动画效果（默认无动画，可自定义）。  
- **ItemDecoration**：绘制 Item 间的分割线、间距或装饰（如列表分割线）。  

## 二、核心源码解析  

### 2.1 RecyclerView 初始化与核心流程  

RecyclerView 的核心逻辑集中在 `onMeasure`（测量）、`onLayout`（布局）、`onTouchEvent`（滚动）三个阶段，最终通过 **Recycler** 复用 ViewHolder，通过 **LayoutManager** 布局子 View。  

#### 关键初始化代码  

```java  
// RecyclerView.java  
public class RecyclerView extends ViewGroup {  
    private final Recycler mRecycler = new Recycler(); // 负责复用  
    private LayoutManager mLayout; // 布局管理器（必须设置，否则报错）  
    private Adapter mAdapter; // 数据适配器  

    public RecyclerView(Context context) {  
        super(context);  
        init(null);  
    }  

    private void init(Context context) {  
        // 初始化触摸事件处理器（用于滚动）  
        mScrollListener = new ScrollListener();  
        setOnScrollListener(mScrollListener);  
        // 初始化默认 ItemAnimator（可选）  
        setItemAnimator(new DefaultItemAnimator());  
        // 其他初始化（如布局参数、绘制等）  
    }  

    // 必须设置 LayoutManager，否则抛出异常  
    public void setLayoutManager(LayoutManager layout) {  
        if (layout == null) {  
            throw new IllegalArgumentException("LayoutManager cannot be null");  
        }  
        mLayout = layout;  
        mLayout.setRecyclerView(this); // 双向绑定  
    }  
}  
```  

### 2.2 LayoutManager：布局与滚动的核心  

LayoutManager 是 RecyclerView 的「布局大脑」，决定子 View 的位置、大小和滚动方向。系统提供 `LinearLayoutManager`（线性）、`GridLayoutManager`（网格）、`StaggeredGridLayoutManager`（瀑布流），也可通过继承 `LayoutManager` 自定义。  

#### 核心方法：`onLayoutChildren`（布局子 View）  

以 `LinearLayoutManager` 为例，其布局流程可概括为：  

1. 清空旧布局，回收子 View 到 Recycler。  
2. 计算可用空间（排除 padding 等）。  
3. 从 Recycler 中获取 ViewHolder，绑定数据后布局到屏幕。  

```java  
// LinearLayoutManager.java  
@Override  
public void onLayoutChildren(Recycler recycler, State state) {  
    // 1. 回收所有可见子 View 到 Recycler（进入「待复用」状态）  
    detachAndScrapAttachedViews(recycler);  

    // 2. 计算可用布局空间（高度 = 控件高度 - paddingTop - paddingBottom）  
    int availableHeight = getHeight() - getPaddingTop() - getPaddingBottom();  

    // 3. 填充子 View（从 position 0 开始，直到填满可用空间）  
    int currentPosition = 0;  
    int currentHeight = getPaddingTop();  
    while (currentHeight < availableHeight && currentPosition < state.getItemCount()) {  
        // 从 Recycler 中获取 ViewHolder（优先复用，无则新建）  
        View view = recycler.getViewForPosition(currentPosition);  
        // 测量子 View（根据布局规则计算宽高）  
        measureChildWithMargins(view, 0, 0);  
        // 计算子 View 高度（包含 margin）  
        int viewHeight = getDecoratedMeasuredHeight(view);  
        // 布局子 View（指定位置）  
        layoutDecorated(  
            view,  
            getPaddingLeft(),  
            currentHeight,  
            getPaddingLeft() + getDecoratedMeasuredWidth(view),  
            currentHeight + viewHeight  
        );  
        // 更新当前高度和位置  
        currentHeight += viewHeight;  
        currentPosition++;  
    }  
}  
```  

#### 滚动处理：`scrollVerticallyBy`（垂直滚动）  

滚动时，LayoutManager 会计算滚动距离，回收「滑出屏幕」的 ViewHolder，复用它们布局「滑入屏幕」的新 Item。  

```java  
// LinearLayoutManager.java  
@Override  
public int scrollVerticallyBy(int dy, Recycler recycler, State state) {  
    // 1. 计算实际可滚动距离（避免超出边界）  
    int consumed = Math.min(dy, getMaxScrollDistance());  

    // 2. 滚动时，回收滑出屏幕的子 View  
    if (consumed > 0) { // 向上滚动  
        recycleViewsOutOfBounds(recycler, state, getPaddingTop(), currentScrollY - consumed);  
    } else if (consumed < 0) { // 向下滚动  
        recycleViewsOutOfBounds(recycler, state, currentScrollY - consumed, getHeight() - getPaddingBottom());  
    }  

    // 3. 调整子 View 位置（或复用 ViewHolder 布局新 Item）  
    offsetChildrenVertical(-consumed);  

    return consumed;  
}  
```  

### 2.3 Recycler：ViewHolder 复用机制（性能核心）  

Recycler 是 RecyclerView 高效的关键，通过三级缓存实现 ViewHolder 的复用，避免频繁创建和销毁 View（Android 中 View 创建成本高）。  

#### 三级缓存结构  

```txt
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  
│     Scrap       │  │   ViewCache     │  │ RecycledViewPool │  
├─────────────────┤  ├─────────────────┤  ├─────────────────┤  
│ 「临时缓存」     │  │ 「最近缓存」     │  │ 「通用缓存池」   │  
│ 屏幕内/刚滑出的  │  │ 最近回收的少数  │  │ 按 ViewType 分类 │  
│ ViewHolder      │  │ ViewHolder      │  │ 存储大量ViewHolder│  
└─────────────────┘  └─────────────────┘  └─────────────────┘  
     优先级最高          优先级次之          优先级最低  
```  

- **Scrap 缓存**：存储当前屏幕内或刚滑出屏幕的 ViewHolder（未真正回收），可直接复用（无需重新绑定数据）。  
- **ViewCacheExtension**：开发者自定义缓存（默认空实现），可存储特定 ViewHolder。  
- **RecycledViewPool**：按 `getItemViewType` 分类的通用缓存池，最多缓存 5 个（默认）同类型 ViewHolder，复用前需重新绑定数据（`onBindViewHolder`）。  

#### 核心方法：`getViewForPosition`（获取 Item View）  

当需要显示某个 position 的 Item 时，Recycler 按优先级从三级缓存中查找可用 ViewHolder，找不到则通过 Adapter 新建。  

```java  
// Recycler.java  
public View getViewForPosition(int position) {  
    // 1. 从 Scrap 缓存中查找（最快，无需重新绑定）  
    ViewHolder holder = getScrapOrHiddenOrCachedHolderForPosition(position);  
    if (holder != null) {  
        return holder.itemView;  
    }  

    // 2. 从 ViewCacheExtension 查找（开发者自定义缓存）  
    View view = mViewCacheExtension.getViewForPositionAndType(this, position, type);  
    if (view != null) {  
        return view;  
    }  

    // 3. 从 RecycledViewPool 查找（按 ViewType 匹配）  
    holder = getRecycledViewPool().getRecycledView(type);  
    if (holder != null) {  
        // 复用前需重新绑定数据  
        mAdapter.bindViewHolder(holder, position);  
        return holder.itemView;  
    }  

    // 4. 缓存中无可用 ViewHolder，通过 Adapter 新建  
    holder = mAdapter.createViewHolder(RecyclerView.this, type);  
    mAdapter.bindViewHolder(holder, position);  
    return holder.itemView;  
}  
```  

### 2.4 Adapter 与 ViewHolder：数据与 UI 的桥梁  

Adapter 负责提供数据和 ViewHolder，是 RecyclerView 与数据的接口。ViewHolder 则封装 Item 布局的子 View，避免频繁 `findViewById`。  

#### Adapter 核心方法  

```java  
public abstract class Adapter<VH extends ViewHolder> {  
    // 1. 创建 ViewHolder（初始化 Item 布局）  
    public abstract VH onCreateViewHolder(ViewGroup parent, int viewType);  

    // 2. 绑定数据到 ViewHolder（将数据设置到 Item 控件）  
    public abstract void onBindViewHolder(VH holder, int position);  

    // 3. 返回数据总数  
    public abstract int getItemCount();  

    // 4. （可选）返回 Item 类型（用于多类型列表，不同类型用不同 ViewHolder）  
    public int getItemViewType(int position) {  
        return 0; // 默认所有 Item 类型相同  
    }  
}  
```  

#### ViewHolder 作用  

```java  
public static abstract class ViewHolder {  
    public final View itemView; // Item 根布局  
    // 缓存子 View（避免重复 findViewById）  
    private SparseArray<View> mItemViewSparseArray;  

    public ViewHolder(View itemView) {  
        this.itemView = itemView;  
        mItemViewSparseArray = new SparseArray<>();  
    }  

    // 查找子 View 并缓存  
    public <T extends View> T getView(int viewId) {  
        View view = mItemViewSparseArray.get(viewId);  
        if (view == null) {  
            view = itemView.findViewById(viewId);  
            mItemViewSparseArray.put(viewId, view);  
        }  
        return (T) view;  
    }  
}  
```  

### 2.5 数据更新机制：`notify` 系列方法  

当数据变化时，Adapter 需调用 `notifyXXX` 方法通知 RecyclerView 更新，避免全量刷新（性能优化）。  

```java  
// Adapter.java  
public final void notifyItemInserted(int position) {  
    mObservable.notifyItemRangeInserted(position, 1);  
}  

public final void notifyItemChanged(int position) {  
    mObservable.notifyItemRangeChanged(position, 1);  
}  

// 内部通过 RecyclerViewDataObserver 通知 RecyclerView刷新  
private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver() {  
    @Override  
    public void onItemRangeInserted(int positionStart, int itemCount) {  
        mLayout.onItemsAdded(positionStart, itemCount); // 通知LayoutManager  
        requestLayout(); // 触发重新布局  
    }  
};  
```  

## 三、设计优势总结  

1. **职责分离**：通过 Adapter、LayoutManager、Recycler 等组件拆分功能，各部分可独立扩展（如自定义 LayoutManager 实现特殊布局）。  
2. **高效复用**：三级缓存机制大幅减少 View 创建/销毁次数，性能优于 ListView（仅一级缓存）。  
3. **高扩展性**：支持自定义 Item 动画、分割线、布局方式，满足复杂 UI 需求。  
4. **灵活的数据更新**：通过 `notifyXXX` 方法实现局部刷新，避免全量重绘。  

RecyclerView 的源码设计体现了「单一职责」和「开闭原则」，是 Android 中组件化设计的典范，也是高性能列表展示的首选方案。

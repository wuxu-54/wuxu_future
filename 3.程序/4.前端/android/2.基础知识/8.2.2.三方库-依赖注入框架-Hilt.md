# Hilt

Hilt 是 Google 基于 Dagger2 推出的 Android 依赖注入框架，旨在简化 Dagger2 在 Android 项目中的使用。它通过自动生成组件和预定义的作用域，大幅减少模板代码，让开发者更专注于业务逻辑。以下是 Hilt 的核心概念、使用方法及最佳实践的详细解析：

## 一、核心概念与优势

1. **简化 Dagger2 的 Android 集成**  
   Hilt 预定义了与 Android 组件生命周期绑定的组件（如 `ActivityComponent`、`FragmentComponent` 等），无需手动编写 `@Component` 接口。

2. **自动生成组件**  
   通过编译时注解处理器生成 Dagger2 组件，避免手动维护复杂的组件依赖关系。

3. **预定义作用域**  
   提供 `@Singleton`、`@ActivityScoped`、`@FragmentScoped` 等注解，自动管理依赖对象的生命周期。

4. **与 Android 框架深度集成**  
   支持注入 `Activity`、`Fragment`、`Service`、`ViewModel` 等 Android 组件。

## 二、基础使用

### 1. 环境配置

在项目的 `build.gradle` 中添加依赖：

```gradle
// 项目级 build.gradle
buildscript {
    repositories {
        google()
    }
    dependencies {
        classpath 'com.google.dagger:hilt-android-gradle-plugin:2.48'
    }
}

// 模块级 build.gradle
plugins {
    id 'dagger.hilt.android.plugin'
}

dependencies {
    implementation 'com.google.dagger:hilt-android:2.48'
    kapt 'com.google.dagger:hilt-android-compiler:2.48' // Kotlin 使用 kapt
    // Java 使用 annotationProcessor
}
```

### 2. 应用初始化

在 Application 类上添加 `@HiltAndroidApp` 注解：

```java
@HiltAndroidApp
public class MyApp extends Application {
    // 应用启动逻辑
}
```

此注解会触发 Hilt 生成应用级组件，支持后续依赖注入。

### 3. 依赖注入示例

**注入 Activity/Fragment**：

```java
@AndroidEntryPoint // 标记 Android 组件可注入
public class MainActivity extends AppCompatActivity {
    @Inject
    UserRepository userRepository; // 自动注入依赖

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // 使用注入的依赖
    }
}
```

**提供依赖（Module）**：

```java
@Module
@InstallIn(SingletonComponent.class) // 作用域为应用单例
public abstract class AppModule {
    @Binds
    public abstract DataSource bindDataSource(NetworkDataSource impl);

    @Provides
    @Singleton
    public static OkHttpClient provideOkHttpClient() {
        return new OkHttpClient.Builder().build();
    }
}
```

### 4. 注入 ViewModel

```java
@HiltViewModel
public class MyViewModel extends ViewModel {
    private final UserRepository repository;

    @Inject
    public MyViewModel(UserRepository repository) {
        this.repository = repository;
    }
}
```

在 Activity/Fragment 中获取注入的 ViewModel：

```java
@AndroidEntryPoint
public class MainActivity extends AppCompatActivity {
    private MyViewModel viewModel;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        viewModel = new ViewModelProvider(this).get(MyViewModel.class);
    }
}
```

## 三、高级特性

### 1. 作用域与生命周期

Hilt 提供多种预定义作用域：

- `@Singleton`：应用级单例
- `@ActivityScoped`：Activity 生命周期内单例
- `@FragmentScoped`：Fragment 生命周期内单例
- `@ServiceScoped`：Service 生命周期内单例

示例：

```java
@ActivityScoped
public class NavigationManager {
    @Inject
    public NavigationManager() {}
}
```

### 2. 自定义作用域

通过 `@DefineComponent` 和 `@ComponentScoped` 创建自定义作用域：

```java
@DefineComponent(parent = ActivityComponent.class)
public interface MyCustomComponent {}

@Scope
@Retention(RetentionPolicy.RUNTIME)
public @interface MyCustomScope {}

@MyCustomScope
@InstallIn(MyCustomComponent.class)
public class CustomService {}
```

### 3. 多绑定与限定符

使用 `@IntoSet`、`@IntoMap` 实现多绑定：

```java
@Module
@InstallIn(SingletonComponent.class)
public abstract class LoggerModule {
    @Binds
    @IntoSet
    public abstract Logger bindConsoleLogger(ConsoleLogger impl);

    @Binds
    @IntoSet
    public abstract Logger bindFileLogger(FileLogger impl);
}
```

通过 `@Qualifier` 区分同一类型的不同实现：

```java
@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface ProdApiKey {}

@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface DevApiKey {}

@Module
@InstallIn(SingletonComponent.class)
public class ApiModule {
    @Provides
    @ProdApiKey
    public String provideProdApiKey() {
        return "prod_key";
    }

    @Provides
    @DevApiKey
    public String provideDevApiKey() {
        return "dev_key";
    }
}
```

### 4. 处理 Android 特定依赖

注入 `Context`：

```java
@Module
@InstallIn(SingletonComponent.class)
public class AppModule {
    @Provides
    public static SharedPreferences provideSharedPreferences(@ApplicationContext Context context) {
        return context.getSharedPreferences("my_prefs", Context.MODE_PRIVATE);
    }
}
```

## 四、测试

### 1. 单元测试

使用 `@HiltAndroidTest` 和 `@UninstallModules` 替换生产依赖：

```java
@HiltAndroidTest
@UninstallModules(ProdModule.class)
public class MyViewModelTest {
    @get:Rule
    public HiltAndroidRule hiltRule = new HiltAndroidRule(this);

    @Inject
    TestRepository testRepository;

    @Before
    public void setUp() {
        hiltRule.inject();
        // 测试准备
    }

    @Test
    public void testViewModel() {
        // 测试逻辑
    }
}
```

### 2. 自定义测试组件

使用 `@CustomTestApplication` 创建测试专用的 Application：

```java
@CustomTestApplication(MyApp.class)
public interface HiltTestApplication {}
```

## 五、与 Dagger2 的对比

| 特性                | Dagger2                          | Hilt                             |
|---------------------|----------------------------------|----------------------------------|
| 组件定义            | 手动编写 `@Component` 接口       | 自动生成预定义组件               |
| Android 集成        | 需要手动处理 Android 组件        | 直接支持 Activity、Fragment 等   |
| 作用域管理          | 自定义作用域注解                 | 预定义 Android 生命周期作用域   |
| 代码量              | 大量模板代码                     | 极少模板代码                     |
| 学习曲线            | 陡峭                             | 平缓                             |

## 六、最佳实践

1. **合理使用作用域**  
   根据依赖的生命周期选择合适的作用域，避免内存泄漏。

2. **模块化设计**  
   将相关依赖放在同一个 Module 中，并使用 `@InstallIn` 指定作用域。

3. **避免过度依赖**  
   保持依赖关系简洁，避免复杂的依赖图。

4. **结合 ViewModel**  
   通过 `@HiltViewModel` 注入 ViewModel，实现数据与 UI 分离。

5. **测试策略**  
   使用 `@UninstallModules` 和测试专用 Module 替换生产依赖，确保测试独立性。

## 七、总结

Hilt 作为 Dagger2 的 Android 专用简化框架，通过自动生成组件和预定义作用域，显著降低了 Android 项目中依赖注入的复杂度。它与 Android 组件生命周期的深度集成，让开发者可以更高效地管理依赖，同时保持代码的可测试性和可维护性。对于 Android 开发者，尤其是初学者，Hilt 是实现依赖注入的首选方案。

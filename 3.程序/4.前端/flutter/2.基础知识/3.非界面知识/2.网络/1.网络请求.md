# 获取、上传数据

在Flutter中获取和上传网络数据通常涉及使用HTTP请求。以下是如何使用`http`包和`dio`包来实现这些功能的步骤和示例。

## 获取网络数据

### 使用http包

添加依赖：在`pubspec.yaml`中添加http包。

```json
dependencies:
  http: ^0.13.3
```

发送GET请求：

```dart
import 'package:http/http.dart' as http;

Future<void> fetchUrlData(String url) async {
  final response = await http.get(Uri.parse(url),
    headers: {
    HttpHeaders.authorizationHeader: 'Basic your_api_token_here',//添加 Authorization Headers 认证。用于需要认证的接口请求
    },
  );

  if (response.statusCode == 200) {
    // 成功处理，解析响应体
    var data = response.body;
    // 如果响应是JSON格式，可以使用jsonDecode进行解析
    var jsonData = jsonDecode(data);
  } else {
    // 错误处理
    print('Failed to load data: ${response.statusCode}');
  }
}
```

### 使用dio包

添加依赖：在`pubspec.yaml`中添加dio包。

```json
dependencies:
  dio: ^4.0.0
```

发送GET请求：

```dart
import 'package:dio/dio.dart';

Future<void> fetchUrlData(String url) async {
  Dio dio = Dio();

  try {
    Response response = await dio.get(url);
    if (response.statusCode == 200) {
      // 成功处理，解析响应体
      var data = response.data;
      // 如果响应是JSON格式，可以使用jsonDecode进行解析
      var jsonData = jsonDecode(data);
    } else {
      // 错误处理
      print('Failed to load data: ${response.statusCode}');
    }
  } catch (e) {
    // 捕获错误
    print('Error fetching data: $e');
  }
}
```

---

## 上传数据

### 使用http包上传JSON数据

```dart
Future<void> uploadJsonData(String url, Map<String, dynamic> data) async {
  final response = await http.post(
    Uri.parse(url),
    headers: {'Content-Type': 'application/json'},
    body: jsonEncode(data),
  );

  if (response.statusCode == 200) {
    // 成功处理
    var responseData = response.body;
  } else {
    // 错误处理
    print('Upload failed with status: ${response.statusCode}');
  }
}
```

### 使用http包上传文件

```dart
import 'dart:io';
import 'package:http/http.dart' as http;

Future<void> uploadFile(String url, File file) async {
  var request = http.MultipartRequest(
    'POST', Uri.parse(url)
  );

  var filePath = file.path;
  var fileName = file.path.split('/').last;

  request.files.add(await http.MultipartFile.fromPath('file', filePath));

  // 或者使用文件流
  // request.files.add(http.MultipartFile.fromBytes('file', file.readAsBytesSync()));

  var response = await request.send();

  if (response.statusCode == 200) {
    // 成功处理
    print('File uploaded successfully.');
  } else {
    // 错误处理
    print('File upload failed with status: ${response.statusCode}');
  }
}
```

### 使用dio包上传JSON数据

```dart
Future<void> uploadJsonData(String url, Map<String, dynamic> data) async {
  Dio dio = Dio();

  try {
    Response response = await dio.post(
      url,
      data: data,
      options: Options(
        headers: {
          'Content-Type': 'application/json',
        },
      ),
    );

    if (response.statusCode == 200) {
      // 成功处理
      var responseData = response.data;
    } else {
      // 错误处理
      print('Upload failed with status: ${response.statusCode}');
    }
  } catch (e) {
    // 捕获错误
    print('Error uploading data: $e');
  }
}
```

### 使用dio包上传文件

```dart
Future<void> uploadFile(String url, File file) async {
  Dio dio = Dio();
  FormData formData = FormData();
  formData.files.add(MapEntry("file", file));

  try {
    Response response = await dio.post(
      url,
      data: formData,
    );

    if (response.statusCode == 200) {
      // 成功处理
      var responseData = response.data;
    } else {
      // 错误处理
      print('File upload failed with status: ${response.statusCode}');
    }
  } catch (e) {
    // 捕获错误
    print('Error uploading file: $e');
  }
}
```

## 注意事项

* 在发送请求之前，请确保服务器端点可以处理相应的请求方法和数据格式。
* 对于文件上传，确保服务器端点能够解析`multipart/form-data`格式的请求。
* 使用异步函数`async`和`await`来处理网络请求，并在UI中提供适当的加载状态。
* 实现错误处理逻辑，以便妥善处理网络请求失败的情况。
* 对于敏感数据，确保使用HTTPS协议进行加密传输，以保护用户数据的安全。
* 在进行网络请求时，考虑使用拦截器（`Interceptors`）来处理诸如认证令牌、公共请求头等通用的网络请求逻辑。

通过使用`http`或`dio`包，你可以在Flutter应用中方便地实现网络数据的获取和上传。

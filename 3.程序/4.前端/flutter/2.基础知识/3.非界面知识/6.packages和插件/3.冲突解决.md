# 冲突解决

假设你想在应用中使用 `some_package` 和 `other_package`，并且它们依赖于不同版本的 `url_launcher`。于是我们便有了潜在的冲突。

## 自动解决

避免这种情况的最好方法是 package 的作者在指定依赖项时使用 版本范围 而非特定版本。

```python
dependencies:
  url_launcher: ^5.4.0    # Good, any version >= 5.4.0 but < 6.0.0
  image_picker: '5.4.3'   # Not so good, only version 5.4.3 works.
```

如果 `some_package` 声明了以上依赖，并且 `another_package` 声明了一个兼容的 `url_launcher` 依赖项，如 `'5.4.6'` 或 `^5.5.0`， pub 能够自动解决冲突问题。 Gradle modules 和 CocoaPods 也是用类似的方式解决平台依赖的。

即使 `some_package` 和 `another_package` 声明了不兼容的 `url_launcher` 版本，它们实际上仍可能以兼容的方式使用 `url_launcher`。在这种情况下，可在 `pubspec.yaml` 文件中添加一个依赖覆盖声明来强制使用特定版本，从而处理冲突。

## 依赖覆盖

使用`dependency_overrides`进行依赖覆盖。

为了强制使用版本为 `5.4.0` 的 `url_launcher`，你可以对应用的 `pubspec.yaml` 文件做如下更改：

```yaml
dependencies:
  some_package:
  another_package:
dependency_overrides:
  url_launcher: '5.4.0' # 这里是强制明确版本为：5.4.0
```

如果依赖冲突项不是 package 自身，而是如 guava 这样特定于 Android 的库，那么依赖的覆盖声明必须添加到 Gradle 的构建逻辑中。
>这个方法有助于解决远程依赖和本地依赖导致的冲突问题。

```yaml
dependencies:
  some_package:
    version:'5.4.0'
    hosted:
      name: transmogrify
      url: https://some-package-server.com
dependency_overrides:
  some_package: 
    path:'本地路径' # 这里是强制明确版本为：5.4.0
```

## 原生构建解决冲突

为了强制使用版本为 28.0 的 guava，你可以对 `android/build.gradle` 文件做如下更改：

```grovy
configurations.all {
    resolutionStrategy {
        force 'com.google.guava:guava:28.0-android'
    }
}
```

CocoaPods 目前尚不提供依赖项覆盖功能。

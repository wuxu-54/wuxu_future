# 开发建议

>我抄录的不全，要看官网中的[性能最佳实践](https://flutter.cn/docs/perf/best-practices)

1. 尽量减少消耗资源的操作
    * 控制 build() 方法的耗时
    * 谨慎使用 saveLayer()
    * 尽量减少使用不透明度和裁剪
    * 谨慎使用网格列表和列表
    * 尽量减少由内部操作引起的布局传递
    * 在 16ms 内渲染完成每一帧
2. 减少影响性能的操作

## 尽量减少消耗资源的操作

### 为什么谨慎使用 saveLayer()

答：

过多调用 saveLayer() 会导致卡顿。调用 `saveLayer()` 会开辟一片离屏缓冲区并将内容绘制到离屏缓冲区可能会触发渲染目标切换。 GPU 希望直达目标地运行，但渲染目标迫使 GPU 暂时重定向到该数据流，然后又直接把它切回来。这样会对渲染吞吐量造成特别大的破坏性。

### 其他会触发 saveLayer() 的 widget

其他会触发 saveLayer() 的 widget，也有潜在的性能代价：

* ShaderMask
* ColorFilter
* Chip— 当 `disabledColorAlpha != 0xff` 的时候，会调用 `saveLayer()`
* Text— 当有 `overflowShader` 时，会调用`saveLayer()`

---

## 减少影响性能的操作

* 避免使用 `Opacity widget`，尤其是在动画中避免使用。可以使用 `AnimatedOpacity` 或 `FadeInImage` 代替该操作。

* 使用 `AnimatedBuilder` 时，请避免在不依赖于动画的 widget 的构造方法中构建 widget 树，不然，动画的每次变动都会重建这个 widget 树，应当将这部分子树作为 child 传递给 AnimatedBuilder，从而只构建一次。

* 避免在动画中裁剪，尽可能的在动画开始之前预先裁剪图像。

* 如果大多数子元素在屏幕上不可见，避免使用带有具体子元素List的构造函数(例如Column()或ListView())，以避免构建成本。

* 如果大多数 children widget 在屏幕上不可见，请避免使用返回具体列表的构造函数（例如 Column() 或 ListView()），以避免构建成本。

* 避免在 Widget 对象上重写 `operator ==`。虽然这看起来有助于避免不必要的重建，但在实践中，它实际上损害了性能，因为这是 **O(N²)** 的行为。只有 leaf widget（没有子的 widget）是个例外，在这种特殊的情况下，比较 widget 的属性可能比重建 widget 更加有效，也能更少改变 widget 的配置。即使在这种情况下，最好还要缓存 widget，因为哪怕有一次对 `operator ==` 进行覆盖也会导致全面性能的下降，编译器也会因此不再认为调用总是静态的。

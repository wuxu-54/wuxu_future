# 新页面与StoreProvider

flutter redux库，navigator跳转后需要重新用StoreProvider包裹吗，为什么？

在Flutter中使用`flutter_redux`库时，通常在`Navigator`跳转后不需要重新用`StoreProvider`包裹，下面为你详细解释原因。

## 1. `StoreProvider`的作用

`StoreProvider`是`flutter_redux`库中的一个组件，它的主要作用是将`Store`对象存储在`InheritedWidget`中，使得在整个应用程序的组件树中可以方便地访问`Store`。`InheritedWidget`是Flutter中一种特殊的Widget，它可以高效地将数据从父组件传递到子组件，并且当数据发生变化时，会自动通知依赖该数据的子组件进行更新。

## 2. 不需要重新包裹的原因

- **`Store`的全局可访问性**：`StoreProvider`通常会被放置在应用程序的根组件附近，这样整个应用程序的组件树都可以通过`StoreProvider.of(context)`方法访问到`Store`。当使用`Navigator`进行页面跳转时，新页面仍然是原组件树的一部分，因此可以直接访问到`Store`，无需重新包裹。
- **`InheritedWidget`的特性**：`InheritedWidget`会在组件树中向上查找，只要`StoreProvider`在组件树的上层，新页面的组件就可以找到它并获取`Store`。

## 3. 示例代码

下面是一个简单的示例，展示了如何在不重新包裹`StoreProvider`的情况下进行页面跳转并访问`Store`：

```dart
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:redux/redux.dart';

// 定义Action
enum CounterAction { increment }

// 定义Reducer
int counterReducer(int state, dynamic action) {
  if (action == CounterAction.increment) {
    return state + 1;
  }
  return state;
}

// 定义第一个页面
class FirstPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('First Page'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            StoreConnector<int, VoidCallback>(
              converter: (store) => () => store.dispatch(CounterAction.increment),
              builder: (context, callback) {
                return ElevatedButton(
                  onPressed: () {
                    callback();
                    Navigator.push(
                      context,
                      MaterialPageRoute(builder: (context) => SecondPage()),
                    );
                  },
                  child: Text('Go to Second Page'),
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}

// 定义第二个页面
class SecondPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Second Page'),
      ),
      body: Center(
        child: StoreConnector<int, int>(
          converter: (store) => store.state,
          builder: (context, count) {
            return Text('Counter: $count');
          },
        ),
      ),
    );
  }
}

void main() {
  // 创建Store
  final store = Store<int>(counterReducer, initialState: 0);

  runApp(
    StoreProvider<int>(
      store: store,
      child: MaterialApp(
        home: FirstPage(),
      ),
    ),
  );
}
```

在这个示例中，`StoreProvider`被放置在`MaterialApp`的外层，当从`FirstPage`跳转到`SecondPage`时，`SecondPage`可以直接通过`StoreConnector`访问到`Store`，无需重新包裹`StoreProvider`。

综上所述，在`Navigator`跳转后不需要重新用`StoreProvider`包裹，因为`StoreProvider`提供的`Store`是全局可访问的，新页面可以通过`InheritedWidget`机制访问到它。

# 自定义中间件

本节，我们自定义个中间件，它用于处理异步操作和复杂的响应式流逻辑。
>**默认Redux都是同步操作**，我们自定义个中间件，其内部维护了一个Stream对象，通过Stream可以实现异步处理操作。

## 示例代码

```dart
/// A [Redux](https://pub.dartlang.org/packages/redux) middleware that passes
/// a stream of dispatched actions to the given [Epic].
///
/// It is recommended that you put your `EpicMiddleware` first when constructing
/// the list of middleware for your store so any actions dispatched from
/// your [Epic] will be intercepted by the remaining Middleware.
///
/// Example:
///
///     var epicMiddleware = new EpicMiddleware(new ExampleEpic());
///     var store = new Store<List<Action>, Action>(reducer,
///       initialState: [], middleware: [epicMiddleware]);
class EpicStore<State> {
  final Store<State> _store;

  EpicStore(this._store);

  /// Returns the current state of the redux store
  State get state => _store.state;

  Stream<State> get onChange => _store.onChange;

  /// through to the reducer.
  dynamic dispatch(dynamic action) {
    return _store.dispatch(action);
  }
}

class EpicMiddleware<State> extends MiddlewareClass<State> {
  final StreamController<dynamic> _actions =
      StreamController<dynamic>.broadcast();
  final StreamController<Epic<State>> _epics =
      StreamController.broadcast(sync: true);

  final bool supportAsyncGenerators;
  Epic<State> _epic;
  bool _isSubscribed = false;

  EpicMiddleware(Epic<State> epic, {this.supportAsyncGenerators = true})
      : _epic = epic;

  @override
  void call(Store<State> store, dynamic action, NextDispatcher next) {
    if (!_isSubscribed) {
      _epics.stream
          .switchMap<dynamic>((epic) => epic(_actions.stream, EpicStore(store)))
          .listen(store.dispatch);

      _epics.add(_epic);

      _isSubscribed = true;
    }

    next(action);

    if (supportAsyncGenerators) {
      // Future.delayed is an ugly hack to support async* functions.
      //
      // See: https://github.com/dart-lang/sdk/issues/33818
      Future.delayed(Duration.zero, () {
        _actions.add(action);
      });
    } else {
      _actions.add(action);
    }
  }

  /// Gets or replaces the epic currently used by the middleware.
  ///
  /// Replacing epics is considered an advanced API. You might need this if your
  /// app grows large and want to instantiate Epics on the fly, rather than
  /// as a whole up front.
  Epic<State> get epic => _epic;

  set epic(Epic<State> newEpic) {
    _epic = newEpic;

    _epics.add(newEpic);
  }
}
```

使用：

```dart
Stream<dynamic> loginEpic(Stream<dynamic> actions, EpicStore<WXState> store) {
  Stream<dynamic> _loginIn(
      LoginAction action, EpicStore<WXState> store) async* {//async* 表示异步
    CommonUtils.showLoadingDialog(action.context);
    var res = await UserDao.login(
        action.username!.trim(), action.password!.trim(), store);
    Navigator.pop(action.context);
    yield LoginSuccessAction(action.context, (res != null && res.result));//yield关键字 表示将新值先返出去，具体用法可看yield章节。
  }
  return actions
      .whereType<LoginAction>()//Stream方法，进行过滤
      .switchMap((action) => _loginIn(action, store));
}

final List<Middleware<WXState>> middleware = [
  EpicMiddleware<WXState>(loginEpic),
];
```

# StoreConnector

在 Flutter 中，`StoreConnector` 是 `flutter_redux` 库提供的核心组件，用于将 Redux 的全局状态（Store）与 UI 组件高效连接。以下是其关键点和使用方法：

---

## **核心作用**

1. **状态与UI解耦**  
   将 Redux Store 中的状态转换为 UI 所需的 ViewModel，并自动响应状态变化，触发 UI 更新。

2. **性能优化**  
   通过 `distinct` 参数避免不必要的重建，仅在 ViewModel 变化时更新组件。

---

## **主要参数**

| 参数 | 类型 | 说明 |
|------|------|------|
| `converter` | `Store<State> → ViewModel` | 将 Store 转换为 ViewModel（含数据和方法） |
| `builder` | `(BuildContext, ViewModel) → Widget` | 根据 ViewModel 构建 UI |
| `distinct` | `bool` (默认 `true`) | 是否仅在 ViewModel 变化时重建 |

---

## **工作流程**

1. **获取 Store**  
   通过 `StoreProvider.of<State>(context)` 获取顶层注入的 Store。

2. **转换 ViewModel**  
   调用 `converter` 函数，将 Store 的 `state` 和 `dispatch` 方法转换为 ViewModel。

3. **构建 UI**  
   使用 `builder` 生成 Widget，ViewModel 作为输入。

4. **监听变化**  
   Store 更新时，重新计算 ViewModel，若不同则触发重建。

---

## **代码示例**

```dart
import 'package:flutter/material.dart';
import 'package:flutter_redux/flutter_redux.dart';
import 'package:redux/redux.dart';

// 状态类
class AppState {
  final int count;
  AppState({required this.count});
}

// Action
class IncrementAction {}

// Reducer
AppState reducer(AppState state, dynamic action) {
  if (action is IncrementAction) {
    return AppState(count: state.count + 1);
  }
  return state;
}

// ViewModel
class CounterViewModel {
  final int count;
  final Function() onIncrement;

  CounterViewModel({
    required this.count,
    required this.onIncrement,
  });

  // 实现相等性比较（或用 equatable 简化）
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CounterViewModel &&
          runtimeType == other.runtimeType &&
          count == other.count;

  @override
  int get hashCode => count.hashCode;
}

void main() {
  final store = Store<AppState>(
    reducer,
    initialState: AppState(count: 0),
  );

  runApp(StoreProvider<AppState>(
    store: store,
    child: MaterialApp(
      home: CounterScreen(),
    ),
  ));
}

class CounterScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Redux Counter')),
      body: StoreConnector<AppState, CounterViewModel>(
        converter: (store) => CounterViewModel(
          count: store.state.count,
          onIncrement: () => store.dispatch(IncrementAction()),
        ),
        builder: (context, viewModel) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text('Count: ${viewModel.count}'),
              ElevatedButton(
                onPressed: viewModel.onIncrement,
                child: Text('Increment'),
              ),
            ],
          ),
        ),
        distinct: true, // 仅当 count 变化时重建
      ),
    );
  }
}
```

---

## **最佳实践**

1. **保持 ViewModel 轻量**  
   仅包含 UI 所需的数据和方法，避免冗余数据触发重建。

2. **不可变状态**  
   使用不可变对象（如 `equatable`）简化相等性比较，确保 `distinct` 正确判断。

3. **选择性重建**  
   将大组件拆分为多个 `StoreConnector`，仅关键部分响应状态变化，提升性能。

---

通过 `StoreConnector`，你可以高效管理 Flutter 应用的状态，确保 UI 与数据层清晰分离，同时保持流畅的性能表现。

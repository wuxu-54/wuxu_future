# 列表

Flutter 中的列表是应用开发中最常用的组件之一，主要用于展示可滚动的数据集合。以下是 Flutter 列表的详细解析，涵盖核心组件、使用场景、进阶用法和注意事项。

---

## **一、核心列表组件**

Flutter 提供了多种列表组件，适用于不同场景：

### 1. **`ListView`**

最基本的垂直/水平滚动列表组件，支持多种构造方法：

#### a. **默认构造函数**

直接传入子组件列表，适合少量数据（一次性构建所有子项）。

```dart
ListView(
  children: <Widget>[
    ListTile(title: Text('Item 1')),
    ListTile(title: Text('Item 2')),
    // ...
  ],
)
```

#### b. **`ListView.builder`**

动态生成子项，**懒加载**（按需构建），适合长列表或动态数据。

```dart
ListView.builder(
  itemCount: 100, // 数据总数
  itemBuilder: (context, index) {
    return ListTile(title: Text('Item $index'));
  },
)
```

#### c. **`ListView.separated`**

在列表项之间添加分隔线，需指定 `separatorBuilder`。

```dart
ListView.separated(
  itemCount: 100,
  separatorBuilder: (context, index) => Divider(),
  itemBuilder: (context, index) {
    return ListTile(title: Text('Item $index'));
  },
)
```

#### d. **`ListView.custom`**

完全自定义子项布局，需指定 `childrenDelegate`（如 `SliverChildBuilderDelegate`）。

---

### 2. **`GridView`**

网格布局列表，支持多种构造方法：

#### a. **`GridView.count`**

通过 `crossAxisCount` 指定列数：

```dart
GridView.count(
  crossAxisCount: 2, // 两列
  children: List.generate(100, (index) => Card(child: Text('Item $index'))),
)
```

#### b. **`GridView.extent`**

通过 `maxCrossAxisExtent` 指定子项最大宽度，自动计算列数。

```dart
GridView.extent(
  maxCrossAxisExtent: 150, // 子项最大宽度为 150
  children: List.generate(100, (index) => Card(child: Text('Item $index'))),
)
```

#### c. **`GridView.builder`**

懒加载网格，适合动态数据：

```dart
GridView.builder(
  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
    crossAxisCount: 2,
    childAspectRatio: 1.5, // 子项宽高比
  ),
  itemCount: 100,
  itemBuilder: (context, index) => Card(child: Text('Item $index')),
)
```

---

## **二、列表相关组件**

### 1. **`ListTile`**

预定义样式的列表项，常用于展示图标、文本和操作按钮。

```dart
ListTile(
  leading: Icon(Icons.person),
  title: Text('用户名'),
  subtitle: Text('user@example.com'),
  trailing: Icon(Icons.arrow_forward),
  onTap: () => print('点击'),
)
```

### 2. **`SliverList` 和 `SliverGrid`**

用于 `CustomScrollView`，实现复杂的滚动效果（如结合 AppBar 和列表）。

```dart
CustomScrollView(
  slivers: [
    SliverAppBar(title: Text('复杂滚动视图')),
    SliverList(
      delegate: SliverChildBuilderDelegate(
        (context, index) => ListTile(title: Text('Item $index')),
        childCount: 100,
      ),
    ),
  ],
)
```

---

## **三、进阶用法**

### 1. **分页加载**

结合 `ScrollController` 监听滚动位置，实现上拉加载更多：

```dart
final ScrollController _controller = ScrollController();
bool _isLoading = false;

@override
void initState() {
  super.initState();
  _controller.addListener(() {
    if (_controller.position.pixels == _controller.position.maxScrollExtent) {
      _loadMoreData();
    }
  });
}

Future<void> _loadMoreData() async {
  if (_isLoading) return;
  setState(() => _isLoading = true);
  // 加载更多数据
  setState(() => _isLoading = false);
}
```

### 2. **下拉刷新**

使用 `RefreshIndicator` 包裹列表：

```dart
RefreshIndicator(
  onRefresh: () async {
    // 重新加载数据
  },
  child: ListView.builder(...),
)
```

### 3. **滑动删除**

通过 `Dismissible` 实现滑动删除效果：

```dart
ListView.builder(
  itemCount: items.length,
  itemBuilder: (context, index) => Dismissible(
    key: Key(items[index].id),
    background: Container(color: Colors.red),
    onDismissed: (direction) => _deleteItem(index),
    child: ListTile(title: Text(items[index].text)),
  ),
)
```

---

## **四、性能优化**

1. **懒加载**：优先使用 `ListView.builder` 或 `GridView.builder`，避免一次性构建所有子项。
2. **复用子项**：为列表项设置稳定的 `Key`，避免不必要的重建。
3. **避免复杂布局**：简化列表项的 UI 结构，减少重绘和重排。
4. **使用 `const` 构造函数**：尽可能将静态组件标记为 `const`。

---

## **五、常见问题**

### 1. **列表无限高度错误**

在嵌套滚动视图时，可能遇到 `Vertical viewport was given unbounded height` 错误。解决方案：

- 使用 `shrinkWrap: true`。
- 将列表包裹在固定高度的容器中（如 `SizedBox`）。

### 2. **滚动位置控制**

通过 `ScrollController` 控制滚动位置：

```dart
_controller.jumpTo(100); // 跳转到指定位置
_controller.animateTo(200, duration: Duration(seconds: 1), curve: Curves.ease); // 动画滚动
```

---

## **六、总结**

- **`ListView`**：适合线性布局，支持垂直/水平滚动。
- **`GridView`**：适合网格布局，多列展示。
- **性能优先**：长列表务必使用 `builder` 构造方法。
- **组合使用**：结合 `CustomScrollView` 和 Sliver 系列组件实现复杂交互。

通过灵活运用这些组件和技巧，可以高效实现各种列表需求，同时保证应用的流畅性。

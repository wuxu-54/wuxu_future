# 构建自适应应用

>这节大部分内容是官方原文，核心就是各平台、设备的适配处理，很重要。
[官方说明文档](https://flutter.cn/docs/ui/layout/responsive/building-adaptive-apps)

自适应在布局方面需要是响应式，即响应式设计，达到根据设备、视口的不同显示不同的样式。其他方面如 手势、主题等处理需要根据设备平台不同进行处理。（ps：这里也具体说明了自适应有依赖响应式的部分如布局样式，也有独立的部分如手势操作。）

构建自适应应用在 Flutter 中涉及到创建能够根据不同设备屏幕尺寸和用户需求调整布局和界面元素的 UI。以下是构建自适应应用的关键步骤和方法：

1. 构建自适应的布局
2. 输入
3. 适配不同平台行为习惯及规范

## 构建自适应的布局

简单来讲就是**界面适配**，保证在各种设备、屏幕上的展示。这一步其实就是响应式设计。主要内容：

1. 布局widgets(widgets进行界面适配)
2. 视觉密度（屏幕密度调整ui）
3. 基于上下文的布局（代码细化控制ui展示）
4. 单一来源控制样式（边距、间距、圆角、字体等样式值控制）
5. 针对特性屏幕进行设计（如刘海屏的适配）
6. 利用桌面端应用快速测试（flutter可生产在多个平台应用，因桌面端可以进行宽高拉伸，借此达到测试效果）
7. 触摸UI（不同平台，触摸等输入事件展示ui不同，需要特性化处理）

### 1. 布局widgets

选用响应式的widgets。Flutter 中最有用的部分布局 widgets 包括：

单子级 (Single child)

* Align——让子级在其内部进行对齐。可使用 -1 至 1 之间的任意值在垂直和水平方向上进行对齐。
* AspectRatio——尝试让子级以指定的比例进行布局。
* ConstrainedBox——对子级施加尺寸限制，可以控制最小和最大的尺寸。
* CustomSingleChildLayout——使用代理方法对单个子级进行定位。代理方法可以为子级确定布局限制和定位。
* Expanded 和 Flexible——允许 Row 或 Column 的子级填充剩余空间或者尽可能地小。
* FractionallySizedBox——基于剩余空间的比例限定子级的大小。
* LayoutBuilder——让子级可以基于父级的尺寸重新调整其布局。
* SingleChildScrollView——为单一的子级添加滚动。通常配合 Row 或 Column 进行使用。

多子级 (Multi child)

* Column、Row 和 Flex—— 在同一水平线或垂直线上放置所有子级。 Column 和 Row 都继承了 Flex widget。
* CustomMultiChildLayout—— 在布局过程中使用代理方法对多个子级进行定位。
* Flow——相对于 CustomMultiChildLayout 更高效的布局方式。在绘制过程中使用代理方法对多个子级进行定位。
* ListView、GridView 和 CustomScrollView—— 为所有子级增加滚动支持。
* Stack——基于 Stack 的边界对多个子级进行放置和定位。与 CSS 中的 position: fixed 功能类似。
* Table——使用经典的表格布局算法，可以组合多列和多行。
* Wrap——将子级顺序显示在多行或多列内。

查看 [布局 widgets](https://flutter.cn/docs/ui/widgets/layout) 了解更多的 widgets 和代码示例。

### 2. 视觉密度

不同的设备会提供不同级别的显示密度，**视觉密度**影响用户界面的紧凑程度，它允许开发者根据目标设备的预期使用模式来调整界面元素的大小和间距。

Flutter 提供了几种工具和概念来控制视觉密度：

1. ThemeData
ThemeData 是 Flutter 中用于定义应用主题数据的类，它包括了视觉密度的配置。

    ```dart
    ThemeData(
    visualDensity: VisualDensity.comfortable, // 可以是 low, medium, comfortable 或 high
    )
    ```

2. VisualDensity
VisualDensity 是一个枚举类，提供了四种不同的视觉密度设置：
    * **VisualDensity.comfortable**：这是默认设置，提供了一个平衡的界面密度。
    * **VisualDensity.compact**：这种设置下，界面元素会更小且更紧凑。
    * **VisualDensity.standard**：与 comfortable 类似，但稍微增加了一些空间。
    * **VisualDensity.minimal**：界面元素尽可能的大，间距也更宽。

3. MediaQuery
MediaQuery 可以用于获取设备的尺寸和字体大小，这些信息可以帮助你决定使用哪种视觉密度。
    * MediaQuery.of(context).size
    * MediaQuery.of(context).textScaleFactor

4. 自定义视觉密度
除了使用 ThemeData 中的预设，你也可以通过调整 Material 组件的属性来自定义视觉密度。

    ```dart
    ElevatedButton(
    style: ButtonStyle(
        // 调整按钮的最小宽度、高度、文字大小等
    ),
    child: Text('Custom Button'),
    )
    ```

5. 应用视觉密度
你可以将视觉密度应用到整个应用，或者只应用到特定的 Theme。

    ```dart
    MaterialApp(
    theme: ThemeData(
        visualDensity: VisualDensity.comfortable,
    ),
    home: MyHomePage(),
    )
    ```

    或者，只为特定的 Widget 设置主题：

    ```dart
    Theme(
    data: ThemeData(
        visualDensity: VisualDensity.compact,
        child: MyCompactThemeWidget(),
    ),
    )
    ```

6. 适配不同设备
考虑到不同设备可能有不同的视觉密度需求，你可以使用 LayoutBuilder 或 MediaQuery 来动态设置视觉密度。

    ```dart
    LayoutBuilder(
    builder: (context, constraints) {
        final visualDensity = constraints.maxWidth > 600 ? VisualDensity.standard : VisualDensity.compact;
        return Theme(
        data: ThemeData(
            visualDensity: visualDensity,
            child: MyAdaptiveWidget(),
        ),
        );
    },
    )
    ```

在密度变化时，容器不仅能自动地对其做出反应，还会结合动画进行过渡变化。所有的组件都会联系在一起，使整个应用平滑过渡。

### 3. 基于上下文的布局

如果你需要的不仅是密度的变化，并且没有找到一个满足需求的 widget，那么你可以使用代码进行更细化的控制、计算尺寸、切换 widgets 或是完全重新构建你的 UI 适配对应的外形结构。

以下是代码进行更细化的控制：

1. 使用 MediaQuery
MediaQuery 是获取屏幕尺寸、用户字体偏好等上下文信息的常用方式。

    ```dart
    double screenWidth = MediaQuery.of(context).size.width;
    double screenHeight = MediaQuery.of(context).size.height;
    double textScaleFactor = MediaQuery.of(context).textScaleFactor;
    ```

2. 使用 LayoutBuilder
LayoutBuilder 允许你根据父级容器的约束来构建布局，这可以用来创建依赖于可用空间的 UI。

    ```dart
    LayoutBuilder(
    builder: (BuildContext context, BoxConstraints constraints) {
        // 根据 constraints 来决定布局
        return Container(
        width: constraints.maxWidth,
        height: constraints.maxHeight,
        // 其他子组件...
        );
    },
    )
    ```

3. 使用 Theme 和 ThemeData
Theme 和 ThemeData 可以提供关于应用主题的上下文信息，包括颜色、字体大小等。

    ```dart
    Theme.of(context).textTheme.headline6
    Theme.of(context).primaryColor
    ```

4. 使用 BuildContext
BuildContext 可以提供关于当前 Widget 在 Widget 树中的位置的信息，可以用来确定如何构建子树。

    ```dart
    BuildContext context
    ```

5. 使用 OrientationBuilder
OrientationBuilder 可以根据设备的方向（纵向或横向）来构建布局。

    ```dart
    OrientationBuilder(
    builder: (BuildContext context, Orientation orientation) {
        // 根据 orientation 来决定布局
        if (orientation == Orientation.portrait) {
        return VerticalLayout();
        } else {
        return HorizontalLayout();
        }
    },
    )
    ```

6. 动态媒体查询
可以结合 MediaQuery 和 LayoutBuilder 来创建既考虑屏幕尺寸又考虑布局约束的复杂布局。

    ```dart
    LayoutBuilder(
    builder: (BuildContext context, BoxConstraints constraints) {
        final bool isLandscape =
            MediaQuery.of(context).orientation == Orientation.landscape;
        // 根据屏幕尺寸和布局约束来决定布局
        if (isLandscape) {
        // 横向模式布局
        } else {
        // 纵向模式布局
        }
    },
    )
    ```

7. 上下文分解
在某些情况下，你可能需要从给定的上下文中提取特定的信息。例如，你可以使用 `Theme.of(context)` 来获取当前的主题信息。

示例：基于上下文的布局

```dart
//假设我们想根据屏幕尺寸来决定是否显示网格视图或列表视图。

class MyResponsiveWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final bool isTablet = MediaQuery.of(context).size.shortestSide >= 600;

    if (isTablet) {
      // 在平板尺寸上使用网格视图
      return GridView.count(
        // ...
      );
    } else {
      // 在手机尺寸上使用列表视图
      return ListView(
        // ...
      );
    }
  }
}
```

通过基于上下文的布局，你可以创建出灵活且适应性强的 Flutter 应用，它们能够为不同的设备和用户偏好提供最佳的用户体验。

### 4. 单一来源控制样式

单一来源控制样式主要是以下几点：

1. 制定统一的设计规范。
2. 使用 Theme.of(context).platform 进行主题和设计的选择，例如，需要显示什么样的开关，以及根据平台的不同显示 `Cupertino/Material` 的设计
3. 样式集中管理维护，提高可维护性。

#### 具体实现单一来源控制样式

以下是几种实现这一目标的方法：

1. 使用 Theme 和 ThemeData
Flutter 的 Theme 组件允许你定义一个应用的全局样式，包括颜色、字体、组件样式等。

    ```dart
    ThemeData themeData = ThemeData(
    primarySwatch: Colors.blue,
    visualDensity: VisualDensity.adaptivePlatformDensity,
    textTheme: TextTheme(
        headline6: TextStyle(fontSize: 20),
        // 其他样式...
    ),
    // 其他主题属性...
    );
    

    MaterialApp(
    title: 'My App',
    theme: themeData,
    home: MyHomePage(),
    );
    ```

2. 创建样式指南
定义一套设计规范，包括颜色、字体、间距等，并在应用中坚持使用这些规范。

3. 使用 Provider 或状态管理库
状态管理库如 Provider、Riverpod 或 Bloc 可以帮助你将样式信息作为单一数据源进行管理。

    ```dart
    //ChangeNotifier
    class ThemeNotifier with ChangeNotifier {
    Color _primaryColor = Colors.blue;

    Color get primaryColor => _primaryColor;

    void changePrimaryColor(Color color) {
        _primaryColor = color;
        notifyListeners();
    }
    }

    // 在 MaterialApp 中使用
    MaterialApp(
    home: ChangeNotifierProvider(
        create: (context) => ThemeNotifier(),
        child: MyHomePage(),
    ),
    );
    ```

4. 定义组件样式
创建具有默认样式的组件，并通过属性`props`允许用户覆盖这些样式。

    ```dart
    class MyButton extends StatelessWidget {
    final Color color;
    final VoidCallback onPressed;

    const MyButton({Key key, this.color = Colors.blue, this.onPressed})
        : super(key: key);

    @override
    Widget build(BuildContext context) {
        return ElevatedButton(
        onPressed: onPressed,
        child: Text('Click Me'),
        style: ButtonStyle(
            backgroundColor: MaterialStateProperty.all<Color>(color),
        ),
        );
    }
    }
    ```

5. 使用 withTheme
创建可定制主题的组件。

    ```dart
    class MyTheme extends InheritedWidget {
    final ThemeData theme;

    const MyTheme({
        Key key,
        @required this.theme,
        @required Widget child,
    }) : super(key: key, child: child);

    static ThemeData of(BuildContext context) {
        return context.dependOnInheritedWidgetOfExactType<MyTheme>().theme;
    }

    @override
    bool updateShouldNotify(MyTheme oldWidget) => theme != oldWidget.theme;
    }
    ```

6. 避免硬编码样式
尽可能避免在多个地方硬编码样式，而是将它们定义在一个地方，如 ThemeData 或状态管理器中。

7. 样式一致性
确保在应用的所有组件和屏幕中使用一致的样式，以增强品牌识别度和用户体验。

通过上述方法，你可以在 Flutter 应用中实现单一来源控制样式，从而使得应用的样式更加统一和易于管理。

### 5. 针对不同屏幕进行设计

除了屏幕尺寸以外，也应当针对各种不同外形屏幕的优劣点进行设计。比如：针对手机设备的刘海屏，进行特性化设计，达到兼容效果处理。

### 6. 利用桌面端应用快速测试

测试自适应界面的最快方式，是利用桌面端快速进行构建。

在桌面上运行应用时，你可以在应用运行时轻易地改变窗口的大小，预览多种尺寸的布局。配上热重载，能极大程度地加快响应式开发的速度。

### 7. 触摸UI

在移动端构建优良的触摸交互式 UI 通常比传统的桌面端更为困难，因为它缺少类似右键单击、滚轮或键盘快捷键这样的快速输入设备。针对这种差异性，进行特别的UI处理，比如：按钮触摸变色效果，在网页上没有必要，但手机端是很有必要的。

---

## 处理输入

应用只适配了界面是远远不够的，你还需要适配各种用户的输入操作。鼠标和键盘提供了触摸设备不具备的输入方式，例如滚轮、右键点击、悬停交互、Tab 遍历切换和键盘快捷键。

### 滚轮

像 `ScrollView 和 ListView` 这样的滚动 widget 默认支持滚轮行为，而大部分可滚动的自定义 widget 都是基于它们构建的，所以也同样支持。

如果你需要实现自定义的滑动行为，可以使用 `Listener` widget，通过它你可以完全自定义 UI 如何响应滚轮行为。

```dart
return Listener(
  onPointerSignal: (event) {
    if (event is PointerScrollEvent) print(event.scrollDelta.dy);
  },
  child: ListView(),
);
```

### Tab 遍历切换和焦点交互

使用键盘的用户，可能会希望通过 Tab 键在应用中快速导航，特别是对有动效和视觉障碍的用户，他们几乎完全依赖于键盘导航。

在考虑 Tab 遍历切换时，有两点需要注意：焦点如何在 widget 之间遍历，以及 widget 聚焦时的突出显示。

大部分内置的组件，类似于按钮和输入框，都默认支持遍历和高亮。如果你想让自己的 widget 包含在遍历中，你可以利用 `FocusableActionDetector` 进行控制。它将 `Actions`、`Shortcuts`、`MouseRegion` 和 `Focus` 的能力进行了整合，创建出一个可以定义行为和键位绑定，并且提供聚焦和悬浮高亮事件回调的 widget。

```dart
class _BasicActionDetectorState extends State<BasicActionDetector> {
  bool _hasFocus = false;
  @override
  Widget build(BuildContext context) {
    return FocusableActionDetector(
      onFocusChange: (value) => setState(() => _hasFocus = value),
      actions: <Type, Action<Intent>>{
        ActivateIntent: CallbackAction<Intent>(onInvoke: (intent) {
          print('Enter or Space was pressed!');
          return null;
        }),
      },
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          const FlutterLogo(size: 100),
          // Position focus in the negative margin for a cool effect
          if (_hasFocus)
            Positioned(
              left: -4,
              top: -4,
              bottom: -4,
              right: -4,
              child: _roundedBorder(),
            )
        ],
      ),
    );
  }
}
```

#### 控制遍历顺序

想要控制用户按下 Tab 键时的 widget 切换顺序，你可以使用 `FocusTraversalGroup` 来指定树中的区域，作为切换时的组别

例如，你可能想要用户逐个切换所有的输入框，最后再切换到提交按钮：

```dart
return Column(children: [
  FocusTraversalGroup(
    child: MyFormWithMultipleColumnsAndRows(),
  ),
  SubmitButton(),
]);
```

Flutter 有几种内置的方法对 widget 和组别进行遍历，默认使用的是 `ReadingOrderTraversalPolicy` 类。这个类通常可以正常使用，你也可以创建另一个 `TraversalPolicy` 或创建一个自定义的规则，对它进行定义。

### 键盘响应

桌面和web可以快捷键操作，所有需要处理键盘的响应。根据目标的不同，在 Flutter 中可以通过几种方式实现利用键盘提升用户操作速度。

如果你已经有一个包含焦点的 widget，例如 TextField 或者 Button，你可以嵌套一个 `KeyboardListener` 或者 `Focus` widget 来监听键盘事件：

```dart
  @override
  Widget build(BuildContext context) {
    return Focus(
      onKeyEvent: (node, event) {
        if (event is KeyDownEvent) {
          print(event.logicalKey);
        }
        return KeyEventResult.ignored;
      },
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 400),
        child: const TextField(
          decoration: InputDecoration(
            border: OutlineInputBorder(),
          ),
        ),
      ),
    );
  }
}
```

如果你想将一组键盘快捷键应用到更大范围的 widget，你可以使用 `Shortcuts` widget：

```dart
// Define a class for each type of shortcut action you want
class CreateNewItemIntent extends Intent {
  const CreateNewItemIntent();
}

Widget build(BuildContext context) {
  return Shortcuts(
    // Bind intents to key combinations
    shortcuts: const <ShortcutActivator, Intent>{
      SingleActivator(LogicalKeyboardKey.keyN, control: true):
          CreateNewItemIntent(),
    },
    child: Actions(
      // Bind intents to an actual method in your code
      actions: <Type, Action<Intent>>{
        CreateNewItemIntent: CallbackAction<CreateNewItemIntent>(
          onInvoke: (intent) => _createNewItem(),
        ),
      },
      // Your sub-tree must be wrapped in a focusNode, so it can take focus.
      child: Focus(
        autofocus: true,
        child: Container(),
      ),
    ),
  );
}
```

`Shortcuts` widget 非常有用，因为它会让 widget 树的这一分支或它的子级仅在有焦点且可见时触发快捷方式。

最后，你还可以全局添加监听。这样的监听可以用于始终需要监听，且为应用全局的快捷键，或是在任何时候（无论是否已聚焦）都接收快捷键的部分。使用 `HardwareKeyboard` 添加全局监听非常简单：

```dart
@override
void initState() {
  super.initState();
  HardwareKeyboard.instance.addHandler(_handleKey);
}

@override
void dispose() {
  HardwareKeyboard.instance.removeHandler(_handleKey);
  super.dispose();
}
```

要想在全局监听中判断组合按键，你可以使用 `RawKeyboard.instance.keysPressed` 这个 Map 进行判断。例如下面这个方法，可以判断是否已经按下了指定的按键：

```dart
static bool isKeyDown(Set<LogicalKeyboardKey> keys) {
  return keys
      .intersection(HardwareKeyboard.instance.logicalKeysPressed)
      .isNotEmpty;
}
```

将它们合并判断，你就可以在 Shift+N 同时按下时触发行为：

```dart
bool _handleKey(KeyEvent event) {
  bool isShiftDown = isKeyDown({
    LogicalKeyboardKey.shiftLeft,
    LogicalKeyboardKey.shiftRight,
  });

  if (isShiftDown && event.logicalKey == LogicalKeyboardKey.keyN) {
    _createNewItem();
    return true;
  }

  return false;
}
```

使用静态的监听时有一件值得注意的事情，当用户在输入框中输入内容，或关联的 widget 从视图中隐藏时，通常需要**禁用监听**。与 `Shortcuts` 和 `KeyboardListener` 不同，你需要自己对它们进行管理。当你在为 Delete 键构建一个删除或退格行为的监听时，需要尤其注意，因为用户可能会在 TextField 中输入内容时受到影响。

### 鼠标进入、移出和悬停事件

在桌面平台上，常会在鼠标悬停在内容上时，改变光标以表明不同的功能用途。例如，你会在鼠标悬停的按钮上看到手指光标，或是在悬停的文字上看到一个 I。

Material 系列组件内置了对标准的按钮和文字的光标支持。你可以使用 MouseRegion 在你自己的 widget 上改变光标。

```dart
// Show hand cursor
return MouseRegion(
  cursor: SystemMouseCursors.click,
  // Request focus when clicked
  child: GestureDetector(
    onTap: () {
      Focus.of(context).requestFocus();
      _submit();
    },
    child: Logo(showBorder: hasFocus),
  ),
);
```

`MouseRegion` 对于创建自定义翻转和悬停效果也很有用：

```dart
return MouseRegion(
  onEnter: (_) => setState(() => _isMouseOver = true),
  onExit: (_) => setState(() => _isMouseOver = false),
  onHover: (e) => print(e.localPosition),
  child: Container(
    height: 500,
    color: _isMouseOver ? Colors.blue : Colors.black,
  ),
);
```

---

## 设定平台行为习惯和规范

每个平台都有其不同的行为习惯与规范，在UI、交互上设定统一标准，兼容各个平台行为习惯和规范很重要。

### 常见平台行为习惯和规范

#### 1. 滚动条的外观和行为

无论是桌面端还是移动端的用户，都需要滚动条，但他们对不同平台所期待的行为是不一样的。移动端的用户希望滚动条小一些，只在滚动时出现，而桌面端的用户一般想要更大且一直显示的滚动条，同时可以点击和拖动。

Flutter 内置了 `Scrollbar` widget，会根据当前所在的平台自适应颜色和大小。你可能会需要调整 alwaysShown 以在桌面平台上一直显示滚动条：

```dart
return Scrollbar(
  thumbVisibility: DeviceType.isDesktop,
  controller: _scrollController,
  child: GridView.count(
    controller: _scrollController,
    padding: const EdgeInsets.all(Insets.extraLarge),
    childAspectRatio: 1,
    crossAxisCount: colCount,
    children: listChildren,
  ),
);
```

对这些细节的把握，可以让你的应用在对应平台上体验更为良好。

#### 2. 多选列表

跨平台的另一个存在差异的地方，是如何处理列表中的多选：

```dart
static bool get isSpanSelectModifierDown =>
    isKeyDown({LogicalKeyboardKey.shiftLeft, LogicalKeyboardKey.shiftRight});
```

要想监测不同平台的 Control 或 Command 键，你可以编写以下的代码：

```dart
static bool get isMultiSelectModifierDown {
  bool isDown = false;
  if (Platform.isMacOS) {
    isDown = isKeyDown(
      {LogicalKeyboardKey.metaLeft, LogicalKeyboardKey.metaRight},
    );
  } else {
    isDown = isKeyDown(
      {LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.controlRight},
    );
  }
  return isDown;
}
```

最后一项针对键盘用户需要考虑的是 全选 操作。如果你的列表里有很多的可选择内容，可能你的许多用户也会希望能使用 `Control+A` 选中所有内容。

#### 3. 触屏设备

在触屏设备上，多选操作通常会被简化，与在桌面上按下了 isMultiSelectModifier（多选按钮）的行为类似。

在不同设备上处理多选操作，取决于你的用例是否有区分，但更重要的是为各个平台提供最好的交互模式。

#### 4. 可选文字

对于 Web 平台（以及小部分的桌面平台）而言，大部分能看到的文字都是可以使用鼠标选择的。如果不能选择，用户可能会感到不正常。

幸运的是，使用 `SelectableText` 就可以很简单地支持选择：

```dart
return const SelectableText('Select me!');
```

可以用 TextSpan 支持富文本：

```dart
return const SelectableText.rich(
  TextSpan(
    children: [
      TextSpan(text: 'Hello'),
      TextSpan(text: 'Bold', style: TextStyle(fontWeight: FontWeight.bold)),
    ],
  ),
);
```

#### 5. 标题栏

在现代的桌面应用程序中，经常会有定制应用窗口的标题栏、添加 Logo 或者其他控制的需求，能节省界面对于垂直空间的占用。

Flutter 并没有内置这样的支持，但是你可以使用 `bits_dojo` package 禁用标题栏，并且替换成自己的。

你可以利用这个 package 将任意 widget 应用在标题栏上，因为它是基于 Flutter 的 widget 进行设置的。如此一来，当你在应用内各个地方浏览时，标题栏都能以非常便捷的方式进行适配。

#### 6.上下文菜单和提示

在桌面平台上，通常有几种在叠加层中显示的交互组件，它们各自有不同的触发、关闭和定位方式：

* **上下文菜单**——通常在右键单击时显示，上下文菜单会显示在鼠标点击位置的附近，可以点击任意位置关闭、点击选项关闭或点击外部区域关闭。

* **提示**——提示通常会在交互元素上悬停 200-400 毫秒后出现，一般会锚定在 widget 上（与鼠标位置相反），并在鼠标移出元素后消失。

* **悬浮面板（浮出控件）**——悬浮面板与提示类似，通常会锚定在 widget 上。它与提示的区别是一般会在点击事件触发时显示，并且在鼠标移出时不会自动消失。通常来说，点击外部区域或者 关闭 或 提交 按钮时会关闭悬浮面板。

若你想在 Flutter 中显示一个简单的提示，你可以使用 `Tooltip` widget：

```dart
return const Tooltip(
  message: 'I am a Tooltip',
  child: Text('Hover over the text to show a tooltip.'),
);
```

Flutter 同时也为编辑和选择文字提供了内置的上下文菜单。

若你想显示更高级的提示、悬浮面板或自定义的上下文菜单，你可以使用已有的 package，或利用 Stack 和 Overlay 进行构建。

可以使用的 package 包括：

* context_menus
* anchored_popups
* flutter_portal
* super_tooltip
* custom_pop_up_menu

尽管这些控制对于触控用户来说只是一种增强，但对于桌面用户而言，它们是必不可少的。桌面用户会期望能够右键点击其中一些内容，当场进行编辑，悬浮时查看更多信息。若你的应用并不包含这类交互，相关的用户群体可能会感到有些失望，或是认为某些地方不合理。

#### 7. 按钮的水平排列

在 Windows 上展示一行按钮时，确认按钮会在一行的起始位置（左侧）。而在其他平台上，则是完全相反的，确认按钮显示在末尾位置（右侧）。

在 Flutter 里你可以很轻松地修改 `Row` 的 `TextDirection` 来达到这个效果：

```dart
TextDirection btnDirection =
    DeviceType.isWindows ? TextDirection.rtl : TextDirection.ltr;
return Row(
  children: [
    const Spacer(),
    Row(
      textDirection: btnDirection,
      children: [
        DialogButton(
          label: 'Cancel',
          onPressed: () => Navigator.pop(context, false),
        ),
        DialogButton(
          label: 'Ok',
          onPressed: () => Navigator.pop(context, true),
        ),
      ],
    ),
  ],
);
```

#### 8. 菜单栏

桌面平台有另一种常见的内容：菜单栏。在 Windows 和 Linux 上，Chrome 的菜单栏整合在标题栏内，而在 macOS 上，菜单栏在主屏幕的顶部。

目前你可以使用一个原型插件来指定菜单栏的入口，我们希望这个功能最终能合并到 SDK 中。

值得一提的是，在 Windows 和 Linux 上，你无法将自定义的标题栏与菜单栏整合在一起。在构建自定义的标题栏时，实际上是替换了整个原生的标题栏，意味着你也同时失去了原生的菜单栏。

如果你同时需要自定义的标题栏和菜单栏，你可以使用 Flutter 进行实现，类似于自定义的上下文菜单。

#### 9. 拖放（拖动和放置）

拖放是基于触摸和指针的交互的一项核心。虽然这两种交互类型都需要拖放，但是在滑动整个包含可拖拽元素的列表时，仍然需要考虑其中的差异。

一般来说，触屏用户希望看到可拖动的手柄，以区分拖动和滚动的范围，或者通过长按操作来进行拖动。这是由于滑动和拖动操作都是由一个触摸点完成的。

鼠标用户有着不止一种输入方式。他们可以使用滚轮和滑动条进行滑动，这样便不再专门需要操作手柄进行指示操作。如果你使用过 macOS 的访达和 Windows 的资源管理器，你会看到它们在选中一个元素后，就可以开始拖动。

在 Flutter 中，你可以用多种方式实现拖放。但是我们不在本篇文章中讨论这个话题，以下是一些更高级的选项：

* 使用 `Draggable` 和 `DragTarget API` 定制界面和交互。

* 监听 `onPan` 手势事件，利用 `Stack` 移动对象。

* 使用 `pub.dev` 上一些 预先实现的 package。

---

## 示例：构建自适应电子商务应用

假设我们要创建一个电子商务应用，它在移动设备上以列表形式展示产品，在桌面设备上则以网格形式展示。

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(ShopApp());
}

class ShopApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(
          title: Text('Shop App'),
        ),
        body: LayoutBuilder(
          builder: (BuildContext context, BoxConstraints constraints) {
            return constraints.maxWidth > 600
                ? DesktopProductView()
                : MobileProductView();
          },
        ),
      ),
    );
  }
}

class DesktopProductView extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // 桌面视图的实现...
  }
}

class MobileProductView extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // 移动视图的实现...
  }
}
```

## 总结

作为开发人员，你应当花一些时间学习基本的可用性原则([文档页面底部](https://flutter.cn/docs/ui/layout/responsive/building-adaptive-apps#idioms-and-norms))，帮助你做出更好的决策

创建自适应布局的简要步骤：

* 确定布局需求：根据目标设备和使用场景，确定布局需求。
* 使用 LayoutBuilder：在应用中使用 LayoutBuilder 来获取布局约束，并根据这些约束来构建不同的布局。
* 响应屏幕尺寸：使用 MediaQuery 获取屏幕尺寸，并据此调整布局。
* 处理不同方向：使用 OrientationBuilder 来处理不同方向（纵向或横向）的布局差异。
* 测试不同设备：在不同的设备和屏幕尺寸上测试应用，确保布局能够正确响应。
* 性能优化：确保布局的构建不会对性能产生负面影响，避免过度的重建和布局计算。

通过上述步骤和方法，你可以创建一个既美观又实用的自适应 Flutter 应用，它能够在不同设备上提供最佳的用户体验。

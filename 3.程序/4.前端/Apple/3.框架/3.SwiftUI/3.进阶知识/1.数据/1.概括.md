# 数据

在SwiftUI中，数据通常通过`@State`、`@Binding`、`@EnvironmentObject`、`@ObservedObject`和`@FetchRequest`等属性包装器来管理和使用。这些属性包装器提供了一种声明式的方式来绑定和响应数据变化。

## @State

用于定义视图内部的状态，它只会在该视图的生命周期内持久化。

```swift
struct ContentView: View {
    @State private var count = 0

    var body: some View {
        Button("Tap me") {
            count += 1
        }
        Text("Taps: \(count)")
    }
}
```

## @StateObject

作用同`@State`，区别是：

1. **管理复杂状态**：当你需要在视图中管理复杂的状态，而这些状态不适合使用简单的 `@State` 来管理时。
2. **自动销毁**：当你需要在视图消失时自动销毁对象，释放资源，而不是仅仅更新视图。
3. **重建视图**：当你希望在对象的属性发生变化时完全重建视图，而不是仅仅更新变化的部分。

## @Binding

允许你创建一个双向绑定，通常与父视图的状态或另一个视图的状态绑定。

```swift
struct ParentView: View {
    @State private var count = 0

    var body: some View {
        ChildView(count: $count)
    }
}

struct ChildView: View {
    @Binding var count: Int

    var body: some View {
        Button("Tap me") {
            count += 1
        }
        Text("Taps: \(count)")
    }
}
```

## @EnvironmentObject

用于在视图层次结构中传递全局状态或配置。

```swift
class AppSettings: ObservableObject {
    @Published var theme: String = "Light"
}

struct ContentView: View {
    @EnvironmentObject var settings: AppSettings

    var body: some View {
        Text("Current theme is \(settings.theme)")
    }
}

struct MainView: View {
     var body: some View {
        ContentView().environmentObject(AppSettings()) //向ContentView注入AppSettings实例对象
    }
}
```

## @ObservedObject

用于观察一个对象的属性变化，当对象的`@Published`属性变化时，视图会自动更新。

```swift
class UserViewModel: ObservableObject {
    @Published var username: String = "JohnDoe"

    func updateUsername(to newName: String) {
        username = newName
    }
}

struct ProfileView: View {
    @ObservedObject var viewModel = UserViewModel()

    var body: some View {
        Text(viewModel.username)
        Button("Change Username") {
            viewModel.updateUsername(to: "JaneDoe")
        }
    }
}
```

## @FetchRequest

用于从Core Data获取数据，并在数据变化时更新视图。

```swift
struct ContentView: View {
    @FetchRequest(
        entity: Item.entity(),
        sortDescriptors: [NSSortDescriptor(keyPath: \Item.name, ascending: true)]
    ) private var items: FetchRequest<Item>

    var body: some View {
        List(items, id: \.self) { item in
            Text(item.name ?? "Unknown")
        }
    }
}
```

## 数据流

在SwiftUI中，数据流通常是单向的，从父视图流向子视图。父视图通过属性包装器和视图修饰符将数据传递给子视图，子视图通过用户交互来更新数据。

## 数据更新

数据更新通常通过修改属性包装器的值来触发，这会导致视图重新渲染以反映新的数据状态。

## 数据共享

数据共享可以通过`@EnvironmentObject`或`@ObservedObject`来实现，它们允许在不同的视图之间共享和响应数据变化。

通过这些属性包装器，SwiftUI提供了一种声明式的方式来处理数据和视图之间的交互，使得数据管理更加直观和高效。

---

## 总结

1. @State 视图自己使用
2. @Binding 子视图可以访问父视图的@State数据
3. @EnvironmentObject 修饰视图中声明的属性，外部使用时可以通过`.environmentObject()`将数据注入给视图的属性。
4. @ObservedObject 观察`@Published`属性，变化会引起视图刷新

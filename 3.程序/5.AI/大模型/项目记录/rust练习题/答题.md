# Rust习题

## 1. Rust基础

概念题：

问题1. 解释Rust中变量默认不可变的设计理念，以及如何声明可变变量？

设计理念：1. 安全性：1.减少bug，避免变量修改引起的问题 2.更好的并发支持，不可变数据可以安全的共享在多个线程间
使用`mut`修饰可变变量：`mut let x = 1;`

问题2. Rust中的原始数据类型有哪些？并说明它们的大小。

1. 整数类型：
    i8,i16,i32,i64,i128(有符号)
    u8,u16,u32,u64,u128(无符号)
2. 浮点类型：
    f32（32位）, f64(64位)
3. 布尔类型：
    bool（1字节）
4. 字符类型：
    char（4字节，Unicode标量值）

---

代码题

1. 编写一个函数，接收一个整数n，返回1到n的所有偶数的和。

```rust
fn findAllNumbers(n:i32)->i32{
    let mut sum = 0;
    for i in 1..=n{
        if i %2 ==0{
            println!("i:{}", i);
            sum += i;
        }
    }

    return sum;
}
```

实战应用题

1. 实现一个简单的命令行计算器，支持基本的四则运算。

```rust
use std::io;
pub fn caculateTool(){
    // + - * /
    println!("请输入第一个数字：");
   let mut inputNum1 = String::new();
   io::stdin().read_line(&mut inputNum1).expect("读取失败");

   println!("请输入第二个数字：");
   let mut inputNum2 = String::new();
   io::stdin().read_line(&mut inputNum2).expect("读取失败");

   println!("请输入运算符（+ - * /）：");
   let mut operater = String::new();
   io::stdin().read_line(&mut operater).expect("读取失败");


    //将字符串转换为数字
    let num1:f64 = inputNum1.trim().parse().unwrap();
    let num2:f64 =  inputNum2.trim().parse().unwrap();

    let mut ret = 0.0;

    match operater.trim() {
            "+" => ret = num1 + num2,
            "-" => ret = num1 - num2,
            "*" => ret = num1 * num2,
            "/" => {
                if num2 == 0.0 {
                    println!("除数不能为0");
                    return;
                }
                ret = num1 / num2;
            }
            _ => {
                println!("无效的运算符");
                return;
            }
        }


    println!("运算结果：{}",ret);
}
```

---

## 2. 所有权系统

问题1：三大核心原则？

答：

1.所有权持有者唯一
2.所有权转移
3.超出作用域自动释放

这些原则在编译时强制执行，保证内存安全，无需垃圾回收机制

问题2 ：引用的借用规则？

答：

1. 在任意时间，要么只有一个可变引用或只有多个不可变引用
2. 引用必须总是有效的，不能存在悬垂指针

问题3：可变引用和不可变引用有什么区别？

不可变引用（&T）：可以同时多个存在，只读数据
可变引用（&mut T）：同时间仅有一个，可读、可写

---

## 解释Rust中线程安全的实现机制，以及Send和Sync trait的作用

rust 线程安全机制：

1. Send trait:
    - 表示类型可以安全地在线程间转移所有权
    - 大多数类型都实现了Send
    - 例外：Rc，RefCell等

2. Sync trait:
    - 表示类型可以安全地在多个线程间共享引用
    - &T是Sync，则T可以安全的在多线程间共享
    - 例外：内部可变性类型

3. 所有权和借用检查：
    - 编译时防止数据竞争
    - 确保共享状态的安全访问
    - 强制实施"要么多个不可变引用，要么一个可变引用"

---

## 多线程

实现一个多线程计数器，使用互斥锁(Mutex)保护共享状态。

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // 创建一个 Arc 包装的 Mutex，用于多线程间共享和同步访问计数器
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    // 创建 10 个线程，每个线程都会对计数器加 1
    for _ in 0..10 {
        // 克隆 Arc 智能指针，以便每个线程都能持有一个引用
        let counter = Arc::clone(&counter);
        // 创建一个新线程
        let handle = thread::spawn(move || {
            // 锁定 Mutex 以获取对计数器的独占访问权
            let mut num = match counter.lock() {
                Ok(guard) => guard,
                Err(e) => {
                    eprintln!("Failed to lock mutex: {}", e);
                    return;
                }
            };
            // 对计数器加 1
            *num += 1;
        });
        // 将线程句柄添加到向量中
        handles.push(handle);
    }

    // 等待所有线程完成
    for handle in handles {
        if let Err(e) = handle.join() {
            eprintln!("Thread panicked: {:?}", e);
        }
    }

    // 锁定 Mutex 以获取最终的计数器值
    let final_count = match counter.lock() {
        Ok(guard) => *guard,
        Err(e) => {
            eprintln!("Failed to lock mutex: {}", e);
            return;
        }
    };
    // 打印最终的计数结果
    println!("计数结果: {}", final_count);
}    
```

# 函数调用（Function Calling）

是LLM调用预定义函数的机制，但高度依赖特定平台（每个大模型发布方都有自己的函数调用的实现方式）。核心作用就是可以调用外部工具完成LLM无法直接回答的问题。
>后面有一种通用的协议：MCP协议，可以替代函数调用

## 前言

个人理解：函数调用需要在客户端配置（就是用户使用的那个web网页、AI app、AI插件）

资料：

```txt
https://blog.csdn.net/qingkahui24689/article/details/141186047
https://mp.weixin.qq.com/s/C_xOFFlyrWDITace1NvgcA
https://mp.weixin.qq.com/s/TYoJ9mQL8tgT7HjTQiSdlw
```

## 作用

函数调用使开发者能够创建：

- 能够高效使用外部工具回答问题的对话代理。例如，查询“伯利兹的天气如何？”将被转换为类似get_current_weather(location: string, unit: 'celsius' | 'fahrenheit')的函数调用
- 用于提取和标记数据的LLM驱动解决方案（例如，从维基百科文章中提取人名）
- 可以帮助将自然语言转换为API调用或有效数据库查询的应用程序
- 能够与知识库交互的对话式知识检索引擎

---

## AI简介

大型语言模型（LLM）中的**函数调用**（Function Calling）是一种将模型能力与外部工具或API结合的关键技术。通过函数调用，LLM可以根据用户请求动态选择并触发预定义的函数，从而扩展其能力边界（如实时数据查询、计算、数据库操作等）。以下是对这一技术的详细解析：

---

### 一、函数调用的核心逻辑

1. **意图识别**  
   LLM首先理解用户输入的意图，判断是否需要调用外部函数。例如：
   - 用户问：“北京今天的天气如何？” → 需调用天气API。
   - 用户问：“计算sin(30°)的值” → 需调用数学计算函数。

2. **函数选择与参数生成**  
   模型从预定义的函数列表中选择最相关的函数，并生成符合函数要求的参数（通常为JSON格式）。例如：

   ```json
   {
     "function": "get_weather",
     "params": {"location": "北京", "date": "2023-10-01"}
   }
   ```

3. **执行与反馈**  
   系统执行函数后，将结果返回给LLM，LLM将结果整合到自然语言回复中。

---

### 二、实现函数调用的关键步骤

#### 1. 定义函数库

预先声明模型可调用的函数及其参数格式。例如：

```python
functions = [
    {
        "name": "get_stock_price",
        "description": "获取指定股票的实时价格",
        "parameters": {
            "type": "object",
            "properties": {
                "symbol": {"type": "string", "description": "股票代码，例如AAPL"}
            },
            "required": ["symbol"]
        }
    }
]
```

#### 2. 用户输入与模型推理

将用户输入和函数描述一起传递给LLM，触发模型决策。例如使用OpenAI API：

```python
response = openai.ChatCompletion.create(
    model="gpt-4",
    messages=[{"role": "user", "content": "苹果公司的最新股价是多少？"}],
    functions=functions,
    function_call="auto"  # 由模型决定是否调用函数
)
```

#### 3. 解析模型输出

模型返回的响应中会包含函数调用请求：

```json
{
    "role": "assistant",
    "content": null,
    "function_call": {
        "name": "get_stock_price",
        "arguments": "{\"symbol\": \"AAPL\"}"
    }
}
```

#### 4. 执行函数并生成最终回复

调用对应函数获取结果后，将结果返回给LLM生成自然语言回复：

```python
stock_data = get_stock_price(symbol="AAPL")
final_response = openai.ChatCompletion.create(
    model="gpt-4",
    messages=[
        {"role": "user", "content": "苹果公司的最新股价是多少？"},
        {"role": "assistant", "content": None, "function_call": ...},
        {"role": "function", "name": "get_stock_price", "content": json.dumps(stock_data)}
    ]
)
print(final_response.choices[0].message['content'])
# 输出："苹果公司（AAPL）的最新股价为$189.20，较昨日上涨1.5%"
```

---

### 三、核心挑战与调优策略

#### 1. 函数选择的准确性

- **问题**：模型可能错误选择函数或遗漏关键参数。
- **解决**：
  - 优化函数描述的清晰度（如使用更详细的`description`字段）。
  - 使用少量示例（few-shot learning）引导模型学习调用模式。

#### 2. 参数生成与校验

- **问题**：模型生成的参数格式错误（如字段类型不匹配）。
- **解决**：
  - 在函数定义中明确参数类型和约束。
  - 添加后处理逻辑校验参数格式。

#### 3. 错误处理

- **问题**：函数执行失败（如API超时）时需优雅降级。
- **解决**：
  - 设计重试机制。
  - 允许模型根据错误信息调整参数或选择备用函数。

---

### 四、典型应用场景

| 场景                | 示例函数                  | 用途                     |
|---------------------|--------------------------|--------------------------|
| 实时数据查询        | `get_weather(location)`  | 天气、股价、新闻等       |
| 工具集成            | `send_email(to, body)`   | 邮件发送、日历事件创建   |
| 复杂计算            | `calculate_loan(amount)` | 金融计算、工程公式求解   |
| 数据库操作          | `query_database(sql)`    | 检索企业私有数据         |

---

### 五、技术延伸

1. **链式调用**（Chain-of-Function）  
   允许多个函数按顺序调用，例如：  
   `查询天气 → 推荐出行装备 → 预订出租车`

2. **动态函数发现**  
   高级系统可支持运行时动态加载新函数，无需重新训练模型。

3. **安全控制**  
   通过权限管理限制敏感函数调用（如数据库写入操作）。

---

### 六、代码示例（简化版）

```python
import json
import openai

# 定义函数
functions = [
    {
        "name": "get_weather",
        "description": "获取指定城市的天气信息",
        "parameters": {
            "type": "object",
            "properties": {
                "location": {"type": "string", "description": "城市名称"}
            },
            "required": ["location"]
        }
    }
]

# 用户输入
user_query = "上海明天会下雨吗？"

# 调用模型
response = openai.ChatCompletion.create(
    model="gpt-4",
    messages=[{"role": "user", "content": user_query}],
    functions=functions,
    function_call="auto"
)

# 解析函数调用
if 'function_call' in response.choices[0].message:
    func_name = response.choices[0].message.function_call.name
    args = json.loads(response.choices[0].message.function_call.arguments)
    
    # 执行函数（此处模拟）
    if func_name == "get_weather":
        weather_data = {"location": args["location"], "forecast": "Rainy"}
        
    # 将结果返回给模型生成最终回复
    final_response = openai.ChatCompletion.create(
        model="gpt-4",
        messages=[
            {"role": "user", "content": user_query},
            {"role": "assistant", "content": None, "function_call": response.choices[0].message.function_call},
            {"role": "function", "name": func_name, "content": json.dumps(weather_data)}
        ]
    )
    print(final_response.choices[0].message['content'])
else:
    print(response.choices[0].message['content'])
```

---

通过函数调用，LLM从纯粹的文本生成器进化为可连接真实世界的智能代理。这一技术的成熟将显著提升AI在垂直领域（如金融、客服、IT运维）的应用价值。

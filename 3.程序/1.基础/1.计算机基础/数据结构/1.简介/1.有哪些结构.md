# 有哪些结构

数据结构是软件开发的核心，是高效算法和系统设计的基本构建模块。以下为你介绍常见的数据结构：

- **线性结构**：
  - **数组**：在连续内存块中存储元素，可通过索引快速访问，适合存储需恒定时间访问和修改的元素列表，但调整大小成本高，中间插入或删除元素需移动其他元素。
  - **链表**：每个元素（节点）包含值和指向下一个节点的引用，无需连续内存，可动态增长或收缩，适合频繁插入或删除元素的场景，分为单链表、双链表等。
  - **栈**：一种后进先出（LIFO）的数据结构，元素从顶部添加和移除，常用于文本编辑器的撤销操作、表达式解析等。
  - **队列**：一种先进先出（FIFO）的数据结构，元素在尾部插入，从头部移除，适用于任务调度、服务器处理请求等场景。
- **非线性结构**：
  - **树**：由节点组成的分层结构，每个节点可有子节点，用于表示层次关系，如文件目录、组织结构图等，常见的有二叉树、平衡二叉树、二叉搜索树等。
  - **图**：由顶点（节点）和边组成，用于表示关系或网络，如社交网络、路由算法等，可分为有向图、无向图、加权图等。
- **散列结构**：
  - **哈希表**：存储键值对，通过哈希函数计算索引来快速查找值，常用于缓存、数据库索引等场景。
  - **哈希集合（HashSet）**：存储独特元素，利用哈希函数映射元素，可快速检查元素是否存在。
- **其他高级数据结构**：
  - **优先队列**：一种特殊的队列，每个元素都有一个优先级，出队时优先级高的元素先出队，通常基于堆实现。
  - **并查集**：用于处理不相交集合的合并与查询问题，在kruskal算法等场景中有应用。
  - **布隆过滤器**：用于快速判断元素是否在一个集合中，空间效率高，但存在误判可能。
  - **后缀树和后缀数组**：用于字符串相关问题，如字符串匹配、最长公共子串等。
- **特殊用途的数据结构**：
  - **线段树**：用于处理区间查询和修改问题，如查询区间最大值、最小值等。
  - **四叉树**：用于二维空间划分，常用于地理信息系统和图像处理。
  - **八叉树**：三维空间的划分数据结构，常用于三维空间的快速检索。
  - **环形缓冲区**：固定大小的缓冲区，用于数据流的缓存，常用于音频、视频数据处理。
  - **滑动窗口**：用于处理数据流中的固定大小窗口问题，如在字符串中查找特定子串等场景。

---

## 介绍一下

以下是软件开发中常见数据结构的详细解释，包括其定义、特点、操作方式及典型应用场景：

### **一、线性结构**

线性结构中元素按线性顺序排列，每个元素（除首尾外）有唯一前驱和后继。

#### 1. **数组（Array）**

- **定义**：在连续内存空间中存储相同类型元素的集合，通过索引（下标）访问。
- **特点**：
  - 随机访问效率高（时间复杂度O(1)），直接通过索引定位。
  - 大小固定（静态数组），动态数组（如Java的ArrayList）可自动扩容，但扩容时需复制元素（O(n)时间）。
  - 中间插入/删除元素成本高（需移动后续元素，O(n)时间）。
- **操作**：
  - 访问：`array[index]`
  - 插入/删除：需移动元素（动态数组可在尾部高效插入，O(1) amortized）。
- **应用**：存储固定大小的列表（如用户ID列表）、矩阵、缓存等。

#### 2. **链表（Linked List）**

- **定义**：由节点组成，每个节点包含数据和指向其他节点的引用（指针），内存不连续。
- **类型**：
  - 单链表：每个节点仅指向下一个节点。
  - 双链表：每个节点同时指向前驱和后继节点。
  - 循环链表：尾节点指向头节点，形成环形。
- **特点**：
  - 动态大小，无需预分配内存。
  - 插入/删除元素高效（只需修改指针，O(1)时间，前提是已定位节点）。
  - 访问元素需从头遍历（O(n)时间），内存开销略高（需存储指针）。
- **操作**：
  - 插入：修改前驱节点的指针指向新节点，新节点指向后继节点。
  - 删除：修改前驱节点的指针跳过待删节点。
- **应用**：实现链表式队列/栈、哈希表的冲突解决（链地址法）、浏览器历史记录（双向链表）。

#### 3. **栈（Stack）**

- **定义**：遵循“后进先出（LIFO）”原则的线性结构，仅允许在顶部（栈顶）操作。
- **特点**：
  - 操作受限：仅支持栈顶的插入（push）、删除（pop）和查看（peek）。
  - 可基于数组或链表实现。
- **操作**：
  - push：添加元素到栈顶（O(1)）。
  - pop：移除并返回栈顶元素（O(1)）。
  - peek：返回栈顶元素（O(1)）。
- **应用**：
  - 表达式求值（如后缀表达式）。
  - 函数调用栈（递归实现）。
  - 撤销操作（文本编辑器）。

#### 4. **队列（Queue）**

- **定义**：遵循“先进先出（FIFO）”原则的线性结构，元素从尾部插入，从头部删除。
- **类型**：
  - 普通队列：基于数组（易产生假溢出）或链表实现。
  - 循环队列：数组实现的优化版，首尾相连避免假溢出。
  - 双端队列（Deque）：允许首尾同时插入/删除（如Java的ArrayDeque）。
- **特点**：
  - 操作受限：尾部插入（enqueue）、头部删除（dequeue）。
- **操作**：
  - enqueue：添加元素到队尾（O(1)）。
  - dequeue：移除并返回队头元素（O(1)）。
- **应用**：
  - 任务调度（如打印机队列）。
  - 广度优先搜索（BFS）。
  - 缓冲处理（如网络数据接收）。

### **二、非线性结构**

非线性结构中元素间存在多对多关系，不按线性顺序排列。

#### 1. **树（Tree）**

- **定义**：由n个节点组成的分层结构，有一个根节点，其余节点分为若干子树，节点间为父子关系。
- **基本术语**：
  - 根：无父节点的节点。
  - 叶子：无子节点的节点。
  - 深度：节点到根的路径长度。
  - 高度：节点到最深叶子的路径长度。
- **常见类型**：
  - **二叉树**：每个节点最多有2个子节点（左、右子树）。
    - 满二叉树：所有叶子在同一层，非叶子节点均有两个子节点。
    - 完全二叉树：除最后一层外均满，最后一层左对齐（适合数组存储）。
  - **二叉搜索树（BST）**：左子树所有节点值 < 根节点值 < 右子树所有节点值，支持高效查找（O(log n)）。
  - **平衡树**：避免BST退化（如AVL树、红黑树），通过旋转维持平衡，保证O(log n)操作。
  - **堆（Heap）**：完全二叉树，分为大顶堆（父节点 ≥ 子节点）和小顶堆（父节点 ≤ 子节点），用于实现优先队列。
  - **字典树（Trie）**：多叉树，用于存储字符串，高效检索前缀（如自动补全）。
- **遍历方式**：
  - 深度优先（DFS）：前序（根-左-右）、中序（左-根-右）、后序（左-右-根）。
  - 广度优先（BFS）：按层遍历。
- **应用**：
  - 数据库索引（B+树）。
  - 哈夫曼编码（压缩算法）。
  - 决策树（机器学习）。

#### 2. **图（Graph）**

- **定义**：由顶点（Vertex）和边（Edge）组成的非线性结构，边表示顶点间的关系。
- **类型**：
  - 有向图：边有方向（如A→B）。
  - 无向图：边无方向（如A-B）。
  - 加权图：边带权重（如表示距离、成本）。
  - 连通图：任意两顶点间有路径；非连通图反之。
- **存储方式**：
  - 邻接矩阵：二维数组`graph[i][j]`表示顶点i和j是否有边（适合稠密图）。
  - 邻接表：数组+链表，每个顶点对应其相邻顶点列表（适合稀疏图）。
- **遍历方式**：
  - 深度优先搜索（DFS）：递归或栈实现，优先深入分支。
  - 广度优先搜索（BFS）：队列实现，按层次扩散。
- **应用**：
  - 社交网络（用户为顶点，关系为边）。
  - 最短路径算法（Dijkstra、Floyd）。
  - 拓扑排序（任务调度，处理依赖关系）。

### **三、散列结构**

基于哈希函数实现键到值的映射，强调快速查找。

#### 1. **哈希表（Hash Table）**

- **定义**：通过哈希函数将键（Key）映射到数组索引，存储键值对（Key-Value）。
- **核心机制**：
  - 哈希函数：将任意键转换为数组索引（如取模运算）。
  - 冲突解决：
    - 链地址法：冲突的键值对以链表形式存储在同一索引。
    - 开放地址法：冲突时寻找下一个空闲位置（如线性探测）。
- **特点**：
  - 平均查找/插入/删除效率为O(1)，最坏情况O(n)（取决于哈希函数和冲突处理）。
  - 性能依赖哈希函数的质量（减少冲突）。
- **应用**：
  - 缓存（如Redis）。
  - 数据库索引。
  - 计数统计（如词频统计）。

#### 2. **哈希集合（HashSet）**

- **定义**：基于哈希表的集合，存储唯一元素（无重复）。
- **特点**：
  - 元素无序，查询“是否存在”效率高（O(1)）。
  - 不允许重复元素，插入时会自动去重。
- **应用**：去重操作、快速判断元素归属（如黑名单检查）。

### **四、高级数据结构**

#### 1. **优先队列（Priority Queue）**

- **定义**：元素按优先级排序，出队时优先级最高的元素先出（非FIFO）。
- **实现**：通常基于堆（高效）或平衡树。
- **操作**：
  - 插入（O(log n)）：按优先级插入堆。
  - 提取最大/小值（O(log n)）：取出堆顶元素。
- **应用**：
  - 任务调度（高优先级任务先执行）。
  - Dijkstra算法（最短路径）。

#### 2. **并查集（Union-Find/Disjoint Set）**

- **定义**：管理多个不相交集合，支持“合并”和“查询”操作。
- **核心优化**：
  - 路径压缩：查询时扁平化树结构，加速后续操作。
  - 按秩合并：合并时将小树挂到大树上，保持树浅。
- **操作**：
  - find：查找元素所属集合的根（O(α(n))，α为反阿克曼函数，接近O(1)）。
  - union：合并两个集合（O(α(n))）。
- **应用**：
  - 连通分量判断（如网络节点连通性）。
  - Kruskal算法（最小生成树）。

#### 3. **布隆过滤器（Bloom Filter）**

- **定义**：空间高效的概率型数据结构，用于判断元素“可能存在”或“一定不存在”。
- **原理**：
  - 通过多个哈希函数将元素映射到位数组的多个位置，标记为1。
  - 查询时，若所有位置均为1则“可能存在”（有假阳性）；否则“一定不存在”。
- **特点**：
  - 空间效率极高，查询快（O(k)，k为哈希函数数量）。
  - 有假阳性率（可通过调整参数降低），无假阴性。
- **应用**：
  - 缓存穿透防护（快速过滤不存在的键）。
  - 分布式系统中的元素存在性判断。

#### 4. **线段树（Segment Tree）**

- **定义**：用于区间查询和更新的二叉树，每个节点代表一个区间。
- **功能**：
  - 区间查询：如区间求和、最大值、最小值（O(log n)）。
  - 单点/区间更新（O(log n)）。
- **应用**：
  - 范围统计（如成绩区间内的人数）。
  - 动态区间最值查询。

### **总结**

选择数据结构需权衡**时间复杂度**（查询、插入、删除效率）、**空间复杂度**（内存占用）和**适用场景**：

- 需快速随机访问 → 数组。
- 频繁插入删除 → 链表。
- 后进先出操作 → 栈。
- 先进先出操作 → 队列。
- 层次关系或排序 → 树（BST、堆等）。
- 多对多关系 → 图。
- 键值对快速查询 → 哈希表。

理解各类数据结构的特性是设计高效算法和系统的基础。

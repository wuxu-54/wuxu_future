# BFS与DFS

BFS（广度优先搜索，Breadth-First Search）和DFS（深度优先搜索，Depth-First Search）是两种基本的图遍历算法，它们在很多应用场景中都非常有用，比如在网络爬虫、社交网络分析、游戏AI、迷宫求解等问题中。下面是对BFS和DFS的详解：

## 广度优先搜索（BFS）

**概念**：

- BFS从一个节点开始，逐层遍历图中的所有节点。
- 它使用队列作为其主要的数据结构来保持访问顺序。

**步骤**：

1. 从源节点开始，将其入队。
2. 当队列非空时，执行以下操作：
   - 出队队列头部的节点。
   - 访问该节点的所有未访问邻居节点，并将它们入队。
   - 标记访问过的节点。

**特点**：

- BFS可以找到最短路径。
- 对于无权图，BFS可以用于确定两个节点之间的最短距离。
- BFS的时间复杂度是O(V+E)，其中V是顶点数，E是边数。

**应用场景**：

- 寻找最短路径。
- 在层次化结构中查找节点。

## 深度优先搜索（DFS）

**概念**：

- DFS从一个节点开始，尽可能深地搜索图的分支。
- 它使用栈作为其主要的数据结构，可以是显式的栈或递归调用。

**步骤**：

1. 从源节点开始，将其压栈。
2. 当栈非空时，执行以下操作：
   - 弹出栈顶的节点并访问它。
   - 将该节点的所有未访问邻居节点压栈。
   - 标记访问过的节点。

**特点**：

- DFS不保证找到最短路径。
- DFS可以用于拓扑排序、检测环、求解迷宫等。
- DFS的时间复杂度也是O(V+E)。

**应用场景**：

- 拓扑排序。
- 检测图中的环。
- 求解迷宫或类似的路径问题。

## 比较

- **栈 vs 队列**：DFS使用栈（递归实现时是系统调用栈），而BFS使用队列。
- **顺序**：DFS先访问深层次的节点，BFS先访问浅层的节点。
- **最短路径**：BFS可以找到最短路径，DFS不能。
- **空间复杂度**：在最坏的情况下，DFS的空间复杂度可能较高，因为它可能需要存储整个路径。

## 实现

BFS和DFS都可以使用递归或非递归方式实现。递归实现更简洁，但可能受到系统调用栈大小的限制。非递归实现通常使用队列或栈来显式地控制节点的访问顺序。

在实际应用中，选择BFS还是DFS取决于问题的需求。如果需要找到最短路径，BFS是更好的选择；如果需要探索尽可能深的分支，DFS可能更合适。

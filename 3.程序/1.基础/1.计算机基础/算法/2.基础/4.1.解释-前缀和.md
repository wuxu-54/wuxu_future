# 前缀和

前缀和是一种高效计算数组（或序列）中**区间和**的算法技巧，核心思想是通过预处理构建一个“前缀和数组”，将原本需要O(n)时间的区间和计算优化为O(1)，广泛应用于数组区间查询问题中。

## 一、一维前缀和

### 1. 定义

对于一个一维数组 `nums`（长度为n），其前缀和数组 `prefix`（通常长度为n+1）的定义为：  
`prefix[0] = 0`（哨兵，方便计算）  
`prefix[i] = nums[0] + nums[1] + ... + nums[i-1]`（即前i个元素的和）  

### 2. 例子

原数组 `nums = [1, 2, 3, 4, 5]`  
前缀和数组 `prefix` 计算如下：  
`prefix[0] = 0`  
`prefix[1] = nums[0] = 1`  
`prefix[2] = nums[0] + nums[1] = 1+2=3`  
`prefix[3] = nums[0]+nums[1]+nums[2] = 1+2+3=6`  
`prefix[4] = 1+2+3+4=10`  
`prefix[5] = 1+2+3+4+5=15`  

### 3. 核心作用：快速计算区间和

若要计算原数组中 **[l, r] 区间**（0-based，包含l和r）的和，公式为：  
`sum(l, r) = prefix[r+1] - prefix[l]`  

例如：  
计算 `nums[1..3]`（即元素2,3,4）的和：  
`sum(1,3) = prefix[4] - prefix[1] = 10 - 1 = 9`（正确，2+3+4=9）  

### 4. 构建步骤（代码示例）

```python
def build_prefix(nums):
    n = len(nums)
    prefix = [0] * (n + 1)
    for i in range(1, n+1):
        prefix[i] = prefix[i-1] + nums[i-1]
    return prefix

# 测试
nums = [1,2,3,4,5]
prefix = build_prefix(nums)
print(prefix)  # [0,1,3,6,10,15]
print("sum(1,3) =", prefix[4] - prefix[1])  # 9
```

## 二、二维前缀和

对于二维矩阵（如二维数组），前缀和可扩展为“二维前缀和”，用于快速计算**子矩阵的和**。

### 1. 定义

对于矩阵 `matrix`（行数m，列数n），二维前缀和数组 `prefix`（大小(m+1)×(n+1)）的定义为：  
`prefix[i][j]` 表示以 `matrix[0][0]` 为左上角、`matrix[i-1][j-1]` 为右下角的矩形区域的总和。  

### 2. 构建公式（容斥原理）

`prefix[i][j] = matrix[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]`  
（解释：当前单元格的值 + 上方矩形和 + 左方矩形和 - 重复计算的左上角矩形和）  

### 3. 子矩阵和计算

若要计算以 `(x1, y1)` 为左上角、`(x2, y2)` 为右下角的子矩阵和（0-based），公式为：  
`sum = prefix[x2+1][y2+1] - prefix[x1][y2+1] - prefix[x2+1][y1] + prefix[x1][y1]`  

### 4. 例子与代码

矩阵 `matrix = [[1,2,3], [4,5,6], [7,8,9]]`  
构建的二维前缀和 `prefix` 如下（3+1行，3+1列）：  

```txt
prefix[0][*] = 0，prefix[*][0] = 0
prefix[1][1] = 1
prefix[1][2] = 1+2=3
prefix[1][3] = 1+2+3=6
prefix[2][1] = 1+4=5
prefix[2][2] = 1+2+4+5=12（用公式计算：5+3-1+5=12）
...（完整计算后）
prefix = [
 [0,0,0,0],
 [0,1,3,6],
 [0,5,12,21],
 [0,12,27,45]
]
```

计算子矩阵 `(1,1) 到 (2,2)`（即元素5,6,8,9）的和：  
`sum = prefix[3][3] - prefix[1][3] - prefix[3][1] + prefix[1][1] = 45 - 6 - 12 + 1 = 28`（正确，5+6+8+9=28）

代码实现：

```python
def build_2d_prefix(matrix):
    m, n = len(matrix), len(matrix[0])
    prefix = [[0]*(n+1) for _ in range(m+1)]
    for i in range(1, m+1):
        for j in range(1, n+1):
            prefix[i][j] = matrix[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]
    return prefix

# 测试
matrix = [[1,2,3],[4,5,6],[7,8,9]]
prefix = build_2d_prefix(matrix)
print("sum(1,1 to 2,2) =", prefix[3][3] - prefix[1][3] - prefix[3][1] + prefix[1][1])  # 28
```

## 三、应用场景

1. **高频区间和查询**：如“多次查询数组中某段的和”（LeetCode 303. 区域和检索 - 数组不可变）。  
2. **子数组/子矩阵问题**：如“统计和为k的子数组数量”（结合哈希表优化）、“最大子矩阵和”等。  
3. **前缀和变种**：如“前缀异或”（用于快速计算区间异或和）、“前缀积”（需处理0的情况）等。  

## 四、优缺点

- **优点**：预处理O(n)或O(mn)，查询O(1)，极大提升多次查询的效率。  
- **缺点**：仅适用于**静态数据**（数组/矩阵内容不变），若有频繁更新操作，需用线段树、树状数组等数据结构。

前缀和是算法入门的核心技巧之一，掌握后能显著简化区间求和类问题的复杂度。

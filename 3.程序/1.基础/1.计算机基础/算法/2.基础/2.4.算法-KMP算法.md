# KMP算法

KMP算法，全称Knuth-Morris-Pratt算法，是一种用于字符串匹配的算法。该算法由D.E.Knuth、J.H.Morris和V.R.Pratt提出，因此也称为克努特-莫里斯-普拉特操作。

[视频讲解](https://www.bilibili.com/video/BV1jb411V78H/?spm_id_from=333.337.search-card.all.click&vd_source=3509947f569e04aa5c144447e22d0ceb)

以下是对KMP算法的详细介绍：

## 一、算法原理

KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。在匹配过程中，KMP算法通过预处理模式串，构建一个部分匹配表（也称为失配函数或next数组），该表包含了模式串的局部匹配信息。在匹配失败时，KMP算法根据部分匹配表直接跳转到下一个可能的匹配位置，而不是像暴力匹配算法那样回溯主串的指针。

## 二、部分匹配表（next数组）

部分匹配表是KMP算法的关键所在。它记录了模式串中每个位置之前的子串的最长相同前缀和后缀的长度。在匹配过程中，当模式串的某个字符与主串的字符不匹配时，可以根据部分匹配表直接跳转到模式串的下一个可能匹配位置。

部分匹配表的计算方法是：

1. 初始化一个与模式串长度相等的数组next，并将next[0]设为-1（或0，根据具体实现而定）。
2. 使用两个指针i和j，其中i指向模式串的当前位置，j指向模式串的前缀位置。
3. 遍历模式串，对于每个位置i，如果j为-1或模式串[i]等于模式串[j]，则将next[i+1]设为j+1，并同时移动i和j。
4. 如果模式串[i]不等于模式串[j]，则将j回退到next[j-1]的位置，并继续比较。

## 三、算法步骤

1. 输入主串T和模式串P。
2. 预处理模式串P，计算部分匹配表next。
3. 初始化两个指针i和j，分别指向主串T和模式串P的当前位置。
4. 遍历主串T，对于每个位置i：
   * 如果j为-1（或0，根据next数组的初始化而定）或T[i]等于P[j]，则移动指针i和j，继续匹配下一个字符。
   * 如果T[i]不等于P[j]，则根据部分匹配表将j回退到next[j-1]的位置，并从当前位置i开始重新比较。
5. 如果j等于模式串P的长度，则说明匹配成功，返回匹配位置i-j+1（或i-j，根据具体实现而定）。
6. 如果遍历完主串T仍未找到匹配，则返回-1。

## 四、算法优点

1. 时间复杂度低：KMP算法的时间复杂度为O(m+n)，其中m和n分别是主串和模式串的长度。相比暴力匹配算法的O(m*n)时间复杂度，KMP算法具有更高的效率。
2. 易于实现和理解：KMP算法虽然涉及部分匹配表的计算，但整体思路相对清晰，易于实现和理解。

## 五、应用场景

KMP算法广泛应用于各种需要快速、高效字符串匹配的场景中，如字符串搜索、字符串编辑、自动补全、基因序列匹配以及代码编辑器中的代码提示功能等。

综上所述，KMP算法是一种高效、易实现的字符串匹配算法，通过预处理模式串并构建部分匹配表，可以在匹配过程中减少不必要的比较次数，提高匹配效率。

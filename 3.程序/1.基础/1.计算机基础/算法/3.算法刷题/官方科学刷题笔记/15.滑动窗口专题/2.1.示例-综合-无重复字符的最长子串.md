# 3. 无重复字符的最长子串(中等)

```txt
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
 

提示：

0 <= s.length <= 5 * 104
s 由英文字母、数字、符号和空格组成
```

## 解

根据定长滑动窗口和不定长滑动窗口的简介说明，可以知道解法：设定左边界和右边界，设定一个无重复哈希即Set（js里是map），当不重复时一直增加右边界，当重复时，左边界向右移动，并删除记录的左边界所在位置。如此得出最长值，即为题解。
>为啥是两种滑动窗口的结合呢？细想可知，每次【当重复时，左边界向右移动，并删除记录的左边界所在位置】其实就是长度固定的窗口。每次【当不重复时一直增加右边界】其实就是不断改变长度的窗口

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
    let maxLength = 0; // 寻找无重复字符串的最长值
    let left = 0;

    let map = new Map()

    for(let right = 0; right < s.length;right++ ){
        if(map.has(s.charAt(right))){
            //有重复的字符了，将左节点右移到原有重复字符节点位置的下一位  map.get(right) 是right
            left =Math.max(map.get(s.charAt(right))+1,left); // 因为节点位置可能小于当前left位置,取最大值
        }

        map.set(s.charAt(right),right);
        maxLength = Math.max(maxLength,right-left+1);
    }
    return maxLength;
};
```

---

大佬给的模版公式：

```java
//外层循环扩展右边界，内层循环扩展左边界
for (int l = 0, r = 0 ; r < n ; r++) {
 //当前考虑的元素
 while (l <= r && check()) {//区间[left,right]不符合题意
        //扩展左边界
    }
    //区间[left,right]符合题意，统计相关信息
}
```

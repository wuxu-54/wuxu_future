# 简介-理解动态规划

[一文学会动态规划解题技巧](https://leetcode.cn/circle/discuss/lxC3ZB/)

上面是力扣推荐学习动态规划的文章，直接看其内容学习。

## 动态规划的定义与特点

动态规划是一种用于解决优化问题的算法策略，其核心原理是将一个复杂的问题分解为一系列相互关联的子问题，通过求解这些子问题并利用子问题的解来构建原问题的解，以避免对相同子问题的重复计算，从而提高计算效率。

## 总结文章内容

### 1. 什么是动态规划

动态规划是将问题不断分解为子问题，自底向上求最优解的算法。
>后文AI给的答复中，也有自顶向下的算法。也就是这个地方AI给出的动态规划的定义其实与上面文章有差异。我个人理解：只要符合上面的动态规划的定义与特点的算法，都属于动态规划。所以总结来说，AI说的算法是全面的，而文章阐述的只是其中的一个算法。

动态规划的三要素：

1. 最优子结构
2. 状态转移方程
3. 重叠子问题

### 2. 如何判断需要动态规划

1. 判断是否可用递归来解，可以的话进入步骤 2
2. 分析在递归的过程中是否存在大量的重复子问题
3. 采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）
4. 改用自底向上的方式来递推，即动态规划

### 3. 用递归解题的基本套路（四步曲）

1. 先定义一个函数，明确这个函数的功能，由于递归的特点是问题和子问题都会调用函数自身，所以这个函数的功能一旦确定了， 之后只要找寻问题与子问题的递归关系即可
2. 接下来寻找问题与子问题间的关系（即递推公式），这样由于问题与子问题具有相同解决思路，只要子问题调用步骤 1 定义好的函数，问题即可解决。所谓的关系最好能用一个公式表示出来，比如 `f(n) = n * f(n-)` 这样，如果暂时无法得出明确的公式，用伪代码表示也是可以的, 发现递推关系后，要寻找最终不可再分解的子问题的解，即（临界条件），确保子问题不会无限分解下去。由于第一步我们已经定义了这个函数的功能，所以当问题拆分成子问题时，子问题可以调用步骤 1 定义的函数，符合递归的条件（函数里调用自身）
3. 将第二步的递推公式用代码表示出来补充到步骤 1 定义的函数中
4. 最后也是很关键的一步，根据问题与子问题的关系，推导出时间复杂度,如果发现递归时间复杂度不可接受，则需转换思路对其进行改造，看下是否有更靠谱的解法

---

## AI解释

动态规划（Dynamic Programming，DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学等领域中用来求解决策过程最优化问题的方法。动态规划算法通过把原问题分解为相对简单的子问题的方式求解复杂问题。以下是动态规划解题的一般步骤：

1. **定义状态**：
   - 确定状态变量，通常是`dp[i]`，表示到第`i`个位置（或时间点、或其他）的状态。
   - 状态变量通常与问题中的决策点有关。

2. **确定状态转移方程**：
   - 状态转移方程描述了状态之间的关系，即`dp[i]`如何由前一个或多个状态计算得出。
   - 这是动态规划最核心的部分，需要根据问题的具体逻辑来推导。

3. **确定初始状态**：
   - 确定`dp[0]`或`dp[i]`在初始条件下的值，这通常是边界条件。

4. **确定边界条件**：
   - 边界条件是状态转移的基础，通常对应于子问题的最小规模。

5. **计算顺序**：
   - 确定计算状态的顺序，这通常依赖于状态转移方程。在某些情况下，可以自底向上计算，也可以自顶向下计算。

6. **实现算法**：
   - 根据上述步骤实现算法。通常有两种方法：
     - 自顶向下（Top-Down）：使用递归，通常需要记忆化（Memoization）来避免重复计算。
     - 自底向上（Bottom-Up）：使用迭代，从最小的子问题开始，逐步构建解决方案。

7. **优化**：
   - 在实现算法后，检查是否可以优化空间复杂度，例如通过滚动数组（滚动优化）来减少空间使用。

8. **测试**：
   - 对算法进行测试，确保它可以正确解决所有边界情况和特殊情况。

9. **分析复杂度**：
   - 分析算法的时间复杂度和空间复杂度。

## 示例：斐波那契数列

**问题**：计算斐波那契数列的第`n`项。

1. **定义状态**：`dp[i]`表示第`i`项的斐波那契数。
2. **状态转移方程**：`dp[i] = dp[i-1] + dp[i-2]`。
3. **初始状态**：`dp[0] = 0`，`dp[1] = 1`。
4. **边界条件**：`n = 0`时，答案为`0`；`n = 1`时，答案为`1`。
5. **计算顺序**：从小到大计算`dp[i]`。
6. **实现算法**：

   ```python
   def fib(n):
       if n <= 1:
           return n
       dp = [0] * (n + 1)
       dp[1] = 1
       for i in range(2, n + 1):
           dp[i] = dp[i - 1] + dp[i - 2]
       return dp[n]
   ```

7. **优化**：可以使用滚动数组减少空间复杂度。
8. **测试**：确保算法可以正确计算出不同`n`值的斐波那契数。
9. **分析复杂度**：时间复杂度为`O(n)`，空间复杂度为`O(n)`，可以优化到`O(1)`。

动态规划的关键在于正确地定义状态和推导出状态转移方程，这通常需要对问题有深入的理解。

---

## 自顶向下和自底向上的动态规划方法有什么区别？

自顶向下（Top - Down）和自底向上（Bottom - Up）是动态规划中两种不同的实现方式，它们在问题求解思路、代码实现形式、空间利用和适用场景等方面存在明显区别：

### 1. 问题求解思路

- **自顶向下**
  - 从原问题出发，将其分解为规模更小的子问题。如果子问题已经解决过，直接使用之前记录的结果；如果未解决，则递归求解该子问题。这种方式是一种“递归 + 记忆化”的策略，有点类似于深度优先搜索，不断深入地将问题细化，直到遇到最基础的子问题。
  - 例如，在计算斐波那契数列第 `n` 项 `F(n)` 时，会先考虑 `F(n) = F(n - 1) + F(n - 2)`，然后递归求解 `F(n - 1)` 和 `F(n - 2)`，依次类推，直到遇到最基础的 `F(0)` 和 `F(1)`。
- **自底向上**
  - 从最基础的子问题开始，逐步求解规模更大的子问题，直到得到原问题的解。它是一种顺序求解的方式，先解决那些最简单、最容易求解的子问题，然后利用这些子问题的解来构建更复杂问题的解。
  - 同样对于斐波那契数列，会先计算 `F(0)` 和 `F(1)`，然后根据这两个基础结果计算 `F(2)`，再根据 `F(1)` 和 `F(2)` 计算 `F(3)`，依此类推，直到计算出 `F(n)`。

### 2. 代码实现形式

- **自顶向下**
  - 通常使用递归函数来实现，并且会结合一个数据结构（如数组、哈希表等）来进行记忆化，避免重复计算。以下是使用 Python 实现的自顶向下计算斐波那契数列的代码示例：

```python
def fibonacci_top_down(n, memo={}):
    if n in memo:
        return memo[n]
    if n == 0 or n == 1:
        result = n
    else:
        result = fibonacci_top_down(n - 1, memo) + fibonacci_top_down(n - 2, memo)
    memo[n] = result
    return result
```

- **自底向上**
  - 一般使用迭代的方式实现，通过循环依次计算子问题的解。以下是使用 Python 实现的自底向上计算斐波那契数列的代码示例：

```python
def fibonacci_bottom_up(n):
    if n == 0 or n == 1:
        return n
    dp = [0] * (n + 1)
    dp[0] = 0
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```

### 3. 空间利用

- **自顶向下**
  - 由于使用递归，会有额外的栈空间开销，栈的深度取决于递归的层数。在最坏情况下，递归深度可能达到问题规模 `n`，因此栈空间复杂度为 $O(n)$。此外，还需要额外的空间来进行记忆化，空间复杂度通常也是 $O(n)$。
- **自底向上**
  - 通常需要一个数组或表格来存储子问题的解，空间复杂度为 $O(n)$。不过，在一些情况下，可以对空间进行优化，只保留必要的子问题解，将空间复杂度降低到 $O(1)$。例如在斐波那契数列的计算中，只需要保留前两个数，就可以计算出后续的数。

### 4. 适用场景

- **自顶向下**
  - 当问题的递归结构比较明显，并且不需要求解所有子问题时，自顶向下的方法更合适。因为它只在需要时才计算子问题的解，避免了不必要的计算。例如，在某些树形结构的动态规划问题中，可能只需要求解部分路径上的子问题。
- **自底向上**
  - 当需要求解所有子问题，或者问题的规模较小且可以方便地确定计算顺序时，自底向上的方法更具优势。它的迭代方式避免了递归带来的栈空间开销，并且代码结构相对简单，更易于理解和优化。例如，在背包问题中，通常使用自底向上的方法来填充整个表格，以得到最优解。

# 背包问题

背包问题，就是给定一个背包，背包容量为n，背包内可以装的物体有m种，每种物体的重量为w，价值为v，求背包内装的最大价值。
>先看[1.1简介-理解动态规划](./1.1.%E7%AE%80%E4%BB%8B-%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md)，你会明白什么是动态规划以及是怎么去判断哪类问题可以采用动态规划进行解决，不过动态规划难点在于状态转移公式的确定，因此我们需要根据问题的类型，进行进一步的拆解分析，以此快速确定状态转移公式。背包问题是学习动态规划的基础练习题，我们要进一步去学习背包问题，这样可以快速理解这类问题的dp公式的创建思路。

- [一篇文章吃透背包问题！（细致引入+解题模板+例题分析+代码呈现） by 星晴pro](https://leetcode.cn/problems/last-stone-weight-ii/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-5lfv/)
- [分享｜深度讲解背包问题：面试中每五道动态规划就有一道是背包模型 ... by 宫水三叶](https://leetcode.cn/circle/discuss/GWpXCM/)

[TOC]

## 分类

【星晴pro】文章中的描述，背包问题可分类为以下几种：

1. 0/1背包问题：每个元素最多选取一次
2. 完全背包问题：每个元素可以重复选择
3. 组合背包问题：背包中的物品要考虑顺序
4. 分组背包问题：不止一个背包，需要遍历每个背包

而每个背包问题要求的也是不同的，按照所求问题分类，又可以分为以下几种：

1. 最值问题：要求最大值/最小值
2. 存在问题：是否存在…………，满足…………
3. 组合问题：求所有满足……的排列组合

因此把背包类型和问题类型结合起来就会出现以下细分的题目类型：

1. 0/1背包最值问题
2. 0/1背包存在问题
3. 0/1背包组合问题
4. 完全背包最值问题
5. 完全背包存在问题
6. 完全背包组合问题
7. 分组背包最值问题
8. 分组背包存在问题
9. 分组背包组合问题

这九类问题作者认为几乎可以涵盖力扣上所有的背包问题

### 背包问题解题模板

首先先了解一下原始背包问题的解题思路和代码：
>没有接触过背包问题的新手，直接看下面的代码可能一头雾水。可以先看后面目录[0/1 背包问题](#01-背包问题)，了解什么是背包问题后再看下面的两处代码就很容易理解其意思！

最开始的背包问题是二维动态规划

```cpp
// 0-1背包问题母代码(二维)
void bags()
{
    vector<int> weight = {1, 3, 4};   //各个物品的重量
    vector<int> value = {15, 20, 30}; //对应的价值
    int bagWeight = 4;                //背包最大能放下多少重的物品

    // 二维数组：状态定义:dp[i][j]表示从0-i个物品中选择不超过j重量的物品的最大价值
    vector<vector<int>> dp(weight.size() + 1, vector<int>(bagWeight + 1, 0));

    // 初始化:第一列都是0，第一行表示只选取0号物品最大价值
    for (int j = bagWeight; j >= weight[0]; j--)
        dp[0][j] = dp[0][j - weight[0]] + value[0];

    // weight数组的大小 就是物品个数
    for (int i = 1; i < weight.size(); i++) // 遍历物品(第0个物品已经初始化)
    {
        for (int j = 0; j <= bagWeight; j++) // 遍历背包容量
        {
            if (j < weight[i])           //背包容量已经不足以拿第i个物品了
                dp[i][j] = dp[i - 1][j]; //最大价值就是拿第i-1个物品的最大价值
            //背包容量足够拿第i个物品,可拿可不拿：拿了最大价值是前i-1个物品扣除第i个物品的 重量的最大价值加上i个物品的价值
            //不拿就是前i-1个物品的最大价值,两者进行比较取较大的
            else
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    cout << dp[weight.size() - 1][bagWeight] << endl;
}
```

二维代码可以进行优化，去除选取物品的那一层，简化为一维背包

```cpp
// 一维
//状态定义：dp[j]表示容量为j的背包能放下东西的最大价值

void test_1_wei_bag_problem()
{
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for (int i = 0; i < weight.size(); i++)
    { // 遍历物品
        for (int j = bagWeight; j >= weight[i]; j--)
        {                                                     // 遍历背包容量(一定要逆序)
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); //不取或者取第i个
        }
    }
    cout << dp[bagWeight] << endl;
}
```

但是这样的代码用来解题显然还是让人一头雾水的，下面给出的解题模板可以很好地将解决这个问题

#### 分类解题模版

背包问题大体的解题模板是两层循环，分别遍历物品nums和背包容量target，然后写转移方程，
根据背包的分类我们确定物品和容量遍历的先后顺序，根据问题的分类我们确定状态转移方程的写法

首先是背包分类的模板：

1. 0/1背包：外循环nums,内循环target,target倒序且target>=nums[i];
2. 完全背包：外循环nums,内循环target,target正序且target>=nums[i];
3. 组合背包：外循环target,内循环nums,target正序且target>=nums[i];
4. 分组背包：这个比较特殊，需要三重循环：外循环背包bags,内部两层循环根据题目的要求转化为1,2,3三种背包类型的模板

然后是问题分类的模板：

1. 最值问题: `dp[i] = max/min(dp[i], dp[i-nums]+1)或dp[i] = max/min(dp[i], dp[i-num]+nums);`
2. 存在问题(bool)：`dp[i]=dp[i]||dp[i-num];`
3. 组合问题：`dp[i]+=dp[i-num];`

这样遇到问题将两个模板往上一套大部分问题就可以迎刃而解

---

## 0/1 背包问题

0-1 背包问题 ：有 N 件物品和一个容量为 C 的背包。第 i 件物品的费用是 v[i]，价值是 w[i]。

求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

0-1 背包问题是众多背包问题中最简单的，其特点是物品不能重复放入。

定义状态：即 `f[i][C]` 表示前 i 件物品放入一个容量为 C 的背包可以获得的最大价值。

状态转移方程为：

`f[i][C] = max(f[i - 1][C], w[i] + f[i - 1][C - v[i])`

即对于第 i 件物品，我们有两种决策方案：

1. 不选择第 i 件物品，则最大价值等于 `f[i - 1][C]` ，全部容量留给前 `i - 1` 件物品
2. 选择第 i 件物品，则最大价值等于 `w[i] + f[i - 1][C - v[i]]` ，其中 `w[i]` 代表当前物品的价值，这样就用掉了 `v[i]` 的体积，留给前 `i - 1` 件物品的容量就剩下 `C - v[i]`，所以总的价值等于 `w[i] + f[i - 1][C - v[i]]`

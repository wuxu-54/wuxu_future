# 连续的子数和

<https://leetcode.cn/problems/continuous-subarray-sum/description/>

## 题目

```txt
给你一个整数数组 nums 和一个整数 k ，如果 nums 有一个 好的子数组 返回 true ，否则返回 false：

一个 好的子数组 是：

长度 至少为 2 ，且
子数组元素总和为 k 的倍数。
注意：

子数组 是数组中 连续 的部分。
如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终 视为 k 的一个倍数。
```

## 题解

摘录自评论大神：

根据官方题解整理了一波思路：(java版本)

【同余定理】 【哈希表】【简化前缀和】

同余定理：如果两个整数m、n满足n-m能被k整除，那么n和m对k同余

即 ( pre(j) - pre (i) ) % k == 0 则 pre(j) % k == pre(i) % k

推导 => pre (i) % k = (a0 + a1 + ... + ai) % k = (a0 % k + a1 % k + ... ai % k ) % k
（该推导在简化前缀和的时候有用，说明当前前缀和 % k 不会影响后面的前缀和 % k ）

哈希表 存储
Key ：pre(i) % k
Value： i

遍历过程：

计算前缀和 pre( j ) % k

当pre(j) % k 在哈希表中已存在，则说明此时存在 i 满足 pre(j) % k == pre(i) % k ( i < j )

HashMap里，已知Key，可以取到Value 即i的值， 最后 判断 j - i >= 2 是否成立 即可

当 pre(j) % k 不存在于哈希表，则将 (pre(j) % k, j ) 存入哈希表
因在计算 pre(i) = (pre(i-1) + nums[i]) % k 时，pre(i) 只与上一个状态有关

故可以直接用变量pre 替代数组。 那么 求前缀和 % k 的公式就简化为 题解代码中的 remainder = (remainder + nums[i]) % k;

```cpp
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> map;
        int pre = 0;
        if(nums.size()<2){
            return false;
        }
        map[0]=-1;
        for(int i = 0;i<nums.size();i++){
            pre = (pre+nums[i])%k;
            //同余定理 ： n-m 能被k整除，那么n%k = m%k
            //前缀和
            //m-n 如果 >= 2  符合题意
            //这道题核心是存放的key为   前缀和 % k，因为同余定理，只要保证找到的索引与新索引大于2 那么认为有超过2个的数组。
            if(map.find(pre)!=map.end()){
                if(i-map[pre]>=2){
                    return true;
                }
            }else{
                map[pre] = i;
            }
        
        }
        return false;
    }
};
```

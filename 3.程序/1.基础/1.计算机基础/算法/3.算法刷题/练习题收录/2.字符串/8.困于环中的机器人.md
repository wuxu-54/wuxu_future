# 困于环中的机器人(中等)

[传送门](https://leetcode.cn/problems/robot-bounded-in-circle/?envType=study-plan-v2&envId=programming-skills)

```txt
在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。注意:

北方向 是y轴的正方向。
南方向 是y轴的负方向。
东方向 是x轴的正方向。
西方向 是x轴的负方向。
机器人可以接受下列三条指令之一：

"G"：直走 1 个单位
"L"：左转 90 度
"R"：右转 90 度
机器人按顺序执行指令 instructions，并一直重复它们。

只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。

 

示例 1：

输入：instructions = "GGLLGG"
输出：true
解释：机器人最初在(0,0)处，面向北方。
“G”:移动一步。位置:(0,1)方向:北。
“G”:移动一步。位置:(0,2).方向:北。
“L”:逆时针旋转90度。位置:(0,2).方向:西。
“L”:逆时针旋转90度。位置:(0,2)方向:南。
“G”:移动一步。位置:(0,1)方向:南。
“G”:移动一步。位置:(0,0)方向:南。
重复指令，机器人进入循环:(0,0)——>(0,1)——>(0,2)——>(0,1)——>(0,0)。
在此基础上，我们返回true。
示例 2：

输入：instructions = "GG"
输出：false
解释：机器人最初在(0,0)处，面向北方。
“G”:移动一步。位置:(0,1)方向:北。
“G”:移动一步。位置:(0,2).方向:北。
重复这些指示，继续朝北前进，不会进入循环。
在此基础上，返回false。
示例 3：

输入：instructions = "GL"
输出：true
解释：机器人最初在(0,0)处，面向北方。
“G”:移动一步。位置:(0,1)方向:北。
“L”:逆时针旋转90度。位置:(0,1).方向:西。
“G”:移动一步。位置:(- 1,1)方向:西。
“L”:逆时针旋转90度。位置:(- 1,1)方向:南。
“G”:移动一步。位置:(- 1,0)方向:南。
“L”:逆时针旋转90度。位置:(- 1,0)方向:东方。
“G”:移动一步。位置:(0,0)方向:东方。
“L”:逆时针旋转90度。位置:(0,0)方向:北。
重复指令，机器人进入循环:(0,0)——>(0,1)——>(- 1,1)——>(- 1,0)——>(0,0)。
在此基础上，我们返回true。
 

提示：

1 <= instructions.length <= 100
instructions[i] 仅包含 'G', 'L', 'R'

    北
    |
西 -  -东
    |
    南
```

解：这个问题需要想明白怎么会陷入无限循环(也就是在一定界限内走动)即可获取到答案，在执行一遍指令时，只会分为以下几种情况：

1. **回到原点**：无所谓方向，此时是陷入无限循环的，无法走出去。
2. **非原点**，假定坐标为（x，y）有以下几种情况：
    - 面朝北，那么下一次循环，坐标百分百是`（2 * x，2 * y）`，那么是不会陷入循环，可以走出去。
    - 面朝东（西方向同理），此时等同于方向旋转90度，由于无限循环中每次的距离固定，那么以后会在一定边界内活动（想象成画圆），无法走出去。
    - 面朝南，第二次循环就变成了反向，距离不变，回到了原点，那么无限循环仍是在边界内活动，无法走出去。

由此可知，会陷入循环的情况是上述【情况1】或【情况2且不朝北】，假设执行一遍，用条件语句表示为：（x，y） == （0,0） && 方向不朝北

思路理清楚了，那么代码怎么处理呢？我这样想的：假设x，y表示坐标，direcIndex表示方向，执行一遍指令判断上面的条件语句即可。代码如下：

```cpp
class Solution {
public:
    bool isRobotBounded(string instructions) {
       vector<vector<int>> direc = {{0,1},{-1,0},{0,-1},{1,0}};//表示方向，北、东、南、西

       int x=0,y=0;
       int direcIndex = 0;// 方向

        for(char c : instructions){
            if(c=='G'){
                x+=direc[direcIndex][0];//x坐标增加
                y+=direc[direcIndex][1];//y坐标增加
            }else if(c=='L'){//等于 左转90度。 用代码表示为 index+=3，要取摩（例如方向在北，那么左转90度就是朝西了）
                direcIndex = (direcIndex+3) % 4; // 取模是保证index在方向数组内
            }else if(c=='R'){//等于 右转90度。用代码表示为 index+=1，要取摩（例如方向在北，那么右转90度就是朝东了）
                  direcIndex = (direcIndex+1) % 4; // 取模是保证index在方向数组内
            }
        }

        return x==0&&y==0 || direcIndex!=0;//走不出去的情况为：在坐标原点，或者 面不朝北
    }
};
```

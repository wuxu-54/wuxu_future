# 1.找出字符串中第一个匹配项的下标(简单)

[leetcode地址](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=programming-skills)

```txt
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。

示例 1：

输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
示例 2：

输入：haystack = "leetcode", needle = "leeto"
输出：-1
解释："leeto" 没有在 "leetcode" 中出现，所以返回 -1 。

提示：

1 <= haystack.length, needle.length <= 104
haystack 和 needle 仅由小写英文字符组成
```

解：

1. 暴力解法。没有含金量
2. [KMP算法](../../../3.%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/4.KMP%E7%AE%97%E6%B3%95.md)，KMP算法就是字符串匹配算法。

    gpt：

    ```cpp
    std::vector<int> KMP(const std::string &text, const std::string &pattern) {
    int n = text.size(), m = pattern.size();
    std::vector<int> next(m, 0);
    std::vector<int> matches;

    for (int i = 1; i < m; i++) {
        int j = next[i - 1];
        while (j > 0 && pattern[i] != pattern[j])
            j = next[j - 1];
        if (pattern[i] == pattern[j])
            j++;
        next[i] = j;
    }

    int i = 0, j = 0;
    while (i < n) {
        while (j > 0 && text[i] != pattern[j])
            j = next[j - 1];
        if (text[i] == pattern[j])
            j++;
        if (j == m) {
            matches.push_back(i - j + 1);
            j = next[m - 1];
        }
        i++;
    }
    return matches;
    }
    ```

    我的理解：

    ```cpp
    //KMP算法
    具体待补充
    ```

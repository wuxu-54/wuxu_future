# 总持续时间可被 60 整除的歌曲(中等)

[传送门](https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/description/)

```txt
在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字 i 和 j 满足  i < j 且有 (time[i] + time[j]) % 60 == 0。

示例 1：

输入：[30,20,150,100,40]
输出：3
解释：这三对的总持续时间可被 60 整数：
(time[0] = 30, time[2] = 150): 总持续时间 180
(time[1] = 20, time[3] = 100): 总持续时间 120
(time[1] = 20, time[4] = 40): 总持续时间 60
示例 2：

输入：[60,60,60]
输出：3
解释：所有三对的总持续时间都是 120，可以被 60 整数。
 

提示：

1 <= time.length <= 60000
1 <= time[i] <= 500
```

## 解

[作者：力扣官方题解](https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60/solutions/2258328/zong-chi-xu-shi-jian-ke-bei-60-zheng-chu-42cu/)

### (文心一言)

**解题思路**：

1. **问题转化**：

    * 首先，我们需要找到所有满足 `(time[i] + time[j]) % 60 == 0` 的歌曲对 `(i, j)`。
    * 这可以转化为找到所有满足 `(time[i] % 60 + time[j] % 60) % 60 == 0` 的歌曲对，因为对任意整数 a 和 b，有 `(a + b) % c == ((a % c) + (b % c)) % c`。

2. **余数分析**：

    * 假设 `mod1 = time[i] % 60` 和 `mod2 = time[j] % 60`。
    * 要使 `(mod1 + mod2) % 60 == 0`，有两种情况：
        1. `mod1 == mod2 == 0`：即两首歌曲的持续时间都是 60 的倍数。
        2. `mod1 + mod2 == 60` 或 `mod1 == 60 - mod2`：即两首歌曲的持续时间的余数相加为 60。

3. **哈希表（或数组）记录余数出现次数**：

    * 遍历歌曲列表，计算每首歌曲持续时间的余数，并使用哈希表（或长度为 60 的数组）记录每个余数出现的次数。
    * 对于当前歌曲的持续时间 `time[i]`，计算其余数 `mod = time[i] % 60`。
    * 如果 `mod == 0`，则检查哈希表中余数为 0 的次数（设为 `count`），并将 `count * (count - 1) / 2`（即从 `count` 个元素中选取两个的组合数）加到结果中，因为余数为 0 的歌曲可以与其他余数为 0 的歌曲组成满足条件的对。
    * 否则，检查哈希表中余数为 `60 - mod` 的次数，并将其加到结果中，因为余数为 `mod` 和 `60 - mod` 的歌曲可以组成满足条件的对。

4. **返回结果**：

    * 遍历完所有歌曲后，返回累计的结果作为总的歌曲对数量。

这种解题思路的时间复杂度为 O(n)，其中 n 是歌曲的数量，因为我们只需要遍历一次歌曲列表。空间复杂度为 O(1)（不考虑输入数组本身的空间），因为我们只需要一个固定大小为 60 的哈希表（或数组）来记录余数的出现次数。

---

## 代码实例

上述解释中 `count * (count - 1) / 2` 其实是数学中**等差数列求前n项和**公式，即：a1...an  = n/2(a1+an)。其中：a1=0，an=count-1，n=count。

```cpp
class Solution {
public:
    int numPairsDivisibleBy60(vector<int>& time) {
        /**
        对60取余，用60长度的数组存，有两种情况：
        1. ==0，即是60 的倍数，俩俩相加百分百符合要求。 这个就是等差数列求前项和。
        2. !=0，n+m = 60的情况，俩俩相加==60 也符合要求。
        */

        vector<int> arr(60,0);
        
        for(int i : time){
           arr[i % 60]++;
        }

        long long count = 0L;//不用long会溢出
        //情况1，等差数列求和，公式：a1+a2..+an = n/2 * (a1+an);  这里a1 = 0，an=个数-1
         count +=  (long long)(arr[0]-1) * (long long)arr[0]/2;//不用long会溢出
        
        //情况2，n+m=60,这里可以清晰看出，我们只需要遍历30次即可
        for(int i = 1;i<30;i++){
            count += arr[60-i] * arr[i];
        }
        count += (long long)arr[30]*(arr[30]-1)/2;// 模为30特殊，等同于等差数列计算

        return count;
    }
};
```

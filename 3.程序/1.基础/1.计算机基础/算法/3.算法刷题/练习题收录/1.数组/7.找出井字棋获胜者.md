# 找出井字棋的获胜者(简单)

[传送门](https://leetcode.cn/problems/find-winner-on-a-tic-tac-toe-game/description/?envType=study-plan-v2&envId=programming-skills)

```txt
井字棋 是由两个玩家 A 和 B 在 3 x 3 的棋盘上进行的游戏。井字棋游戏的规则如下：

1. 玩家轮流将棋子放在空方格 (' ') 上。
2. 第一个玩家 A 总是用 'X' 作为棋子，而第二个玩家 B 总是用 'O' 作为棋子。
3. 'X' 和 'O' 只能放在空方格中，而不能放在已经被占用的方格上。
4. 只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。
5. 如果所有方块都放满棋子（不为空），游戏也会结束。
6. 游戏结束后，棋子无法再进行任何移动。


给你一个数组 moves，其中 moves[i] = [rowi, coli] 表示第 i 次移动在 grid[rowi][coli]。如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 "Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"。

你可以假设 moves 都 有效（遵循 井字棋 规则），网格最初是空的，A 将先行动。

示例1：

输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
输出："A"
解释："A" 获胜，他总是先走。

示例2：

输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
输出："B"
解释："B" 获胜。

示例3：

输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
输出："Draw"
解释：由于没有办法再行动，游戏以平局结束。

提示：

1 <= moves.length <= 9
moves[i].length == 2
0 <= moves[i][j] <= 2
moves 里没有重复的元素。
moves 遵循井字棋的规则。
```

解：

1. 暴力枚举

    ```cpp
    class Solution {
    public:
        string tictactoe(vector<vector<int>>& moves) {
            int t[3][3];
            for(int i = 0;i<moves.size();i++){
                t[moves[i][0]][moves[i][1]]=i % 2==0?1:2;//将moves转换为 9 宫格数据，里面存对应值，1表示A，2表示B
            }

            if((t[0][0] == t[1][1] && t[1][1] == t[2][2] || t[0][2] == t[1][1] && t[1][1] == t[2][0]) && t[1][1] != 0){//这是两个斜线
                    return t[1][1]==1?"A":"B";
            }

            for(int i = 0;i<3;i++){//判断横、竖两个方向是否存在相等的情况
                if(t[0][i] == t[1][i] && t[1][i] == t[2][i] && t[0][i] != 0){
                    return t[0][i]==1?"A":"B";
                }

                if(t[i][0] == t[i][1] && t[i][1] == t[i][2] && t[i][0] != 0){
                    return t[i][0]==1?"A":"B";
                }
            }
            return (moves.size() == 9 ? "Draw" : "Pending");//以上均不符合时，通过判断moves的长度确定是否完成井字棋
        }
    };
    ```

2. 暴力枚举-官方解答(有点复杂了不推荐)

    我们可以模拟数组 move 中的每一步落子。我们使用两个集合 A 和 B 存放每位玩家当前已经落子的位置，并用集合 wins 存放棋子排成一条直线的所有情况（排成一行或一列各有 3 种，排成对角线有 2 种，总计 8 种）。当某位玩家落子时，我们枚举 wins 中的每一种情况，并判断该玩家是否将棋子落在了这些位置。如果满足了其中一种情况，则该玩家获胜。

    如果直到落子完毕仍然没有玩家获胜，那么根据数组 move 的长度返回平局 Draw 或游戏未结束 Pending。

    ```cpp
    class Solution {
    public:
        bool checkwin(unordered_set<int>& S, vector<vector<int>>& wins) {
            for (auto win: wins) {
                bool flag = true;
                for (auto pos: win) {//遍历，如果不存在，那么就不是落子位置
                    if (!S.count(pos)) {//unordered_set中的方法，如果存在pos返回1，不存在返回0
                        flag = false;
                        break;
                    }
                }
                if (flag) {
                    return true;
                }
            }
            return false;
        }

        string tictactoe(vector<vector<int>>& moves) {
            vector<vector<int>> wins = {
                {0, 1, 2},
                {3, 4, 5},
                {6, 7, 8},
                {0, 3, 6},
                {1, 4, 7},
                {2, 5, 8},
                {0, 4, 8},
                {2, 4, 6}
            };

            unordered_set<int> A, B;
            for (int i = 0; i < moves.size(); ++i) {
                int pos = moves[i][0] * 3 + moves[i][1];//将moves转换为9宫格 0-8 位置。
                if (i % 2 == 0) {
                    A.insert(pos);
                    if (checkwin(A, wins)) {
                        return "A";
                    }
                }
                else {
                    B.insert(pos);
                    if (checkwin(B, wins)) {
                        return "B";
                    }
                }
            }

            return (moves.size() == 9 ? "Draw" : "Pending");
        }
    };

    /**
    作者：力扣官方题解
    链接：https://leetcode.cn/problems/find-winner-on-a-tic-tac-toe-game/solutions/101698/zhao-chu-jing-zi-qi-de-huo-sheng-zhe-by-leetcode-s/
    来源：力扣（LeetCode）
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 
    */
    ```

# 单调数列（简单）

```txt
如果数组是单调递增或单调递减的，那么它是 单调 的。

如果对于所有 i <= j，nums[i] <= nums[j]，那么数组 nums 是单调递增的。 如果对于所有 i <= j，nums[i]> = nums[j]，那么数组 nums 是单调递减的。

当给定的数组 nums 是单调数组时返回 true，否则返回 false。

 

示例 1：

输入：nums = [1,2,2,3]
输出：true
示例 2：

输入：nums = [6,5,4,4]
输出：true
示例 3：

输入：nums = [1,3,2]
输出：false
 

提示：

1 <= nums.length <= 105
-105 <= nums[i] <= 105
```

解：

1. 暴力遍历一次。时间复杂度为O(n)。-最优解

    ```java
    class Solution {
        public boolean isMonotonic(int[] nums) {
            if(nums.length==1){
                return true;
            }
            int a = nums[nums.length-1] - nums[0];
            for(int i =0;i<nums.length-1;i++){
            if(a==0&&nums[i] != nums[i+1]){
                    return false;
            }else if(a<0&&nums[i+1]>nums[i]){
                    return false;
            }else if(a>0&&nums[i+1]<nums[i]){
                    return false;
            }
            }
            return true;
        }
    }
    ```

2. 遍历两次数组，分别判断其是否为单调递增或单调递减。时间复杂度为O(n*n) - 不好！

    ```java
    class Solution {
    public boolean isMonotonic(int[] nums) {
        return isSorted(nums, true) || isSorted(nums, false);
    }

    public boolean isSorted(int[] nums, boolean increasing) {
            int n = nums.length;
            if (increasing) {
                for (int i = 0; i < n - 1; ++i) {
                    if (nums[i] > nums[i + 1]) {
                        return false;
                    }
                }
            } else {
                for (int i = 0; i < n - 1; ++i) {
                    if (nums[i] < nums[i + 1]) {
                        return false;
                    }
                }
            }
            return true;
        }
    }

    //作者：力扣官方题解
    //链接：https://leetcode.cn/problems/monotonic-array/solutions/624659/dan-diao-shu-lie-by-leetcode-solution-ysex/
    //来源：力扣（LeetCode）
    //著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
    ```

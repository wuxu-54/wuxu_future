# 三角形的最大周长(简单)

```txt
给定由一些正数（代表长度）组成的数组 nums ，返回 由其中三个长度组成的、面积不为零的三角形的最大周长 。如果不能形成任何面积不为零的三角形，返回 0。

 
示例 1：

输入：nums = [2,1,2]
输出：5
解释：你可以用三个边长组成一个三角形:1 2 2。
示例 2：

输入：nums = [1,2,1,10]
输出：0
解释：
你不能用边长 1,1,2 来组成三角形。
不能用边长 1,1,10 来构成三角形。
不能用边长 1、2 和 10 来构成三角形。
因为我们不能用任何三条边长来构成一个非零面积的三角形，所以我们返回 0。
 

提示：

3 <= nums.length <= 104
1 <= nums[i] <= 106
```

记录原因：当时没有想明白排序后，为啥只需要比较 a[i-2] + a[i-1]>a[i]。

评论区解释：

```txt
为什么只需要判断 a + b > c ?

正常情况下，对于三条边长，判断能否组成三角形需要判断任何两条边长相加都大于其余的一条边长，即：

a + b > c && a + c > b && b + c > a
而如果已知 a<=b<=c，那么必然有：

a + c > b，因为 c >= b，那c加上一个正数一定就比b大了。而题目里说所数都>=1，所以c加上a一定比b大。
b + c > a，因为b和c至少跟a一样大(b>=a, c>=a)，加起来的结果至少有2a，即 b+c >= 2a > a
所以最终只需要判断 a + b > c 即可。

为什么只需要判断数组中相邻的三个数？

在固定最后一个数 A[i] 时，前两个数需不需要再往前找呢？

如果 A[i-2] + A[i-1] <= A[i] ，这三个数一定不能构成三角形，而A[i-3]以及更往前的数，都小于等于A[i-2]，所以再往前取任何两个数只会让相加的值更小，就更不能满足 A[j] + A[k] > A[i]了 (j<i-2, k<i-1, j<k)。所以如果相邻的数构不成三角形，就不需要再固定第三个数并往前找两个数了。

如果 A[i-2] + A[i-1] > A[i]j，这三个数可以构成三角形，再往前找只会让周长变短，所以也不用再往前了。

综上，只需要判断相邻的三个数。
```

答案：

```dart
class Solution {
  int largestPerimeter(List<int> nums) {
    //三角形：两边之长大于第三边
     nums.sort((a,b)=> b.compareTo(a));//先排倒序
    //三次循环会超出时间限制的
    for(int i1 = 0;i1<nums.length-2;i1++){
        if(nums[i1+2]+nums[i1+1] > nums[i1]){
            return nums[i1+1]+nums[i1+2] + nums[i1];
        } 
    }
    return 0;
  }
}
```

# 关键字

C++ 继承了 C 语言的大部分关键字，同时新增了大量面向对象、泛型编程等特性相关的关键字，部分关键字在 C 和 C++ 中的含义也存在差异。以下是 C++ 关键字的完整列表，并标注与 C 语言的主要区别：

## 一、C++ 新增的关键字（C 语言无这些关键字）

这些关键字是 C++ 为支持类、继承、多态、泛型等特性新增的，C 语言完全不支持。

| 关键字         | 说明                                                                 |
|----------------|----------------------------------------------------------------------|
| `class`        | 定义类（C++ 面向对象的核心，用于封装数据和方法）                     |
| `public`       | 类成员访问控制符（公开成员，类内外均可访问）                         |
| `private`      | 类成员访问控制符（私有成员，仅类内可访问）                           |
| `protected`    | 类成员访问控制符（保护成员，类内和派生类可访问）                     |
| `friend`       | 声明友元（允许其他类/函数访问当前类的私有成员）                       |
| `virtual`      | 声明虚函数（支持多态，派生类可重写）                                 |
| `override`     | C++11 新增，显式声明派生类函数重写基类虚函数（编译期检查）           |
| `final`        | C++11 新增，限制类不能被继承或函数不能被重写                         |
| `explicit`     | 用于构造函数，禁止隐式类型转换（仅允许显式转换）                     |
| `namespace`    | 定义命名空间（避免命名冲突）                                         |
| `using`        | 1. 引入命名空间成员；2. 定义类型别名（替代 `typedef` 的更灵活方式）  |
| `template`     | 定义模板（函数模板/类模板，支持泛型编程）                             |
| `typename`     | 1. 模板中声明类型参数；2. 指明依赖类型                               |
| `this`         | 指向当前对象的指针（类成员函数中使用）                               |
| `operator`     | 重载运算符（如 `operator+` 重载 `+` 号）                             |
| `new`          | 动态内存分配（相比 C 的 `malloc`，会调用构造函数）                   |
| `delete`       | 释放动态内存（相比 C 的 `free`，会调用析构函数）                     |
| `delete[]`     | 释放动态数组内存（匹配 `new[]`）                                     |
| `try`          | 异常处理的开始（搭配 `catch` 使用）                                 |
| `catch`        | 捕获异常（处理 `try` 块中抛出的异常）                               |
| `throw`        | 抛出异常                                                             |
| `typeid`       | 获取类型信息（返回 `type_info` 对象，用于运行时类型识别 RTTI）       |
| `dynamic_cast` | 运行时类型转换（主要用于多态类型的安全转换，失败返回 `nullptr`）     |
| `static_cast`  | 编译期类型转换（用于相关类型转换，如 `int`→`float`、基类与派生类指针）|
| `const_cast`   | 移除或添加 `const`/`volatile` 修饰符（仅改变常量性，不改变类型）     |
| `reinterpret_cast` | 底层二进制重新解释的转换（如指针与整数互转、不同类型指针互转）       |
| `nullptr`      | C++11 新增，空指针常量（替代 `NULL`，类型安全）                      |
| `decltype`     | C++11 新增，推导表达式的类型（用于泛型编程中获取类型）               |
| `auto`         | C++11 起重新定义：自动推导变量类型（不再是 C 中的“自动存储期”）      |
| `constexpr`    | C++11 新增，声明编译期常量或函数（可在编译时计算）                   |
| `consteval`    | C++20 新增，强制函数在编译期执行（编译期函数）                       |
| `constinit`    | C++20 新增，保证变量在编译期初始化（用于静态/线程存储期变量）        |
| `concept`      | C++20 新增，约束模板参数（泛型编程中的类型检查）                     |
| `requires`     | C++20 新增，用于 `concept` 定义或模板约束                          |
| `co_await`     | C++20 新增，暂停协程等待结果                                         |
| `co_return`    | C++20 新增，协程返回结果                                             |
| `co_yield`     | C++20 新增，协程产出中间结果                                         |
| `thread_local` | C++11 新增，线程局部存储期（变量在每个线程有独立副本）               |
| `mutable`      | 1. 允许 `const` 成员函数修改该成员；2. 打破 lambda 表达式的 `const` 捕获 |
| `volatile`     | （C 也有，但 C++ 中扩展：可用于类成员，且语义更严格）                |
| `wchar_t`      | 宽字符类型（C99 也引入，但 C++ 中作为内置类型，C 中需通过头文件定义）|
| `char16_t`     | C++11 新增，16 位字符类型（用于 UTF-16）                            |
| `char32_t`     | C++11 新增，32 位字符类型（用于 UTF-32）                            |
| `alignas`      | C++11 新增，指定变量/类型的对齐方式                                 |
| `alignof`      | C++11 新增，获取类型的对齐要求（类似 C 的 `_Alignof`，但更通用）     |
| `noexcept`     | C++11 新增，指定函数不抛出异常（优化编译，增强可读性）               |
| `static_assert`| C++11 新增，编译期断言（检查条件是否为真，失败则编译报错）           |

## 二、C 和 C++ 均有，但含义/用法不同的关键字

这些关键字在 C 和 C++ 中都存在，但语义或适用场景有差异。

| 关键字    | C 语言中的含义/用法                                  | C++ 中的含义/用法（差异点）                          |
|-----------|------------------------------------------------------|-----------------------------------------------------|
| `auto`    | 声明自动存储期变量（可省略，默认就是 auto）           | C++11 起：自动推导变量类型（不再表示存储期）          |
| `const`   | 声明只读变量（本质是“不能通过该变量修改”，仍可通过指针间接修改） | 真正的常量（编译期可用于数组长度、case 标签等；类中可作为成员常量） |
| `static`  | 1. 静态存储期；2. 文件作用域（仅当前文件可见）       | 继承 C 的功能，新增：类内静态成员（属于类而非对象）；静态成员函数（无 `this` 指针） |
| `struct`  | 仅用于定义数据结构（成员默认 public，无成员函数）     | 可定义类（支持成员函数、访问控制、继承等，与 `class` 仅默认访问控制不同） |
| `union`   | 联合体（仅数据成员，无成员函数，不能包含非 POD 类型） | 可包含成员函数、构造函数/析构函数；支持模板、继承（有限制） |
| `enum`    | 枚举（枚举值为全局作用域，可隐式转换为 int）          | 新增“限定作用域枚举” `enum class`（枚举值需用 `enum名::值` 访问，不可隐式转换为 int） |
| `inline`  | 建议编译器内联函数（C99 引入，较弱的建议）            | 更强的内联建议；可在头文件中定义函数（避免链接错误，C 中不允许） |
| `register`| 建议编译器将变量存储在寄存器（C11 仍支持，C++17 弃用） | C++17 起被弃用（无实际作用，编译器优化已替代）        |
| `sizeof`  | 计算类型/变量的大小（对数组名返回数组大小，对函数参数数组退化为指针） | 支持对类成员使用 `sizeof(Class::member)`（无需对象实例）；对引用返回被引用对象大小（C 中无引用） |
| `typedef` | 定义类型别名                                          | 功能相同，但 C++ 新增 `using` 作为更灵活的替代（支持模板别名） |

## 三、C 语言有，但 C++ 中被移除或语义受限的关键字

这些关键字在 C 中存在，但 C++ 中不支持或语义被严格限制。

| 关键字      | C 语言中的含义                          | C++ 中的情况（差异点）                          |
|-------------|-----------------------------------------|-------------------------------------------------|
| `_Bool`     | C99 新增，布尔类型（需 `#include <stdbool.h>`） | C++ 直接用 `bool` 作为内置类型（无需头文件），`_Bool` 被弃用（视为 `bool` 的别名） |
| `_Complex`  | C99 新增，复数类型（如 `double _Complex`） | C++ 用 `std::complex`（需 `#include <complex>`），不支持 `_Complex` 关键字 |
| `_Imaginary`| C99 新增，虚数类型                      | C++ 不支持该关键字（无对应功能）                 |
| `restrict`  | C99 新增，指针 restrict 限定（表明指针是唯一访问其指向对象的方式） | C++ 不支持 `restrict`，用 `__restrict__`（编译器扩展，非标准）或 `const` 替代 |
| `inline`    | （见上文“含义不同”部分，C++ 增强了内联的语义） | -                                               |

## 总结

C++ 关键字相比 C 语言的核心差异体现在：  

1. 新增大量面向对象（`class`、`virtual` 等）、泛型（`template`、`typename` 等）、异常处理（`try`、`catch` 等）相关关键字；  
2. 对部分 C 关键字（如 `auto`、`const`、`static`）扩展了语义，使其适应更复杂的编程场景；  
3. 移除了 C 中与 C++ 特性冲突或冗余的关键字（如 `_Complex`、`restrict`）。  

这些差异反映了 C++ 作为“带类的 C”到“多范式语言”的进化，也体现了其对类型安全、模块化和抽象能力的强化。

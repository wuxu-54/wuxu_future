# Equatable

在 Swift 中，`Equatable` 协议定义了一种名为 `==` 的操作符，用于比较两个实例是否相等。当你的自定义类型遵循 `Equatable` 协议时，你需要实现这个操作符，以确定何时两个实例应该被认为是相等的。

## 基本要求

要遵循 `Equatable` 协议，你的类型必须实现 `static func == (lhs: Self, rhs: Self) -> Bool` 方法。这个方法应该返回一个布尔值，指示两个实例是否在逻辑上相等。

## 示例

假设你有一个 `Person` 结构体，你想要比较两个 `Person` 实例是否相等：

```swift
struct Person: Equatable {
    var name: String
    var age: Int
}

func == (lhs: Person, rhs: Person) -> Bool {
    return lhs.name == rhs.name && lhs.age == rhs.age
}
```

在这个例子中，我们定义了一个 `Person` 结构体，并让它遵循 `Equatable` 协议。我们实现了 `==` 操作符，比较两个 `Person` 实例的 `name` 和 `age` 属性是否都相等。

## 自动合成实现

如果你的所有属性都是遵循 `Equatable` 协议的类型，Swift 可以为你自动合成 `==` 操作符的实现。这意味着你不需要手动实现它：

```swift
struct Person: Equatable {
    var name: String
    var age: Int
}

// 自动合成的 == 操作符会检查 name 和 age 是否都相等
```

## 使用 Equatable

一旦你的类型遵循了 `Equatable` 协议，你就可以在标准库中的许多算法和集合操作中使用它，例如在数组中搜索元素、比较集合是否相等、使用集合的 `filter` 方法等。

## 与 Hashable 协议的关系

`Equatable` 协议通常与 `Hashable` 协议一起使用。`Hashable` 协议要求类型提供一个 `hash(into:)` 方法，用于计算实例的哈希值。如果你的类型遵循了 `Equatable`，那么通常也应该遵循 `Hashable`，这样实例就可以被用作字典的键或添加到集合中。

## 示例：同时遵循 Equatable 和 Hashable

```swift
struct Person: Equatable, Hashable {
    var name: String
    var age: Int
}

// 自动合成的 == 操作符和 hash(into:) 方法
```

## 注意事项

- 当你重写 `==` 操作符时，确保它满足等价关系：自反性、对称性和传递性。
- 如果你的类型包含引用类型的属性，确保比较这些属性时使用正确的方法，比如使用 `===` 来比较类实例的引用等价性。
- 当你添加或删除属性时，记得更新 `==` 操作符的实现，以确保它正确地反映了类型的相等性。

`Equatable` 协议是 Swift 标准库中的基础协议之一，它为类型提供了一种定义和比较实例相等性的方法。

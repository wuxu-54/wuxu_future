# `Identifiable`和`Hashable`

在Swift中，`Identifiable`和`Hashable`是两个协议，它们在处理数据集合时非常有用。

## Identifiable

`Identifiable`是一个协议，它要求遵循它的类型提供一个唯一的标识符。这个协议通常用于SwiftUI中的列表和其他集合，以便可以唯一地识别每个元素。

```swift
protocol Identifiable {
    associatedtype ID
    var id: ID { get }
}
```

`Identifiable`协议有一个关联类型`ID`，它是用于标识元素的唯一标识符。当你创建一个遵循`Identifiable`的类型时，你需要指定`ID`的具体类型，并提供一个`id`属性。

## Hashable

`Hashable`是一个协议，它允许类型实例被用作字典的键或集合的元素。为了使类型成为`Hashable`，它必须能够生成一个唯一的哈希值，这通常通过实现`hash(into:)`方法来完成。

```swift
protocol Hashable {
    func hash(into hasher: inout Hasher)
}
```

`Hashable`协议要求遵循它的类型提供一个方法，该方法将实例的哈希值添加到提供的`Hasher`中。Swift标准库中的许多基本类型（如`Int`、`String`等）已经实现了`Hashable`。

## 使用场景

- **Identifiable**：
  - 用于SwiftUI中的列表和集合，以便可以唯一地识别和跟踪元素。
  - 用于数据模型，当你需要在更新数据时识别特定的元素时。

- **Hashable**：
  - 用于字典的键，因为字典的键必须是可哈希的。
  - 用于集合（如`Set`），集合中的元素必须是可哈希的。
  - 用于任何需要唯一标识符的场景，例如缓存、索引或其他需要快速查找的数据结构。

## 示例代码

```swift
struct User: Identifiable {
    let id: Int
    let name: String
}

var users = [User(id: 1, name: "Alice"), User(id: 2, name: "Bob")]

struct Point: Hashable {
    let x: Int
    let y: Int
}

var points = Set<Point>([Point(x: 1, y: 2), Point(x: 3, y: 4)])
```

在这个例子中，`User`结构体遵循了`Identifiable`协议，并且`Point`结构体遵循了`Hashable`协议。这样，`User`可以在SwiftUI列表中使用，而`Point`可以作为字典的键或集合的元素。

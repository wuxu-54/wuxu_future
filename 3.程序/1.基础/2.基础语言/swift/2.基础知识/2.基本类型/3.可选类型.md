# 可选类型

在Swift中，可选类型（Optional Type）是一种特殊的类型，它表示一个变量可以持有某个类型的值，或者根本没有值（即`nil`）。可选类型主要用于处理可能不存在的值，从而提高程序的安全性和健壮性。

以下是可选类型的一些关键概念和用法：

1. **声明可选类型**：
   - 可选类型通过在类型名称后面添加问号`?`来声明。例如，`String?`表示一个可选的字符串。

2. **初始化可选类型**：
   - 可选类型的变量在声明时如果没有初始化，它的默认值是`nil`。例如，`var optionalString: String?`默认值为`nil`。

3. **空值检查**：
   - 在使用可选类型的变量之前，需要检查它是否包含值。这可以通过`if let`或`guard let`语句来实现。

   ```swift
   var optionalString: String? = "Hello"
   if let unwrappedString = optionalString {
       print(unwrappedString) // "Hello"
   }
   ```

4. **可选链**：
   - 当你想要访问可选类型的属性或方法时，可以使用可选链（Optional Chaining）来安全地访问。如果可选值为`nil`，可选链将返回`nil`而不会引发运行时错误。

   ```swift
   class Person {
       var name: String?
   }
   let person: Person? = Person()
   print(person?.name) // 输出 nil
   ```

5. **提供默认值**：
   - 使用`??`运算符可以从可选类型中提供一个默认值。如果可选值为`nil`，则使用默认值；否则，返回可选值本身。

   ```swift
   let safeString = optionalString ?? "Default String"
   print(safeString) // 如果optionalString为nil，输出 "Default String"
   ```

6. **隐式解析可选（Implicitly Unwrapped Optional）**：
   - 有时，你知道某个可选类型在初始化后永远不会是`nil`，可以使用`!`来声明一个隐式解析可选。这允许你在访问时省略`!`，但必须确保它永远不会是`nil`。

   ```swift
   var implicitlyUnwrappedString: String! = "Hello"
   // 使用时不需要解包：print(implicitlyUnwrappedString)
   ```

7. **可选类型的数组**：
   - 数组中的元素可以是可选类型，表示某些元素可能没有值。

   ```swift
   var optionalStrings: [String?] = ["Hello", nil, "World"]
   ```

8. **可选类型的函数返回值**：
   - 函数可以返回可选类型，表示函数可能没有返回值。

   ```swift
   func findFirstCharacter(in string: String) -> Character? {
       return string.isEmpty ? nil : string.first
   }
   ```

9. **可选类型的布尔值**：
   - 布尔值也可以是可选的，例如`Bool?`，它可以是`true`、`false`或`nil`。

10. **协议中的可选类型**：
    - 协议可以要求实现可选类型的属性或方法。

11. **try?**：可选try，异常时忽略错误，会返回nil。

可选类型是Swift中处理可能缺失值的强大工具，它避免了空指针异常，并提高了代码的安全性和表达能力。

---

## 可选链

在Swift中，可选链（Optional Chaining）是一种安全快捷的方式来访问或修改可选类型的属性、方法或下标。可选链允许你检查可选类型是否有值，如果有值，就访问或修改它；如果没有值，就适当地处理`nil`。
> 其实就是可选类型的调用

### 可选链的关键特性

1. **安全访问**：
   使用可选链可以在不引起运行时错误的情况下访问可选类型的属性或调用方法。

2. **语法**：
   可选链通过在属性访问或方法调用后添加问号（`?`）来实现。

3. **自动解包**：
   可选链可以与解包（`if let` 或 `guard let`）结合使用，自动解包可选类型的值。

4. **链式调用**：
   如果可选链的第一个调用返回`nil`，则整个表达式的结果为`nil`，并且后续的调用将被忽略。

5. **可选方法**：
   使用可选链调用方法时，如果对象为`nil`，则方法不会被调用。

6. **可选属性**：
   使用可选链访问属性时，如果对象为`nil`，则属性访问将返回`nil`。

7. **可选下标**：
   使用可选链访问下标时，如果对象为`nil`，则下标访问将返回`nil`。

### 示例

```swift
class Person {
    var name: String?
}

let person: Person? = Person()
let name = person?.name // 使用可选链访问属性
print(name) // 输出 "nil"，因为 person 是可选类型，且 name 属性未初始化

// 使用可选链和自动解包
if let unwrappedName = person?.name {
    print("The person's name is \(unwrappedName).")
} else {
    print("The person does not have a name.")
}
```

### 可选链方法调用

```swift
class Person {
    func sayHello() {
        print("Hello!")
    }
}

let person: Person? = Person()
person?.sayHello() // "Hello!"，如果 person 不是 nil，将调用 sayHello 方法

// 使用可选链和自动解包
if let person = person {
    person.sayHello() // 安全地调用方法
}
```

### 可选链下标访问

```swift
let numbers: [String]? = ["One", "Two", "Three"]
let thirdNumber = numbers?[2] // "Three"，使用可选链访问下标
print(thirdNumber) // 输出 "Optional("Three")"
```

### 可选链与`nil`合并运算符

```swift
let name = person?.name ?? "No Name" // 如果 person?.name 是 nil，name 将是 "No Name"
```

### 可选链与柯里化

```swift
let multiplier = { (a: Int, b: Int) -> Int in a * b }
let result = (5 as Int?).unaryMultiply(using: multiplier) // 使用可选链和柯里化函数
print(result) // 输出 "nil"，因为 5 被包装在可选类型中
```

可选链是Swift中处理可选类型的强大工具，它提高了代码的安全性和表达能力，同时避免了繁琐的`if let`或`guard let`检查。通过使用可选链，开发者可以编写更简洁、更安全的代码来处理可能为`nil`的值。

---

## try?

在 Swift 中，`try?` 是错误处理的一种方式，称为“可选的 try”，它用于处理可能会抛出错误的操作。当你使用 `try?` 前缀调用一个可以抛出错误的函数时，如果函数执行成功，它会返回一个 `nil` 值；如果函数抛出错误，它也会返回 `nil`。这种方式通常用于不需要立即处理错误的场合，或者当错误可以被忽略时。

Swift 中的错误处理通常使用 `do-catch` 语句或 `try` 关键字，其中 `try` 用于调用可能抛出错误的函数，而 `do-catch` 用于捕获并处理这些错误。与之相对的 `try?` 则是一种更轻量级的错误处理方式。

以下是 `try?` 的使用示例：

```swift
func mightThrowError() throws -> Int {
    // 这个函数可能会抛出一个错误
    // 例如，它可以抛出一个自定义的错误类型
}

let result: Int? = try? mightThrowError()

// result 现在是 Int? 类型，即 Int 的可选类型
// 如果 mightThrowError() 成功执行，result 将包含返回的 Int 值
// 如果 mightThrowError() 抛出错误，result 将为 nil
```

在这个例子中，`mightThrowError()` 是一个可以抛出错误的函数。使用 `try?` 调用这个函数时，如果函数成功执行，`result` 将包含返回的 `Int` 值；如果函数抛出错误，`result` 将为 `nil`。

`try?` 常用于以下情况：

- 当你不想在调用点处理错误，而是希望将错误传播到调用栈的上层时。
- 当函数的调用者需要决定如何处理错误时。
- 当错误可以被视为“非致命”的，并且你希望继续执行后续代码时。

请注意，`try?` 会将错误转换为 `nil`，这意味着你失去了错误的详细信息。如果你需要处理错误并采取特定的行动，你应该使用 `do-catch` 语句或 `try` 关键字来捕获错误。

# 柯里化

柯里化（Currying）是一种将接受多个参数的函数转换成多个接受单个参数的函数，并返回这些函数的技术。这种技术允许你将函数的部分应用，即创建一个新函数，它将剩余的参数与其组合。

Swift并没有直接支持柯里化的语言特性，但你可以通过闭包和函数来手动实现柯里化。以下是如何在Swift中实现柯里化的示例：

## 示例1：基本柯里化

```swift
func add(_ a: Int) -> (Int) -> Int {
    return { b in a + b }
}

let addFive = add(5)
print(addFive(3)) // 输出 "8"，因为 addFive 是一个返回 5+b 的函数
```

在这个例子中，`add`函数接受一个整数`a`，并返回一个新的函数，这个新函数接受一个整数`b`，并返回`a + b`的结果。

## 示例2：多参数柯里化

```swift
func multiply(_ a: Int) -> (Int) -> Int {
    return { b in a * b }
}

let multiplyByThree = multiply(3)
print(multiplyByThree(4)) // 输出 "12"，因为 multiplyByThree 是一个返回 3*b 的函数
```

在这个例子中，`multiply`函数接受一个整数`a`，并返回一个新的函数，这个新函数接受一个整数`b`，并返回`a * b`的结果。

## 示例3：使用柯里化实现条件逻辑

```swift
func conditional<T>(_ condition: @escaping (T) -> Bool) -> ((T) -> T) -> T -> T {
    return { function in
        { value in condition(value) ? function(value) : value }
    }
}

let isPositive = conditional { $0 > 0 }
let squareIfPositive = isPositive { $0 * $0 }

print(squareIfPositive(10)) // 输出 "100"
print(squareIfPositive(-2)) // 输出 "-2"，因为没有平方化
```

在这个例子中，我们创建了一个`conditional`函数，它接受一个条件并返回一个新的函数，这个新函数接受一个变换函数，并返回一个应用条件的函数。

## 示例4：柯里化实现高阶函数

```swift
func map<T, U>(_ transform: @escaping (T) -> U) -> ([T]) -> [U] {
    return { array in array.map(transform) }
}

let square = map { $0 * $0 }
let numbers = [1, 2, 3, 4, 5]
let squaredNumbers = square(numbers) // [1, 4, 9, 16, 25]
```

在这个例子中，我们创建了一个`map`函数，它接受一个转换函数，并返回一个新的函数，这个新函数接受一个数组，并返回一个新的数组，其中每个元素都应用了转换函数。

柯里化在函数式编程中非常有用，它允许你创建更灵活、更可重用的函数。通过手动实现柯里化，你可以在Swift中利用这种强大的技术来编写更声明性和模块化的代码。

---

## `@escaping`

在 Swift 中，`@escaping` 属性用于标记一个闭包参数，表明这个闭包可能会在定义它的函数返回之后被调用。换句话说，如果一个闭包需要被持有，并且可能会在原始上下文之外被执行，那么它必须被标记为 `@escaping`。

闭包可以被捕获并存储在函数外部定义的变量中，或者作为另一个函数的参数传递，这种情况下，闭包被称为“逃逸闭包”（escaping closure）。如果闭包没有标记为 `@escaping` 但尝试在函数返回后执行它，Swift 编译器会报错。

以下是一些 `@escaping` 的使用示例：

1. **存储闭包以供稍后使用**：

   ```swift
   func performActionLater(_ action: @escaping () -> Void) {
       print("Action will be performed later.")
       action() // 闭包可能在 performActionLater 函数返回后执行
   }

   let myClosure: () -> Void = {
       print("Hello, World!")
   }
   performActionLater(myClosure)
   ```

2. **作为另一个函数的参数**：

   ```swift
   func processUserData(_ user: String, completion: @escaping (String) -> Void) {
       // 模拟异步操作
       DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
           completion("Processed \(user)")
       }
   }

   processUserData("Alice") { processedUser in
       print(processedUser) // 闭包在异步操作完成后执行
   }
   ```

3. **使用 `@escaping` 与 `self`**：

   ```swift
   class MyClass {
       func doSomethingWithEscapingClosure(_ closure: @escaping () -> Void) {
           // 闭包可能在 MyClass 实例被销毁后执行
           closure()
       }
   }
   ```

在上述示例中，`@escaping` 确保了闭包可以被存储并在稍后执行，即使它超出了原始函数的作用域。这在处理异步操作、定时器、API 回调等场景中非常常见。

请注意，使用 `@escaping` 时，闭包捕获的 `self` 将自动使用 `[weak self]` 来避免强引用循环，除非明确指定使用 `[unowned self]`。这是因为闭包可能会在原始实例被释放后执行，如果闭包强引用了 `self`，可能会导致内存泄漏。

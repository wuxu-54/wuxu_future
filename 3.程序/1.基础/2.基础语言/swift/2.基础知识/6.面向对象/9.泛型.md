# 泛型

在Swift中，泛型（Generics）是一种允许你定义类型安全的数据结构和函数的机制，而不需要在编译时指定具体的类型。泛型提供了一种方式来创建可以与多种类型一起工作的灵活和可重用的代码。

以下是Swift泛型的一些关键概念：

1. **定义泛型类型**：
   使用尖括号`<>`来定义泛型类型，其中可以包含一个或多个类型参数。

   ```swift
   struct Stack<Element> {
       var items = [Element]()
       func push(_ item: Element) {
           items.append(item)
       }
       func pop() -> Element? {
           return items.popLast()
       }
   }
   ```

2. **使用泛型类型**：
   创建泛型类型的实例时，可以指定具体的类型。

   ```swift
   var stringStack = Stack<String>() // 创建一个Stack实例，其元素类型为String
   stringStack.push("Hello")
   ```

3. **泛型函数**：
   泛型函数允许你定义可以操作任何类型的数据的函数。

   ```swift
   func printArray<T>(_ array: [T]) {
       for item in array {
           print(item)
       }
   }
   ```

4. **类型约束**：
   在泛型中，可以使用类型约束来限制类型参数必须是特定类型或遵循特定的协议。

   ```swift
   func findIndex<T: Equatable>(of value: T, in array: [T]) -> Int? {
       for (index, item) in array.enumerated() {
           if item == value {
               return index
           }
       }
       return nil
   }
   ```

5. **关联类型**：
   在协议中，可以使用关联类型来定义一个占位符，该占位符在协议被遵循时指定具体的类型。

   ```swift
   protocol Container {
       associatedtype Item
       func append(_ item: Item)
   }
   ```

6. **泛型和协议**：
   泛型类型可以遵循协议，并且可以在协议的上下文中使用泛型。

   ```swift
   protocol StackProtocol: class {
       func push(_ item: Element)
       func pop() -> Element?
   }
   ```

7. **泛型和继承**：
   泛型类型可以继承自另一个泛型或非泛型类型。

   ```swift
   class BasicStack<Element> {
       var items = [Element]()
   }

   class IntStack: BasicStack<Int> {
       // IntStack 继承自 BasicStack，并且其元素类型为 Int
   }
   ```

8. **泛型和性能**：
   泛型代码在编译时会被单态化（monomorphic），这意味着编译器会为每个具体的类型生成专门的代码，以确保性能。

9. **泛型和类型推断**：
   Swift的类型推断系统能够自动推断泛型参数的类型，使得代码更加简洁。

10. **泛型和扩展**：
    可以为泛型类型添加扩展，以添加新的功能或遵守新的协议。

---

## 泛型原理简单了解

Swift中的泛型原理基于类型参数化，允许开发者定义函数、类型、协议等，而不需要在编译时指定具体的类型。泛型提供了一种编写类型安全且可重用代码的方法。以下是Swift泛型的一些核心原理：

1. **类型参数化**：
   泛型通过类型参数（尖括号`<>`内的参数）定义，这些参数在编译时不必指定具体类型。

   ```swift
   struct Stack<Element> {
       var items: [Element]
   }
   ```

2. **类型擦除**：
   在Swift中，泛型类型使用类型擦除技术来实现。这意味着泛型类型在运行时并不保留其类型参数的具体类型信息，从而使得泛型代码更加高效。
   >c++、java等语言也有泛型及同样的类型擦除处理

3. **单态化**：
   Swift编译器在编译时会为每个具体的类型实例生成专门的代码。这个过程称为单态化，确保了运行时的性能。

4. **类型约束**：
   类型约束用于限制泛型参数必须是特定类型或遵循特定的协议。这有助于提供更多的类型安全保证。

   ```swift
   func findIndex<T: Equatable>(of value: T, in array: [T]) -> Int? {
       // ...
   }
   ```

5. **协议的泛型**：
   协议可以与泛型结合使用，定义一组必须实现的方法或属性，同时允许使用泛型类型作为协议的关联类型。

   ```swift
   protocol Container {
       associatedtype Item
       mutating func append(_ item: Item)
   }
   ```

6. **泛型下推**：
   Swift编译器能够根据上下文推断泛型参数的类型，这个过程称为泛型下推。

7. **条件编译**：
   泛型代码可以通过条件编译来支持不同的平台或操作系统版本，提供更好的兼容性。

8. **元组的泛型**：
   元组可以使用泛型来定义，允许将不同类型的值组合在一起。

9. **泛型数组**：
   Swift数组是泛型类型，可以存储任何类型的元素。

10. **泛型字典**：
    字典也是泛型类型，允许将键值对存储为指定的键类型和值类型。

11. **泛型集合类型**：
    集合类型如`Set`和`OrderedSet`也是泛型，只存储特定的元素类型。

12. **泛型算法**：
    标准库中的算法如`map`、`filter`、`reduce`等都是泛型函数，可以应用于任何类型的集合。

泛型的原理使得Swift能够提供类型安全、灵活且高效的数据结构和算法，同时保持代码的简洁性和可维护性。通过泛型，开发者可以编写出适用于多种数据类型的通用代码，而无需为每种类型编写重复的逻辑。

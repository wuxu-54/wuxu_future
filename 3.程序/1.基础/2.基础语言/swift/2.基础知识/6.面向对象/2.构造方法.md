# 构造方法

在Swift中，类的构造方法用于创建并初始化类的新实例。构造方法有几种类型，每种都有不同的用途：

1. **指定构造器（Designated Initializer）**：
   - 这是最常见的构造器类型，用于初始化类的属性。
   - 指定构造器可以被子类覆盖以提供子类的初始化逻辑。

   ```swift
   class Person {
       var name: String
       var age: Int
       
       init(name: String, age: Int) {
           self.name = name
           self.age = age
       }
   }
   ```

2. **便利构造器（Convenience Initializer）**：
   - 便利构造器用于提供额外的初始化选项，通常调用同一个类的其他构造器（指定或另一个便利构造器）。
   - 便利构造器不能被子类覆盖。

   ```swift
   class Person {
       var name: String
       var age: Int
       
       init(name: String, age: Int) {
           self.name = name
           self.age = age
       }
       
       convenience init() {
           self.init(name: "Unknown", age: 0)
       }
   }
   ```

3. **默认构造器**：
   - 如果你没有为类定义任何构造器，Swift会为你提供一个默认构造器，它将所有属性初始化为它们的默认值。

4. **析构器（Deinitializer）**：
   - 析构器不是构造器，但在类实例生命周期结束时被调用。析构器用于执行清理工作，如释放资源。

5. **继承和构造器**：
   - 当子类覆盖父类的构造器时，它必须调用`super.init()`来确保父类的初始化逻辑被执行。

6. **失败构造器（Failable Initializer）**：
   - 失败构造器可以返回一个可选类型（`init?`），如果初始化失败则返回`nil`。
   - 失败构造器通常用于处理可能失败的初始化过程，如解档（decoding）或从外部数据源创建实例。

   ```swift
   class Document {
       var text: String
       
       init?(text: String) {
           if text.isEmpty {
               return nil // 初始化失败
           }
           self.text = text
       }
   }
   ```

7. **构造器参数的属性化**：
   - 构造器参数可以用于设置类的属性，而不需要显式调用构造器。

   ```swift
   class Circle {
       var radius: Double
       
       init(radius: Double) {
           self.radius = radius
       }
   }
   ```

8. **构造器链**：
   - 在类的继承体系中，构造器可以形成一个调用链，确保每个级别的类都被正确初始化。

9. **循环引用和构造器**：
   - 在构造器中，如果类的实例捕获了它们自己的引用，需要使用`weak`或`unowned`来避免循环引用。

使用构造器时，Swift提供了强大的内存安全保障，确保每个对象在使用前都被正确初始化。构造器是类设计中的关键部分，它们定义了如何创建和设置对象的状态。

---

## 析构

在Swift中，析构方法（Deinitializer）是一种特殊的方法，它在类的实例被销毁之前被调用。析构方法使用`deinit`关键字来定义，并且每个类最多只能有一个析构方法。

### 析构方法的用途

1. **资源清理**：
   当类的实例即将被销毁时，使用析构方法来释放或清理它所持有的资源，例如关闭文件、停止计时器、释放内存等。

2. **执行最终操作**：
   在对象生命周期结束时执行一些必要的最终操作。

### 析构方法的特性

1. **自动调用**：
   析构方法不需要手动调用，当类的实例作用域结束或被显式销毁时，系统会自动调用。

2. **执行顺序**：
   析构方法在类的属性观察器之后调用，但在整个实例销毁之前。

3. **不能继承或重写**：
   析构方法不能被继承或重写。

4. **使用`super.deinit()`**：
   如果类有父类，并且在析构方法中需要确保父类的资源也被正确清理，可以显式地调用`super.deinit()`，但通常这不是必需的，因为父类的析构方法会在子类的析构方法之后自动调用。

### 示例

```swift
class ResourceHandler {
    var resource: String?

    init(resource: String) {
        self.resource = resource
        print("\(resource) resource allocated.")
    }

    deinit {
        print("Cleaning up \(resource!) resource.")
    }
}

var handler: ResourceHandler? = ResourceHandler(resource: "File")
// 使用handler...

handler = nil // 此时会打印 "Cleaning up File resource."
```

在这个示例中，`ResourceHandler`类有一个属性`resource`，它在初始化时被设置，并在析构时被清理。当`handler`的实例被设置为`nil`时，其作用域结束，析构方法被自动调用。

析构方法在Swift中非常有用，特别是在处理需要显式清理的资源时。然而，由于Swift的自动引用计数（ARC）机制，许多情况下内存管理是自动进行的，因此析构方法的使用相对较少。不过，在处理非内存资源时，析构方法仍然是一个关键的工具。

---

## 指定构造器与便利构造器区别

在Swift中，构造器用于创建和初始化类的实例。类可以有一个或多个构造器，其中包括指定构造器（Designated Initializers）和便利构造器（Convenience Initializers）。以下是它们的主要区别：

### 指定构造器（Designated Initializers）

1. **主要构造器**：指定构造器是类的主构造器，用于执行标准的初始化任务。
2. **继承和调用**：如果一个类继承自另一个类，它必须调用其父类的一个指定构造器（通过`super.init()`）。
3. **初始化所有属性**：指定构造器负责初始化类中的所有属性。
4. **可以被子类重写**：子类可以重写父类的指定构造器。

### 便利构造器（Convenience Initializers）

1. **辅助构造器**：便利构造器用于提供额外的初始化选项，它们通常调用同一个类的其他构造器。
2. **不能初始化所有属性**：便利构造器不能直接初始化类中的所有属性，它们必须调用另一个构造器来完成这一任务。
3. **可以是继承的**：子类可以继承父类的便利构造器，但它们不能调用父类的便利构造器。
4. **用于特定情况**：便利构造器通常用于创建特定条件下的实例，例如创建具有默认值或特定配置的对象。

### 指定构造器与便利构造器区别示例

```swift
class Person {
    var name: String
    var age: Int

    // 指定构造器
    init(name: String, age: Int) {
        self.name = name
        self.age = age
        print("\(name) with age \(age) is initialized.")
    }

    // 便利构造器
    convenience init() {
        self.init(name: "Unknown", age: 0)
        print("Default person is initialized.")
    }
}

let person = Person(name: "Alice", age: 30) // 使用指定构造器
let defaultPerson = Person() // 使用便利构造器，内部调用指定构造器
```

在这个示例中，`Person`类有一个指定构造器，它接受`name`和`age`作为参数，并有一个便利构造器，它没有参数并使用默认值。便利构造器通过使用`self.init`来调用指定构造器。

### 继承中的构造器

```swift
class Employee: Person {
    var jobTitle: String

    // 指定构造器，必须调用父类的指定构造器
    init(name: String, age: Int, jobTitle: String) {
        self.jobTitle = jobTitle
        super.init(name: name, age: age)
        print("\(name) with job title \(jobTitle) is initialized as an employee.")
    }

    // 便利构造器，可以提供不同的初始化路径
    convenience init(jobTitle: String) {
        self.init(name: "Unknown", age: 0, jobTitle: jobTitle)
        print("Default employee with job title \(jobTitle) is initialized.")
    }
}

let employee = Employee(name: "Bob", age: 25, jobTitle: "Engineer")
let defaultEmployee = Employee(jobTitle: "Manager") // 使用便利构造器
```

在这个继承示例中，`Employee`类继承自`Person`类，并添加了`jobTitle`属性。它有一个指定构造器，用于初始化所有属性，并调用父类的指定构造器。它还有一个便利构造器，用于快速创建具有特定职位的员工实例。

指定构造器和便利构造器在类的初始化过程中发挥着不同但互补的作用，它们共同提供了灵活的初始化选项。

---

## 子父类构造方法与析构方法调用顺序

在Swift中，当创建一个子类的实例时，构造器的调用顺序和销毁实例时析构器的调用顺序是固定的。以下是详细的调用顺序：

### 构造过程

1. **父类的指定构造器**：
   - 总是首先调用父类的指定构造器（designated initializer）。

2. **子类的指定构造器**：
   - 接下来调用子类的指定构造器，它必须调用其父类的指定构造器（使用`super.init`）。

3. **便利构造器**：
   - 如果使用便利构造器（convenience initializer），它必须最终委托给同一个类的某个指定构造器。

4. **属性初始化**：
   - 在指定构造器中，所有存储属性必须被初始化。

5. **内存分配**：
   - 类的实例的内存被分配。

示例代码展示构造过程：

```swift
class Parent {
    init() {
        print("Parent's designated initializer")
    }
}

class Child: Parent {
    convenience init() {
        self.init(childProperty: "Child's property")
    }
    
    override init(childProperty: String) {
        print("Child's designated initializer with property \(childProperty)")
        super.init()
    }
}

let child = Child() // 输出 Parent 和 Child 的构造器调用顺序
```

### 析构过程

1. **子类的析构器**：
   - 首先调用子类的`deinit`方法，执行子类的资源清理工作。

2. **父类的析构器**：
   - 子类的析构器执行完成后，接着调用父类的`deinit`方法。

3. **资源释放**：
   - 随着析构器的调用，实例的内存被释放。

示例代码展示析构过程：

```swift
class Parent {
    deinit {
        print("Parent's deinitializer")
    }
}

class Child: Parent {
    deinit {
        print("Child's deinitializer")
    }
}

var child: Child? = Child()
child = nil // 输出 Child 和 Parent 的析构器调用顺序
```

在这个示例中，创建了`Child`的实例，然后将其设置为`nil`，触发了析构过程。首先打印`Child's deinitializer`，然后打印`Parent's deinitializer`。

这种构造和析构的调用顺序确保了类的属性被正确初始化并且在对象生命周期结束时被适当清理。开发者应当了解这一顺序，以确保类的实例在其生命周期内保持有效和一致的状态。

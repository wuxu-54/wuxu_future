# 属性

在Swift中，属性（Properties）是存储在类、结构体或枚举中的值。属性可以是不同类型的，包括基本数据类型、其他类、结构体或枚举。以下是Swift中属性的一些关键特性：

1. **存储属性（Stored Properties）**：
   - 存储属性用于存储值。在类中，存储属性的默认访问级别是`private`，而在结构体和枚举中，默认访问级别是`public`。

   ```swift
   class Person {
       private var name: String
       var age: Int // 在结构体中默认是public
       
       init(name: String, age: Int) {
           self.name = name
           self.age = age
       }
   }
   ```

2. **计算属性（Computed Properties）**：
   - 计算属性不存储值，而是提供一个getter和可选的setter来访问和设置值，基于其他属性或复杂逻辑计算得出。

   ```swift
   struct Rectangle {
       var width: Double
       var height: Double {
           didSet {
               print("Height is now \(height)")
           }
       }
       var area: Double {
           return width * height
       }
   }
   ```

3. **属性观察器（Property Observers）**：
   - 属性观察器可以在属性值改变时获得通知。`willSet`在属性值改变前调用，`didSet`在属性值改变后调用。

4. **类型属性（Type Properties）**：
   - 类型属性属于类类型本身（其实就是java的静态变量），而不是类的实例。类型属性可以用`static`（对于存储类型属性）或`class`（对于计算类型属性和可以被子类重写的存储属性）关键字声明。

   ```swift
   class Counter {
       static var count = 0
       class var description: String {
           return "Counter has been instantiated \(count) times."
       }
   }
   ```

5. **懒加载存储属性（Lazy Stored Properties）**：
   - 懒加载存储属性的值在第一次被访问时才计算，并且只计算一次。使用`lazy`关键字。（等同于kotlin的`by lazy`，dart的`late`）

   ```swift
   class DataImporter {
       lazy var data: [String] = {
           print("Data is being initialized.")
           return ["Data1", "Data2", "Data3"]
       }()
   }
   ```

6. **只读和可读写属性**：
   - 属性可以声明为只读（使用关键字`let`，类可在构造方法调用时赋值。或是只设置getter。或设定私有setter: `private set`），这意味着它们只能被赋值一次，通常在声明时或初始化时。
   - 可读写属性可以多次赋值（使用`var`修饰，表示可变）。

7. **内存管理**：
   - 在类中，属性的内存管理需要考虑引用计数和循环引用问题。使用`weak`或`unowned`关键字可以避免循环引用。

8. **访问控制**：
   - 可以为属性设置不同的访问级别（`private`、`fileprivate`、`internal`、`public`、`open`），以控制外部对属性的访问。

9. **自定义子脚本（Subscripts）**：
   - 可以为属性定义下标脚本，允许使用下标语法访问属性。

10. **属性封装**：
    - Swift要求使用属性来封装所有的数据，直接公开变量是不被允许的。

通过使用属性，Swift代码可以保持清晰、安全和易于维护。属性的封装特性有助于保护数据不被外部代码以意外的方式修改，同时提供了灵活性来定义如何访问和修改数据。

---

## 属性观察器

在Swift中，属性观察器（Property Observers）是一种特殊的功能，允许代码在属性值改变时获得通知。属性观察器主要用于类和结构体的存储属性，但不能用于全局变量或局部变量。

属性观察器包括：

1. **`willSet`**：
   - `willSet`观察器在属性的值即将被设置前调用。你可以使用它来观察属性值的变化，但`willSet`不能阻止赋值操作。
   - `willSet`的参数是即将被赋给属性的新值。

   ```swift
   struct Person {
       var name: String {
           willSet {
               print("About to set the name to \(newValue).")
           }
       }
   }
   ```

2. **`didSet`**：
   - `didSet`观察器在属性的值已经被设置后调用。你可以使用它来响应属性值的变化。
   - 如果你需要在属性被设置后执行某些操作，`didSet`非常有用。

   ```swift
   class Timer {
       var isValid: Bool {
           didSet {
               if isValid {
                   print("Timer is now valid.")
               } else {
                   print("Timer is no longer valid.")
               }
           }
       }
   }
   ```

3. **观察器组合使用**：
   - `willSet`和`didSet`可以组合使用在同一个属性上，以提供设置前后的行为。

   ```swift
   var someValue: Int {
       willSet {
           print("The value will be set to \(newValue).")
       }
       didSet {
           if someValue != oldValue {
               print("The value has changed from \(oldValue) to \(someValue).")
           }
       }
   }
   ```

4. **观察器的执行顺序**：
   - 当属性被赋新值时，首先是`willSet`执行，然后是属性值更新，最后是`didSet`执行。

5. **观察器与可变性**：
   - 观察器仅适用于可变存储属性。

6. **观察器与继承**：
   - 如果子类重写了一个属性，它可以选择性地为该属性添加自己的观察器。

7. **观察器和延迟存储属性**：
   - 延迟存储属性不能有观察器，因为它们的值在首次访问时计算。

属性观察器是Swift中实现属性值变更通知的一种优雅方式。它们可以用于调试、日志记录、状态更新、数据验证等多种场景。使用观察器可以确保相关逻辑在属性值改变时自动执行，有助于维护代码的整洁性和一致性。

---

## setter、 getter

在Swift中，每个属性（property）实际上都隐式地拥有一个getter方法，用于获取属性的值。对于可写的属性，还有一个setter方法，用于设置属性的值。大多数情况下，当你声明一个属性时，Swift会自动为你生成这些getter和setter的实现。

### 默认的 Getter 和 Setter

当你声明一个可写的属性时，Swift会自动为你生成一个简单的getter和setter：

```swift
class MyClass {
    var property: Int = 10
    
    // 'property' 有一个默认的 getter 和 setter
}
```

在这个例子中，`property`有一个默认的getter和setter。你可以像这样使用它们：

```swift
let myObject = MyClass()
print(myObject.property) // 使用 getter 获取属性的值
myObject.property = 20  // 使用 setter 设置属性的值
```

### 自定义 Getter 和 Setter

Swift允许你为属性提供自定义的getter和setter。这在你想要控制属性值的访问或修改时非常有用。例如，你可以添加逻辑来验证设置的值，或者在属性值改变时执行某些操作：

```swift
class Person {
    private var _age: Int = 0
    
    var age: Int {
        get {
            return _age
        }
        set {
            if newValue > 0 {
                _age = newValue
            } else {
                print("Age must be greater than zero.")
            }
        }
    }
}
```

在这个例子中，`age`属性有一个自定义的setter，它检查新值是否大于0。如果新值无效，setter将不更新`_age`，并且会打印一条消息。

### 只读属性的 Getter

对于只读属性，你只需要提供getter。这通常用于你想要提供一个值但不能被外部代码修改的情况：

```swift
struct Rectangle {
    var width: Int
    var height: Int
    
    var area: Int {
        return width * height
    }
}
```

在这个例子中，`area`是一个只读属性，它有一个getter，但没有setter。你不能为`area`设置一个值，因为它是基于`width`和`height`计算得出的。

### 属性的内存管理

当你在类中使用属性时，需要考虑内存管理，特别是循环引用。如果属性是类类型，并且属性值可能捕获属性所在的实例，你应该使用`weak`（弱引用）或`unowned`（无主引用）来避免循环引用：

```swift
class Developer {
    weak var manager: Manager?
}
```

在这个例子中，`manager`属性是一个弱引用，因为`Manager`类可能已经持有对`Developer`的强引用，使用`weak`可以防止循环引用。

通过使用getter和setter，Swift提供了一种灵活的方式来控制属性值的访问和修改，同时保持代码的封装性和安全性。

---

## 属性包装器

在 Swift 中，属性包装器（Property Wrappers）是一种强大的特性，它允许你定义自定义的属性包装器来封装属性的行为。属性包装器可以用于实现各种功能，如数据验证、属性观察、懒加载、环境依赖注入等。

### 基本语法

属性包装器的实现包括以下几个部分：

1. **定义属性包装器**：
   使用 `@propertyWrapper` 属性来标记一个结构体或类。

2. **存储属性**：
   定义一个或多个存储属性来保存实际的值。

3. **wrappedValue 属性**：
   定义一个计算属性，用于获取和设置包装的值。

4. **初始化器**：
   可以定义一个初始化器来初始化存储属性。

### 示例：简单的属性包装器

下面是一个简单的属性包装器示例，用于实现一个带有初始值的属性：

```swift
@propertyWrapper
struct InitialValue {
    private var value: Int
    
    var wrappedValue: Int {
        get { value }
        set { value = newValue }
    }
    
    init( initialValue: Int) {
        self.value = initialValue
    }
}

struct Test {
    @InitialValue(10)
    var number: Int
}

let test = Test()
print(test.number) // 输出 10
test.number = 20
print(test.number) // 输出 20
```

### 示例：带验证的属性包装器

下面是一个带有数据验证的属性包装器示例：

```swift
@propertyWrapper
struct PositiveValue {
    private var value: Int
    
    var wrappedValue: Int {
        get { value }
        set { value = newValue > 0 ? newValue : 0 }
    }
    
    init(wrappedValue initialValue: Int) {
        self.value = initialValue > 0 ? initialValue : 0
    }
}

struct Test {
    @PositiveValue var number: Int
}

let test = Test()
test.number = -10
print(test.number) // 输出 0
test.number = 20
print(test.number) // 输出 20
```

### 示例：懒加载属性包装器

下面是一个实现懒加载的属性包装器示例：

```swift
@propertyWrapper
struct Lazy<Value> {
    private var value: Value?
    private let factory: () -> Value
    
    var wrappedValue: Value {
        get {
            if let stored = value {
                return stored
            } else {
                let newValue = factory()
                value = newValue
                return newValue
            }
        }
        set {
            value = newValue
        }
    }
    
    init(wrappedValue: Value) {
        self.factory = { wrappedValue }
    }
}

struct Test {
    @Lazy var expensiveComputation: String = {
        print("Computing expensive value...")
        return "Expensive Value"
    }()
}

var test = Test()
print(test.expensiveComputation) // 第一次访问时计算
print(test.expensiveComputation) // 再次访问时直接返回，不再计算
```

### 示例：环境依赖注入属性包装器

下面是一个实现环境依赖注入的属性包装器示例：

```swift
@propertyWrapper
struct Environment<Object> {
    private let keyPath: KeyPath<EnvironmentValues, Object>
    private let defaultValue: Object
    
    var wrappedValue: Object {
        get { EnvironmentValues[keyPath: keyPath] ?? defaultValue }
        set { EnvironmentValues[keyPath: keyPath] = newValue }
    }
    
    init(_ keyPath: KeyPath<EnvironmentValues, Object>, defaultValue: Object) {
        self.keyPath = keyPath
        self.defaultValue = defaultValue
    }
}

struct User {
    let id: Int
}

struct ContentView: View {
    @Environment(\.locale, defaultValue: Locale.current) var locale
    @Environment(\.user, defaultValue: User(id: 0)) var user

    var body: some View {
        Text("User ID: \(user.id)")
    }
}

struct EnvironmentValues {
    static var locale: Locale = .current
    static var user: User? = nil
}
```

### 总结

属性包装器提供了一种灵活的方式来封装和管理属性的行为，使得代码更加模块化和可重用。通过定义属性包装器，你可以实现各种复杂的属性行为，如数据验证、懒加载、环境依赖注入等。

---

## 常见属性包装器

在 Swift 中，属性包装器（Property Wrappers）是一种非常有用的语言特性，它允许开发者封装属性的获取和设置行为。以下是一些在 Swift 开发中常见的属性包装器：

1. **@State**:
   用于 SwiftUI 视图中，用于定义私有状态，当状态改变时，视图会自动更新。

   ```swift
   struct ContentView: View {
       @State private var isEnabled = true
   }
   ```

2. **@Binding**:
   用于在 SwiftUI 视图之间创建状态的双向绑定，通常与父视图的 `@State` 属性一起使用。

   ```swift
   struct ToggleView: View {
       @Binding var isEnabled: Bool

       var body: some View {
           Text("Toggle is \(isEnabled ? "On" : "Off")")
               .toggleable()
               .foregroundColor(isEnabled ? .green : .red)
       }
   }
   ```

3. **@EnvironmentObject**:
   用于在 SwiftUI 视图中提供和订阅应用程序范围内的状态，通过将对象注入环境来实现。

   ```swift
   class UserData: ObservableObject {
       @Published var userName = "Guest"
   }

   struct ContentView: View {
       @EnvironmentObject var userData: UserData
   }
   ```

4. **@ObservedObject**:
   用于在 SwiftUI 视图中观察单个对象的状态变化，当对象的属性发生变化时，视图会更新。

   ```swift
   struct ContentView: View {
       @ObservedObject var userData = UserData()
   }
   ```

5. **@Published**:
   用于声明一个类的属性是可观察的，通常与 `ObservableObject` 基类一起使用。

   ```swift
   class UserData: ObservableObject {
       @Published var userName: String
   }
   ```

6. **@AppStorage**:
   用于持久化用户设置，将数据存储在用户的设备上，以便在应用程序重新启动之间保持状态。

   ```swift
   struct SettingsView: View {
       @AppStorage("username") var username = "defaultUser"
   }
   ```

7. **@SceneStorage**:
   用于存储与特定场景相关的状态，与 `@AppStorage` 类似，但仅限于特定场景。

8. **@FocusState**:
   用于管理键盘焦点状态，确定哪个文本字段或其他可聚焦元素当前具有焦点。

9. **@DynamicProperty**:
   允许你创建动态可观察的属性，这些属性可以在运行时添加到视图或其他对象上。

10. **@ScaledMetric**:
    用于创建根据用户设置的缩放比例动态调整的数值，例如根据用户的文本大小首选项调整间距或尺寸。

11. **@LazyHGC**:
    用于实现延迟初始化，确保属性只在首次访问时创建。

12. **@MainActor**:
    用于确保 UI 相关的属性和方法总是在主线程上访问，用于线程安全。

这些属性包装器提供了一种声明性和可组合的方式来管理状态和行为，使得 Swift 应用程序更加模块化和响应式。在 SwiftUI 中，它们尤其有用，因为它们可以帮助你创建声明式的、响应式的 UI。

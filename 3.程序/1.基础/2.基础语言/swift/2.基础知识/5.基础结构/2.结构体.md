# 结构体

在Swift中，结构体（Structure，简称`struct`）是一种值类型，用于封装数据和功能。结构体提供了一种方式来创建自定义数据类型，非常适合用来表示简单的数据聚合。以下是结构体的一些主要特性和用法：

1. **定义结构体**：
   使用`struct`关键字来定义结构体。

   ```swift
   struct Person {
       var name: String
       var age: Int
       let sex: String 
   }
   ```

   > 注意！构造体中的属性如果没有默认值并且不可空，默认构造器会带有这个参数，也就是必须得给赋初始值。

2. **成员变量**：
   结构体可以拥有存储属性，用于存储数据。

3. **构造器**：
   结构体可以定义一个或多个构造器来初始化其属性。

   ```swift
   struct Point {
       var x: Int
       var y: Int
       init(x: Int, y: Int) {
           self.x = x
           self.y = y
       }
   }
   ```

4. **默认构造器**：
   如果没有定义任何构造器，Swift会提供一个默认的无参数构造器。

5. **成员方法**：
   结构体可以定义方法，包括实例方法和静态计算属性。

   ```swift
   extension Person {
       func greet() -> String {
           return "Hello, \(name)!"
       }
   }
   ```

6. **计算属性**：
   结构体可以定义计算属性，这些属性不直接存储值，而是根据其他属性计算得出。

   ```swift
   struct Rectangle {
       var width: Int
       var height: Int
       var area: Int {
           return width * height
       }
   }
   ```

7. **属性观察器**：
   结构体的属性可以拥有`willSet`和`didSet`观察器，用于在属性值变更时执行代码。

   ```swift
   struct Temperature {
       var celsius: Double {
           didSet {
               print("The temperature has been set to \(celsius)°C")
           }
       }
   }
   ```

8. **嵌套类型**：
   结构体可以包含其他类型，包括其他结构体和枚举。

9. **遵循协议**：
   结构体可以遵循协议，实现协议中定义的方法和属性。

   ```swift
   protocol Greeting {
       func sayHello() -> String
   }
   struct Person: Greeting {
       var name: String
       func sayHello() -> String {
           return "Hello, \(name)!"
       }
   }
   ```

10. **结构体的可变性**：
    结构体的实例是值类型，当它们被赋值给新的变量或常量时，会进行拷贝。

11. **结构体的比较**：
    结构体可以使用`==`运算符进行比较，如果所有属性都相等，则认为两个实例相等。

12. **自定义字符串表示**：
    结构体可以实现`CustomStringConvertible`协议，提供自定义的字符串描述。

    ```swift
    struct Rectangle: CustomStringConvertible {
        var width: Int
        var height: Int
        var description: String {
            return "Rectangle: width = \(width), height = \(height)"
        }
    }
    ```

13. **结构体的递归定义**：
    结构体可以递归地定义，即结构体的属性可以是它本身。

以下是使用结构体的示例代码：

```swift
struct Rectangle {
    var width: Int
    var height: Int
    
    func area() -> Int {
        return width * height
    }
}

let rect = Rectangle(width: 10, height: 20)
print("Area: \(rect.area())") // "Area: 200"
```

结构体是Swift中非常重要的一个特性，它们是轻量级的、易于使用的，并且非常适合用于存储一组相关的数据。由于结构体是值类型，它们在函数间传递时会进行拷贝，这使得并发编程更加安全。

---

## 与类的区别

结构体（`struct`）和类（`class`）在Swift中都是定义自定义数据类型的封装性数据结构，但它们之间存在一些关键区别：
>c++章节其实我也列了与类的对比。这里再写一下，swift比c++更细化了，比如swift结构体支持协议（就是java中的接口、TS中的约束）

1. **继承**：
   - 结构体不能继承其他类型，它们没有继承链。
   - 类可以继承自其他类，支持类的继承体系。

2. **引用语义 vs 值语义**：
   - 结构体是值类型，当结构体实例赋值给另一个变量或常量时，会进行拷贝。
   - 类是引用类型，当类实例赋值给另一个变量或常量时，两个引用指向同一个对象。

3. **可变性**：
   - 结构体的实例默认是不可变的，除非你在结构体或其方法中使用`mutating`关键字修改它。
   - 类的实例默认是可变的，可以修改其属性，除非在类或其属性中指定为`let`。

4. **构造器**：
   - 结构体和类都可以定义自定义构造器，但它们处理默认构造器的方式不同。如果没有定义任何构造器，类会获得一个无参数的默认构造器，而结构体会获得所有属性的默认构造器。

5. **析构器**：
   - 类可以定义析构器（`deinit`）来执行对象销毁前的操作。
   - 结构体不支持析构器。

6. **协议遵循**：
   - 结构体和类都可以遵循协议，并实现协议要求的方法。

7. **类型转换**：
   - 类支持向下类型转换（`as`、`as?`、`is`、`is?`），因为它们可以有子类。
   - 结构体不支持向下类型转换，因为它们不能被继承。

8. **内存管理**：
   - 类的实例可能涉及更复杂的内存管理，尤其是在使用引用计数的情况下。
   - 结构体的内存管理通常更简单，因为它们总是通过值传递。

9. **方法和计算属性**：
   - 结构体和类都可以定义实例方法和计算属性。

10. **嵌套类型**：
    - 结构体和类都可以包含嵌套类型。

11. **扩展性**：
    - 结构体和类都可以通过扩展（`extension`）来增加新功能。

12. **访问控制**：
    - 类支持更细粒度的访问控制（`private`、`fileprivate`、`internal`、`public`、`open`）。
    - 结构体的访问控制与类类似，但没有`open`级别。

13. **使用场景**：
    - 结构体适用于轻量级的数据聚合，当你知道数据将被复制，并且不需要继承时。
    - 类适用于需要继承体系或需要引用语义来共享数据的复杂对象。

选择使用结构体还是类通常取决于是否需要继承、数据是否应该被共享（引用），以及数据的可变性。Swift鼓励在不需要继承的情况下使用结构体，以利用其值语义的优势。

---

## 构造函数结合闭包（类也可以这样写）

在Swift中，结构体可以与Lambda表达式（也称为闭包）一起使用，Lambda表达式是一种简洁的定义匿名函数的方法。以下是一些结构体与Lambda表达式的常见写法：

### 定义结构体

首先定义一个简单的结构体：

```swift
struct Person {
    var name: String
    var age: Int
}
```

### 使用Lambda表达式作为属性

结构体可以拥有一个Lambda表达式作为其属性，例如，作为初始化后立即执行的配置代码：

```swift
struct Person {
    var name: String
    var age: Int
    let configure: () -> Void

    init(name: String, age: Int, configure: @escaping () -> Void) {
        self.name = name
        self.age = age
        self.configure = configure
        configure()
    }
}

let person = Person(name: "Alice", age: 30) {
    print("Person initialized: \(name), \(age)")
}
```

多个函数参数，闭包表示示例：

```swift
    struct Test{
        var a : ()->Void
        var b : ()->Void
        
    init(t:String ,a: @escaping () -> Void, b: @escaping () -> Void) {
            self.a = a
            self.b = b
        }
    }

    Test(t:"123"){//第一个闭包函数无需写 a:
                
    } b: {
                
    }
```

### 存储Lambda表达式作为回调

结构体可以存储Lambda表达式作为回调函数，例如，用于处理事件：

```swift
struct EventManager {
    var onEvent: (() -> Void)?

    init(onEvent: @escaping () -> Void) {
        self.onEvent = onEvent
    }

    func trigger() {
        onEvent?()
    }
}

let manager = EventManager { 
    print("Event triggered!") 
}

manager.trigger() // 输出: Event triggered!
```

### Lambda表达式作为方法参数

结构体的方法可以接受Lambda表达式作为参数，用于自定义行为：

```swift
struct Counter {
    var count = 0

    mutating func increment(by amount: Int, then execute: (Int) -> Void) {
        count += amount
        execute(count)
    }
}

var counter = Counter()
counter.increment(by: 5) { newCount in
    print("Count is now \(newCount)")
}
```

### 使用Lambda表达式处理异步结果

结构体可以结合Lambda表达式处理异步操作的结果：

```swift
struct AsyncDataLoader {
    func loadData(completion: @escaping (String) -> Void) {
        // 模拟异步加载数据
        DispatchQueue.global().asyncAfter(deadline: .now() + 1) {
            let data = "Loaded data"
            completion(data)
        }
    }
}

let loader = AsyncDataLoader()
loader.loadData { data in
    print("Data loaded: \(data)")
}
```

### Lambda表达式作为属性的默认值

结构体的属性可以有Lambda表达式作为默认值：

```swift
struct Logger {
    var logMessage: (String) -> Void = { message in
        print("Log: \(message)")
    }
}

struct DataProcessor {
    var data: [Int]
    var logger: Logger

    init(data: [Int], logger: Logger = Logger()) {
        self.data = data
        self.logger = logger
    }

    func processData() {
        // 使用Logger记录处理过程
        logger.logMessage("Processing \(data.count) items")
    }
}

let processor = DataProcessor(data: [1, 2, 3, 4])
processor.processData()
```

Lambda表达式提供了一种强大的方式来增加Swift结构体的灵活性和功能，允许开发者以声明式的方式定义和使用匿名函数。

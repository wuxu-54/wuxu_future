# 注解

同java的注解，编译器在编译时可以根据注解对被标注对象进行处理，改变它们的行为或提供额外信息。

---

## 自定义注解

在Swift中，你可以自定义注解来为代码添加元数据，这些注解可以被编译器或其他工具识别和使用。自定义注解是通过定义一个属性，使用`@_AttributeName`语法，其中`AttributeName`是你自定义的注解名称。
> 自定义注解就是通过后面【面向对象-属性】章节学习的属性包装器实现的。

以下是如何定义和使用自定义注解的基本步骤：

1. **定义注解**：
   使用`@propertyWrapper`来创建一个自定义注解。

    ```swift
    @propertyWrapper
    struct CustomAnnotation {
        private var value: String // 注解内使用的私有属性

        var wrappedValue: String {// 包装属性，属性包装器的公共接口，替代被注解修饰的属性。
            get { value }
            set { 
                print("CustomAnnotation set with value: \(newValue)")
                value = newValue 
            }
        }

         
        init(wrappedValue: String) {// 定义了一个初始化器，用于创建 CustomAnnotation 实例。
            self.value = wrappedValue
        }
    }
    ```

    解释：

    - `private var value: String`：注解内使用的私有属性，无其他作用。
    - `var wrappedValue: String`：包装属性，属性包装器的公共接口，替代被注解修饰的属性。当被修饰属性被赋值或使用时走这个包装属性的set、get
    - `init(wrappedValue: String)`：定义了一个初始化器，用于创建 CustomAnnotation 实例。
      - **属性首次被初始化**：当你在类的实例或结构体的实例中声明一个使用属性包装器的属性时，属性包装器的初始化器会被调用。这是属性包装器存储属性被创建并初始化其值的时刻。
      - **属性赋值**：如果你的属性包装器的 wrappedValue 有 set 访问器，那么在属性被赋新值时，set 访问器中的代码会被执行。虽然这不是属性包装器的初始化器被调用，但它是属性包装器逻辑的一部分，通常用于处理属性值的变更。
      - **属性投影**：在使用 @Binding 属性包装器时，如果你在 SwiftUI 视图中使用该属性，那么每当视图的状态更新时，属性包装器的初始化器可能会被调用，以便创建新的绑定。
      - **拷贝和克隆**：当使用属性包装器的实例被拷贝或克隆时，例如在复制一个结构体或类实例时，属性包装器的初始化器可能会被用来创建属性的新实例。
      - **序列化和反序列化**：如果你的类或结构体实例被序列化（例如，使用 Codable 协议保存到文件），然后反序列化回来，属性包装器的初始化器可能会被调用，以确保属性在反序列化过程中被正确初始化。
      - **反射和镜像**：在使用 Swift 的反射API，如 Mirror 类，来检查属性时，属性包装器的初始化器可能会被调用，以便创建属性的镜像。

2. **应用注解**：
   使用自定义注解来修饰类、结构体或属性。

   ```swift
   class MyClass {
       @CustomAnnotation("Initial Value")
       var myProperty: String
   }
   ```

3. **注解的逻辑**：
   自定义注解可以包含初始化逻辑、属性观察器或其他自定义行为。

4. **使用注解**：
   创建类的实例时，注解的初始化逻辑会被调用，并且注解的行为会生效。

   ```swift
   let myClass = MyClass()
   myClass.myProperty = "Updated Value"
   ```

5. **注解的元数据**：
   自定义注解可以存储元数据，这些数据可以是注解参数或其他计算得到的值。

6. **注解的继承**：
   如果自定义注解是一个属性包装器，它可以被其他属性包装器继承和扩展。

7. **注解的反射**：
   Swift的反射API可以用来检查和使用自定义注解，但这通常需要注解是公开的，并且使用了`@available`或其他反射可见的属性。

8. **注解的局限性**：
   自定义注解不会改变语言的语法或增加新的关键字，它们主要用于添加元数据或改变属性的行为。

自定义注解是Swift高级特性的一部分，它们提供了一种灵活的方式来扩展语言的能力。然而，自定义注解应该谨慎使用，以避免过度复杂化代码。在实际开发中，自定义注解常用于添加框架特定的元数据、序列化支持、测试钩子等。

---

## 常见注解

1. **`@IBAction`**：
   - 用于连接Interface Builder中的用户界面元素（如按钮）和代码中的事件处理函数。这允许你在Xcode的Interface Builder中触发动作。

2. **`@IBOutlet`**：
   - 用于连接Interface Builder中的用户界面元素和代码中的引用，以便可以在代码中访问和操作这些元素。

3. **`@NSManaged`**：
   - 在使用Core Data时，用于指示属性由Core Data框架管理，通常用于`NSManagedObject`的子类中。

4. **`@objc`**：
   - 用于暴露Swift定义的成员给Objective-C代码，或用于实现Objective-C的协议。

5. **`@escaping`**：
   - 用于标记闭包参数，表示该闭包会在其定义的作用域之外被调用，因此需要逃逸调用函数的作用域。

6. **`@autoclosure`**：
   - 用于自动将表达式转换为闭包，通常与`#keyPath`或其他元编程特性一起使用。

7. **`@available`**：
   - 用于检查API的可用性，确保代码在不同版本的操作系统上正确运行。

8. **`@frozen`**：
   - 用于指示结构体或枚举是不可变的，可以提高性能。这个注解在Swift中已经不推荐使用，因为所有的结构体和枚举默认都是冻结的。

9. **`@dynamicCallable`**：
   - 用于定义一个类型，使其实例可以像函数一样被调用。

10. **`@main`**：
    - 用于定义应用程序的入口点，指定哪个类或结构体包含应用程序的生命周期管理。

11. **`@nonobjc`**：
    - 用于指示属性、方法或下标不支持Objective-C运行时。

12. **`@objcMembers`**：
    - 用于类扩展，允许类使用Objective-C兼容的成员。

13. **`@warn_unused_result`**：
    - 用于函数，以确保调用者使用该函数的返回值，避免潜在的错误。

14. **`@available`**：
    - 用于标记API的可用性，允许开发者指定API在不同平台和版本上的可用性。

15. **`@_silgen_name`**：
    - 用于为生成的符号指定一个名称，这在与C API交互时特别有用。

16. **`@_cdecl`**：
    - 用于指定按照C语言的调用约定生成符号。

17. **`@convention`**：
    - 用于指定函数调用的约定（如C、Objective-C）。

18 **`@inlinable`**： 内联（等同于kotlin的inline关键字），它允许你将函数、方法或属性的实现内联到调用它的代码中。

### 补充

- `@State`： SwiftUI 中用于定义视图的私有状态。
- `@Binding`： SwiftUI 中用于定义视图之间的状态绑定。
- `@EnvironmentObject`： SwiftUI 中用于定义环境对象，用于跨视图传递数据。
- `@Published`： SwiftUI 中用于定义可观察的属性。
- `@AppStorage`： SwiftUI 中用于定义持久化存储的属性。

# 枚举

在Swift中，枚举（Enumeration，简称enum）是一种特殊的类型，它包含了一组相关的值，这些值被称为枚举成员（enum cases）。枚举提供了一种类型安全的方式来处理一组相关的数据。以下是Swift枚举的一些主要特性和用法：

1. **定义枚举**：
   使用`enum`关键字来定义枚举。

   ```swift
   enum Weekday {
       case monday, tuesday, wednesday, thursday, friday
   }
   ```

2. **原始值**（Raw Values）：
   枚举成员可以关联一个原始值，如整型、字符串或字符。

   ```swift
   enum Weekday: Int {
       case monday = 1, tuesday, wednesday, thursday, friday
   }
   ```

3. **关联值**（Associated Values）：
   枚举成员可以关联一个或多个值，这些值可以是不同的类型。

   ```swift
   enum Temperature {
       case celsius(Double)
       case fahrenheit(Double)
   }
   ```

4. **枚举成员的访问**：
   使用点语法（`.`）来访问枚举成员。

   ```swift
   let day = Weekday.monday
   ```

5. **原始值的获取**：
   如果枚举有原始值，可以通过`rawValue`属性获取。

   ```swift
   let day = Weekday.friday.rawValue
   ```

6. **关联值的获取**：
   如果枚举有关联值，可以通过解包来获取。

   ```swift
   let temperature = Temperature.celsius(100.0)
   if case .celsius(let celsiusValue) = temperature {
       print(celsiusValue)
   }
   ```

7. **递归枚举**：
   枚举可以包含自身类型的成员，用于表示树状结构或递归数据结构。

   ```swift
   enum Tree<T> {
       case leaf(T)
       case node([Tree<T>])
   }
   ```

8. **方法和计算属性**：
   枚举可以定义方法和计算属性。

   ```swift
   enum TriStateSwitch {
       case off, low, high
       mutating func next() {
           switch self {
           case .off:
               self = .low
           case .low:
               self = .high
           case .high:
               self = .off
           }
       }
   }
   ```

9. **模式匹配**：
   使用`switch`语句对枚举进行模式匹配。

   ```swift
   let someDay = Weekday.thursday
   switch someDay {
   case .monday:
       print("Start of the week")
   case .friday:
       print("End of the week")
   default:
       print("Middle of the week")
   }
   ```

10. **反射**：
   枚举可以利用Swift的反射特性，如获取枚举的所有成员。

    ```swift
    let allDays = Weekday.allCases
    ```

11. **协议遵循**：
    枚举可以遵循协议，实现协议中定义的方法和属性。

Swift的枚举是一种非常强大的特性，它不仅可以表示一组固定的值，还可以与原始值、关联值结合使用，甚至可以包含递归定义和实现协议。枚举使得Swift代码更加安全、灵活和表达性强。

---

## 关联值细解

在Swift中，定义一个包含关联值的枚举可以让你为枚举的每个案例关联不同的数据。这使得枚举不仅仅是一组相关的值，还可以携带额外的信息，从而更加强大和灵活。
> 关联值就是允许匹配不同类型的值

### 定义包含关联值的枚举

以下是如何定义一个包含关联值的枚举的步骤：

1. **定义枚举**：
   使用`enum`关键字定义枚举，并为每个案例指定关联值的类型。

   ```swift
   enum Result<T, U> {
       case success(T)
       case failure(U)
   }
   ```

   在这个例子中，`Result`枚举有两个案例：`success`和`failure`。`success`关联了一个类型为`T`的值，而`failure`关联了一个类型为`U`的值。

2. **指定关联值的类型**：
   在每个案例后面，使用圆括号`()`来指定关联值的类型。

### 使用枚举

使用枚举时，你可以创建枚举的实例，并根据需要处理不同的案例和关联值。

1. **创建枚举实例**：
   使用枚举的案例来创建实例，并传递关联值。

   ```swift
   let successResult = Result<Int, Error>.success(42)
   let failureResult = Result<Int, Error>.failure(NSError(domain: "ErrorDomain", code: 404, userInfo: nil))
   ```

2. **处理枚举**：
   使用`switch`语句来处理枚举的每个案例，并访问关联值。

   ```swift
   switch successResult {
   case .success(let value):
       print("Success with value: \(value)")
   case .failure(let error):
       print("Failure with error: \(error)")
   }

   switch failureResult {
   case .success(let value):
       print("Success with value: \(value)")
   case .failure(let error):
       print("Failure with error: \(error)")
   }
   ```

   `let` 关键字必须要写，意思是将关联值绑定到名为value/error的常量上。这样才能访问关联值

3. **模式匹配**：
   在`switch`语句中，你可以使用模式匹配来提取关联值，并在代码块中使用它们。

### 示例代码

```swift
enum Result<T, U> {
    case success(T)
    case failure(U)
}

func handleResult(_ result: Result<Int, Error>) {
    switch result {
    case .success(let value):
        print("Success with value: \(value)")
    case .failure(let error):
        print("Failure with error: \(error.localizedDescription)")
    }
}

let successResult = Result<Int, Error>.success(42)
let failureResult = Result<Int, Error>.failure(NSError(domain: "ErrorDomain", code: 404, userInfo: nil))

handleResult(successResult)
handleResult(failureResult)
```

在这个示例中，`Result`枚举用于表示操作的结果，可以是成功的值或失败的错误。`handleResult`函数接受一个`Result`实例，并使用`switch`语句来处理不同的案例。通过模式匹配，可以提取并使用关联值。

关联值的枚举使得Swift的枚举更加灵活，允许你创建表达力强且功能丰富的代码。

# 自动引用计数(ARC)

>java里内存回收机制旧版本也是这样的处理，后来修改了计算方式。

在Swift中，自动引用计数（Automatic Reference Counting，简称ARC）是一种自动内存管理机制。它通过跟踪每个对象的引用次数来决定何时释放对象占用的内存。以下是ARC的详解以及如何处理强引用互相引用（循环引用）的问题。

## ARC详解

1. **引用计数**：
   - ARC通过引用计数来跟踪对象的引用数量。每次对象被新引用时，其引用计数增加；当引用结束时，引用计数减少。

2. **对象释放**：
   - 当对象的引用计数降到0时，ARC会自动释放对象占用的内存。

3. **强引用**：
   - 强引用是最常见的引用类型，它会显著增加对象的引用计数。

4. **所有权**：
   - ARC根据引用的所有权来决定何时增加或减少引用计数。

5. **作用域**：
   - 在作用域内，变量可以被访问；当作用域结束时，ARC会减少变量的引用计数。

6. **循环引用**：
   - 当两个对象互相强引用时，它们的引用计数永远不会降到0，从而导致内存泄漏。

## 强引用互相引用问题

当两个对象互相持有强引用，例如两个类的实例互相作为属性持有对方，就会发生循环引用。由于它们的引用计数始终至少为1，ARC无法释放它们占用的内存，导致内存泄漏。

## 解决循环引用的策略

1. **弱引用（Weak References）**：
   - 弱引用不会增加对象的引用计数。
   - 当对象被销毁时，所有指向它的弱引用会自动置为`nil`。

   ```swift
   class Person {
       weak var spouse: Person?
   }
   ```

2. **无主引用（Unowned References）**：
   - 无主引用假定它引用的对象的生命周期至少和它一样长。
   - 如果无主引用的对象先被销毁，访问无主引用将导致运行时错误。

   ```swift
   class Parent {
       unowned var child: Child
       init(child: Child) {
           self.child = child
       }
   }
   ```

3. **闭包中的循环引用**：
   - 如果闭包捕获了它所在的类的强引用，并且类又捕获了闭包的强引用，会发生循环引用。
   - 通过将闭包的类型明确声明为`[weak self]`或`[unowned self]`来解决。

   ```swift
   class MyClass {
       var closure: (() -> Void)?
       deinit {
           closure?()
       }
   }
   ```

   ```swift
   instance.closure = [weak instance] in {
       // 使用弱引用的instance执行某些操作
   }
   ```

4. **延迟释放（Dealing with Delayed Deinitialization）**：
   - 在某些情况下，即使发生了循环引用，对象也可能因为延迟释放而不立即被销毁。
   - 确保在不需要对象时将其设置为`nil`，以允许ARC释放内存。

5. **析构方法（Deinitializers）**：
   - 使用`deinit`来执行清理工作，但注意，由于循环引用，`deinit`可能不会立即被调用。

## 最佳实践

- 总是考虑对象的所有权和生命周期。
- 避免不必要的强引用，特别是在闭包和代理中。
- 使用弱引用和无主引用来打破循环引用。
- 在合适的时机将引用设置为`nil`。

通过理解ARC的工作原理和使用适当的引用类型，你可以有效地管理内存，并避免循环引用导致的内存泄漏。

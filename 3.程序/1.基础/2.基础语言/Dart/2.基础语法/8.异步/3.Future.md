# Future

在Dart语言中，Future是一种表示异步操作最终完成（或失败）的对象。它用于封装一个未来某个时间点才能得知结果的操作，这个操作可能是I/O操作、网络请求、长时间的计算等。通过Future，你可以以一种声明式的方式处理异步操作，而不必编写复杂的回调函数。

## Future的一些关键特性

* 异步操作：Future用于表示一个可能会在未来完成的异步操作。

* 延迟计算：Future提供了一种方式来延迟计算，直到需要结果的时候才开始执行。

* 回调：可以使用.then()方法为Future添加回调，当Future完成时，回调将被执行。

* 错误处理：Future可以传递错误，如果异步操作失败，Future将完成为一个错误，可以通过.catchError()添加错误处理回调。

* 链式调用：可以对Future进行链式调用，每个.then()调用都会返回一个新的Future。

* 等待完成：使用await关键字可以等待Future完成，这允许你以同步的方式编写异步代码。

* 执行器：Future可以与async函数一起使用，在async函数中，可以使用await关键字等待Future的完成。

* 惰性性质：Future是惰性的，直到你通过添加回调或者使用await才会开始执行。

## 使用示例

### 1. 创建 Future

你可以使用 `Future` 构造函数创建一个 Future 对象，通常与 `async` 函数一起使用：

```dart
Future<String> getFutureData() {
  return Future<String>.delayed(Duration(seconds: 2), () {
    return 'Data after 2 seconds';
  });
}
```

### 2. 等待 Future 完成

使用 `then` 方法来添加一个回调，当 Future 完成时执行：

```dart
getFutureData().then((data) {
  print(data); // 打印: Data after 2 seconds
});
```

### 3. 错误处理

使用 `catchError` 方法来捕获并处理 Future 中发生的错误：

```dart
Future<void> someAsyncOperation() async {
  try {
    var data = await someOtherAsyncFunction();
    print(data);
  } catch (e) {
    print('An error occurred: $e');
  }
}
```

### 4. 使用 try-catch 块

你可以在 `then` 方法链中使用 try-catch 来捕获异常：

```dart
getFutureData().then((data) {
  print(data);
}).catchError((error) {
  print('An error occurred: $error');
});
```

### 5. 处理 Future 的结果

使用 `Future.value` 来立即解决一个 Future：

```dart
Future<String> immediateFuture = Future.value('Immediate data');
immediateFuture.then((data) {
  print(data); // 打印: Immediate data
});
```

### 6. 链式调用

`Future` 的 `then` 方法返回一个新的 `Future`，这允许你进行链式调用：

```dart
getFutureData()
  .then((data) => data.toUpperCase())
  .then((upperCaseData) => 'Received: $upperCaseData')
  .then((finalData) {
    print(finalData); // 打印: Received: DATA AFTER 2 SECONDS
  });
```

### 7. 等待多个 Future

使用 `Future.wait` 来等待多个 Future 完成：

```dart
Future.wait([
  getFutureData(),
  anotherAsyncFunction()
]).then((List results) {
  print(results[0]); // 打印第一个 Future 的结果
  print(results[1]); // 打印第二个 Future 的结果
});
```

### 8. 使用 async 函数

`async` 标记的函数会返回一个 `Future`，使得异步操作更加简洁：

```dart
Future<void> asyncFunction() async {
  var data = await getFutureData();
  print(data);
}

asyncFunction();
```

### 9. 取消 Future

使用 `Completer` 来创建一个可以取消的 Future：

```dart
Completer<void> completer = Completer();
Future<void> cancelableFuture = completer.future;

// 取消 Future
cancelableFuture.then((_) {
  print('Future was not canceled.');
}).catchError((_) {
  print('Future was canceled.');
});

// 某个条件下取消 Future
if (someCondition) {
  completer.completeError('Future was canceled');
}
```

### 完整示例

下面是一个使用Future的示例：

```dart
import 'dart:async';

// 一个返回Future的示例函数
Future<String> fetchAsString() {
  // 模拟一个异步I/O操作，例如文件读取或网络请求
  return Future.delayed(Duration(seconds: 1), () {
    return 'Some data';
  });
}

void main() async {
  // 使用await等待Future完成
  String data = await fetchAsString();
  print(data); // 打印: Some data
  
  // 使用.then()添加回调
  fetchAsString().then((String result) {
    print(result); // 打印: Some data
  }).catchError((error) {
    print('An error occurred: $error');
  });
}
```

在这个示例中，`fetchAsString`函数返回一个`Future<String>`类型的值，它在一秒后通过`Future.delayed`构造函数完成，并返回字符串"Some data"。在main函数中，使用`await`关键字等待`Future`的完成，然后打印结果。另外，我们也使用了.`then()`方法为`Future`添加了回调函数，以及使用`.catchError()`添加了错误处理。

## 注意事项

* 使用 `await` 关键字只能在 `async` 函数内部使用。
* 错误必须被捕获和处理，否则会传播并可能导致应用程序崩溃。
* 确保不要在异步操作中进行阻塞调用，这会阻止事件循环并降低性能。

## 总结

Future是Dart异步编程的核心概念，它允许你以一种简洁和高效的方式处理异步数据和事件。

---

## 补充

### `.then`调用

实际开发中，发现一种用法：

```dart
initUserInfo() async{
    return DataResult("123", true);
}

Future.delayed(const Duration(seconds: 3),(){
      UserDao.initUserInfo().then((res){// UserDao.initUserInfo()被async修饰

  });
});
```

为啥`UserDao.initUserInfo()`可以调用.then?

答：在实际应用中，通常不需要手动包装同步值到 Future 中，因为 Dart 的异步机制（例如使用 async 函数）会自动处理同步和异步值。因此，initUserInfo函数被async修饰，其返回值是个Future对象（dart类型推断机制）。

# yield

在Dart语言中，yield关键字用于**生成器函数**，它允许函数在执行过程中“暂停”并“返回”一个值给调用者，然后再次从暂停的地方继续执行。这种函数被称为**生成器(generator)**。

生成器函数通常用于惰性计算，即只在需要时才计算下一个值。生成器函数可以返回一个Iterable对象，调用者可以使用for循环或者Iterable的其它方法来迭代生成器函数产生的值。

下面是一个简单的例子，展示了如何使用yield关键字创建一个生成器函数：

```dart
Iterable<int> countTo(int limit) sync* {
  int i = 0;
  while (i < limit) {
    yield i;  // 使用yield返回当前值
    i++;
  }
}

void main() {
  for (var i in countTo(10)) {
    print(i);  // 打印从0到9的数字
  }
}
```

在这个例子中，`countTo`函数是一个生成器函数，它使用`sync*`标识符来声明。`sync*`表示这是一个同步生成器。Dart 2.7引入了异步生成器，使用`async*`来声明。函数体内部的`yield`语句会在每次迭代时返回一个值。

当调用者迭代`countTo(10)`生成的Iterable时，countTo函数会从i = 0开始执行，每次循环都会通过`yield`返回当前的`i`值，直到i达到limit值（在这个例子中是10），然后函数结束，迭代也随之结束。

生成器是Dart中处理数据流的一种非常有用的工具，特别是在处理大量数据或者需要按需生成数据的场景中。

---

## java中的yield

在Java中，`yield`关键字的使用与Dart中的用法有所不同。在Java中，**yield是并发编程中的一部分**，特别是在与`Thread.yield()`方法一起使用时。`Thread.yield()`方法的作用是**让当前线程放弃当前的CPU时间片**，使得线程调度器可以调度其他线程运行。这通常用于线程优先级的管理，尤其是在线程之间需要协调执行顺序时。

下面是一个简单的例子，展示了如何在Java中使用`Thread.yield()`方法：

```java
public class YieldExample {
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            while (true) {
                System.out.println("Thread 1 is running");
                Thread.yield(); // 让出CPU时间片
            }
        });

        Thread thread2 = new Thread(() -> {
            while (true) {
                System.out.println("Thread 2 is running");
                Thread.yield(); // 让出CPU时间片
            }
        });

        thread1.start();
        thread2.start();
    }
}
```

在这个例子中，我们创建了两个线程thread1和thread2，它们都在一个无限循环中运行，并在每次循环时打印一条消息。在打印消息之后，我们调用`Thread.yield()`方法，这会提示线程调度器当前线程愿意让出对CPU的使用权。然而，需要注意的是，`Thread.yield()`并**不保证**线程一定会放弃CPU时间片，这取决于线程调度器的实现。

此外，Java中也有生成器（Generator）的概念，但是它不是通过yield关键字实现的，而是通过`Spliterator接口`和`Stream API`。在Java的Stream API中，并没有直接使用yield关键字，而是通过Stream的各种操作来生成和处理数据流。

例如，你可以使用`Stream.generate()`方法来创建一个无限流，它接受一个`Supplier`函数作为参数，每次调用都会生成一个新值：

```java
Stream.generate(Math::random).limit(5).forEach(System.out::println);
```

在这个例子中，我们使用`Stream.generate()`创建了一个生成随机数的无限流，并通过limit(5)限制它只生成5个元素，然后使用forEach来打印这些随机数。这里的生成逻辑是通过`Supplier`函数`Math::random`实现的，而不是使用yield关键字。

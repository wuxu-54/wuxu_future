# 构造函数

在 Dart 中，**构造函数**是用于创建和初始化类对象的特殊方法。以下是 Dart 构造函数的详细解析，涵盖基本用法、高级特性和最佳实践。

---

## **1. 基本构造函数**

### **默认构造函数**

- 如果未显式定义构造函数，Dart 会自动生成一个无参构造函数。

- 显式定义简单构造函数：

  ```dart
  class Person {
    String name;
    int age;
    
    // 默认构造函数
    Person(this.name, this.age);
  }
  ```

  - 使用 `this.参数` 语法直接初始化成员变量（Dart 特有语法糖）。

---

## **2. 命名构造函数**

- 通过命名提供多个构造函数，解决不同场景下的初始化需求：

  ```dart
  class Person {
    String name;
    int age;
    
    Person(this.name, this.age); // 默认构造函数
    
    // 命名构造函数
    Person.fromBirthYear(String name, int birthYear) {
      this.name = name;
      this.age = DateTime.now().year - birthYear;
    }
  }
  
  // 使用
  var p1 = Person('Alice', 25);
  var p2 = Person.fromBirthYear('Bob', 1995);
  ```

---

## **3. 初始化列表（Initializer List）**

- 在构造函数体执行前初始化 `final` 变量或执行其他逻辑：

  ```dart
  class Point {
    final double x;
    final double y;
    final double distance;
    
    Point(double x, double y)
      : x = x,
        y = y,
        distance = sqrt(x * x + y * y); // 初始化列表
  }
  ```

  - 初始化列表中的表达式会按顺序执行。

---

## **4. 重定向构造函数**

- 一个构造函数调用另一个构造函数，简化代码：

  ```dart
  class Vector {
    final int x, y;
    
    Vector(this.x, this.y);
    
    // 重定向到主构造函数
    Vector.diagonal(int value) : this(value, value);
  }
  ```

---

## **5. 常量构造函数（`const` Constructor）**

- 用于创建编译时常量对象，所有成员变量必须为 `final`：

  ```dart
  class ImmutablePoint {
    final double x, y;
    
    const ImmutablePoint(this.x, this.y);
  }
  
  // 使用
  const p1 = ImmutablePoint(2, 3);
  const p2 = ImmutablePoint(2, 3);
  print(identical(p1, p2)); // true，相同内存对象
  ```

---

## **6. 工厂构造函数（`factory` Constructor）**

- 不总是创建新实例，可用于返回缓存对象或子类实例：

  ```dart
  class Logger {
    final String name;
    static final Map<String, Logger> _cache = {};
    
    factory Logger(String name) {
      return _cache.putIfAbsent(name, () => Logger._internal(name));
    }
    
    Logger._internal(this.name); // 私有构造函数
  }
  
  // 使用
  var logger = Logger('core');
  ```

---

## **7. 私有构造函数**

- 通过 `_` 前缀定义私有构造函数，常用于单例模式：

  ```dart
  class Singleton {
    static final Singleton _instance = Singleton._internal();
    
    // 私有构造函数
    Singleton._internal();
    
    factory Singleton() => _instance;
  }
  ```

---

## **8. 构造函数继承与父类调用**

- 子类构造函数必须调用父类构造函数（显式或隐式）：

  ```dart
  class Animal {
    String name;
    
    Animal(this.name);
  }
  
  class Dog extends Animal {
    String breed;
    
    Dog(String name, this.breed) : super(name); // 调用父类构造函数
  }
  ```

---

## **9. 可选参数与默认值**

- 使用可选参数灵活初始化：

  ```dart
  class Config {
    String host;
    int port;
    bool debug;
    
    Config({
      required this.host,      // 必填参数
      this.port = 8080,         // 默认值
      this.debug = false,       // 默认值
    });
  }
  
  // 使用命名参数
  var config = Config(host: 'api.example.com', debug: true);
  ```

---

## **10. 最佳实践**

1. **优先使用初始化列表**：在初始化 `final` 变量或需要计算初始值时。
2. **避免冗长构造函数**：使用命名构造函数或工厂构造函数拆分逻辑。
3. **利用 `const` 构造函数优化性能**：适用于不可变对象。
4. **明确必填参数**：使用 `required` 关键字强制传递必要参数。
5. **私有化不需要公开的构造函数**：增强代码安全性。

---

## **完整示例**

```dart
class Document {
  final String id;
  final String title;
  final String content;
  final DateTime createdAt;

  // 主构造函数
  Document({
    required this.id,
    required this.title,
    required this.content,
    DateTime? createdAt,
  }) : createdAt = createdAt ?? DateTime.now();

  // 命名构造函数（从 JSON 创建）
  factory Document.fromJson(Map<String, dynamic> json) {
    return Document(
      id: json['id'],
      title: json['title'],
      content: json['content'],
      createdAt: DateTime.parse(json['createdAt']),
    );
  }

  // 重定向构造函数
  Document.empty() : this(
    id: 'default',
    title: 'Untitled',
    content: '',
  );
}

// 使用
var doc1 = Document(
  id: '001',
  title: 'Dart Guide',
  content: '...',
);

var doc2 = Document.fromJson(jsonData);
var doc3 = Document.empty();
```

---

## 资源释放

注：dart没有析构函数， 如果想管理资源可在flutter中的disposed方法中执行释放资源逻辑或使用 `finalize` 库（适用于更底层的资源管理） `dart:ffi` 库中的 Finalizer 类可以用来实现类似析构函数的功能，它可以在对象被垃圾回收时执行特定的清理操作。`Finalizer` 使用示例：

```dart
import 'dart:ffi';
import 'dart:io';

// 模拟一个需要清理的资源
class MyResource {
  final int resourceId;

  MyResource(this.resourceId);

  // 模拟资源清理操作
  void cleanUp() {
    print('Cleaning up resource with ID: $resourceId');
  }
}

void main() {
  // 创建 Finalizer 对象
  final finalizer = Finalizer<MyResource>((resource) {
    resource.cleanUp();
  });

  // 创建资源对象
  var myResource = MyResource(1);

  // 注册 Finalizer
  finalizer.attach(myResource, myResource);

  // 让资源对象不再被引用，触发垃圾回收
  myResource = null as MyResource;

  // 强制进行垃圾回收（仅用于演示）
  System.gc();
  sleep(Duration(seconds: 1));
}
```

---

## **常见错误**

1. **忘记调用父类构造函数**：

   ```dart
   // ❌ 错误
   class Sub extends Super {
     Sub() {} // 缺少 super()
   }
   
   // ✅ 正确
   class Sub extends Super {
     Sub() : super();
   }
   ```

2. **未初始化 `final` 变量**：

   ```dart
   class Demo {
     final int value; // ❌ 未初始化
     Demo();
   }
   ```

3. **错误使用 `factory`**：

   ```dart
   factory Demo() {
     this.value = 5; // ❌ factory 中不能使用 `this`
   }
   ```

---

掌握 Dart 构造函数的不同特性，可以编写出更灵活、高效且安全的代码！

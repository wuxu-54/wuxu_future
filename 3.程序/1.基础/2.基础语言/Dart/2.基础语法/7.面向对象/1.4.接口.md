# 接口

在 Dart 中，接口是一种定义类应该实现哪些方法的契约，它规定了类的行为规范，但不提供具体的实现。
>同java不一样，dart直接以class来定义接口，高版本的dart增加了同java一样的关键字`interface`显示的定义接口，只不过方法没有实现，只能由实现类去实现

以下是关于 Dart 接口的详细介绍：

## 1. 接口的基本概念与使用方式

在 Dart 里，通过 `implements` 关键字让一个类实现一个或多个接口。当一个类实现某个接口时，它必须实现该接口中定义的所有方法。

### 1.1 示例1

```dart
// 定义一个类作为接口
class Drawable {
  void draw();
}

// 定义一个类实现 Drawable 接口
class Circle implements Drawable {
  @override
  void draw() {
    print('Drawing a circle.');
  }
}

void main() {
  Circle circle = Circle();
  circle.draw(); // 输出: Drawing a circle.
}
```

在上述代码中，`Drawable` 类作为接口，它定义了一个 `draw` 方法。`Circle` 类使用 `implements` 关键字实现了 `Drawable` 接口，并且必须提供 `draw` 方法的具体实现。

### 示例2

```dart
//a.dart
interface class Vehicle {
  void moveForward(int meters) {
    // ...
  }
}

//b.dart
// Can be constructed.
Vehicle myVehicle = Vehicle();

// ERROR: Can't be inherited.
class Car extends Vehicle {
  int passengers = 4;
  // ...
}

// Can be implemented.
class MockVehicle implements Vehicle {
  @override
  void moveForward(int meters) {
    // ...
  }
}
```

## 2. 实现多个接口

一个类可以同时实现多个接口，这为类赋予了更丰富的行为。

```dart
// 定义第一个接口
class Printable {
  void printInfo();
}

// 定义第二个接口
class Resizable {
  void resize();
}

// 定义一个类实现多个接口
class Square implements Printable, Resizable {
  @override
  void printInfo() {
    print('This is a square.');
  }

  @override
  void resize() {
    print('Resizing the square.');
  }
}

void main() {
  Square square = Square();
  square.printInfo(); // 输出: This is a square.
  square.resize(); // 输出: Resizing the square.
}
```

这里，`Square` 类同时实现了 `Printable` 和 `Resizable` 两个接口，因此需要实现这两个接口中定义的所有方法。

## 3. 接口与抽象类的区别

虽然接口和抽象类都可以定义类的行为规范，但它们有一些明显的区别：

- **实现方式**：接口使用 `implements` 关键字，一个类可以实现多个接口；而抽象类使用 `extends` 关键字，一个类只能继承一个抽象类。
- **方法实现**：接口中的方法必须全部由实现类提供具体实现；抽象类中可以有抽象方法（需要子类实现），也可以有具体方法（子类可以直接使用或重写）。

```dart
// 定义抽象类
abstract class Shape {
  // 抽象方法
  double area();

  // 具体方法
  void printShapeType() {
    print('This is a shape.');
  }
}

// 定义接口
class Colorable {
  void setColor(String color);
}

// 定义一个类继承抽象类并实现接口
class Rectangle extends Shape implements Colorable {
  final double width;
  final double height;

  Rectangle(this.width, this.height);

  @override
  double area() {
    return width * height;
  }

  @override
  void setColor(String color) {
    print('Setting rectangle color to $color.');
  }
}

void main() {
  Rectangle rectangle = Rectangle(4, 6);
  rectangle.printShapeType(); // 输出: This is a shape.
  print('Rectangle area: ${rectangle.area()}'); // 输出: Rectangle area: 24
  rectangle.setColor('blue'); // 输出: Setting rectangle color to blue.
}
```

在这个例子中，`Rectangle` 类继承了 `Shape` 抽象类，实现了 `Colorable` 接口。它必须实现 `Shape` 类的抽象方法 `area` 和 `Colorable` 接口的 `setColor` 方法，同时可以直接使用 `Shape` 类的具体方法 `printShapeType`。

## 4. 接口的作用

- **规范行为**：接口为类提供了明确的行为规范，使得不同的类可以遵循相同的标准，提高了代码的可维护性和可扩展性。
- **实现多态**：通过接口可以实现多态性，不同的类实现同一个接口，在使用时可以将这些类的对象赋值给接口类型的变量，从而实现不同的行为。

```dart
// 定义接口
class Playable {
  void play();
}

// 定义实现类
class Song implements Playable {
  @override
  void play() {
    print('Playing a song.');
  }
}

class Video implements Playable {
  @override
  void play() {
    print('Playing a video.');
  }
}

void startPlaying(Playable playable) {
  playable.play();
}

void main() {
  Song song = Song();
  Video video = Video();

  startPlaying(song); // 输出: Playing a song.
  startPlaying(video); // 输出: Playing a video.
}
```

在这个示例中，`Song` 和 `Video` 类都实现了 `Playable` 接口，`startPlaying` 函数接收一个 `Playable` 类型的参数，根据传入的实际对象类型调用不同的 `play` 方法，实现了多态。

综上所述，接口在 Dart 中是一种强大的工具，它有助于提高代码的灵活性、可维护性和可扩展性，使得代码更加符合面向对象的设计原则。

# 密封类

在 Dart 中，`sealed class`（密封类）是 Dart 2.17 引入的一个特性，它用于限制类的继承，使得只有在同一库中定义的子类才能继承该密封类。这为代码的安全性和可维护性提供了保障，尤其是在处理模式匹配时非常有用。
>跟kotlin中的一样

以下是关于 Dart 中密封类的详细介绍：

## 1. 基本定义和语法

密封类使用 `sealed` 关键字来定义，它可以包含抽象方法，也可以有具体的实现。密封类不能直接实例化，必须通过其子类来创建对象。

```dart
// 定义一个密封类
sealed class Shape {
  double area();
}

// 定义密封类的子类
class Circle extends Shape {
  final double radius;

  Circle(this.radius);

  @override
  double area() {
    return 3.14 * radius * radius;
  }
}

class Rectangle extends Shape {
  final double width;
  final double height;

  Rectangle(this.width, this.height);

  @override
  double area() {
    return width * height;
  }
}
```

## 2. 密封类的使用场景

### 模式匹配

密封类在模式匹配中特别有用，因为编译器可以确保所有可能的子类都被处理。

```dart
void printArea(Shape shape) {
  switch (shape) {
    case Circle(:final radius):
      print('Circle area: ${3.14 * radius * radius}');
    case Rectangle(:final width, :final height):
      print('Rectangle area: ${width * height}');
  }
}

void main() {
  Shape circle = Circle(5);
  Shape rectangle = Rectangle(4, 6);

  printArea(circle); // 输出: Circle area: 78.5
  printArea(rectangle); // 输出: Rectangle area: 24
}
```

### 数据类型的层次结构

当你需要定义一组相关的数据类型，并且希望限制这些类型的扩展时，可以使用密封类。例如，定义一个表示不同类型事件的层次结构。

```dart
sealed class Event {}

class UserLoggedIn extends Event {
  final String username;

  UserLoggedIn(this.username);
}

class UserLoggedOut extends Event {}

void handleEvent(Event event) {
  switch (event) {
    case UserLoggedIn(:final username):
      print('User $username logged in.');
    case UserLoggedOut():
      print('User logged out.');
  }
}

void main() {
  Event loginEvent = UserLoggedIn('John');
  Event logoutEvent = UserLoggedOut();

  handleEvent(loginEvent); // 输出: User John logged in.
  handleEvent(logoutEvent); // 输出: User logged out.
}
```

## 3. 密封类的继承规则

- **同一库限制**：只有在定义密封类的同一库中才能定义该密封类的子类。这确保了密封类的层次结构是可控的，外部库无法随意扩展该类。
- **子类类型**：密封类的子类可以是具体类，也可以是抽象类。如果是抽象类，它还可以有自己的子类。

```dart
// 定义一个密封类
sealed class Animal {
  void makeSound();
}

// 定义一个抽象子类
abstract class Mammal extends Animal {}

// 定义具体子类
class Dog extends Mammal {
  @override
  void makeSound() {
    print('Woof!');
  }
}

class Cat extends Mammal {
  @override
  void makeSound() {
    print('Meow!');
  }
}
```

## 4. 密封类与普通类的区别

- **继承限制**：普通类可以被任何其他类继承，而密封类只能在同一库中被继承。
- **模式匹配支持**：密封类在模式匹配时，编译器可以进行完整性检查，确保所有可能的子类都被处理。而普通类没有这种支持。

## 5. 注意事项

- **密封类的可见性**：密封类的可见性（如 `public`、`private` 等）会影响其子类的定义和使用。如果密封类是私有的，那么它的子类也只能在同一库中使用。
- **编译时检查**：密封类的主要优势在于编译时的安全性和类型检查。在使用模式匹配时，编译器会检查是否覆盖了所有可能的子类情况，避免遗漏。

综上所述，密封类是 Dart 中一个强大的特性，它提供了一种安全、可控的方式来定义类的层次结构，特别是在需要进行模式匹配和数据类型管理的场景中非常有用。

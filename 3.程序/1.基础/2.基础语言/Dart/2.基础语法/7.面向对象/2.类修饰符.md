# 类修饰符

在 Dart 语言中，类修饰符用于定义类的可见性和行为。以下是一些常用的类修饰符：

1. abstract：定义一个抽象类。抽象类不能被实例化，通常包含一些未实现的方法，这些方法由继承该抽象类的子类实现。

    ```dart
    abstract class Animal {
      void makeSound();
    }
    ```

2. sealed：定义一个封闭类。封闭类不能被继承，除非它在同一个库中。

    ```dart
    sealed class Shape {}
    ```

3. enum：定义一个枚举类。枚举类是一种特殊的类，它只能有一个或多个常量值。

    ```dart
    enum Color { red, green, blue }
    ```

4. final：定义一个最终类。最终类不能被继承。

   ```dart
   final class ImmutableClass {}
   ```

5. const：定义一个常量构造函数，用于创建不可变的实例。

   ```dart
    class Point {
      final int x;
      final int y;
      
      const Point(int x, int y) : x = x, y = y {
        // ...
      }
    }
   ```

6. factory：定义一个工厂构造函数。工厂构造函数用于控制类的实例化过程，可以返回任何类型的实例。

    ```dart
    class FactoryExample {
      factory FactoryExample.fromString(String str) {
        // ...
        return new FactoryExample();
      }
    }
    ```

7. typedef：定义一个函数类型别名。这不是一个类修饰符，但它可以用来定义类成员的类型。

    ```dart
    typedef void MyCallback(int value);
    class MyClass {
      MyCallback callback;
    }
    ```

8. extension：定义一个扩展，为现有类添加新的方法或属性。

    ```dart
    extension StringExtension on String {
      String toTitleCase() {
        // ...
      }
    }
    ```

9. implements：用于类实现接口。

    ```dart
    abstract class MyInterface {
      void doSomething();
    }

    class MyClass implements MyInterface {
      void doSomething() {
        // ...
      }
    }
    ```

10. with：用于混入（mixin），允许一个类继承另一个类的代码。

    ```dart
    mixin MyMixin {
      void doSomething() {
        // ...
      }
    }

    class MyClass with MyMixin {
      // ...
    }
    ```

这些修饰符提供了强大的工具来控制类的继承、实例化和行为，使得 Dart 语言在面向对象编程方面更加灵活和强大。

---

## 补充

修饰符：`abstract`、`base`、`final`、`interface`、`sealed` 和 `mixin` 。其中`base`、`interface`是高版本新增的
>我理解新增是为了明确class的职责范围。将接口和抽象类区分。`base`使得子类只能被继承，无法被实现。`interface`使得实现类只能被implements，不能被extends。

这些修饰符在类的定义和使用中有着不同的作用，下面为你详细介绍：

### 1. `abstract` 修饰符

`abstract` 用于定义抽象类。抽象类不能被实例化，主要用于定义一些通用的接口或行为，供子类继承和实现。抽象类中可以包含抽象方法（只有声明，没有实现）和具体方法（有实现）。

**示例代码**：

```dart
// 定义一个抽象类
abstract class Animal {
  // 抽象方法，子类必须实现
  void makeSound();

  // 具体方法
  void eat() {
    print('Animal is eating.');
  }
}

// 子类继承抽象类并实现抽象方法
class Dog extends Animal {
  @override
  void makeSound() {
    print('Woof!');
  }
}

void main() {
  // Animal animal = Animal(); // 错误，抽象类不能实例化
  Dog dog = Dog();
  dog.makeSound(); // 输出: Woof!
  dog.eat(); // 输出: Animal is eating.
}
```

### 2. `base` 修饰符

Dart高版本增加了`base` 修饰符。要强制继承类或mixin的实现，请使用基修饰符。基类不允许在自己的库之外实现。这个担保:

- 每当创建类的子类型的实例时，就调用基类构造函数。
- 所有实现的私有成员都存在于子类型中。
- 基类中新实现的成员不会破坏子类型，因为所有子类型都继承新成员。
  - 除非子类型已经声明了具有相同名称和不兼容签名的成员，否则是正确的。

必须将实现或继承基类的任何类标记为基类、final类或密封类。这可以防止外部库破坏基类的保证。

>@武旭：个人理解，base修饰后，子类必须调用父类构造，且子类可以拥有所有基类的私有成员。子类也必须用base修饰。

**示例代码**：

```dart
//a.dart
base class Vehicle {
  void moveForward(int meters) {
    // ...
  }
}

//b.dart
// Can be constructed.
Vehicle myVehicle = Vehicle();

// Can be extended.
base class Car extends Vehicle {
  int passengers = 4;
  // ...
}

// ERROR: Can't be implemented.
base class MockVehicle implements Vehicle {
  @override
  void moveForward() {
    // ...
  }
}
```

### 3. `final` 修饰符

`final` 修饰符可以用于类和变量。当用于类时，`final` 类不能被继承，意味着它是一个最终类，不能有子类。

**示例代码**：

```dart
// 定义一个 final 类
final class ImmutableClass {
  final int value;

  ImmutableClass(this.value);
}

// 以下代码会报错，因为 final 类不能被继承
// class SubClass extends ImmutableClass {} 

void main() {
  ImmutableClass obj = ImmutableClass(10);
  print(obj.value); // 输出: 10
}
```

### 4. `interface` 修饰符

Dart 高版本增加了 `interface` 关键字。用于显示定义了一个接口，该接口包含了类的所有实例成员（方法和属性）。如果一个类要实现另一个类的接口，需要使用 `implements` 关键字。

**示例代码**：

```dart
//a.dart
interface class Vehicle {
  void moveForward(int meters) {
    // ...
  }
}

//b.dart
// Can be constructed.
Vehicle myVehicle = Vehicle();

// ERROR: Can't be inherited.
class Car extends Vehicle {
  int passengers = 4;
  // ...
}

// Can be implemented.
class MockVehicle implements Vehicle {
  @override
  void moveForward(int meters) {
    // ...
  }
}
```

### 5. `sealed` 修饰符

`sealed` 修饰符用于定义密封类。密封类可以有子类，但这些子类必须在与密封类相同的库中定义。密封类通常用于限制类的继承层次结构，使得代码更加安全和可维护。

**示例代码**：

```dart
// 定义一个密封类
sealed class Color {}

// 子类必须在同一个库中定义
class Red extends Color {}
class Blue extends Color {}

void main() {
  Color red = Red();
  Color blue = Blue();
}
```

### 6. `mixin` 修饰符

`mixin` 用于定义可复用的代码块，可以在多个类中共享。`mixin` 不能被实例化，它的主要作用是为类提供额外的功能。

**示例代码**：

```dart
// 定义一个 mixin
mixin Flyable {
  void fly() {
    print('Flying...');
  }
}

// 类使用 mixin
class Bird with Flyable {}

void main() {
  Bird bird = Bird();
  bird.fly(); // 输出: Flying...
}
```

综上所述，这些修饰符在 Dart 中各自有着独特的用途，合理使用它们可以提高代码的可维护性和可扩展性。

---

## 组合使用修饰符

您可以为分层限制组合一些修饰符。一个类的声明可以是：

- （可选）abstract，描述类是否可以包含抽象成员并防止实例化。
- （可选）base、interface、final或sealed 中的一种，描述对其他类子类化的限制。
- （可选）mixin，描述是否可以混合声明。
- class关键字本身。

你不能把一些修饰语组合在一起，因为它们是矛盾的、冗余的或互斥的：

- abstract 与 sealed.。密封类是隐式抽象的。
- interface 或 final 或 sealed 与 mixin。这些访问修饰符防止混入。

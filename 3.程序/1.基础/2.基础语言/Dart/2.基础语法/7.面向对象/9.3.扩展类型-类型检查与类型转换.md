# 扩展类型的类型检查与类型转换

在 Dart 语言中，**扩展类型（Extension Types）** 是 Dart 3.0 引入的新特性，允许开发者基于现有类型（称为“表示类型”）创建新的类型，同时保持零运行时开销。扩展类型主要用于在不改变内存布局的情况下，为现有类型添加额外的接口或约束行为，同时保持类型系统的安全性。

以下是关于 **扩展类型的类型检查与类型转换** 的详细说明：

---

## **一、扩展类型的基本概念**

### **1. 定义扩展类型**

```dart
// 基于 int 类型声明一个扩展类型
extension type MyInt(int value) {
  // 可以添加自定义方法或属性
  void printValue() => print('Value: $value');
}
```

- **表示类型（Representation Type）**：`int value` 是底层存储的类型。
- **扩展类型**：`MyInt` 是基于 `int` 的包装器，但类型系统中视为独立类型。

### **2. 核心特性**

- **零运行时开销**：编译后会被擦除，直接使用底层类型的运行时表示。
- **类型独立性**：尽管基于 `int`，但 `MyInt` 和 `int` 在类型系统中是不同的类型。

---

## **二、类型检查**

### **1. 显式类型检查**

扩展类型与表示类型在类型系统中严格分离：

```dart
void main() {
  MyInt myInt = MyInt(42);
  int rawInt = 42;

  print(myInt is int);    // false：扩展类型实例不是表示类型
  print(rawInt is MyInt); // false：表示类型实例不是扩展类型
}
```

### **2. 隐式类型兼容性**

扩展类型默认不继承表示类型的接口，但可以通过 `implements` 声明兼容性：

```dart
extension type MyInt(int value) implements int {
  // 显式实现表示类型的接口
  void printValue() => print('Value: $value');
}

void main() {
  MyInt myInt = MyInt(42);
  print(myInt + 1);      // 43：通过 `implements int` 继承运算符
  print(myInt is int);   // true：因实现了接口，类型检查通过
}
```

---

## **三、类型转换**

### **1. 显式转换**

- **扩展类型 → 表示类型**：直接访问 `.value` 成员：

  ```dart
  MyInt myInt = MyInt(42);
  int rawInt = myInt.value; // 42
  ```

- **表示类型 → 扩展类型**：通过构造函数转换：

  ```dart
  int rawInt = 42;
  MyInt myInt = MyInt(rawInt);
  ```

### **2. 强制类型转换（`as` 操作符）**

- **无效转换**：若未声明 `implements`，强制转换会抛出错误：

  ```dart
  MyInt myInt = MyInt(42);
  int rawInt = myInt as int; // 运行时错误：TypeError
  ```

- **有效转换**：若通过 `implements` 声明兼容性：

  ```dart
  extension type MyInt(int value) implements int {}

  void main() {
    MyInt myInt = MyInt(42);
    int rawInt = myInt as int; // 合法，但实际无需转换（可直接赋值）
  }
  ```

### **3. 隐式转换**

默认不存在隐式转换，必须显式操作：

```dart
void func(int x) {}

void main() {
  MyInt myInt = MyInt(42);
  func(myInt);          // 编译错误：类型不匹配
  func(myInt.value);    // 正确
}
```

---

## **四、类型系统的核心规则**

| **行为**                  | **无 `implements`**         | **有 `implements T`**       |
|--------------------------|-----------------------------|-----------------------------|
| 扩展类型实例 `is T`       | false                       | true                        |
| T 实例 `is` 扩展类型      | false                       | false                       |
| 扩展类型可赋值给 `T`      | 否                          | 是                          |
| 可调用 `T` 的方法/运算符 | 否（除非显式暴露）          | 是                          |

---

## **五、实际应用场景**

### **1. 添加类型安全约束**

```dart
// 定义一个仅允许正数的扩展类型
extension type PositiveInt(int value) {
  PositiveInt(this.value) : assert(value > 0);
}

void processValue(PositiveInt value) { ... }

void main() {
  processValue(PositiveInt(10)); // 合法
  processValue(10);              // 编译错误：类型不匹配
}
```

### **2. 封装底层类型**

```dart
// 封装字符串表示的电话号码
extension type PhoneNumber(String value) {
  static final _regex = RegExp(r'^\+?[0-9]{8,15}$');

  PhoneNumber(this.value) : assert(_regex.hasMatch(value));

  String get formatted => '+86 $value';
}
```

---

## **六、总结**

- **类型独立性**：扩展类型默认与表示类型是独立类型，需显式声明 `implements` 才能兼容。
- **类型检查**：使用 `is` 操作符时，扩展类型实例不会被视为表示类型（除非实现接口）。
- **类型转换**：必须通过 `.value` 或构造函数显式转换，无隐式转换。
- **设计目标**：在保持零开销的前提下，增强类型安全和封装性。

通过合理使用扩展类型，可以在不牺牲性能的情况下，为现有类型添加类型安全和语义约束。

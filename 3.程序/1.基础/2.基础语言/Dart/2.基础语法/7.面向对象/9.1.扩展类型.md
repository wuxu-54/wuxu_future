# 扩展类型

dart中的扩展类型，是对类型的扩展。扩展类型是在静态的，在编译时确定，所以不会有性能问题。
> 2024年发布的，Dart3.3中的内容

解释：扩展类型，相当于**传入数据类型的包装器**。对传入的类型进行相应的代码扩展。开发者实例化后后，可以调用其中的代码。在编译时，实例化是此扩展类型，但**编译后其实就是传入的数据类型**，通过 `as` 可显示转换为传入数据类型 避免编译时报错。
>个人的通俗理解：扩展类型可以看成是一个类，其有自己的构造函数、方法。本质是传入类型+对传入类型的扩展方法。只是通过此定义将二者关联起来了。如 传入类型是int，那么基于此的扩展类型，在使用时，实例化后的数据类型是int，然后给int增加了一些扩展的内容。

## 语法

使用 `extension type` 定义类型。

扩展类型的基本语法如下：

```dart
extension type <ExtensionTypeName>(<UnderlyingType> value) {
  // 可以定义构造函数、方法、字段等
}
```

- `<ExtensionTypeName>`：扩展类型的名称，这是新创建的类型的名称。
- `<UnderlyingType>`：基础类型，即被扩展的原始类型。
- `value`：一个参数，用于存储基础类型的值。

### 示例1

```dart
//包装 int 类型
extension type IdNumber(int id) {

  operator <(IdNumber other) => id < other.id;
}

void main() {
  int myUnsafeId = 42424242;
  myUnsafeId = myUnsafeId + 10; 

  var safeId = IdNumber(42424242);// 编译后 IdNumber 会被编译为int类型
  safeId + 10; // 编译时报错，在编译时是IdNumber类型，Compile-time error: No '+' operator.
  myUnsafeId = safeId; //编译时报错，在编译时是IdNumber类型 Compile-time error: Wrong type.
  myUnsafeId = safeId as int; //显示转换为int类型，避免编译时报错。 OK: Run-time cast to representation type.
  safeId < IdNumber(42424241); // OK: Uses wrapped '<' operator.
}
```

### 示例2

```dart
// 定义一个扩展类型
extension type NonNegativeInt(int value) {
  // 构造函数，用于验证输入的值是否为非负
  NonNegativeInt._(int val) : this(val >= 0 ? val : throw ArgumentError('Value must be non-negative'));

  // 工厂构造函数，方便创建实例
  factory NonNegativeInt(int val) => NonNegativeInt._(val);

  // 添加一个方法，用于获取平方值
  int square() => value * value;
}

void main() {
  // 创建一个 NonNegativeInt 实例
  NonNegativeInt num = NonNegativeInt(5);

  // 调用扩展类型的方法
  int result = num.square();
  print('The square of 5 is $result');

  // 尝试创建一个负数的 NonNegativeInt 实例，会抛出异常
  try {
    NonNegativeInt negativeNum = NonNegativeInt(-1);
  } catch (e) {
    print('Error: $e');
  }
}
```

代码解释:

- 定义扩展类型：extension type NonNegativeInt(int value) 定义了一个名为 NonNegativeInt 的扩展类型，它包装了 int 类型的值。
- 构造函数：NonNegativeInt._(int val) 是一个私有构造函数，用于验证输入的值是否为非负。factory NonNegativeInt(int val) 是一个工厂构造函数，它调用私有构造函数来创建实例。
- 方法：int square() 是一个添加到扩展类型的方法，用于计算包装的整数的平方。
- 使用扩展类型：在 main 函数中，我们创建了一个 NonNegativeInt 实例，并调用了 square 方法。尝试创建一个负数的 NonNegativeInt 实例会抛出异常。

## 扩展类型的优点

- 类型安全：扩展类型创建了一个新的类型，这有助于提高代码的类型安全性。例如，在上面的示例中，NonNegativeInt 类型明确表示它只能包含非负整数。
- 封装性：扩展类型可以封装额外的逻辑和行为，而不会影响原始类型。这使得代码更加模块化和易于维护。
- 代码复用：可以为不同的基础类型创建相同的扩展类型，从而实现代码的复用。

## 注意事项

- 扩展类型的实例可以通过 value 属性访问其基础类型的值。
- 扩展类型不能继承自其他类，但可以实现接口。
- 扩展类型不能重写基础类型的方法。

## implements

使用`implements` ，扩展类型可以调用所有被实现的类。

示例：

```dart
extension type NumberI(int i) implements int{
    //NumberI 可以使用 int中所有方法
}

//也允许泛型
extension type Sequence<T>(List<T> _) implements Iterable<T> {
  // Better operations than List.
}

extension type Id(int _id) implements Object {
  // Makes the extension type non-nullable.
  static Id? tryParse(String source) => int.tryParse(source) as Id?;
}

//-------
extension type const Opt<T>._(({T value})? _) { 
  const factory Opt(T value) = Val<T>;
  const factory Opt.none() = Non<T>;
}
extension type const Val<T>._(({T value}) _) implements Opt<T> { 
  const Val(T value) : this._((value: value));
  T get value => _.value;
}
extension type const Non<T>._(Null _) implements Opt<Never> {
  const Non() : this._(null);
}
```

## @redeclare

表示不是超类的成员，是自己单独设置的，所以会覆盖超类。

```dart
extension type MyString(String _) implements String {
  // Replaces 'String.operator[]'
  @redeclare
  int operator [](int index) => codeUnitAt(index);
}
```

# get与set

在 Dart 语言中，`set` 和 `get` 是关键字，用于定义类的属性访问器（Accessors），它们是实现封装的重要工具。封装是面向对象编程的一个核心概念，它隐藏了对象的内部状态和实现细节，只暴露出一个可以被外界访问和修改的接口。
>dart中，其本质是个方法。只是在语义上与普通方法不同，更侧重作为**属性**的语义表示

## `get` 关键字：定义 getter

- `get` 关键字用于定义一个 getter，它是一个没有参数、没有返回值、并且总是与一个属性名相关联的方法。getter 用于读取私有变量的值。
- getter 可以用于计算属性，即基于对象的当前状态动态计算并返回一个值。
- getter 可以是同步的，也可以是异步的（如果它们返回一个 `Future`）。

### 示例：使用 `get` 定义只读属性

```dart
class Rectangle {
  double _width, _height;

  // 使用 get 定义只读属性
  double get area => _width * _height;

  Rectangle(double width, double height) : _width = width, _height = height;
}
```

在这个例子中，`area` 是一个只读属性，它通过 `get` 关键字定义。

## `set` 关键字：定义 setter

- `set` 关键字用于定义一个 setter，它是一个有参数、没有返回值，并且总是与一个属性名相关联的方法。setter 用于写入或修改私有变量的值。
- setter 可以包含逻辑来验证或处理设置的值，例如执行类型检查、范围检查或执行其他自定义逻辑。

### 示例：使用 `set` 定义可设置属性

```dart
class Rectangle {
  double _width, _height;

  double get width => _width;
  set width(double value) {
    if (value > 0) {
      _width = value;
    } else {
      throw Exception('Width must be positive');
    }
  }

  // _height 的 getter 和 setter 也可以类似定义
}
```

在这个例子中，`width` 属性通过 `get` 和 `set` 关键字定义。setter 包含了逻辑来确保宽度值是正数。

## 作用和用途

1. **封装**：通过使用 `get` 和 `set`，可以将数据（属性）和对数据的操作（方法）组合在一起，隐藏内部实现细节。
2. **数据验证**：在 setter 中，可以添加逻辑来验证设置的值，确保数据的有效性。
3. **计算属性**：getter 可以返回基于当前对象状态计算的值，而不是直接返回一个字段。
4. **延迟初始化**：可以在 getter 中实现延迟初始化逻辑，即直到第一次访问时才计算属性值。
5. **控制访问**：通过定制 getter 和 setter，可以控制对属性的访问，例如，可以定义一个属性为只读。

## 注意事项

- 使用 `get` 和 `set` 时，Dart 编译器会自动处理属性访问的语法糖，使得访问属性就像访问变量一样。
- Dart 允许使用更简洁的属性声明语法，例如，可以直接写 `int _width;` 而不是 `int get width => _width;`。
- 过度使用 getter 和 setter 可能会使代码变得冗长，因此应根据实际需要使用。

通过使用 `get` 和 `set`，Dart 为开发者提供了一种灵活的方式来控制对类成员变量的访问，同时保持代码的封装性和安全性。

---

## 访问器（即 getter 和 setter）和普通无参函数 之间的区别

在 Dart 中，访问器（即 getter 和 setter）和普通无参函数在功能上有相似之处，但也存在一些区别，并且一般情况下访问器不会额外增加内存。下面详细介绍它们的区别以及内存相关情况。

### 区别

#### 1. 语法和调用方式

- **访问器**：
  - 访问器是一种特殊的属性，使用 `get` 和 `set` 关键字定义。调用时就像访问普通属性一样，不需要使用括号。
  - **示例代码**：

```dart
class Rectangle {
  double _width = 0;
  double _height = 0;

  // getter 访问器
  double get area {
    return _width * _height;
  }

  // setter 访问器
  set width(double value) {
    if (value > 0) {
      _width = value;
    }
  }
}

void main() {
  Rectangle rect = Rectangle();
  rect.width = 5; // 使用 setter 访问器
  double area = rect.area; // 使用 getter 访问器
  print('矩形面积: $area');
}
```

- **普通无参函数**：
  - 普通无参函数使用 `void` 或返回类型来定义，调用时需要使用括号。
  - **示例代码**：

```dart
class Rectangle {
  double _width = 0;
  double _height = 0;

  // 普通无参函数
  double calculateArea() {
    return _width * _height;
  }

  void setWidth(double value) {
    if (value > 0) {
      _width = value;
    }
  }
}

void main() {
  Rectangle rect = Rectangle();
  rect.setWidth(5); // 调用普通无参函数
  double area = rect.calculateArea(); // 调用普通无参函数
  print('矩形面积: $area');
}
```

#### 2. 语义和可读性

- **访问器**：
  - 访问器更强调属性的访问，给人一种该属性是对象固有特性的感觉。例如，`rect.area` 就像在访问矩形的一个固有属性，语义上更自然。
- **普通无参函数**：
  - 普通无参函数更强调行为或操作。例如，`rect.calculateArea()` 明确表示这是一个计算面积的操作。

#### 3. 封装性

- **访问器**：
  - 访问器可以隐藏内部实现细节，通过 getter 和 setter 来控制对私有属性的访问。例如，在 setter 中可以添加验证逻辑，确保属性值的合法性。
- **普通无参函数**：
  - 普通无参函数也可以实现封装，但在语义上不如访问器直接与属性关联紧密。

### 内存方面

一般情况下，访问器不会额外增加内存。原因如下：

- **实现机制**：访问器本质上也是方法，在 Dart 虚拟机中，它们的实现和普通方法类似。当定义一个访问器时，并不会因为它是访问器就占用额外的内存空间。
- **调用方式**：访问器的调用方式虽然看起来像属性访问，但实际上在运行时会执行相应的方法体。这个过程和调用普通方法的内存开销是相似的，不会因为语法上的不同而导致额外的内存消耗。

综上所述，访问器和普通无参函数在语法、语义和封装性上有所不同，但在内存占用方面基本没有差异。开发者可以根据具体的需求和场景来选择使用访问器还是普通无参函数。

# 扩展方法

dart 中不同于kotlin，dart里是对类的扩展，而不是对方法。

以下是扩展方法的一些关键点：

* 使用 `extension` 关键字：定义扩展方法时，使用 `extension` 关键字。

* 指定扩展的类：在 `extension` 关键字后面，指定你想要扩展的类名。

* 定义成员：在扩展中，你可以定义方法、访问器、运算符等，就像在正常的类中一样。

* 成员的调用：扩展方法可以像普通类成员一样被调用。

* 编译时行为：扩展方法在编译时被处理，它们不会在运行时增加类的实例大小。

* 静态成员：扩展方法实际上是静态的，但它们表现得就像是类的实例方法。

* 作用域：扩展方法定义在库（library）级别，不能嵌套在其他类或方法中。

* 冲突解决：如果扩展方法与类的现有成员或其他扩展方法冲突，需要使用命名空间或者方法重载来解决。

## 示例

```dart
extension DoubleExtensions on double {
  // 扩展double类型的一个方法
  String toCurrencyString() {
    return '\$${this.toStringAsFixed(2)}';
  }

  // 扩展double类型的另一个方法
  double timesTwo() {
    return this * 2;
  }
}

void main() {
  var salary = 1500.0;
  print(salary.toCurrencyString()); // 输出: $1500.00
  print(salary.timesTwo());         // 输出: 3000.0
}
```

在这个例子中：

* 使用 `extension` 关键字定义了一个名为 `DoubleExtensions` 的扩展方法，它扩展了 `double` 类型。
* 在扩展中定义了两个方法：`toCurrencyString()` 和 `timesTwo()`。
* 扩展方法通过 `on` 关键字后跟类名指定它们所扩展的类，这里是 `double`。
* 在 `main` 函数中，普通的 `double` 类型的变量 `salary` 可以使用扩展方法，就像它们是 `double` 类型的一部分一样。

## 冲突解决

在Dart中，如果多个库为同一个类提供了同名的扩展方法，就会导致扩展方法冲突。解决这种冲突通常有以下几种方法：

1. 使用 show 或 hide 关键字：在导入库时，可以使用 show 来指定你想要使用的扩展方法，或者使用 hide 来隐藏你不想使用的扩展方法。例如：

    ```dart
    import 'library1.dart'; // 包含 NumberParsing 扩展
    import 'library2.dart' hide NumberParsing; // 隐藏 library2 中的 NumberParsing 扩展
    ```

2. 显示指定扩展类型：如果两个扩展类具有相同的名称，可以通过显示指定扩展类型来解决冲突。

    例如：

    ```dart
    import 'library1.dart';
    import 'library2.dart';
    print(NumberParsing('42').parseInt()); // 使用 library1 中的扩展
    print(NumberParsing2('42').parseInt()); // 使用 library2 中的扩展
    ```

3. 使用前缀：如果两个库中的扩展类型名称不同，可以使用前缀来区分它们。例如：

    ```dart
    import 'library1.dart';
    import 'library2.dart' as rad;
    print(rad.NumberParsing('42').parseInt()); // 使用 library2 中的扩展
    ```

4. 重命名本地扩展：如果扩展方法是在本地库中定义的，可以给扩展类或方法重命名，以避免与第三方库中的扩展方法冲突。

5. 选择性导入：只导入需要使用的扩展方法，而不是整个库。

6. 使用局部扩展：在函数或方法内部定义扩展方法，使其只对特定作用域有效。

7. 组合使用：可以结合使用上述方法，如通过 show 和 hide 与前缀一起使用，以实现更精细的控制。

请注意，dynamic 类型的变量不能使用扩展方法，因为扩展方法的解析是在编译时基于静态类型进行的。此外，由于扩展方法是基于静态类型的，它们与静态方法一样高效。

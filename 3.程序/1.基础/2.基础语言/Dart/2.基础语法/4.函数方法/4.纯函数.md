
# 纯函数

在 Dart 中，纯函数是一种特殊类型的函数，它具有一些重要特性，在函数式编程中扮演着关键角色。下面为你详细介绍 Dart 纯函数。

## 定义与特性

纯函数需满足两个主要特性：

1. **相同输入产生相同输出**：无论何时调用纯函数，只要输入参数相同，它都会返回相同的结果。这意味着函数的输出仅由输入决定，不受外部状态或变量的影响。
2. **无副作用**：纯函数不会对外部环境产生任何可观察的变化，比如不修改全局变量、不进行 I/O 操作（如文件读写、网络请求）等。

### 示例代码

以下是一个简单的 Dart 纯函数示例：

```dart
// 计算两个整数的和
int add(int a, int b) {
  return a + b;
}

void main() {
  int result = add(3, 5);
  print(result); // 输出 8
}
```

在上述代码中，`add` 函数就是一个纯函数。它接收两个整数参数 `a` 和 `b`，返回它们的和。无论何时调用 `add(3, 5)`，都会得到相同的结果 `8`，并且该函数没有对外部环境产生任何影响。

## 纯函数的优势

1. **可测试性**：由于纯函数的输出只依赖于输入，因此很容易编写测试用例。你只需提供不同的输入，检查输出是否符合预期即可。

    ```dart
    void main() {
    int testResult = add(2, 4);
    if (testResult == 6) {
        print('Test passed!');
    } else {
        print('Test failed!');
    }
    }
    ```

2. **可维护性**：纯函数的逻辑相对独立，不依赖于外部状态，因此更容易理解和维护。当需要修改函数逻辑时，只需关注函数内部的代码，而不必担心对其他部分产生影响。
3. **并行处理**：因为纯函数没有副作用，所以可以安全地在多个线程或进程中并行执行，从而提高程序的性能。

### 非纯函数示例

以下是一个非纯函数的示例：

```dart
int globalVariable = 0;

// 非纯函数，修改了全局变量
int incrementGlobal() {
  globalVariable++;
  return globalVariable;
}

void main() {
  int firstResult = incrementGlobal();
  int secondResult = incrementGlobal();
  print(firstResult); // 输出 1
  print(secondResult); // 输出 2
}
```

在这个例子中，`incrementGlobal` 函数不是纯函数，因为它修改了全局变量 `globalVariable`，并且每次调用的输出可能不同，不满足纯函数的两个特性。

## 总结

纯函数是 Dart 中一种重要的编程概念，它具有可测试性、可维护性和并行处理等优势。在编写代码时，尽量使用纯函数可以提高代码的质量和可靠性

---

## 纯函数在内存使用上的差异

在 Dart 里，纯函数和非纯函数在内存使用方面存在一些差异，下面为你详细讲解：

### 1. 栈内存使用

- **调用时的栈帧创建**
无论是纯函数还是非纯函数，在被调用时都会在栈内存里创建一个栈帧。栈帧包含函数的局部变量、参数以及返回地址等信息。例如：

```dart
// 纯函数
int add(int a, int b) {
  return a + b;
}

// 非纯函数
int globalValue = 0;
int incrementAndReturn() {
  globalValue++;
  return globalValue;
}

void main() {
  int result1 = add(3, 5);
  int result2 = incrementAndReturn();
}
```

当调用 `add` 函数与 `incrementAndReturn` 函数时，都会在栈内存创建对应的栈帧，存储传入的参数和局部变量。

- **栈帧销毁**
函数执行完毕后，其栈帧会从栈内存中移除。由于纯函数通常逻辑简单，局部变量较少，所以它的栈帧可能相对较小，在栈内存中的占用时间也可能较短。而非纯函数若涉及复杂逻辑或者更多局部变量，栈帧可能会更大。

### 2. 堆内存使用

- **对象创建**
纯函数通常不会在函数外部创建或修改对象，其操作大多基于输入参数。若输入参数是基本数据类型（如 `int`、`double` 等），就不会在堆内存创建新对象。例如 `add` 函数，其参数和返回值都是基本数据类型，不会在堆内存分配额外空间。
然而，非纯函数可能会创建或修改堆内存中的对象。比如：

```dart
class Counter {
  int value = 0;
  void increment() {
    value++;
  }
}

// 非纯函数，修改了堆内存中的对象
void incrementCounter(Counter counter) {
  counter.increment();
}

void main() {
  Counter myCounter = Counter();
  incrementCounter(myCounter);
}
```

在这个例子里，`incrementCounter` 函数修改了堆内存中 `Counter` 对象的状态，会对堆内存产生影响。

- **内存泄漏风险**
纯函数由于没有副作用，不会造成意外的对象引用，因此基本不存在内存泄漏的风险。但非纯函数如果管理不当，比如创建了对象却没有正确释放引用，就可能导致内存泄漏。

### 3. 缓存与复用

- **纯函数的可缓存性**
因为纯函数对于相同的输入总会返回相同的输出，所以可以对其结果进行缓存。当再次使用相同的输入调用纯函数时，无需重新计算，直接从缓存中获取结果即可，这样能减少内存和计算资源的消耗。例如：

```dart
Map<int, int> factorialCache = {};

// 纯函数，可缓存结果
int factorial(int n) {
  if (n == 0 || n == 1) {
    return 1;
  }
  if (factorialCache.containsKey(n)) {
    return factorialCache[n]!;
  }
  int result = n * factorial(n - 1);
  factorialCache[n] = result;
  return result;
}
```

- **非纯函数难以缓存**
非纯函数的输出可能受外部状态影响，相同的输入不一定产生相同的输出，所以难以对其结果进行缓存，每次调用都可能需要重新计算，会增加内存和计算资源的开销。

综上所述，纯函数在内存使用上通常更加高效、可预测，并且由于其可缓存性，能减少不必要的计算和内存占用。而非纯函数可能会因对象创建、状态修改和难以缓存等因素，在内存管理上更具挑战性。

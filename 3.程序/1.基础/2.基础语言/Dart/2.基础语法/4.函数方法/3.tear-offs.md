# tear-offs

在 Dart 中，“tear-offs”（可以理解为“函数剥离” ）是一种将方法从其对象上下文中分离出来，创建一个独立的可调用函数对象的机制。这使得我们可以将方法作为参数传递给其他函数，或者将其赋值给变量，而不需要立即调用它。
>个人理解就是，将类中的方法函数脱离对象，像普通函数一样使用，无需方法体、参数列表、中括号等。

## 基本概念和语法

在 Dart 里，要创建一个方法的 tear-off，只需要使用方法名但不跟随括号和参数列表。例如，如果有一个对象 `obj` 有一个方法 `method`，那么 `obj.method` 就是这个方法的 tear-off。

## 示例代码

### 1. 将方法 tear-off 赋值给变量

```dart
class Calculator {
  int add(int a, int b) {
    return a + b;
  }
}

void main() {
  Calculator calc = Calculator();
  // 创建 add 方法的 tear-off 并赋值给变量
  int Function(int, int) addFunction = calc.add;
  int result = addFunction(3, 5);
  print(result); // 输出: 8
}
```

在这个例子中，我们定义了一个 `Calculator` 类，其中有一个 `add` 方法。在 `main` 函数里，我们创建了 `Calculator` 的实例 `calc`，然后将 `calc.add` 方法的 tear-off 赋值给 `addFunction` 变量。之后就可以像调用普通函数一样调用 `addFunction`。

### 2. 将方法 tear-off 作为参数传递

```dart
class Printer {
  void printMessage(String message) {
    print(message);
  }
}

void executeAction(void Function(String) action, String msg) {
  action(msg);
}

void main() {
  Printer printer = Printer();
  // 将 printMessage 方法的 tear-off 作为参数传递
  executeAction(printer.printMessage, 'Hello, Dart!');
}
```

这里定义了一个 `Printer` 类，其中有一个 `printMessage` 方法用于打印消息。`executeAction` 函数接受一个函数类型的参数和一个字符串参数，它会调用传入的函数并传入字符串。在 `main` 函数中，我们创建了 `Printer` 的实例 `printer`，然后将 `printer.printMessage` 方法的 tear-off 作为参数传递给 `executeAction` 函数。

### 3. 对于顶级函数和静态方法的 tear-off

顶级函数和静态方法也可以进行 tear-off，因为它们不依赖于特定对象的实例。

```dart
// 顶级函数
int square(int num) {
  return num * num;
}

class MathUtils {
  // 静态方法
  static int cube(int num) {
    return num * num * num;
  }
}

void main() {
  // 顶级函数的 tear-off
  int Function(int) squareFunction = square;
  print(squareFunction(4)); // 输出: 16

  // 静态方法的 tear-off
  int Function(int) cubeFunction = MathUtils.cube;
  print(cubeFunction(3)); // 输出: 27
}
```

在这个示例中，我们定义了一个顶级函数 `square` 和一个类 `MathUtils` 中的静态方法 `cube`。在 `main` 函数里，分别对它们进行 tear-off 并赋值给相应的变量，之后就可以像调用普通函数一样使用这些变量。

## 注意事项

- **类型匹配**：当使用 tear-off 时，赋值给的变量类型必须与该方法的签名（参数类型和返回类型）相匹配。
- **对象生命周期**：如果 tear-off 是基于对象实例的方法，那么该对象的生命周期会影响 tear-off 的可用性。如果对象被销毁，使用其方法的 tear-off 可能会导致错误。

---

## 与闭包的区别

在 Dart 中，函数的 tear - offs 和闭包都是重要的概念，它们在表现和使用上有明显的区别，下面从多个方面进行详细阐述。

### 定义和基本概念

- **函数的 tear - offs**：
    函数的 tear - offs 是将方法从其对象上下文中分离出来，创建一个独立的可调用函数对象的操作。它本质上是对已有方法的一种引用，保留了方法的签名，但不再依赖于立即调用的对象上下文。简单来说，就是把对象的方法拿出来当作一个普通函数来使用。
- **闭包**：
    闭包是一个函数对象，它可以访问并记住其词法作用域内的变量，即使该函数在其定义的作用域之外执行。闭包捕获了其周围环境中的变量，形成了一个独立的执行环境。

### 语法和创建方式

- **函数的 tear - offs**：
    要创建一个方法的 tear - off，只需使用方法名而不跟随括号和参数列表。以下是示例代码：

```dart
class Greeter {
  void greet(String name) {
    print('Hello, $name!');
  }
}

void main() {
  Greeter greeter = Greeter();
  // 创建 greet 方法的 tear - off
  void Function(String) greetFunction = greeter.greet;
  greetFunction('John'); // 输出: Hello, John!
}
```

- **闭包**：
    闭包通常在函数内部定义，并捕获外部函数的变量。示例如下：

```dart
Function makeAdder(int addBy) {
  return (int num) {
    return num + addBy;
  };
}

void main() {
  var add5 = makeAdder(5);
  print(add5(3)); // 输出: 8
}
```

### 作用域和变量捕获

- **函数的 tear - offs**：
    tear - offs 本身并不捕获变量，它只是对已有方法的引用。它依赖于创建时的对象实例，但不会捕获对象的状态或其他变量。如果对象的状态发生变化，tear - off 调用时会反映最新的状态。

```dart
class Counter {
  int count = 0;
  void increment() {
    count++;
    print(count);
  }
}

void main() {
  Counter counter = Counter();
  void Function() incrementFunction = counter.increment;
  incrementFunction(); // 输出: 1
  counter.count = 10;
  incrementFunction(); // 输出: 11
}
```

- **闭包**：
    闭包会捕获其定义时所在作用域内的变量。即使外部函数执行完毕，闭包仍然可以访问并修改这些变量。闭包保存了变量的状态，形成了一个独立的执行环境。

```dart
Function makeCounter() {
  int count = 0;
  return () {
    count++;
    return count;
  };
}

void main() {
  var counter = makeCounter();
  print(counter()); // 输出: 1
  print(counter()); // 输出: 2
}
```

### 使用场景

- **函数的 tear - offs**：
    常用于将对象的方法作为参数传递给其他函数，或者将其赋值给变量以便后续调用。例如，在集合操作中传递对象的方法进行元素处理。

```dart
class Person {
  String name;
  Person(this.name);

  String getName() {
    return name;
  }
}

void main() {
  List<Person> people = [Person('Alice'), Person('Bob')];
  // 使用 tear - off 提取每个人的名字
  List<String> names = people.map((p) => p.getName).map((f) => f()).toList();
  print(names); // 输出: [Alice, Bob]
}
```

- **闭包**：
    常用于实现数据的封装和状态的保存，例如创建私有变量、实现迭代器等。闭包还可以用于实现回调函数，确保回调函数可以访问外部函数的变量。

```dart
void executeAfterDelay(int delay, Function callback) {
  Future.delayed(Duration(seconds: delay), callback);
}

void main() {
  int value = 10;
  executeAfterDelay(2, () {
    print(value * 2); // 输出: 20
  });
}
```

综上所述，函数的 tear - offs 和闭包在定义、语法、变量捕获和使用场景等方面都存在明显的区别。理解这些区别有助于在不同的编程场景中正确使用它们。

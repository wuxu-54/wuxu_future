# 操作符与关键字

## 操作符

Dart 语言提供了丰富的操作符，用于执行各种操作，如算术运算、位运算、逻辑运算、赋值、比较等，跟java、kotlin大体相同。[操作符-官网地址](https://dart.cn/language/operators)

以下是 Dart 中一些主要的操作符及其分类：

### 算术操作符

- `+`（加）
- `-`（减）
- `*`（乘）
- `/`（除）
- `%`（取模）
- `~`（按位取反）
- `<<`（左移位）
- `>>`（右移位）
- `|`（按位或）
- `&`（按位与）
- `^`（按位异或）

### 赋值操作符

- `=`（赋值）
- `+=`（加等于）
- `-=`（减等于）
- `*=`（乘等于）
- `/=`（除等于）
- `%=`（取模等于）
- `<<=`（左移位等于）
- `>>=`（右移位等于）
- `|=`（按位或等于）
- `&=`（按位与等于）
- `^=`（按位异或等于）

### 比较操作符

- `==`（等于）
- `!=`（不等于）
- `>`（大于）
- `<`（小于）
- `>=`（大于等于）
- `<=`（小于等于）

### 逻辑操作符

- `&&`（逻辑与）
- `||`（逻辑或）
- `!`（逻辑非）

### 成员访问操作符

- `.`（成员访问）

### 调用操作符

- `()`（函数或方法调用）

### 条件操作符

- `? :`（三元条件操作符）

### 级联操作符

- `..`（级联操作，用于调用同一对象的多个方法或访问器）

### 命名的可选级联操作符

- `?..`（命名的可选级联操作符，用于安全地进行级联操作）

### 扩展操作符

- `...`（扩展操作符，用于展开可迭代对象）

### 集合字面量操作符

- `{}`（集合字面量）

### Map字面量操作符

- `[]` 或 `[:]`（Map 字面量）

### 索引操作符

- `[]`（索引访问）

### 空安全操作符

- `?.` 和 `??`（空安全导航和空值合并操作符）

### 类型相关操作符

- `as`（类型转换）
- `as?`(空安全类型转换)
- `is`（类型检查）
- `is!`（否定类型检查）

---

## 关键字

[关键字，官网说明](https://dart.cn/language/keywords)
[类型修饰符](https://dart.cn/language/class-modifiers)

### 关键字列表

1. **assert** - 用于断言条件。
2. **async** - 用于定义异步函数。
3. **await** - 用于等待异步操作完成。
4. **break** - 用于跳出最近的循环或switch语句。
5. **case** - 用于switch语句中的条件分支。
6. **catch** - 用于异常处理。
7. **class** - 用于定义类。
8. **const** - 用于创建编译时常量。
9. **continue** - 用于跳过当前循环的剩余部分，直接开始下一次迭代。
10. **default** - 用于switch语句中的默认分支。
11. **deferred** - 用于延迟加载库。
12. **do** - 用于do-while循环。
13. **dynamic** - 用于声明动态类型变量。
14. **else** - 用于if-else语句的else分支。
15. **enum** - 用于定义枚举类型。
16. **export** - 用于导出库中的成员。
17. **extends** - 用于类继承。
18. **external** - 用于声明外部函数或类。
19. **factory** - 用于工厂构造函数。
20. **false** - 布尔值`false`。
21. **final** - 用于声明不可变变量。
22. **finally** - 用于异常处理的finally块。
23. **for** - 用于for循环。
24. **Function** - 用于声明函数类型。
25. **get** - 用于定义getter。
26. **if** - 用于条件语句。
27. **implements** - 用于接口实现。
28. **import** - 用于导入库。
29. **in** - 用于检查一个值是否在集合中。
30. **is** - 用于类型检查。
31. **late** - 用于声明延迟初始化的变量。
32. **library** - 用于定义库。
33. **mixin** - 用于混入。
34. **new** - 用于创建类的实例。
35. **null** - 表示空值。
36. **on** - 用于catch语句中指定异常类型。
37. **operator** - 用于定义操作符。
38. **part** - 用于分割库文件。
39. **required** - 用于构造函数参数，表示必须显式提供。
40. **rethrow** - 用于重新抛出捕获的异常。
41. **return** - 用于从函数返回值。
42. **set** - 用于定义setter。
43. **static** - 用于声明静态成员。
44. **super** - 用于引用父类。
45. **switch** - 用于switch语句。
46. **this** - 用于引用类的当前实例。
47. **throw** - 用于抛出异常。
48. **true** - 布尔值`true`。
49. **try** - 用于尝试代码块。
50. **typedef** - 用于定义类型别名。
51. **var** - 用于声明变量，类型由赋值决定。
52. **void** - 表示没有返回值的函数或方法。
53. **while** - 用于while循环。
54. **with** - 用于实现混入。

### 常用类型修饰符列表

- 访问控制修饰符
  - `private`（dart没有此关键字，约定俗成的命名约定，如以下划线 `_` 开头的标识符）
  - `protected`（dart没有此关键字，在 Dart 中没有直接支持，但可以通过文档和编码约定实现）
  - `public`（dart没有此关键字，默认是公共的，无需显式指定）

- 变量存储修饰符
  - `final`：声明一个不可变变量，一旦初始化后不能被重新赋值。
  - `const`：声明一个编译时常量。
  - `var`：声明一个变量，其类型由赋值决定。
  - `late`：声明一个延迟初始化的变量。

- 类和类型修饰符
  - `abstract`：声明一个抽象类，不能被实例化，通常包含抽象方法。
  - `class`：声明一个类。
  - `enum`：声明一个枚举类型。
  - `typedef`：为函数类型定义别名。

- 类成员修饰符
  - `static`：声明一个静态成员，属于类而不是类的实例。
  - `covariant`：允许协变返回类型。

- 构造函数修饰符
  - `factory`：声明一个工厂构造函数。

- 方法和函数修饰符
  - `async`、`await`：用于异步函数。
  - `operator`：用于定义操作符的自定义行为。

- 参数修饰符
  - `required`：在命名参数中使用，表示该参数必须被提供。
  - 默认参数值：为函数参数提供默认值。

- 其他修饰符
  - `@deprecated`：标记一个API为已弃用。
  - 注解（annotations）：使用 `@` 符号，用于添加元数据。

### 示例

```dart
@deprecated
class MyClass {
  static const final myConst = 0;

  MyClass({required int param1, int param2 = 10});

  void myMethod(covariant String type) {
    // ...
  }

  factory MyClass.fromOther(MyClass other) {
    // ...
  }

  late int myLateField;

  int get myGetter => 0;

  set mySetter(int value) {
    // ...
  }
}
```

---

## `typedef`使用细解

在Dart语言中，`typedef`是一种为函数创建别名的关键字。使用`typedef`可以让你为函数类型定义一个更易读、更具表现力的名称。这对于创建具有复杂参数和返回值的函数类型特别有用。

以下是`typedef`的使用方式和示例：

### 基本语法

```dart
typedef ReturnType FunctionName(ParameterType param1, ParameterType param2, ...);
```

### typedef示例

#### 示例 1：简单函数别名

```dart
typedef int SumFunction(int a, int b);
```

这里`SumFunction`是`int`类型参数的函数的别名，该函数接受两个`int`类型的参数。

#### 示例 2：使用`typedef`创建函数别名

```dart
typedef void ProcessCallback(String data);

void processData(String data) {
  print(data);
}

void main() {
  ProcessCallback callback = processData; // 使用typedef别名
  callback("Hello, World!");
}
```

在这个示例中，`ProcessCallback`是`void`类型参数的函数的别名，该函数接受一个`String`类型的参数。

#### 示例 3：带命名参数的函数别名

```dart
typedef void ConfigFunction({required String name, int? age});

void configure(String name, {int? age}) {
  print("Name: $name, Age: $age");
}

void main() {
  ConfigFunction config = configure;
  config("Alice", age: 30);
}
```

在这个示例中，`ConfigFunction`是带有命名参数的函数的别名。

#### 示例 4：带返回值的函数别名

```dart
typedef String Transformer(int value);

String doubleValue(int value) {
  return (value * 2).toString();
}

void main() {
  Transformer transformer = doubleValue;
  String result = transformer(10); // "20"
  print(result);
}
```

在这个示例中，`Transformer`是接受`int`类型参数并返回`String`类型结果的函数的别名。

### 注意事项

- `typedef`主要用于提高代码的可读性，尤其是在函数类型较为复杂时。
- 你可以使用`typedef`来创建具有特定参数和返回值的函数类型的别名。
- `typedef`不应该与`typedef`关键字一起使用，这可能会导致编译错误。

通过使用`typedef`，你可以使Dart代码更加清晰和易于理解，特别是在处理复杂的函数类型时。

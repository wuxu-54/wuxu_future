# Map

在Dart语言中，Map是一种键值对的集合，它存储着唯一的键（key）映射到特定的值（value）。Dart 2.0之后，Map是泛型的，这意味着你可以指定键和值的类型，以提高程序的类型安全性。

以下是Dart中Map的一些基本用法：

## 创建Map

1. 字面量方式：使用`{}`来创建一个空的Map，或者使用键值对的字面量来初始化一个Map。

    ```dart
    Map<String, int> map = {}; // 创建一个空的Map

    Map<String, int> mapLiteral = {
    'key1': 1,
    'key2': 2,
    'key3': 3,
    };
    ```

2. 构造函数：使用`Map.of`或者`Map.from`来创建一个Map的实例。

    ```dart
    Map<String, int> mapFromIterable = Map.fromIterable(
    iterable,
    key: (element) => element.key,
    value: (element) => element.value,
    );

    Map<String, int> mapOf = Map.of({
    'key1': 1,
    'key2': 2,
    });
    ```

## 强类型字典

从 Dart 2.0 开始，你可以使用尖括号来指定字典中键和值的类型，从而创建强类型的字典：

```dart
Map<int, String> intStringMap = <int, String>{};
intStringMap[1] = 'one';
```

## 访问和修改Map元素

通过键来访问或修改Map中的元素。

```dart
int value = map['key1']; // 获取键'key1'对应的值
map['key1'] = 10; // 修改键'key1'对应的值为10
```

## 添加键值对

向Map中添加一个新的键值对。

```dart
map.addAll({'key4': 4}); // 添加一个新的键值对
```

## 检查键是否存在

检查一个键是否存在于Map中。

```dart
bool hasKey = map.containsKey('key1');
```

## 删除键值对

从Map中删除一个键值对。

```dart
map.remove('key1');
```

## 获取所有键和所有值

获取Map中所有键的集合和所有值的列表。

```dart
Set<String> keys = map.keys; // 获取所有键
List<int> values = map.values.toList(); // 获取所有值
```

## 遍历Map

使用forEach方法遍历Map中的所有键值对。

```dart
map.forEach((key, value) {
  print('$key: $value');
});
```

## Map的长度

获取Map中键值对的数量。

```dart
int count = map.length;
```

## 不可变字典

如果你需要一个不可变的字典，可以使用 const 关键字创建一个编译时常量字典：

```dart
final constantMap = const {
  'key1': 'value1',
  'key2': 'value2',
};
```

---

## 限制

对于值（values），Map没有特别的要求，值可以是任何类型的数据，包括null。

然而，对于键，Dart有以下限制：

* Map的键（keys）必须遵守两个规则：
  * 唯一性：每个键在同一个Map中必须是唯一的。
  * 不可变性：键必须是不可变的，因为如果键是可变的，那么它在Map中的值将难以追踪。
* 键不能是Map或List：因为Map和List是可变的，不能用作Map的键。
* 键不能为null：默认情况下，Dart中的Map不允许键为null。尝试将null作为键插入到Map中将会导致错误。

  **注意**：如果你需要一个键可以为null的Map，可以使用HashMap的变体`HashMap<K, V>`，并指定键的类型为`Object?`，这样键就可以是null了。例如：
  
  ```dart
  HashMap<Object?, String> mapWithNullableKeys = HashMap();
  mapWithNullableKeys[null] = "Value for null key"; // 不报错
  ```

  请注意，即使键可以为null，也只有一个null键被允许，因为键必须保持唯一性。

---

## HashMap与LinkedHashMap区别

Dart 2.12引入了一个新的LinkedHashMap类，它在HashMap的基础上增加了元素的顺序信息。以下是Map和LinkedHashMap之间的主要区别：

1. 迭代顺序：

    * Map：不保证迭代顺序，特别是当它是一个HashMap时，迭代顺序可能会在不同的运行之间改变，因为HashMap的键值对是基于哈希的，可能会有随机性。
    * LinkedHashMap：保持了元素的插入顺序。当对LinkedHashMap进行迭代时，元素会按照它们被插入的顺序来访问。

2. 性能：

    * Map（HashMap）：在大多数情况下，提供最快的查找时间，因为它是基于哈希的。
    * LinkedHashMap：由于需要维护插入顺序，所以可能会有一些额外的内存使用和性能开销。

3. 使用场景：

    * Map：当你需要快速查找元素，并且不需要关心元素的顺序时，使用普通的Map或HashMap。
    * LinkedHashMap：当你需要保持元素的插入顺序，例如实现一个LRU（最近最少使用）缓存时，使用LinkedHashMap。

4. 额外的功能：

    * LinkedHashMap：提供了一些额外的方法，例如LinkedList的firstKey和lastKey，允许你访问或删除链表的第一个或最后一个键。

下面是一个简单的示例，展示了如何在Dart中使用LinkedHashMap：

```dart
void main() {
  LinkedHashMap<String, int> linkedMap = LinkedHashMap();

  linkedMap['first'] = 1;
  linkedMap['second'] = 2;
  linkedMap['third'] = 3;

  // 迭代LinkedHashMap时，会保持元素的插入顺序
  linkedMap.forEach((key, value) {
    print('$key: $value');
  });

  // 访问第一个和最后一个键
  print(linkedMap.firstKey); // 输出: first
  print(linkedMap.lastKey);  // 输出: third
}
```

在Dart中，Map是一个泛型接口，而HashMap和LinkedHashMap是它的具体实现。选择使用哪种类型的Map取决于你的具体需求，包括对迭代顺序的要求和对性能的考虑。

---

## 注意事项

* Dart中的Map是无序的，键值对的顺序可能会在不同的运行中有所变化。
* 从Dart 2.0开始，所有的Map字面量都是类型安全的，这意味着编译器会检查键和值的类型。
* 尝试访问一个不存在的键将导致一个`KeyError`异常，使用containsKey方法可以避免这个异常。

通过使用Map，你可以有效地实现关联数据存储，这在处理需要通过键来检索数据的场景中非常有用。

# 鸭子类型

>@武旭：第一次见到是在python基础学习中。[python鸭子类型](/3.%E7%A8%8B%E5%BA%8F/1.%E5%9F%BA%E7%A1%80/2.%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/python/2.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/2.%E7%B1%BB%E5%9E%8B/4.%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B.md)

## 概念

“鸭子类型（Duck Typing）”是一种编程风格和类型系统的概念，它源自名言 “如果它走路像鸭子，叫声像鸭子，那么它就是鸭子”。在鸭子类型中，一个对象的有效语义，不是由继承自特定的类或实现特定的接口决定，而是由当前对象“具备某些方法和属性”来决定。

在 Dart 里，鸭子类型意味着只要一个对象拥有代码所期望的方法和属性，就可以将其当作特定类型来使用，而不必考虑该对象具体是哪个类的实例。

## 示例代码

以下通过几个例子来详细说明 Dart 中的鸭子类型。

### 简单的鸭子类型示例

```dart
// 定义一个接口（在 Dart 中使用抽象类来模拟接口）
abstract class Flyable {
  void fly();
}

// 实现 Flyable 接口的类
class Bird implements Flyable {
  @override
  void fly() {
    print('Bird is flying.');
  }
}

// 另一个类，虽然没有显式实现 Flyable 接口，但有 fly 方法
class Airplane {
  void fly() {
    print('Airplane is flying.');
  }
}

// 接受 Flyable 类型对象的函数
void makeItFly(Flyable flyable) {
  flyable.fly();
}

void main() {
  Bird bird = Bird();
  Airplane airplane = Airplane();

  // 调用 makeItFly 函数，传入 Bird 对象
  makeItFly(bird);

  // 由于 Airplane 有 fly 方法，也可以当作 Flyable 类型传入
  makeItFly(airplane as Flyable);
}
```

**代码解释**：

- `Flyable` 是一个抽象类，模拟接口，定义了 `fly` 方法。
- `Bird` 类显式实现了 `Flyable` 接口。
- `Airplane` 类没有显式实现 `Flyable` 接口，但它有 `fly` 方法。
- `makeItFly` 函数接受一个 `Flyable` 类型的对象并调用其 `fly` 方法。在 `main` 函数中，既可以传入 `Bird` 对象，也可以将 `Airplane` 对象强制转换为 `Flyable` 类型传入，这体现了鸭子类型，只要对象有 `fly` 方法，就可以当作 `Flyable` 类型来使用。

### 更复杂的鸭子类型示例

```dart
// 定义一个包含多个方法的接口
abstract class Shape {
  num area();
  num perimeter();
}

// 实现 Shape 接口的类
class Circle implements Shape {
  final num radius;

  Circle(this.radius);

  @override
  num area() {
    return 3.14 * radius * radius;
  }

  @override
  num perimeter() {
    return 2 * 3.14 * radius;
  }
}

// 另一个类，没有显式实现 Shape 接口，但有 area 和 perimeter 方法
class Square {
  final num side;

  Square(this.side);

  num area() {
    return side * side;
  }

  num perimeter() {
    return 4 * side;
  }
}

// 接受 Shape 类型对象的函数
void printShapeInfo(Shape shape) {
  print('Area: ${shape.area()}');
  print('Perimeter: ${shape.perimeter()}');
}

void main() {
  Circle circle = Circle(5);
  Square square = Square(4);

  // 调用 printShapeInfo 函数，传入 Circle 对象
  printShapeInfo(circle);

  // 由于 Square 有 area 和 perimeter 方法，也可以当作 Shape 类型传入
  printShapeInfo(square as Shape);
}
```

**代码解释**：

- `Shape` 抽象类定义了 `area` 和 `perimeter` 方法。
- `Circle` 类显式实现了 `Shape` 接口。
- `Square` 类没有显式实现 `Shape` 接口，但有 `area` 和 `perimeter` 方法。
- `printShapeInfo` 函数接受一个 `Shape` 类型的对象并打印其面积和周长。在 `main` 函数中，既可以传入 `Circle` 对象，也可以将 `Square` 对象强制转换为 `Shape` 类型传入，这同样体现了鸭子类型的特性。

## 鸭子类型的优缺点

### 优点

- **灵活性高**：不需要严格的继承或接口实现关系，只要对象具有所需的方法和属性，就可以使用，代码更加灵活。
- **代码复用性强**：可以在不同的类之间复用代码，减少了代码的重复。

### 缺点

- **类型安全性低**：由于不依赖于严格的类型系统，可能会在运行时出现类型错误，增加了调试的难度。
- **可读性降低**：代码中可能会出现一些隐式的类型转换，使得代码的可读性和可维护性降低。

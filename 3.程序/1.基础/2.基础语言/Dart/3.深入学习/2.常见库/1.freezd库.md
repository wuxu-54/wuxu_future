# @freezed 库

以下是关于 **`@freezed`** 的详细解析，涵盖其核心功能、使用方法、代码示例及最佳实践。`@freezed` 是一个强大的 Dart 代码生成库，用于简化不可变（Immutable）数据类的创建，特别适合与 Redux、状态管理等场景结合使用。

---

## **一、@freezed 的核心功能**

| 功能                     | 说明                                                                 |
|--------------------------|--------------------------------------------------------------------|
| **不可变类生成**           | 自动生成不可变（immutable）类，确保对象不可修改                          |
| **`copyWith` 方法**       | 生成便捷的深度复制方法，支持部分字段更新                                 |
| **值相等性（Value Equality）** | 自动实现 `==` 和 `hashCode`，基于属性值而非对象引用比较                   |
| **模式匹配**               | 支持联合类型（Union Types），实现类型安全的模式匹配                       |
| **JSON 序列化**           | 与 `json_serializable` 集成，自动生成序列化/反序列化代码                  |
| **默认值支持**             | 为字段提供默认值                                                       |

---

## **二、快速开始**

### **1. 添加依赖**

在 `pubspec.yaml` 中添加：

```yaml
dependencies:
  freezed_annotation: ^2.2.0

dev_dependencies:
  build_runner: ^2.3.3
  freezed: ^2.3.3
  json_serializable: ^6.6.1  # 可选，用于 JSON 序列化
```

### **2. 创建基础不可变类**

```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user.freezed.dart';

@freezed
class User with _$User {
  const factory User({
    required String name,
    required int age,
    String? email,
  }) = _User;
}
```

运行代码生成：

```bash
flutter pub run build_runner build
```

---

## **三、核心用法详解**

### **1. 不可变性与 `copyWith`**

生成的类不可修改，但可通过 `copyWith` 创建新实例：

```dart
final user = User(name: 'Alice', age: 25);
final newUser = user.copyWith(age: 26); // 只修改 age
```

### **2. 联合类型（Union Types）**

定义多个工厂构造函数，实现类型安全的状态管理：

```dart
@freezed
class AppState with _$AppState {
  // 不同状态
  const factory AppState.loading() = Loading;
  const factory AppState.authenticated(User user) = Authenticated;
  const factory AppState.error(String message) = Error;
}

// 使用 when 进行模式匹配
final state = AppState.authenticated(user);
state.when(
  loading: () => CircularProgressIndicator(),
  authenticated: (user) => ProfilePage(user),
  error: (msg) => ErrorWidget(msg),
);
```

### **3. JSON 序列化**

结合 `json_serializable` 实现序列化：

```dart
@freezed
class User with _$User {
  const factory User({
    required String name,
    required int age,
  }) = _User;

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
}
```

生成代码后可直接转换：

```dart
final user = User.fromJson(jsonData);
final json = user.toJson();
```

---

## **四、高级特性**

### **1. 自定义方法**

为生成的类添加方法：

```dart
@freezed
class User with _$User {
  const User._(); // 私有构造函数用于添加方法

  const factory User({String? name, int? age}) = _User;

  // 自定义方法
  String get displayName => name ?? 'Anonymous';
}
```

### **2. 默认值**

为字段提供默认值：

```dart
@freezed
class Settings with _$Settings {
  const factory Settings({
    @Default(false) bool isDarkMode,
    @Default(16) int fontSize,
  }) = _Settings;
}
```

### **3. 泛型支持**

```dart
@freezed
class PaginatedList<T> with _$PaginatedList<T> {
  const factory PaginatedList({
    required List<T> items,
    required int total,
  }) = _PaginatedList<T>;
}
```

---

## **五、与 Redux 结合示例**

### **1. 定义状态和 Action**

```dart
// user_state.dart
@freezed
class UserState with _$UserState {
  const factory UserState.initial() = Initial;
  const factory UserState.loading() = Loading;
  const factory UserState.loaded(User user) = Loaded;
  const factory UserState.error(String message) = Error;
}

// user_actions.dart
@freezed
class UserAction with _$UserAction {
  const factory UserAction.fetchUser(int userId) = FetchUser;
  const factory UserAction.fetchSuccess(User user) = FetchSuccess;
  const factory UserAction.fetchFailure(String error) = FetchFailure;
}
```

### **2. Reducer 实现**

```dart
UserState userReducer(UserState state, UserAction action) {
  return action.when(
    fetchUser: (userId) => const UserState.loading(),
    fetchSuccess: (user) => UserState.loaded(user),
    fetchFailure: (error) => UserState.error(error),
  );
}
```

---

## **六、最佳实践**

### **1. 文件结构**

```txt
lib/
├── models/
│   ├── user.freezed.dart    # 生成文件
│   └── user.dart            # 源文件
└── states/
    ├── app_state.freezed.dart
    └── app_state.dart
```

### **2. 命名规范**

- **类名**：大驼峰式（如 `UserProfile`）
- **联合类型**：使用动词描述状态（如 `Loading`、`Authenticated`）

### **3. 避免深层嵌套**

```dart
// ✅ 正确：扁平化结构
@freezed
class AppState with _$AppState {
  const factory AppState({
    required User user,
    required Settings settings,
  }) = _AppState;
}

// ❌ 错误：深层嵌套
@freezed
class AppState with _$AppState {
  const factory AppState({
    required Map<String, Map<String, dynamic>> nestedData,
  }) = _AppState;
}
```

---

## **七、常见问题**

### **1. 代码生成失败**

- 确保 `build_runner` 版本兼容
- 检查 `part 'file.freezed.dart';` 路径是否正确
- 运行清理命令后重新生成：

  ```bash
  flutter pub run build_runner clean
  flutter pub run build_runner build --delete-conflicting-outputs
  ```

### **2. 如何继承其他类？**

`@freezed` 不支持继承，但可通过 **接口实现** 或 **Mixin** 复用代码：

```dart
abstract class BaseModel {
  String get id;
}

@freezed
class User with _$User implements BaseModel {
  const factory User({String? id, String? name}) = _User;
}
```

### **3. 自定义 `toString`**

```dart
@freezed
class User with _$User {
  const User._();

  const factory User({String? name, int? age}) = _User;

  @override
  String toString() => 'User(name: $name, age: $age)';
}
```

---

## **八、总结**

`@freezed` 通过代码生成解决了以下痛点：

- **减少模板代码**：自动生成 `copyWith`、`==`、`hashCode` 等方法
- **提升安全性**：强制不可变性，避免意外修改状态
- **增强可维护性**：联合类型和模式匹配使复杂状态逻辑更清晰

在 Flutter 状态管理（如 Redux、Bloc）中，结合 `@freezed` 可以显著提升开发效率和代码质量。

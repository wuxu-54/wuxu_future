# 逆变与协变

先明确含义:

- 逆变：父类型可以赋值给子类型。假定B是A的子类，`List<? super B> = List<A>`。
- 协变：子类型可以赋值给父类型。假定B是A的子类，`List<? extends A> = List<B>`。

目的：

- 逆变与协变的主要目的是为了解决Java中的类型安全。逆变和协变允许在泛型类型中使用更广的泛型类型参数，从而提高代码的可读性、可维护性以及安全性。

代码示例：

```java
import java.util.ArrayList;
import java.util.List;

// 定义父类 Animal
class Animal {
    public void eat() {
        System.out.println("Animal is eating.");
    }
}

// 定义子类 Dog，继承自 Animal
class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("Dog is eating.");
    }
}

// 定义子类 Cat，继承自 Animal
class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("Cat is eating.");
    }
}

public class GenericsVarianceExample {
    public static void main(String[] args) {
        // 协变示例
        List<Dog> dogList = new ArrayList<>();
        dogList.add(new Dog());
        // 协变：子类型可以赋值给父类型
        List<? extends Animal> covariantList = dogList;
        // 只能读取，不能写入
        for (Animal animal : covariantList) {
            animal.eat();
        }

        // 逆变示例
        List<Animal> animalList = new ArrayList<>();
        animalList.add(new Animal());
        // 逆变：父类型可以赋值给子类型
        List<? super Dog> contravariantList = animalList;
        // 可以写入 Dog 及其子类，但读取时只能作为 Object 类型
        contravariantList.add(new Dog());
        for (Object obj : contravariantList) {
            if (obj instanceof Animal) {
                ((Animal) obj).eat();
            }
        }
    }
}
```

代码解释

- 协变部分：

  - `List<Dog>` 是 `List<? extends Animal>` 的子类型，因此可以将 `List<Dog>` 赋值给 `List<? extends Animal>`。
  - 使用 `<? extends Animal>` 声明的列表，只能从中读取 Animal 类型的元素，不能向其中添加元素（除了 null），因为编译器无法确定列表中实际存储的是 Animal 的哪个具体子类。

- 逆变部分：
  - `List<Animal>` 是 `List<? super Dog>` 的父类型，因此可以将 `List<Animal>` 赋值给 `List<? super Dog>`。
  - 使用 `<? super Dog>` 声明的列表，可以向其中添加 Dog 及其子类的对象，但从列表中读取元素时，只能将其作为 Object 类型处理，因为编译器无法确定列表中实际存储的是 Dog 的哪个具体父类。

## 总结

- 协变（`<? extends T>`）：侧重于读取数据，允许将子类型的列表赋值给父类型的列表引用，但不能向列表中添加元素。
- 逆变（`<? super T>`）：侧重于写入数据，允许将父类型的列表赋值给子类型的列表引用，可以向列表中添加 T 及其子类的对象，但读取时需要进行类型转换。

>还有个简单理解：使用时，读均以父类型为标准、写均以子类型为标准。如果是协变，父类型可以明确，比如示例中的Animal，所以可以读出Animal，但是写时无法确定其类型，同理，如果是逆变，子类型可以明确，写时其类型为dog，但是读取时，父类型为Object。

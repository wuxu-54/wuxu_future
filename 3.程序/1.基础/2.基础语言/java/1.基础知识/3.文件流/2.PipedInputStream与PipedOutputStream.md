# PipedInputStream与PipedOutputStream

在Java IO体系中，`PipedInputStream`是一种特殊的输入流，专门用于**线程间的数据传递**，它必须与`PipedOutputStream`配合使用，两者通过"管道"形成连接，实现不同线程间的字节数据传输。

## 核心作用

`PipedInputStream`的设计目的是解决**线程间通信**的问题：一个线程（通常称为"生产者"）通过`PipedOutputStream`写入数据，另一个线程（通常称为"消费者"）通过`PipedInputStream`读取这些数据，数据直接在内存中传递，无需借助外部存储（如文件）。

## 工作原理

1. **管道连接**：`PipedInputStream`必须与`PipedOutputStream`建立连接（形成管道）才能工作。连接方式有两种：
   - 创建时关联：在`PipedInputStream`的构造方法中传入对应的`PipedOutputStream`；
   - 事后连接：通过`connect()`方法手动关联。

2. **数据传递**：  
   当"生产者"线程通过`PipedOutputStream`写入数据时，数据会被暂存到管道内部的缓冲区（默认大小为1024字节）；  
   "消费者"线程通过`PipedInputStream`的`read()`方法读取数据，若缓冲区为空，`read()`会阻塞等待，直到有数据写入或流被关闭。

## 关键方法

- **构造方法**：  
  - `PipedInputStream(PipedOutputStream out)`：创建与指定`PipedOutputStream`连接的输入流；  
  - `PipedInputStream()`：创建未连接的输入流，需后续通过`connect()`方法关联输出流。

- **核心方法**：  
  - `void connect(PipedOutputStream out)`：将当前输入流与指定输出流连接（若已连接会抛异常）；  
  - `int read()`：从管道读取一个字节（阻塞式，无数据时等待），返回-1表示流已关闭；  
  - `int read(byte[] b, int off, int len)`：读取最多`len`个字节到数组`b`中（从`off`位置开始），返回实际读取的字节数；  
  - `void close()`：关闭输入流，释放资源，此时关联的输出流写入操作会抛出异常。

## 使用场景

典型场景是**生产者-消费者模型**，例如：

- 一个线程生成数据（如解析文件、计算结果），通过`PipedOutputStream`写入；
- 另一个线程处理数据（如格式化、存储），通过`PipedInputStream`读取。

## 示例代码

```java
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

public class PipedStreamDemo {
    public static void main(String[] args) throws IOException {
        // 创建管道输入流和输出流，并建立连接
        PipedInputStream in = new PipedInputStream();
        PipedOutputStream out = new PipedOutputStream(in); // 构造时关联输入流

        // 生产者线程：写入数据
        Thread producer = new Thread(() -> {
            try {
                String data = "Hello, Piped Streams!";
                out.write(data.getBytes()); // 写入字节数据
                out.close(); // 写完关闭输出流
                System.out.println("生产者：数据写入完成");
            } catch (IOException e) {
                e.printStackTrace();
            }
        });

        // 消费者线程：读取数据
        Thread consumer = new Thread(() -> {
            try {
                byte[] buffer = new byte[1024];
                int len;
                StringBuilder sb = new StringBuilder();
                // 读取数据（阻塞直到有数据或流关闭）
                while ((len = in.read(buffer)) != -1) {
                    sb.append(new String(buffer, 0, len));
                }
                in.close();
                System.out.println("消费者：读取到数据 -> " + sb.toString());
            } catch (IOException e) {
                e.printStackTrace();
            }
        });

        // 启动线程
        producer.start();
        consumer.start();
    }
}
```

## 注意事项

1. **线程分离**：`PipedInputStream`和`PipedOutputStream`的读写操作**必须在不同线程中进行**，否则可能导致死锁（同一线程中读写会相互阻塞）。  
2. **缓冲区限制**：默认缓冲区大小为1024字节，若写入速度远快于读取速度，缓冲区满时`PipedOutputStream`的`write()`会阻塞，直到有空间释放。  
3. **关闭处理**：若输出流被关闭，输入流的`read()`会返回-1；若输入流被关闭，输出流的`write()`会抛出`IOException`。  

总结来说，`PipedInputStream`是线程间内存级通信的高效工具，通过与`PipedOutputStream`配合，实现了数据在不同线程间的安全传递，适用于需要协作处理数据的场景。

# ReentrantReadWriteLock

ReentrantReadWriteLock是Java中的一个可重入读写锁实现，它允许多个线程同时读取共享资源（读读可以并发），但在写入时只允许一个线程独占（读写、写读、写写互斥）。下面将对其进行详细解析，并提供示例。

## 一、ReentrantReadWriteLock详解

## 1. 主要特性

* **读写互斥**：写锁是独占的，当线程持有写锁时，其他线程不能获取读锁或写锁。同时，读锁与写锁也是互斥的，即当线程持有读锁时，其他线程不能获取写锁。
* **读读共享**：当没有线程持有写锁时，多个线程可以同时持有读锁，从而实现读操作的并发。
* **可重入性**：无论是读锁还是写锁，都支持线程重入。即同一个线程可以多次获取相同类型的锁，而不会产生死锁。
* **锁降级**：持有写锁的线程可以获取读锁，然后释放写锁，从而保持读锁的持有状态。这个过程称为锁降级，它允许线程在保持对共享资源访问的同时，释放对资源修改的独占权。
* **公平性**：支持非公平（默认）和公平的锁获取方式。在非公平模式下，线程可能插队获取锁；在公平模式下，线程按照请求锁的顺序依次获取锁。

## 2. 内部实现

ReentrantReadWriteLock使用了一个内部类Sync来实现锁的功能，Sync继承自AQS（AbstractQueuedSynchronizer）。AQS是Java中锁的基础类，提供了锁的通用实现方式。ReentrantReadWriteLock通过维护一对读写锁（一个读锁和一个写锁）来实现其功能，并使用AQS的state变量来同时表示读锁和写锁的状态。state变量被分为高16位和低16位，高16位表示读锁状态（共享锁计数），低16位表示写锁状态（独占锁计数）。

## 3. 使用场景

ReentrantReadWriteLock适用于读操作远多于写操作的场景，如缓存、数据库连接池等。在这些场景中，使用读写锁可以显著提高系统的并发性能和吞吐量。

## 4. 源码

`ReadWriteLock`的实现类，只有两个方法：`readLock();`,`writeLock();` 方法返回值都是`Lock`接口类型

```java
class ReentrantReadWriteLock
        implements ReadWriteLock, java.io.Serializable {
       
    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this); //这就是readLock返回的锁
        writerLock = new WriteLock(this);//这就是writeLock返回的锁
    }
}
```

所以其本质是通过Lock实现同步。

## 5. kotlin中扩展函数，方便的api

* 读`.read`

    ```kt
    @kotlin.internal.InlineOnly
    public inline fun <T> ReentrantReadWriteLock.read(action: () -> T): T {
        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }
        val rl = readLock()
        rl.lock()
        try {
            return action()
        } finally {
            rl.unlock()
        }
    }
    ```

* 写`.write`

    ```kt
    @kotlin.internal.InlineOnly
    public inline fun <T> ReentrantReadWriteLock.write(action: () -> T): T {
        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }
        val rl = readLock()

        val readCount = if (writeHoldCount == 0) readHoldCount else 0
        repeat(readCount) { rl.unlock() }

        val wl = writeLock()
        wl.lock()
        try {
            return action()
        } finally {
            repeat(readCount) { rl.lock() }
            wl.unlock()
        }
    }
    ```

## 二、ReentrantReadWriteLock示例

以下是一个简单的ReentrantReadWriteLock使用示例，演示了如何使用读锁和写锁来保护共享数据。

```java
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.Lock;

public class SharedData {
    private int data = 0;
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private final Lock readLock = lock.readLock();
    private final Lock writeLock = lock.writeLock();

    public int readData() {
        readLock.lock();
        try {
            return data;
        } finally {
            readLock.unlock();
        }
    }

    public void writeData(int newValue) {
        writeLock.lock();
        try {
            data = newValue;
        } finally {
            writeLock.unlock();
        }
    }

    public static void main(String[] args) {
        SharedData sharedData = new SharedData();

        // 创建多个读线程
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + " is reading data: " + sharedData.readData());
            }, "ReaderThread-" + i).start();
        }

        // 创建一个写线程
        new Thread(() -> {
            sharedData.writeData(42);
            System.out.println(Thread.currentThread().getName() + " has written data: 42");
        }, "WriterThread").start();
    }
}
```

在这个示例中，`SharedData`类包含了一个整数类型的共享数据`data`，并使用`ReentrantReadWriteLock`来对其进行读写保护。`readData`方法使用读锁来保护对数据的读取操作，而`writeData`方法使用写锁来保护对数据的写入操作。在`main`方法中，我们创建了多个读线程来读取数据，并创建了一个写线程来写入新的数据。由于读写锁的特性，多个读线程可以同时读取数据，但写线程在写入数据时会独占写锁，从而确保写入的原子性。

## 三、注意事项

* 在使用ReentrantReadWriteLock时，应确保在finally块中释放锁，以避免死锁。
* 锁降级必须在持有写锁的情况下进行，且必须按照“获取写锁、获取读锁、释放写锁”的顺序进行。
* 锁升级（即持有读锁时获取写锁）是不被支持的，因为这会导致死锁。
* 根据实际需求选择合适的锁获取方式（公平或非公平），以平衡系统的吞吐量和公平性。

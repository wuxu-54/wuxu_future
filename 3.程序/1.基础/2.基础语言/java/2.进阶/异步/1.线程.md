# 线程

Java线程是Java并发编程的核心概念之一。以下是Java线程的详解，包括常用的类和API：

---

## 线程基本概念

1. **线程（Thread）**：线程是程序执行的最小单元，Java中每个线程都继承自`Thread`类或实现`Runnable`接口。

2. **进程（Process）**：进程是资源分配的最小单位，一个进程可以包含多个线程。

3. **并发（Concurrency）**：多个线程同时执行，以提高程序的执行效率。

4. **并行（Parallelism）**：多个线程同时在多个处理器上执行。

5. **线程安全（Thread Safety）**：当多个线程访问共享资源时，保证程序的执行结果正确。

### 常用线程类和接口

1. **Thread**：
   - Java线程类，用于创建和管理线程。

2. **Runnable**：
   - 一个接口，包含`run()`方法，用于定义线程执行的任务。

3. **Callable**：
   - 与`Runnable`类似，但`Callable`的任务可以有返回值，并能抛出异常。

4. **Future**：
   - 表示异步计算的结果，可用于获取`Callable`任务的结果。

5. **Executor**：
   - 一个接口，用于执行任务的组件，如`ExecutorService`。

6. **Executors**：
   - 一个工厂类，用于创建不同类型的线程池。

7. **ThreadLocal**：
   - 用于线程局部变量的存储，每个线程有自己的独立副本。

8. **Atomic**：
   - 原子类，如`AtomicInteger`、`AtomicLong`等，用于实现线程安全的计数器。

9. **Lock**：
   - 一个接口，提供比`synchronized`更丰富的锁操作。

10. **Condition**：
    - 与`Lock`接口配合使用，用于线程间的协调。

11. **ReentrantLock**：
    - 实现`Lock`接口的锁，支持中断、超时和尝试非阻塞获取锁。

12. **Semaphore**：
    - 一个计数信号量，用于控制同时访问某个特定资源的线程数量。

13. **CountDownLatch**：
    - 一个同步辅助工具，允许一个或多个线程等待一组事件。

14. **CyclicBarrier**：
    - 一个同步辅助工具，允许一组线程相互等待，直到所有线程都到达某个公共屏障点。

15. **Phaser**：
    - 一个同步辅助工具，用于多阶段的线程同步。

### 常用线程API

1. **start()**：
   - 启动线程，调用`run()`方法。

2. **run()**：
   - 线程执行的方法。

3. **sleep(long millis)**：
   - 使当前线程暂停执行指定的时间。

4. **yield()**：
   - 暗示调度器当前线程愿意放弃剩余的时间片，调度器可以安排其他线程执行。

5. **join()**：
   - 等待指定线程终止。

6. **interrupt()**：
   - 中断线程，设置中断状态。

7. **isInterrupted()**：
   - 检查线程是否被中断。

8. **currentThread()**：
   - 返回当前执行的线程。

9. **getStackTrace()**：
   - 获取线程的堆栈跟踪。

10. **setName(String name)**：
    - 设置线程的名称。

11. **getName()**：
    - 获取线程的名称。

12. **setDaemon(boolean on)**：
    - 设置线程是否为守护线程。

13. **isAlive()**：
    - 检查线程是否存活。

14. **setPriority(int priority)**：
    - 设置线程的优先级。

15. **getPriority()**：
    - 获取线程的优先级。

### 线程池API

1. **newFixedThreadPool(int nThreads)**：
   - 创建固定大小的线程池。

2. **newSingleThreadExecutor()**：
   - 创建只有一个线程的线程池。

3. **newCachedThreadPool()**：
   - 创建一个可根据需要创建新线程的线程池。

4. **newScheduledThreadPool(int corePoolSize)**：
   - 创建一个固定大小的线程池，用于定时或周期性执行任务。

5. **shutdown()**：
   - 等待线程池中的所有任务执行完毕。

6. **shutdownNow()**：
   - 尝试立即停止所有正在执行的任务，并返回等待执行的任务列表。

7. **isShutdown()**：
   - 检查线程池是否已关闭。

8. **isTerminated()**：
   - 检查线程池是否已终止。

9. **awaitTermination(long timeout, TimeUnit unit)**：
   - 等待线程池中的所有任务在指定时间内执行完毕。

通过这些类和API，你可以在Java中创建和管理线程，实现多线程编程，提高程序的并发性和性能。

---

## ThreadPoolExecutor

`ThreadPoolExecutor` 是 Java 中一个线程池执行器，它允许你管理和复用一组线程来执行任务。

### 构造函数

`ThreadPoolExecutor` 有多个构造函数，最常用的是以下这个：

```java
ThreadPoolExecutor(int corePoolSize,
                    int maximumPoolSize,
                    long keepAliveTime,
                    TimeUnit unit,
                    BlockingQueue<Runnable> workQueue)
```

- **corePoolSize**：线程池的基本大小，即在没有任务执行时线程池保留的线程数量。
- **maximumPoolSize**：线程池能够容纳同时执行的最大线程数量。
- **keepAliveTime**：当线程数大于 `corePoolSize` 时，多余的空闲线程能够存活的时间。
- **unit**：`keepAliveTime` 参数的时间单位。
- **workQueue**：一个阻塞队列，用于存储等待执行的任务。

### 核心概念

- **线程复用**：线程池会尽可能地复用已创建的线程。
- **任务队列**：当所有线程都在忙碌时，新任务会被放入队列等待执行。
- **线程创建**：当线程池中的线程数少于 `corePoolSize` 时，会创建新线程。
- **线程关闭**：线程池关闭时，会等待正在执行的任务完成。

### 使用方法

1. **创建线程池**：

   ```java
   int corePoolSize = 5;
   int maximumPoolSize = 10;
   long keepAliveTime = 1;
   TimeUnit unit = TimeUnit.MINUTES;
   BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();
   ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
   ```

2. **提交任务**：
   使用 `execute(Runnable command)` 方法提交任务：

   ```java
   executor.execute(new Runnable() {
       @Override
       public void run() {
           // 执行任务
       }
   });
   ```

3. **关闭线程池**：
   使用 `shutdown()` 方法关闭线程池，不再接受新任务：

   ```java
   executor.shutdown();
   ```

4. **优雅关闭**：
   使用 `shutdownNow()` 方法尝试立即停止所有正在执行的任务，并返回等待执行的任务列表：

   ```java
   List<Runnable> remainingTasks = executor.shutdownNow();
   ```

5. **等待线程池关闭**：
   使用 `awaitTermination(long timeout, TimeUnit unit)` 方法等待线程池关闭：

   ```java
   executor.awaitTermination(60, TimeUnit.SECONDS);
   ```

6. **设置线程工厂**：
   可以自定义线程工厂来设置线程名称或其他属性：

   ```java
   ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat("ThreadPool-%d").build();
   executor.setThreadFactory(threadFactory);
   ```

7. **设置拒绝策略**：
   当任务太多来不及处理时，可以设置拒绝策略来定义如何响应新任务：

   ```java
   executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
   ```

### 注意事项

- 选择合适的线程池大小，根据任务类型和系统资源进行调整。
- 选择合适的拒绝策略，如 `AbortPolicy`、`CallerRunsPolicy` 或 `DiscardPolicy`。
- 确保线程池在不再需要时被正确关闭，以释放资源。
- 使用线程池可以提高性能和资源利用率，但也要注意线程安全问题。

通过使用 `ThreadPoolExecutor`，你可以有效地管理和复用线程，处理并发任务，提高应用程序的响应性和吞吐量。

---

## 线程池策略

Java中的`ThreadPoolExecutor`类提供了几种不同的拒绝策略（RejectedExecutionHandler），用于处理当线程池无法接受新任务时的情况。这些策略都是在创建`ThreadPoolExecutor`实例时通过构造函数指定的。以下是`ThreadPoolExecutor`提供的四种主要拒绝策略及其具体使用方式：

### 1. AbortPolicy（默认策略）

**行为**：当任务无法被加入线程池时，直接抛出`RejectedExecutionException`异常。

**使用场景**：适用于那些不能丢弃任务且期望调用者处理被拒绝任务的场景。

**示例**：

```java
RejectedExecutionHandler handler = new ThreadPoolExecutor.AbortPolicy();
ExecutorService executor = new ThreadPoolExecutor(
    corePoolSize, 
    maximumPoolSize, 
    keepAliveTime, 
    unit, 
    workQueue, 
    Executors.defaultThreadFactory(), 
    handler
);
```

### 2. CallerRunsPolicy

**行为**：如果线程池不能接受新任务，则调用执行任务的`execute`方法的线程来运行该任务。

**使用场景**：适用于能够容忍任务执行在调用线程中的场景，有助于降低新任务提交的速率。

**示例**：

```java
RejectedExecutionHandler handler = new ThreadPoolExecutor.CallerRunsPolicy();
// 创建ThreadPoolExecutor的代码同上
```

### 3. DiscardPolicy

**行为**：直接丢弃任务，不抛出任何异常。

**使用场景**：适用于可以容忍任务丢失的情境，比如日志记录或统计任务。

**示例**：

```java
RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardPolicy();
// 创建ThreadPoolExecutor的代码同上
```

### 4. DiscardOldestPolicy

**行为**：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行任务（如果再次失败，则重复此过程）。

**使用场景**：适用于需要丢弃旧任务以确保新任务被执行的情境。

**示例**：

```java
RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardOldestPolicy();
// 创建ThreadPoolExecutor的代码同上
```

### 什么时候执行策略

线程池（如`ThreadPoolExecutor`）会在特定情况下执行其配置的拒绝策略。这些情况通常发生在线程池无法再接受新任务时，具体来说，当线程池和它的工作队列都达到饱和状态时，即：

1. **线程池中的线程数量已达到最大线程数（`maximumPoolSize`）**：线程池无法再创建新的线程来执行任务。

2. **工作队列已满**：线程池中的任务队列（如`LinkedBlockingQueue`、`ArrayBlockingQueue`等）已经存储了最大数量的待执行任务，无法再接受新的任务。

当上述两个条件同时满足时，如果再有新任务提交到线程池，线程池就会执行其配置的拒绝策略。Java提供了四种内置的拒绝策略，分别是：

- **AbortPolicy**：直接抛出`RejectedExecutionException`异常，阻止系统正常工作。这是默认的拒绝策略。
- **CallerRunsPolicy**：调用任务的`run()`方法绕过线程池直接运行任务。这可以保护任务不丢失，但可能会增加调用者的负担。
- **DiscardPolicy**：静默地丢弃无法处理的任务，不抛出异常。这可能会导致数据丢失。
- **DiscardOldestPolicy**：丢弃队列中最老的任务，然后尝试重新提交当前任务。这可能会导致一些任务被不公平地处理。

除了内置的拒绝策略外，用户还可以通过实现`RejectedExecutionHandler`接口来定义自己的拒绝策略。

在实际应用中，选择合适的拒绝策略对于确保系统的稳定性和性能至关重要。例如，如果任务非常重要且不能丢失，那么可能需要选择`CallerRunsPolicy`或自定义策略来确保任务得到执行。如果任务可以丢弃或重新生成，那么`DiscardPolicy`或`DiscardOldestPolicy`可能是更好的选择。

此外，为了避免频繁触发拒绝策略，可以通过调整线程池的参数（如核心线程数、最大线程数、工作队列容量等）来优化线程池的配置，以更好地适应应用程序的工作负载。

### 策略注意事项

- **默认策略**：如果未指定拒绝策略，`ThreadPoolExecutor`将使用`AbortPolicy`作为默认策略。
- **配置策略**：在创建`ThreadPoolExecutor`时，可以通过构造函数传入合适的`RejectedExecutionHandler`实现来配置拒绝策略。
- **选择策略**：选择合适的拒绝策略对维护系统的可靠性和性能至关重要，应根据具体的应用场景和需求来决定使用哪种策略。

通过理解和合理配置这些拒绝策略，可以有效地控制线程池在高负载和资源受限情况下的行为，从而确保应用程序的稳定性和性能。

---

## `ThreadPoolExecutor` 和 `Executors`区别

`ThreadPoolExecutor` 和 `Executors` 工具类都是 Java 中用于创建和管理线程池的机制，但它们之间存在一些关键区别：

1. **创建方式**：
   - `ThreadPoolExecutor`：需要手动创建并配置实例，提供了高度的自定义性，允许你精确控制线程池的各种参数，如核心线程数、最大线程数、存活时间、工作队列等。
   - `Executors`：是一个工具类，提供了一些静态工厂方法来快速创建常见的线程池。这些方法封装了 `ThreadPoolExecutor` 的配置过程，使得创建线程池更加便捷。

2. **配置灵活性**：
   - `ThreadPoolExecutor`：提供了极高的灵活性，允许开发者根据具体需求调整线程池的行为。
   - `Executors`：创建的线程池使用了一些默认配置，可能不适合所有场景。例如，使用 `Executors.newCachedThreadPool()` 创建的线程池没有核心线程数限制，可能会导致创建大量线程。

3. **线程池类型**：
   - `ThreadPoolExecutor`：可以创建任意类型的线程池，包括固定大小的线程池、单线程池、可调度线程池等。
   - `Executors`：提供了几种特定类型的线程池，如缓存线程池（`newCachedThreadPool()`）、固定大小线程池（`newFixedThreadPool()`）、单线程池（`newSingleThreadExecutor()`）和可调度线程池（`newScheduledThreadPool()`）。

4. **使用场景**：
   - `ThreadPoolExecutor`：适用于需要精细控制线程池行为的场景，或者需要创建自定义线程池的场景。
   - `Executors`：适用于快速创建标准线程池的场景，简化了线程池的创建过程。

5. **线程工厂和拒绝策略**：
   - `ThreadPoolExecutor`：在创建时可以指定自定义的线程工厂和拒绝策略。
   - `Executors`：创建的线程池使用默认的线程工厂和拒绝策略。例如，缓存线程池使用 `AbortPolicy` 作为拒绝策略，当任务过多时会抛出异常。

6. **性能和资源管理**：
   - `ThreadPoolExecutor`：由于其高度可配置性，可以更好地控制线程池的性能和资源使用。
   - `Executors`：虽然方便，但默认配置可能不是最优的，有时可能导致资源浪费或性能问题。

7. **示例代码**：

   ```java
   // 使用 ThreadPoolExecutor 创建线程池
   ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);

   // 使用 Executors 创建线程池
   ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
   ```

总结来说，`ThreadPoolExecutor` 提供了更多的控制权和自定义选项，适合需要精细调整的场景，而 `Executors` 工具类则提供了快速创建标准线程池的便捷方法，适用于大多数简单场景。在选择使用哪一个时，应根据实际需求和预期的线程池行为来决定。

---

## Condition

在 Java 中，`Condition` 接口是 `java.util.concurrent.locks` 包的一部分，它提供了一种多线程同步机制，允许线程在某些条件不满足时挂起（wait），并在条件满足时被唤醒（signal）。以下是 `Condition` 接口的基本用法和加锁与释放锁的说明：

### Condition 基本用法

1. **获取 Condition 对象**：
   从 `Lock` 接口实现类中获取 `Condition` 对象。

   ```java
   Lock lock = new ReentrantLock();
   Condition condition = lock.newCondition();
   ```

2. **等待条件**：
   使用 `await()` 方法使当前线程等待，直到其他线程调用相同 `Condition` 对象的 `signal()` 或 `signalAll()` 方法。

   ```java
   lock.lock();
   try {
       while (!conditionMet) {
           condition.await();
       }
       // 条件满足后的操作
   } finally {
       lock.unlock();
   }
   ```

3. **唤醒等待的线程**：
   使用 `signal()` 方法唤醒等待队列中的下一个线程，或使用 `signalAll()` 方法唤醒所有等待的线程。

   ```java
   lock.lock();
   try {
       conditionMet = true;
       condition.signalAll(); // 唤醒所有等待的线程
   } finally {
       lock.unlock();
   }
   ```

### 加锁与释放锁

- **加锁**：在调用 `Condition` 的 `await()`、`signal()` 或 `signalAll()` 方法之前，必须首先通过 `Lock` 对象获取锁。这可以通过 `lock.lock()` 方法实现。

- **释放锁**：在 `Condition` 的操作完成后，必须释放锁。这可以通过 `lock.unlock()` 方法实现，通常放在 `finally` 块中，以确保即使发生异常也能释放锁。

### 重要注意事项

- **锁的粒度**：`Condition` 操作必须在 `Lock` 对象的保护下执行，以确保线程安全。
- **避免死锁**：在使用 `Condition` 时，要确保不会因错误的加锁顺序或持有多个锁而导致死锁。
- **响应中断**：`await()` 方法可响应中断，如果线程在等待时被中断，它会抛出 `InterruptedException`。在这种情况下，应该处理异常并根据需要释放锁。
- **超时等待**：`await()` 方法有一个超时版本 `await(long timeout, TimeUnit unit)`，允许线程在指定时间内等待条件满足。

通过使用 `Condition`，你可以实现更细粒度的线程同步控制，例如，当多个条件需要满足时，或者当需要更复杂的线程间协作时。这种机制比使用 `Object` 的 `wait()` 和 `notify()` 方法提供了更高的灵活性和更强的功能。

---

## 注意点

1. lock中不运行使用`wait()`，使用`lock.newCondition()`获取`Condition`对象，通过`Condition`进行加锁和唤醒操作。
2. 实际开发中，使用线程池创建线程，因为其内部有线程调度创建的优化减少资源浪费。同时必须要设置线程名。
3. 在单独子线程想要实现同步，可使用`while(isRun){ await(1000,TimeUnit.MILLISECONDS) }` isRun是个布尔变量，如果是2个以上，那么使用锁机制即可。

---

在Java中，`ThreadGroup` 类是用于对线程进行分组管理的一个类。每个线程都属于某个线程组，当一个线程创建时，它要么属于创建它的线程的线程组，要么属于它指定的线程组。以下是一些关于Java线程组的关键点和用法：

1. **创建线程组**:

   ```java
   ThreadGroup group = new ThreadGroup("groupName");
   ```

2. **创建并启动线程** 在指定的线程组中:

   ```java
   Thread thread = new Thread(group, new Runnable() {
       public void run() {
           // 线程执行的任务
       }
   });
   thread.start();
   ```

3. **获取当前线程的线程组**:

   ```java
   ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();
   ```

4. **获取线程组的名称**:

   ```java
   String groupName = currentGroup.getName();
   ```

5. **遍历线程组中的所有线程**:

   ```java
   int numThreads = currentGroup.activeCount();
   Thread[] threads = new Thread[numThreads];
   currentGroup.enumerate(threads);
   for (Thread thread : threads) {
       // 处理线程
   }
   ```

6. **中断线程组中的所有线程**:

   ```java
   currentGroup.interrupt();
   ```

7. **检查线程组是否为守护线程组**:

   ```java
   boolean isDaemon = currentGroup.isDaemon();
   ```

8. **设置线程组为守护线程组**:

   ```java
   currentGroup.setDaemon(true);
   ```

9. **销毁线程组**:
   销毁一个线程组是危险的操作，因为它会中断其中的所有线程。

   ```java
   currentGroup.destroy();
   ```

10. **设置线程组的优先级**:
    线程组的优先级可以被设置，并且会影响其中所有线程的优先级。

    ```java
    currentGroup.setPriority(Thread.MAX_PRIORITY);
    ```

11. **列出线程组及其所有子线程组**:

    ```java
    ThreadGroup parentGroup = currentGroup.getParent();
    while (parentGroup != null) {
        System.out.println(parentGroup.getName());
        parentGroup = parentGroup.getParent();
    }
    ```

12. **阻止当前线程直到线程组中所有线程执行完毕**:

    ```java
    currentGroup.wait();
    ```

使用线程组可以方便地管理多个线程，尤其是在需要对线程进行批量操作时，例如遍历、中断或等待线程完成。然而，由于Java线程模型的复杂性，`ThreadGroup` 类在现代Java应用程序中的使用并不普遍。通常，更推荐使用`ExecutorService` 来管理线程池和任务执行。

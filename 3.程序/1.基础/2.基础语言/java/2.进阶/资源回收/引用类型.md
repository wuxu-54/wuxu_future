# 引用类型

在 Java 中，引用类型决定了对象的生命周期和垃圾回收行为。Java 提供了四种类型的引用：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。这些引用类型主要用于更精细地控制对象的生命周期。

>结合各个类型的作用，可以方便的管理对象。常用的是弱引用，比如在使用监听器时，通过包裹WeakReference，可将其设置为弱引用，gc会回收此对象避免内存泄漏。

## 1. 强引用（Strong Reference）

- **描述**：最常见的引用类型，如果一个对象具有强引用，那么它永远不会被垃圾回收器回收，直到这个引用被显式地设置为 `null`，或者从集合中移除。
- **示例**：

  ```java
  Object obj = new Object();
  ```

## 2. 软引用（Soft Reference）

- **描述**：软引用关联的对象在内存不足时会被回收。它们主要用于实现内存敏感的高速缓存。
- **特点**：通过 `java.lang.ref.SoftReference` 类实现。
- **使用场景**：缓存机制，如图片缓存、大对象缓存等。
- **示例**：

  ```java
  SoftReference<Object> softRef = new SoftReference<>(new Object());
  ```

## 3. 弱引用（Weak Reference）

- **描述**：弱引用关联的对象只要垃圾回收器发现了它，不管当前内存是否足够，都会回收其指向的对象。
- **特点**：通过 `java.lang.ref.WeakReference` 类实现。
- **使用场景**：临时缓存、引用队列、监听器等。
- **示例**：

  ```java
  WeakReference<Object> weakRef = new WeakReference<>(new Object());
  ```

## 4. 虚引用（Phantom Reference）

- **描述**：虚引用是最弱的一种引用，它不会影响对象的生命周期，即无法通过虚引用来获取一个对象的实例。它主要用于跟踪对象被垃圾回收的活动。
- **特点**：通过 `java.lang.ref.PhantomReference` 类实现，并且必须与 `java.lang.ref.ReferenceQueue` 一起使用。
- **使用场景**：跟踪对象被垃圾回收的状态，用于资源清理。
- **示例**：

  ```java
  ReferenceQueue<Object> queue = new ReferenceQueue<>();
  PhantomReference<Object> phantomRef = new PhantomReference<>(new Object(), queue);
  ```

## 引用队列（ReferenceQueue）

- **描述**：当引用对象被垃圾回收时，引用对象会被加入到与之关联的引用队列中。
- **使用场景**：与弱引用和虚引用配合使用，用于接收垃圾回收的通知。

## 垃圾回收

- **强引用**：只要存在强引用，对象就不会被回收。
- **软引用**：内存不足时会被回收。
- **弱引用**：垃圾回收器发现时会被回收。
- **虚引用**：不影响对象的生命周期，主要用于跟踪对象的回收状态。

## 总结

通过使用不同的引用类型，Java 允许开发者根据应用的需要来控制对象的生命周期。软引用和弱引用常用于缓存，而虚引用则用于资源的清理和监控。强引用是最常用的，但如果使用不当，可能会导致内存泄漏。

---

## 弱引用

在Java中，弱引用（Weak Reference）是一种比软引用（Soft Reference）更弱的引用类型。弱引用所指向的对象只能生存到下一次垃圾回收（GC）发生为止。如果对象只具有弱引用，那么它将被视为垃圾回收的候选对象，只要垃圾回收器发现了它，不管当前内存是否足够，都会回收其指向的对象。

### 弱引用的特点

1. **生命周期短暂**：弱引用指向的对象在垃圾回收时会被回收，即使内存空间还足够。
2. **无法通过弱引用访问对象**：一旦对象被垃圾回收，弱引用将不会指向任何对象。
3. **配合引用队列使用**：弱引用通常与`ReferenceQueue`一起使用，当对象被垃圾回收后，弱引用会被放入引用队列中。

### 弱引用的使用场景

1. **缓存**：用于实现缓存机制，当内存不足时可以自动回收缓存对象。
2. **监听器**：用于管理事件监听器，防止内存泄漏。
3. **临时引用**：用于临时持有对象引用，而不阻止对象被垃圾回收。

### 弱引用的实现

在Java中，弱引用是通过`java.lang.ref.WeakReference`类实现的。以下是使用弱引用的基本步骤：

1. **创建弱引用**：

   ```java
   Object object = new Object();
   WeakReference<Object> weakRef = new WeakReference<>(object);
   ```

2. **使用引用队列**：

   ```java
   ReferenceQueue<Object> queue = new ReferenceQueue<>();
   WeakReference<Object> weakRef = new WeakReference<>(object, queue);
   ```

3. **检查对象是否被回收**：

   ```java
   Object obj = weakRef.get(); // 获取弱引用指向的对象
   if (obj == null) {
       // 对象已被回收
   }
   ```

4. **处理引用队列中的弱引用**：

   ```java
   Reference<?> ref = queue.poll(); // 从引用队列中获取被回收的弱引用
   if (ref != null) {
       // 处理被回收的对象
   }
   ```

### 示例代码

以下是一个使用弱引用的示例，展示如何创建弱引用，如何判断对象是否被回收，以及如何使用引用队列来处理对象回收。

```java
import java.lang.ref.ReferenceQueue;
import java.lang.ref.WeakReference;

public class WeakReferenceExample {
    public static void main(String[] args) {
        // 创建一个对象
        MyObject myObject = new MyObject("Kimi");

        // 创建一个引用队列
        ReferenceQueue<MyObject> queue = new ReferenceQueue<>();

        // 创建一个弱引用，关联到引用队列
        WeakReference<MyObject> weakRef = new WeakReference<>(myObject, queue);

        // 清除强引用，使得对象只被弱引用所引用
        myObject = null;

        // 执行垃圾回收
        System.gc();

        // 检查引用队列，看是否有对象被回收
        WeakReference<MyObject> polledRef;
        while ((polledRef = (WeakReference<MyObject>) queue.poll()) != null) {
            System.out.println("对象已被回收，引用: " + polledRef);
        }

        // 尝试获取弱引用指向的对象
        MyObject obj = weakRef.get();
        if (obj != null) {
            System.out.println("对象仍然存在，内容: " + obj.getContent());
        } else {
            System.out.println("对象已被回收");
        }
    }

    static class MyObject {
        private String content;

        public MyObject(String content) {
            this.content = content;
        }

        public String getContent() {
            return content;
        }
    }
}
```

在这个示例中：

1. 创建了一个MyObject对象，并将其引用传递给一个WeakReference。
2. 将WeakReference注册到一个ReferenceQueue。
3. 清除了强引用，使得对象只被弱引用所引用。
4. 调用System.gc()来提示垃圾回收器进行垃圾回收。
5. 检查引用队列，看是否有对象被回收。
6. 尝试通过弱引用获取对象，判断对象是否仍然存在。

这个示例展示了如何使用弱引用和引用队列来跟踪对象的生命周期，并在对象被回收时进行相应的处理。

### 注意事项

- 弱引用不适合长时间持有对象，因为它们会在下一次垃圾回收时被回收。
- 使用弱引用时，应该注意对象可能随时被回收的情况。
- 弱引用通常与引用队列一起使用，以便在对象被回收时执行一些清理工作。

# ClassLoader

## 源码流程

ClassLoader  jdk中的类

![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image.png)
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-1.png)
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-3.png)
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-2.png)
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-4.png)
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-5.png)
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-6.png)
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-8.png)
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-9.png)

---
loadclass

![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-10.png)
URLClassLoader、SecureClassLoader 都没有重写此方法，所以最终是ClassLoader来处理

![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-11.png)
ClassLoader中采用双亲委派机制，最终交给ExtClassLoader（因为parent最终指向它），再之后parent为空，走到`findBootstrapClassOrNull(name)`

![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-12.png)
由此可知，最终是走到了native方法中。也就是`Bootstrap classloader`里。

---

findclass

ClassLoader是交给子类实现的。观察源码AppClassLoader中也没有实现，向父类跟踪发现其是在URLClassLoader实现的。
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-13.png)
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-14.png)
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-15.png)
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-16.png)
最终还是调用到ClassLoader的difineClass方法
![Alt text](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-17.png)
再往下追踪，走到了native层。也就是说最终走到c++层，说明是虚拟机功能的部分了

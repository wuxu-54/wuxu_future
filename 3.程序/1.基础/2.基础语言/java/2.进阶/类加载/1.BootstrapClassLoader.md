# BootstrapClassLoader

它是c++代码中，是虚拟机的一部分，JVM启动时通过BootStrap类加载器加载rt.jar等核心jar包的class文件。int.class、String.class都是由他加载

![BootstrapClassLoader描述](../../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD/BootstrapClassLoader%E6%8F%8F%E8%BF%B0.png)

## 简介

Bootstrap ClassLoader 是 Java 虚拟机（JVM）的一个核心组件，它负责加载 Java 核心库，比如 `rt.jar`。由于它是用 C++ 实现的，并且是 JVM 的一部分，因此它没有 Java 源码。这意味着我们不能像查看 Java 编写的类加载器（如 `ExtClassLoader` 和 `AppClassLoader`）那样直接查看 Bootstrap ClassLoader 的源码。

Bootstrap ClassLoader 的实现细节隐藏在 JVM 内部，通常是在 JVM 的 C++ 代码中，特别是在 HotSpot 虚拟机中。如果你需要了解 Bootstrap ClassLoader 的工作原理，你可能需要查看 JVM 的实现代码，这通常可以在 OpenJDK 项目中找到。

1. **类加载器的分类**：
   - JVM 支持两种类型的类加载器：引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。
   - 引导类加载器是用 C++ 实现的，而自定义类加载器是用 Java 语言实现的，并且它们都派生于抽象类 `ClassLoader`。

2. **类加载器的层级结构**：
   - JVM 中存在一个类加载器的层级结构，其中 Bootstrap ClassLoader 在最底层，上面是扩展类加载器（ExtClassLoader）和应用程序类加载器（AppClassLoader）。

3. **获取引导类加载器**：
   - 在 Java 代码中，无法直接获取到 Bootstrap ClassLoader 的引用，因为它是在 JVM 层面实现的。
   - 尝试通过 `ClassLoader` 层级获取到 Bootstrap ClassLoader 时，会返回 `null`。

4. **Bootstrap ClassLoader 加载的资源**：
   - Bootstrap ClassLoader 主要负责加载 JVM 核心库，比如 `rt.jar`。

5. **双亲委派模型**：
   - 尽管 Bootstrap ClassLoader 不能直接从 Java 代码中访问，但它是双亲委派模型的一部分，该模型决定了类加载器如何查找和加载类。

6. **自定义类加载器**：
   - 自定义类加载器可以扩展 `ClassLoader` 类并重写 `findClass` 方法来实现自定义的类加载逻辑。

由于 Bootstrap ClassLoader 的实现细节在 JVM 内部，如果你需要深入了解其源码，你可能需要查看 JVM 的具体实现，比如 HotSpot VM 的 C++ 源码。在 OpenJDK 项目中，这些源码通常位于 `src/share/vm` 目录下。

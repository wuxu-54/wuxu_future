# Java 反射相关的主要 API

Java 的反射机制允许程序在运行时动态地获取类的信息并操作类的属性、方法和构造函数等。以下是 Java 反射相关的主要 API 分类介绍：

## 1. `java.lang.Class` 类

`Class` 类是 Java 反射的核心，它代表一个类或接口，通过 `Class` 对象可以获取类的各种信息。

- **获取 `Class` 对象的方法**
  - `Class.forName("全限定类名")`：通过类的全限定名获取 `Class` 对象。

    ```java
    try {
        Class<?> clazz = Class.forName("java.util.ArrayList");
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
    ```

  - `类名.class`：直接通过类名获取 `Class` 对象。

    ```java
    Class<?> clazz = String.class;
    ```

  - `对象.getClass()`：通过对象实例获取其对应的 `Class` 对象。

    ```java
    String str = "hello";
    Class<?> clazz = str.getClass();
    ```

- **`Class` 类的常用方法**
  - `getName()`：返回类的全限定名。
  - `getSimpleName()`：返回类的简单名称。
  - `getSuperclass()`：返回该类的父类的 `Class` 对象。
  - `getInterfaces()`：返回该类实现的所有接口的 `Class` 对象数组。
  - `isPrimitive()`：判断该类是否为基本数据类型。
  - `isArray()`：判断该类是否为数组类型。

## 2. `java.lang.reflect.Constructor` 类

`Constructor` 类代表类的构造函数，通过它可以创建类的实例。

- **获取 `Constructor` 对象的方法**
  - `getConstructors()`：返回该类的所有公共构造函数的 `Constructor` 对象数组。
  - `getConstructor(Class<?>... parameterTypes)`：返回指定参数类型的公共构造函数的 `Constructor` 对象。
  - `getDeclaredConstructors()`：返回该类的所有构造函数的 `Constructor` 对象数组，包括私有构造函数。
  - `getDeclaredConstructor(Class<?>... parameterTypes)`：返回指定参数类型的构造函数的 `Constructor` 对象，包括私有构造函数。
- **`Constructor` 类的常用方法**
  - `newInstance(Object... initargs)`：使用该构造函数创建类的实例。
  - `setAccessible(true)`：设置构造函数的可访问性，可用于访问私有构造函数。

## 3. `java.lang.reflect.Method` 类

`Method` 类代表类的方法，通过它可以调用类的方法。

- **获取 `Method` 对象的方法**
  - `getMethods()`：返回该类的所有公共方法的 `Method` 对象数组，包括继承的方法。
  - `getMethod(String name, Class<?>... parameterTypes)`：返回指定名称和参数类型的公共方法的 `Method` 对象。
  - `getDeclaredMethods()`：返回该类的所有方法的 `Method` 对象数组，不包括继承的方法。
  - `getDeclaredMethod(String name, Class<?>... parameterTypes)`：返回指定名称和参数类型的方法的 `Method` 对象，包括私有方法。
- **`Method` 类的常用方法**
  - `invoke(Object obj, Object... args)`：调用该方法，`obj` 是调用该方法的对象实例，`args` 是方法的参数。
  - `setAccessible(true)`：设置方法的可访问性，可用于访问私有方法。

## 4. `java.lang.reflect.Field` 类

`Field` 类代表类的属性，通过它可以访问和修改类的属性值。

- **获取 `Field` 对象的方法**
  - `getFields()`：返回该类的所有公共属性的 `Field` 对象数组，包括继承的属性。
  - `getField(String name)`：返回指定名称的公共属性的 `Field` 对象。
  - `getDeclaredFields()`：返回该类的所有属性的 `Field` 对象数组，不包括继承的属性。
  - `getDeclaredField(String name)`：返回指定名称的属性的 `Field` 对象，包括私有属性。
- **`Field` 类的常用方法**
  - `get(Object obj)`：获取指定对象的该属性的值。
  - `set(Object obj, Object value)`：设置指定对象的该属性的值。
  - `setAccessible(true)`：设置属性的可访问性，可用于访问和修改私有属性。

## 5. `java.lang.reflect.Modifier` 类

`Modifier` 类用于解析和操作类、方法、属性等的修饰符，如 `public`、`private`、`static` 等。

- **常用方法**
  - `isPublic(int mod)`：判断修饰符是否包含 `public`。
  - `isPrivate(int mod)`：判断修饰符是否包含 `private`。
  - `isStatic(int mod)`：判断修饰符是否包含 `static`。
  - `toString(int mod)`：返回修饰符的字符串表示。

## 6. `java.lang.reflect.Array` 类

`Array` 类提供了动态创建和访问数组的方法。

- **常用方法**
  - `newInstance(Class<?> componentType, int length)`：创建指定类型和长度的数组。
  - `get(Object array, int index)`：获取数组中指定索引位置的元素。
  - `set(Object array, int index, Object value)`：设置数组中指定索引位置的元素的值。

## 示例代码

```java
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

class ExampleClass {
    private String privateField = "private field";
    public String publicField = "public field";

    public ExampleClass() {}

    private ExampleClass(String param) {
        this.privateField = param;
    }

    public void publicMethod() {
        System.out.println("This is a public method.");
    }

    private void privateMethod() {
        System.out.println("This is a private method.");
    }
}

public class ReflectionExample {
    public static void main(String[] args) throws Exception {
        // 获取 Class 对象
        Class<?> clazz = ExampleClass.class;

        // 获取构造函数并创建实例
        Constructor<?> privateConstructor = clazz.getDeclaredConstructor(String.class);
        privateConstructor.setAccessible(true);
        ExampleClass example = (ExampleClass) privateConstructor.newInstance("new value");

        // 获取并修改私有属性
        Field privateField = clazz.getDeclaredField("privateField");
        privateField.setAccessible(true);
        System.out.println(privateField.get(example));
        privateField.set(example, "updated value");
        System.out.println(privateField.get(example));

        // 调用私有方法
        Method privateMethod = clazz.getDeclaredMethod("privateMethod");
        privateMethod.setAccessible(true);
        privateMethod.invoke(example);
    }
}
```

以上代码展示了如何使用 Java 反射机制来访问类的构造函数、属性和方法。

## 示例2

使用反射API创建Person对象并调用其方法：

```java
public class ReflectionExample {
    public static void main(String[] args) {
        try {
            // 获取Person类的Class对象
            Class<?> clazz = Class.forName("Person");

            // 使用无参构造函数创建Person实例
            Object person = clazz.newInstance();

            // 使用有参构造函数创建Person实例
            Constructor<?> constructor = clazz.getConstructor(String.class, int.class);
            Object anotherPerson = constructor.newInstance("John Doe", 30);

            // 获取名为"name"的字段，并设置值
            Field nameField = clazz.getDeclaredField("name");
            nameField.setAccessible(true);
            nameField.set(person, "Alice");

            // 获取名为"age"的字段，并设置值
            Field ageField = clazz.getDeclaredField("age");
            ageField.setAccessible(true);
            ageField.setInt(person, 25);

            // 获取introduceYourself方法并调用
            Method method = clazz.getMethod("introduceYourself");
            method.invoke(person);

            // 调用anotherPerson的introduceYourself方法
            method.invoke(anotherPerson);

            // 调用静态方法并获取结果，使用Method对象的invoke(Object obj, Object... args)方法来调用静态方法。
            //对于静态方法，invoke的第一个参数为null。args是一个对象数组，包含了实际传递给方法的参数值。
            Object result = method.invoke(null, args); 
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

输出结果：

```txt
Hello, my name is Alice and I am 25 years old.
Hello, my name is John Doe and I am 30 years old.
```

通过这个示例，我们展示了如何使用反射API来动态地创建对象、访问和设置字段值，以及调用方法。反射API是Java语言中非常强大的工具，但也应该谨慎使用，因为它可能会导致代码难以理解和调试，同时可能会带来性能问题。

---

除了前面提到的 `Class`、`Constructor`、`Method`、`Field`、`Modifier` 和 `Array` 类之外，Java 反射中还有一些其他比较常用的类，以下为你详细介绍：

## 1. `java.lang.reflect.Proxy` 类

- **作用**：`Proxy` 类提供了创建动态代理类和实例的静态方法，它是 Java 实现动态代理机制的核心类。动态代理允许在运行时创建一个实现了一组指定接口的新类，并且可以在调用这些接口方法时插入自定义的逻辑，常用于 AOP（面向切面编程）、远程方法调用等场景。
- **常用方法**
  - `newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`：该方法用于创建一个实现了指定接口的动态代理对象。`loader` 是定义代理类的类加载器；`interfaces` 是代理类要实现的接口数组；`h` 是一个实现了 `InvocationHandler` 接口的对象，用于处理代理对象方法的调用。
- **示例代码**

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 定义一个接口
interface MyInterface {
    void doSomething();
}

// 实现 InvocationHandler 接口
class MyInvocationHandler implements InvocationHandler {
    private Object target;

    public MyInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("Before method call");
        Object result = method.invoke(target, args);
        System.out.println("After method call");
        return result;
    }
}

// 实现接口的类
class MyClass implements MyInterface {
    @Override
    public void doSomething() {
        System.out.println("Doing something...");
    }
}

public class ProxyExample {
    public static void main(String[] args) {
        MyClass myClass = new MyClass();
        MyInvocationHandler handler = new MyInvocationHandler(myClass);
        MyInterface proxy = (MyInterface) Proxy.newProxyInstance(
                MyClass.class.getClassLoader(),
                new Class<?>[]{MyInterface.class},
                handler
        );
        proxy.doSomething();
    }
}
```

## 2. `java.lang.reflect.InvocationHandler` 接口

- **作用**：`InvocationHandler` 接口是实现动态代理时必须实现的接口，它定义了一个 `invoke` 方法，用于处理代理对象方法的调用。当调用代理对象的方法时，实际上会调用 `InvocationHandler` 中的 `invoke` 方法，在该方法中可以插入自定义的逻辑，如日志记录、权限检查等。
- **常用方法**
  - `invoke(Object proxy, Method method, Object[] args)`：该方法在代理对象的方法被调用时执行。`proxy` 是代理对象本身；`method` 是被调用的方法对象；`args` 是调用方法时传递的参数数组。返回值是方法调用的返回结果。

## 3. `java.lang.reflect.Type` 接口及其子接口

- **作用**：`Type` 接口是 Java 反射中所有类型的公共超接口，它提供了一种更通用的方式来表示类型信息，包括类类型、参数化类型、数组类型、类型变量和通配符类型等。在处理泛型信息时，`Type` 接口及其子接口非常有用。
- **常用子接口和类**
  - **`ParameterizedType` 接口**：表示参数化类型，即带有泛型参数的类型，如 `List<String>`。通过该接口可以获取泛型的实际类型参数。
  - **`GenericArrayType` 接口**：表示泛型数组类型，如 `List<String>[]`。
  - **`TypeVariable` 接口**：表示类型变量，如泛型类或方法中定义的类型参数（如 `T`）。
  - **`WildcardType` 接口**：表示通配符类型，如 `? extends Number` 或 `? super Integer`。
- **示例代码**

```java
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;

class GenericClass<T> {
    private List<T> list;

    public GenericClass() {
        Type superclass = getClass().getGenericSuperclass();
        if (superclass instanceof ParameterizedType) {
            ParameterizedType parameterizedType = (ParameterizedType) superclass;
            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
            for (Type type : actualTypeArguments) {
                System.out.println("Actual type argument: " + type.getTypeName());
            }
        }
    }
}

class StringGenericClass extends GenericClass<String> {
    public StringGenericClass() {
        super();
    }
}

public class TypeExample {
    public static void main(String[] args) {
        StringGenericClass stringGenericClass = new StringGenericClass();
    }
}
```

## 4. `java.lang.reflect.AnnotatedElement` 接口

- **作用**：`AnnotatedElement` 接口是 Java 反射中用于表示可以被注解的元素的接口，包括类、方法、字段、构造函数等。通过该接口可以获取元素上的注解信息，从而在运行时根据注解进行相应的处理。
- **常用方法**
  - `getAnnotations()`：返回该元素上的所有注解。
  - `getAnnotation(Class<T> annotationClass)`：返回该元素上指定类型的注解，如果不存在则返回 `null`。
  - `isAnnotationPresent(Class<? extends Annotation> annotationClass)`：判断该元素上是否存在指定类型的注解。
- **示例代码**

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.Method;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface MyAnnotation {
    String value();
}

class MyAnnotatedClass {
    @MyAnnotation("Hello")
    public void myMethod() {}
}

public class AnnotationExample {
    public static void main(String[] args) throws NoSuchMethodException {
        Class<?> clazz = MyAnnotatedClass.class;
        Method method = clazz.getMethod("myMethod");
        if (method.isAnnotationPresent(MyAnnotation.class)) {
            MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);
            System.out.println("Annotation value: " + annotation.value());
        }
    }
}
```

这些类和接口在 Java 反射中都有着重要的作用，能够帮助开发者在运行时更灵活地操作类和对象，实现一些高级的功能。

---

## getDeclaredField 和 getField  区别

在Java反射API中，getDeclaredField 和 getField 是两个用于获取类字段（Field）的方法，它们属于不同的类，并且有不同的行为：

### getDeclaredField

`getDeclaredField` 是 Class 类的一个方法。它用于获取类中声明的字段，包括**私有（private）字段**，但**不包括继承的字段**。这个方法只能获取到在该类中定义的字段，对于父类中定义的字段，即使它们是可访问的（public, protected），也无法通过子类的 getDeclaredField 获取。

### getDeclaredField示例

```java
Class<?> clazz = MyClass.class;
Field declaredField = clazz.getDeclaredField("myField");
```

### getField

`getField` 是 Class 类的一个方法，但它已经被废弃（deprecated），推荐使用 `getDeclaredField`。
它用于**获取类或其父类、或接口中定义的公共（public）字段**。也就是说，**它可以访问类继承的字段，但不包括私有字段**。

### getField示例

```java
Field field = clazz.getField("myField");
```

### 区别

- 继承字段的访问：getField 可以访问继承的公共字段，而 getDeclaredField 不能，它只能访问在该类中声明的字段。
- 访问权限：getField 只能获取公共字段，而 getDeclaredField 可以获取包括私有字段在内的所有字段（需要使用 setAccessible(true) 来改变访问权限）。
- 推荐使用：getField 已被弃用，推荐使用 getDeclaredField。

### 注意事项

- 从Java 9开始，getFields() 和 getField 方法已被弃用，因为它们违反了Java的封装原则。推荐使用 getDeclaredFields() 和 getDeclaredField。
- 使用反射操作私有字段或方法时，应先通过 setAccessible(true) 方法来改变它们的访问权限，但这可能会破坏封装性并带来安全风险。
- 在实际应用中，应根据具体需求选择使用 getDeclaredField 或其他相关方法。如果需要访问类的所有公共字段，包括继承的字段，可以使用 getDeclaredFields 来获取所有声明的字段的数组，然后过滤出公共字段。

---

## getMethod 和 getDeclaredMethod区别

在Java反射API中，`getMethod` 和 `getDeclaredMethod` 是两个用于获取类中方法（Method）的方法，它们都属于 Class 类，但有着不同的行为和用途：

### getMethod

- getMethod 用于获取类中所有的 public 方法，包括从父类或接口中继承来的方法。
- 只能获取 public 类型的方法，无法获取 private 或 protected 方法。
- 如果子类重写了父类的方法，getMethod 将返回子类覆盖的方法。

示例：

```java
Class<?> clazz = MyClass.class;
Method method = clazz.getMethod("methodName", parameterTypes); // parameterTypes是要传递的参数类型
```

### getDeclaredMethod

- getDeclaredMethod 用于获取类中声明的方法，无论该方法是 public、private、protected 还是 default（包访问权限）。
- 只能获取在该类中声明的方法，不包括继承自父类或接口的方法。
- 如果一个方法在子类中被重写，getDeclaredMethod 将返回子类中声明的版本。

示例：

```java
Class<?> clazz = MyClass.class;
Method declaredMethod = clazz.getDeclaredMethod("methodName", parameterTypes);
```

### Method区别

- 继承方法的访问：getMethod 可以访问从父类或接口继承来的 public 方法，而 getDeclaredMethod 只能访问在该类中声明的方法。
- 访问权限：getMethod 只能获取 public 方法，而 getDeclaredMethod 可以获取任何访问权限的方法。
- 重写方法：当获取一个可能被重写的方法时，getMethod 返回的是实际调用的方法（可能是子类重写的版本），而 getDeclaredMethod 返回的是类中声明的方法版本。

### Method注意事项

- 使用反射调用私有方法或构造函数时，可能需要使用 `setAccessible(true)` 来改变它们的访问权限。
- 反射可以破坏封装性，因此在使用时需要谨慎，以避免安全风险和维护问题。

在实际使用中，选择 `getMethod` 或 `getDeclaredMethod` 取决于你是否需要访问继承的方法，以及你对方法的访问权限有何要求。

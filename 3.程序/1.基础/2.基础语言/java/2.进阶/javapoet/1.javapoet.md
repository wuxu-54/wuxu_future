# javapoet

文档：[github地址](https://github.com/square/javapoet/blob/master/README.md?spm=5176.28103460.0.0.297c5d27mSNjEz&file=README.md)

## 简介

JavaPoet 提供了一系列的 API 来帮助开发者生成 Java 源文件。

## 主要 API

以下是一些常用的 API 及其使用示例，这些示例可以帮助你快速上手 JavaPoet。

1. **ClassName**: 用于表示一个类的完全限定名。

   ```java
   ClassName list = ClassName.get("java.util", "List");
   ```

2. **TypeSpec**: 用于构建类、接口或枚举的定义。
   - 创建类：

     ```java
     TypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")
         .addModifiers(Modifier.PUBLIC)
         .build();
     ```

3. **MethodSpec**: 用来描述方法的签名和内容。
   - 添加方法：

     ```java
     MethodSpec main = MethodSpec.methodBuilder("main")
         .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
         .returns(void.class)
         .addParameter(String[].class, "args")
         .addStatement("$T.out.println($S)", System.class, "Hello, JavaPoet!")
         .build();
     ```

4. **FieldSpec**: 用于定义字段。
   - 添加字段：

     ```java
     FieldSpec staticFinalField = FieldSpec.builder(String.class, "GREETING")
         .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
         .initializer("$S", "Hello, World!")
         .build();
     ```

5. **ParameterSpec**: 定义方法参数的规范。
   - 使用 ParameterSpec 构建参数：

     ```java
     ParameterSpec stringParam = ParameterSpec.builder(String.class, "message")
         .build();
     ```

6. **AnnotationSpec**: 用于创建注解。
   - 添加注解：

     ```java
     AnnotationSpec overrideAnnotation = AnnotationSpec.builder(Override.class).build();
     ```

7. **JavaFile**: 将生成的代码写入到文件中。
   - 写入文件：

     ```java
     JavaFile javaFile = JavaFile.builder("com.example.helloworld", helloWorld)
         .build();
     javaFile.writeTo(System.out); // 输出到控制台
     ```

## 示例代码

```java
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeSpec;

import javax.lang.model.element.Modifier;

public class SimpleClassGenerator {
    public static void main(String[] args) throws Exception {
        // 定义 name 字段
        FieldSpec nameField = FieldSpec.builder(String.class, "name")
                .addModifiers(Modifier.PRIVATE)
                .build();

        // 定义 age 字段
        FieldSpec ageField = FieldSpec.builder(int.class, "age")
                .addModifiers(Modifier.PRIVATE)
                .build();

        // 定义构造函数
        ParameterSpec nameParam = ParameterSpec.builder(String.class, "name").build();
        ParameterSpec ageParam = ParameterSpec.builder(int.class, "age").build();

        MethodSpec constructor = MethodSpec.constructorBuilder()
                .addModifiers(Modifier.PUBLIC)
                .addParameters(nameParam, ageParam)
                .addStatement("this.$N = $N", nameField, nameParam)
                .addStatement("this.$N = $N", ageField, ageParam)
                .build();

        // 定义 getName 方法
        MethodSpec getNameMethod = MethodSpec.methodBuilder("getName")
                .addModifiers(Modifier.PUBLIC)
                .returns(String.class)
                .addStatement("return this.$N", nameField)
                .build();

        // 定义 getAge 方法
        MethodSpec getAgeMethod = MethodSpec.methodBuilder("getAge")
                .addModifiers(Modifier.PUBLIC)
                .returns(int.class)
                .addStatement("return this.$N", ageField)
                .build();

        // 定义 Person 类
        TypeSpec personClass = TypeSpec.classBuilder("Person")
                .addModifiers(Modifier.PUBLIC)
                .addField(nameField)
                .addField(ageField)
                .addMethod(constructor)
                .addMethod(getNameMethod)
                .addMethod(getAgeMethod)
                .build();

        // 生成 Java 文件
        JavaFile javaFile = JavaFile.builder("com.example", personClass)
                .build();

        // 写入文件系统
        javaFile.writeTo(System.out);
    }
}
```

---

## 生成异常捕获代码

在使用 JavaPoet 生成代码时，如果你想在生成的代码中包含异常捕获逻辑，可以通过 `MethodSpec` 的 `beginControlFlow` 和 `nextControlFlow` 方法来构建 try-catch 块。以下是一个简单的例子，展示了如何在生成的方法中添加异常捕获逻辑。

### 示例：生成包含异常捕获的代码

假设我们想要生成一个方法，该方法尝试打开一个文件并读取其内容，同时需要处理可能发生的 `IOException` 异常。我们可以这样做：

```java
import com.squareup.javapoet.*;

import javax.lang.model.element.Modifier;
import java.io.IOException;

public class ExceptionHandlingExample {
    public static void main(String[] args) throws Exception {
        // 创建异常类型
        ClassName IOException = ClassName.get(IOException.class);

        // 创建方法
        MethodSpec readAFile = MethodSpec.methodBuilder("readAFile")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(void.class)
                .addException(IOException)
                .addStatement("$T file = new $T($S)", java.io.File.class, java.io.File.class, "example.txt")
                .beginControlFlow("try")
                    .addStatement("/* 打开和读取文件的代码 */")
                    .addStatement("$T.out.println($S)", System.class, "File read successfully.")
                .nextControlFlow("catch ($T e)", IOException)
                    .addStatement("$T.out.println($S + e.getMessage())", System.class, "Failed to read the file: ")
                .endControlFlow()
                .build();

        // 创建类
        TypeSpec helloWorld = TypeSpec.classBuilder("HelloWorld")
                .addModifiers(Modifier.PUBLIC)
                .addMethod(readAFile)
                .build();

        // 输出到控制台
        JavaFile javaFile = JavaFile.builder("com.example.helloworld", helloWorld)
                .build();
        javaFile.writeTo(System.out);
    }
}
```

### 解释

- **创建异常类型**: 使用 `ClassName.get(IOException.class)` 来引用 `IOException` 类型。
- **添加异常声明**: 在 `methodBuilder` 中通过 `addException(IOException)` 方法指定方法可能抛出的异常。
- **开始控制流**: 使用 `beginControlFlow("try")` 开始一个 try 语句块，并用 `addStatement()` 添加要执行的代码。
- **处理异常**: 使用 `nextControlFlow("catch ($T e)", IOException)` 来定义 catch 语句块，并指定捕获的异常类型和变量名。在这里可以添加处理异常的代码。
- **结束控制流**: 使用 `endControlFlow()` 结束控制流结构。

这段代码会生成一个名为 `HelloWorld` 的类，其中包含一个名为 `readAFile` 的静态方法，该方法演示了如何尝试读取一个文件并在发生 `IOException` 时进行处理。通过这种方式，你可以灵活地为任何生成的方法添加异常处理逻辑。

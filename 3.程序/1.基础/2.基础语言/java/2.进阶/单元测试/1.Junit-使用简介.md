# JUnit使用简介

JUnit 是 Java 编程语言中广泛使用的单元测试框架，它提供了丰富的功能来帮助开发者编写和运行测试。下面从多个方面详细介绍 JUnit 的使用。

## 1. 依赖配置

首先需要在项目中添加 JUnit 依赖。如果使用 Maven，在 `pom.xml` 中添加以下配置：

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.8.2</version>
    <scope>compile</scope>
</dependency>
```

## 2. 基本注解

JUnit 5 提供了一系列注解来标识测试方法和生命周期方法：

- `@Test`：标记一个方法为测试方法。
- `@BeforeEach`：每个测试方法执行前运行。
- `@AfterEach`：每个测试方法执行后运行。
- `@BeforeAll`：所有测试方法执行前运行（必须是静态方法）。
- `@AfterAll`：所有测试方法执行后运行（必须是静态方法）。
- `@Disabled`：禁用测试方法。

下面是一个使用这些注解的示例：

```java
import org.junit.jupiter.api.*;

class CalculatorTest {

    private Calculator calculator;

    @BeforeAll
    static void setUpAll() {
        System.out.println("初始化测试环境...");
    }

    @BeforeEach
    void setUp() {
        calculator = new Calculator();
    }

    @Test
    void testAdd() {
        int result = calculator.add(2, 3);
        Assertions.assertEquals(5, result);
    }

    @Test
    void testSubtract() {
        int result = calculator.subtract(5, 3);
        Assertions.assertEquals(2, result);
    }

    @Disabled("暂时跳过该测试")
    @Test
    void testDivide() {
        int result = calculator.divide(6, 3);
        Assertions.assertEquals(2, result);
    }

    @AfterEach
    void tearDown() {
        System.out.println("清理测试数据...");
    }

    @AfterAll
    static void tearDownAll() {
        System.out.println("清理测试环境...");
    }
}
```

## 3. 断言（Assertions）

JUnit 提供了丰富的断言方法，用于验证测试结果：

```java
import static org.junit.jupiter.api.Assertions.*;

@Test
void testAssertions() {
    // 相等断言
    assertEquals(4, calculator.multiply(2, 2));

    // 真/假断言
    assertTrue("test".equalsIgnoreCase("TEST"));
    assertFalse("test".equals("TEST"));

    // null 断言
    assertNull(null);
    assertNotNull(new Object());

    // 数组相等断言
    assertArrayEquals(new int[]{1, 2, 3}, new int[]{1, 2, 3});

    // 异常断言
    assertThrows(ArithmeticException.class, () -> calculator.divide(1, 0));

    // 超时断言
    assertTimeout(Duration.ofMillis(100), () -> {
        // 执行需要在100毫秒内完成的操作
    });
}
```

## 4. 参数化测试

参数化测试允许使用不同的参数多次运行同一个测试方法：

```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.*;

class StringUtilsTest {

    @ParameterizedTest
    @ValueSource(strings = {"racecar", "radar", "able was I ere I saw elba"})
    void testPalindrome(String candidate) {
        assertTrue(StringUtils.isPalindrome(candidate));
    }

    @ParameterizedTest
    @CsvSource({
        "apple, 5",
        "banana, 6",
        "cherry, 6"
    })
    void testStringLength(String input, int expectedLength) {
        assertEquals(expectedLength, input.length());
    }

    @ParameterizedTest
    @MethodSource("provideStringsForIsBlank")
    void testIsBlank(String input, boolean expected) {
        assertEquals(expected, StringUtils.isBlank(input));
    }

    private static Stream<Arguments> provideStringsForIsBlank() {
        return Stream.of(
            Arguments.of(null, true),
            Arguments.of("", true),
            Arguments.of("  ", true),
            Arguments.of("test", false)
        );
    }
}
```

## 5. 动态测试

动态测试允许在运行时生成测试：

```java
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;

import java.util.Arrays;
import java.util.Collection;

import static org.junit.jupiter.api.Assertions.*;

class DynamicTestsExample {

    @TestFactory
    Collection<DynamicTest> dynamicTestsFromCollection() {
        return Arrays.asList(
            DynamicTest.dynamicTest("Add test", () -> assertEquals(2, 1 + 1)),
            DynamicTest.dynamicTest("Multiply test", () -> assertEquals(4, 2 * 2))
        );
    }

    @TestFactory
    Stream<DynamicTest> dynamicTestsFromStream() {
        return Stream.of("A", "B", "C")
            .map(input -> DynamicTest.dynamicTest(
                "Test " + input,
                () -> assertTrue(Character.isLetter(input.charAt(0)))
            ));
    }
}
```

## 6. 测试套件

测试套件允许将多个测试类组合在一起运行：

```java
import org.junit.platform.suite.api.*;

@Suite
@SelectPackages("com.example.tests")
@IncludeTags("fast")
@ExcludeTags("slow")
public class TestSuite {
    // 该类不需要包含任何方法，仅作为测试套件的入口点
}
```

## 7. 条件测试执行

可以根据不同条件决定是否执行测试：

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assumptions.*;

class ConditionalExecutionTest {

    @Test
    void testOnDeveloperMachine() {
        assumeTrue("DEV".equals(System.getenv("ENV")));
        // 只有在开发环境下才执行的测试
    }

    @Test
    void testInProduction() {
        assumeFalse("DEV".equals(System.getenv("ENV")));
        // 只有在生产环境下才执行的测试
    }

    @Test
    void testOnMacOS() {
        assumeTrue(System.getProperty("os.name").contains("Mac"));
        // 只有在MacOS上才执行的测试
    }
}
```

## 8. 扩展模型

JUnit 5 提供了强大的扩展机制，可以自定义测试行为：

```java
import org.junit.jupiter.api.extension.*;

public class LoggingExtension implements BeforeEachCallback, AfterEachCallback {

    @Override
    public void beforeEach(ExtensionContext context) throws Exception {
        System.out.println("Before test: " + context.getDisplayName());
    }

    @Override
    public void afterEach(ExtensionContext context) throws Exception {
        System.out.println("After test: " + context.getDisplayName());
    }
}

// 在测试类上使用扩展
@ExtendWith(LoggingExtension.class)
class MyTest {
    // 测试方法
}
```

以上就是 JUnit 测试框架的主要使用方法。JUnit 5 提供了丰富的功能和灵活的扩展机制，能够满足各种单元测试需求。

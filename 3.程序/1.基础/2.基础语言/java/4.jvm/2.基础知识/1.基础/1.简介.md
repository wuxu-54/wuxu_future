# 简介

>[转载](https://blog.csdn.net/Ppikaqiu/article/details/106764050)

本文作为JVM简介篇，很多内容在后面的章节会有更详细的解释说明。

- 本文要了解三个概念及三者的关系：

    1. jvm
    2. jre
    3. jdk

- 本文要知道jvm的具体信息：

    1. 原理
    2. 生命周期
    3. 结构
    4. 内存回收机制

## 三个概念及三者的关系

1. jvm
2. jre
3. jdk

### 1. 什么是JVM？

JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。 JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。

Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把**字节码解释成具体平台上的机器指令执行**。这就是Java的能够“一次编译，到处运行”的原因。

### 2. JRE/JDK/JVM是什么关系？

- **JRE(JavaRuntimeEnvironment，Java运行环境)**，也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可。

- **JDK(Java Development Kit)** 是程序开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是 安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。

- **JVM(JavaVirtualMachine，Java虚拟机)** 是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。

## JVM具体信息

### 1. JVM原理

JVM是java的核心和基础，在java编译器和os平台之间的虚拟处理器。它是一种利用软件方法实现的抽象的计算机基于下层的操作系统和硬件平台，可以在上面执行java的字节码程序。

![Alt text](../../../images/jvm/jvm%E7%AE%80%E4%BB%8B-1.png)

java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行。

### 2. JVM执行程序的过程

1. 加载.class文件
2. 管理并分配内存
3. 执行垃圾收集

JRE（java运行时环境）由JVM构造的java程序的运行环，也是Java程序运行的环境，但是他同时一个操作系统的一个应用程序一个进程，因此他也有他自己的运行的生命周期，也有自己的代码和数据空间。JVM在整个jdk中处于最底层，负责于操作系统的交互，用来屏蔽操作系统环境，提供一个完整的Java运行环境，因此也就是虚拟计算机。操作系统装入JVM是通过jdk中Java.exe来完成，通过下面4步来完成JVM环境：

1. 创建JVM装载环境和配置
2. 装载JVM.dll
3. 初始化JVM.dll并挂界到JNIENV(JNI调用接口)实例
4. 调用JNIEnv实例装载并处理class类。

### 3. JVM的生命周期

1. JVM实例对应了一个独立运行的java程序它是进程级别
    - **启动**。启动一个Java程序时，一个JVM实例就产生了，任何一个拥有`public static void main(String[] args)`函数的class都可以作为JVM实例运行的起点
    - **运行**。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以表明自己创建的线程是守护线程
    - **消亡**。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出

2. JVM执行引擎实例则对应了属于用户运行程序的线程它是线程级别的

### 4. JVM的体系结构

![Alt text](../../../images/jvm/jvm%E7%AE%80%E4%BB%8B-2.png)

- 类装载器（ClassLoader）（用来装载.class文件）
- 执行引擎（执行字节码，或者执行本地方法）
- 运行时数据区（方法区、堆、java栈、PC寄存器、本地方法栈）

### 5. JVM运行时数据区

![Alt text](../../../images/jvm/jvm%E7%AE%80%E4%BB%8B-3.png)

由图可以看到，一个java线程，其包括PC寄存器、jvm栈。而堆、本地方法堆栈、方法区在共享区域。

- 第一块：PC寄存器
- 第二块：JVM栈
- 第三块：堆（Heap）
- 第四块：方法区域（Method Area）
- 第五块：运行时常量池（Runtime Constant Pool）
- 第六块：本地方法堆栈（Native Method Stacks）

#### 第一块：PC寄存器

PC寄存器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。

#### 第二块：JVM栈

JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈，JVM栈中存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，非基本类型的对象在JVM栈上仅存放一个指向堆上的地址。

#### 第三块：堆（Heap）

它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配，Heap中的对象的内存需要等待GC进行回收。

![Alt text](../../../images/jvm/jvm%E7%AE%80%E4%BB%8B-4.png)

1. 堆是JVM中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了new对象的开销是比较大的

2. Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间TLAB（Thread Local Allocation Buffer），其大小由JVM根据运行的情况计算而得，在TLAB上分配对象时不需要加锁，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配

3. TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效。

4. 所有新创建的Object 都将会存储在新生代Yong Generation中。如果Young Generation的数据在一次或多次GC后存活下来，那么将被转移到OldGeneration。新的Object总是创建在Eden Space。

#### 第四块：方法区域（Method Area）

（1）在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。

（2）方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。

#### 第五块：运行时常量池（Runtime Constant Pool）

存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。

#### 第六块：本地方法堆栈（Native Method Stacks）

JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。

### 6. JVM垃圾回收

GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停

1. 对新生代的对象的收集称为minor GC；
2. 对旧生代的对象的收集称为Full GC；
3. 程序中主动调用System.gc()强制执行的GC为Full GC。

不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：

1. 强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）
2. 软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）
3. 弱引用：在GC时一定会被GC回收
4. 虚引用：由于虚引用只是用来得知对象是否被GC

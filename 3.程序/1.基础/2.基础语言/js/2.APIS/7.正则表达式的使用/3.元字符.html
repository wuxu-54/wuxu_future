<!-- 
    元字符，正则使用的特殊字符，有特定含义。

    可以灵活描述匹配需要的规则。
     1.边界符  ^开头，$结尾
     2.量，表示次数 + ? *  {n} {n,}  {n,m}
     3.字符类 
        [] : 匹配出现一次就是true；[a-z] [a-zA-Z] [0-9] [^abc]
        预定义 : 
            \d相当于[0-9]; 
            \D相当于[^0-9]除0-9外; 
            \w相当于[A-Za-z0-9_],匹配字母数字下划线; 
            \W相当于[^A-Za-z0-9_]; 
            \s相当于[\t\r\n\v\f] ;
            \S相当于[^\t\r\n\v\f]
     4.修饰符   约束行为，比如大小写，多行匹配等；
        语法： /表达式/修饰符
        i：不区分大小写
        g：global缩写，全局匹配
            如果不带g，正则过程中字符串从左到右匹配，找到第一个符合条件的即匹配成功，返回
            如果带g，则字符串从左到右，找到每个符合条件的都记录下来，直到字符串结尾位置
        m：多行匹配，正常正则匹配单行，但存在\n换行符时，使用m可以多行匹配。


 -->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>正则表达式</title>
</head>

<body>
    <script>

        // 1.边界符  ^开头，$结尾
        /^哈$/.test("sq") //（^开头，$结尾）^与$配合使用，必须精确匹配，跟匹配规则完全一致

        //2.量，表示次数 + ? *  {n} {n,}  {n,m}
        console.log(/^哈+$/.test("sd哈fsa")) //+ 至少一次 ；? 0或1；* 0或多次; {n} n次 ;{n,} >=n; {n,m} n<=次<=m

        //3.字符类 

        //[] 匹配出现一次就是true；[a-z] [a-zA-Z] [0-9] [^abc]
        console.log(/[abc]/.test("sdfs"))

        //预定义 \d相当于[0-9]; \D相当于[^0-9]除0-9外; \w相当于[A-Za-z0-9_],匹配字母数字下划线; \W 相当于[^A-Za-z0-9_]; \s相当于[\t\r\n\v\f] ;\S相当于[^\t\r\n\v\f]

        //4.修饰符
        console.log(/[abc]/i.test("sdfs"))
        console.log(/[df]/m.test("sd\nfs"))
        console.log(/[s]/g.test("sdfs"))
    </script>
</body>

</html>
<!-- 
    浅拷贝、深拷贝 （只针对引用类型）

    浅拷贝：值拷贝，引用数据类型是拷贝地址（当有对象或堆内存数据时，这样就会有问题，只是把地址给了新对象，所以修改一处都会有影响）
    1.newObj= {...oldObj}
    2.Object.assign(newObj,newObj)

    深拷贝：普通类型值拷贝，对象类型会创建新对象，并赋值
    1.递归实现
    2.lodash/cloneDeep
    3.通过JSON.stringify()实现
 -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="lodash.js"></script>
    <title>浅拷贝、深拷贝</title>
</head>
<body>
    <script>
         const oldObj = {i:2,people :{name:"d"}}
        //浅拷贝
        const newObj = {...oldObj}//方式1
        const newObj2 = {}//方式2
        Object.assign(newObj2,oldObj)
    
        console.log(newObj.people  === newObj2.people ) //都相等，说明people 对象 是同一地址
        newObj2.people.name = "1112"
        console.log(oldObj.people.name)//修改了新对象的people 的数据，旧对象也跟着变了
        //深拷贝
        // 方式1，递归，循环将对象数据赋值给新对象
        const newObj3 = {}
        function deepCopy(newObj,oldObj){
           for(let k in oldObj){//k是属性名，
            if(k instanceof Object){
                newObj[k] = []
                deepCopy(newObj[k],oldObj[k])
            } else if(k instanceof Object){
                newObj[k] = {}
                deepCopy(newObj[k],oldObj[k])//oldObj[k] 是属性值
            }else{
                newObj[k] = oldObj[k]//newObj[k] 等价于 newObj.i; 这个等式相当于 ：newObj.i = 2
            }
           }
        }

        deepCopy(newObj3,oldObj)
        console.log(newObj3.people.name)

        //方式2 lodash > cloneDeep
        const newObj4 = _.cloneDeep(oldObj)

        //方式3 利用json
       const newObj5 = JSON.parse(JSON.stringify(oldObj))
       oldObj.people.name = "new 111"
       console.log(newObj5.people.name)//结果仍然是 1112，说明是深拷贝
    </script>
</body>
</html>
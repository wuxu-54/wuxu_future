# 新增-类

js中没有class 类的说法，ES6 开始引入，关键字： class

## 基础使用

### 类定义

```javascript
let E = class{ // 匿名类
    constructor(a){
        this.a = a;
    }
}

let E2 = class Example{ // 命名类
      constructor(a){
        this.a = a;
    }
}
```

### 类声明

```javascript
class T{
    constructor(a){
        this.a = a
    }

    fun1(){

    }
}
```

注意：

1. 同名类不能重复声明
2. 定义类前，必须先声明此类
3. 类内方法，不要加 function 关键字
4. 方法间不能加分号

---

## 类主体

### 属性

#### prototype

ES6中，`prototype` 仍存在，虽然class可以定义方法，但其本质仍然是定义在prototype上。

添加方法：

```javascript
Example.prototype={
    //methods
}

Object.assign(Example.prototype,{
    //methods
})
```

#### 静态属性

class 本身的属性，即定义在类内部的不用实例化的属性。（构造函数是静态方法）
>学习ts时特地查了下静态和实例的区别，这里重复一下，静态：属于类本身  【类名.】调用；实例：属于类的实例对象， 【对象名.】调用

```javascript
class Example {
    static a = 2;//静态属性声明 方式1 ，这个不属于ES6标准，后面ES标准才加入的
}
Example.a;
Example.b = 2;//静态属性声明 方式2
```

#### 公共属性

```javascript
class Example{}
Example.prototype.a = 2;
```

#### 实例属性

定义在实例对象上的属性

```javascript
class Example {
    a = 2;
    constructor () {//构造函数是静态方法
        console.log(this.a);//this是当前的实例对象
    }
}
```

#### name 属性

静态属性，返回的是类的名称(匿名类，是接收变量的名称)

```javascript
let Example=class Exam {
    constructor(a) {
        this.a = a;
    }
}
console.log(Example.name); // Exam
 
let Example=class {
    constructor(a) {
        this.a = a;
    }
}
console.log(Example.name); // Example
```

### 方法

#### 构造方法

constructor 方法是类的默认方法，创建类的实例化对象时被调用。

```javascript
class Example{
    constructor(){
      console.log('我是constructor');
    }
}
new Example(); // 我是constructor
```

构造函数指定返回对象

```javascript
class Test {
    constructor(){
        // 默认返回实例对象 this
    }
}
console.log(new Test() instanceof Test); // true
 
class Example {
    constructor(){
        // 指定返回对象
        return new Test();
    }
}
console.log(new Example() instanceof Example); // false
```

#### 静态方法

static 修饰

```javascript
class Example{
    static sum(a, b) {
        console.log(a+b);
    }
}
Example.sum(1, 2); // 3
```

#### 原型方法(普通方法)

```javascript
class Example {
    sum(a, b) {
        console.log(a + b);
    }
}
let exam = new Example();
exam.sum(1, 2); // 3
```

---

## 类的实例化

### new

class 的实例化对象必须通过new 创建

```javascript
class Example {}
 
let exam1 = Example(); 
// Class constructor Example cannot be invoked without 'new'
```

### 实例化对象-共享原型对象

原`__proto__` 已废弃，不建议使用。class 获取原型对象方式：Object.getPrototypeOf(类的实例对象)

```javascript
class Example {
    constructor(a, b) {
        this.a = a;
        this.b = b;
        console.log('Example');
    }
    sum() {
        return this.a + this.b;
    }
}
let exam1 = new Example(2, 1);
let exam2 = new Example(3, 1);
 
// __proto__ 已废弃，不建议使用
// console.log(exam1.__proto__ == exam2.__proto__); 
 
console.log(Object.getPrototypeOf(exam1) === Object.getPrototypeOf(exam2));// true
 
Object.getPrototypeOf(exam1).sub = function() {
    return this.a - this.b;
}
console.log(exam1.sub()); // 1
console.log(exam2.sub()); // 2
```

---

## decorator 函数

decorator 是一个函数，用来修改类的行为，在代码编译时产生作用。
>TypeScript中，也有此修饰器语法。写法和java中的注解类似，但意义完全不同：修饰器声明方式完全与注解不同，且用来操作被标注成员的

### 类的修饰器

```javascript
function testable(target) { // 这是类的修饰器定义方式，target指向类本身（不是实例对象）
    target.isTestable = true;//这相当于给修饰的类增加了一个静态属性，若要添加实例属性，在类的 prototype 上操作即可
}

@testable
class Example {}
Example.isTestable; // true
```

写法2，可以嵌套，修饰器函数被当做返回值：
>最终相当于仍然是修饰器函数在修饰这个类。TypeScript中一模一样

```javascript
function testable(isTestable) {
    return function(target) {
        target.isTestable=isTestable;
    }
}
@testable(true)
class Example {}
Example.isTestable; // true
```

### 方法修饰

方法的修饰器写法：3个参数：target（类的原型对象）、name（修饰的属性名）、descriptor（该属性的描述对象）。

```javascript
class Example {
    @writable
    sum(a, b) {
        return a + b;
    }
}
function writable(target, name, descriptor) {//用于修饰方法的修饰器
    descriptor.writable = false;
    return descriptor; // 必须返回，TypeScript可以不返回，具体可以看下修饰器章节
}
```

强调：**修饰器执行顺序：由外向内进入，由内向外执行。**

---

## 封装与继承

### getter / setter

又名 *访问器*，关键字：`get`、`set`

使用： 属性，设置触发set、取数触发get

```javascript
class Example{
    constructor(a, b) {
        this.a = a; // 实例化时调用 set 方法
        this.b = b;
    }
    get a(){
        console.log('getter');
        return this.a;
    }
    set a(a){
        console.log('setter');
        this.a = a; // 自身递归调用
    }
}
let exam = new Example(1,2); // 不断输出 setter ，最终导致 RangeError
class Example1{
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }
    get a(){
        console.log('getter');
        return this._a;
    }
    set a(a){
        console.log('setter');
        this._a = a;
    }
}
let exam1 = new Example1(1,2); // 只输出 setter , 不会调用 getter 方法
console.log(exam1._a); // 1, 可以直接访问
```

注意：

1. getter 不可单独出现，否则报错
2. getter 与 setter 必须同级出现，否则报错

### extends

通过 extends 实现类的继承。

```javascript
class Child extends Father { ... }
```

### super

子类 constructor 方法中必须有 super ，且必须出现在 this 之前。

```javascript
class Father {
    constructor() {}
}
class Child extends Father {
    constructor() {}
    // or 
    // constructor(a) {
        // this.a = a;
        // super();
    // }
}
let test = new Child(); // Uncaught ReferenceError: Must call super 
// constructor in derived class before accessing 'this' or returning 
// from derived constructor
```

调用父类构造函数,只能出现在子类的构造函数。

```javascript
class Father {
    test(){
        return 0;
    }
    static test1(){
        return 1;
    }
}
class Child extends Father {
    constructor(){
        super();
    }
}
class Child1 extends Father {
    test2() {
        super(); // Uncaught SyntaxError: 'super' keyword unexpected     
        // here
    }
}
```

调用父类方法, super 作为对象，在普通方法中，指向父类的原型对象，在静态方法中，指向父类

```javascript
class Child2 extends Father {
    constructor(){
        super();
        // 调用父类普通方法
        console.log(super.test()); // 0
    }
    static test3(){
        // 调用父类静态方法
        return super.test1+2;
    }
}
Child2.test3(); // 3
```

注意:

不可继承常规对象。

```javascript
var Father = {
    // ...
}
class Child extends Father {
     // ...
}
// Uncaught TypeError: Class extends value #<Object> is not a constructor or null
 
// 解决方案
Object.setPrototypeOf(Child.prototype, Father);//设置指向Father对象的原型对象
```

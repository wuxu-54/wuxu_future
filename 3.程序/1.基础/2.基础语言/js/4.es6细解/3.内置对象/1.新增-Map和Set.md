# 新增对象-Map、Set

## Map

Map对象存储键值对，键唯一，不可重复，后设置的会覆盖前面的。

与Object的区别

* Object的键只能是*字符串*或*Symbol类型*，Map可以是任意类型
* Map键有序（FIFO 队列），Object中的键无序
* Map有Size属性获取键个数，Object属性只能自己算

### Map使用

```javascript
var map = new Map();//创建map
map.set("key","value");//设置值
var v = map.get("key");//根据key取值

//-----------遍历--------------- 

//方式一 for of
for(var [key,value] of map){}
for(var [key,value] of map.entries){}// 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 
for (var key of map.keys()){}
for (var value of map.values()){}

//方式一 forEach
map.forEach(function(value, key) {}, map)

//-----------Map对象操作--------------- 

//转换为数组
var outArray = Array.from(map); 

//map克隆
var myMap1 = new Map([["key1", "value1"], ["key2", "value2"]]);
var myMap2 = new Map(myMap1);
console.log(original === clone); // 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。

//Map 的合并
var first = new Map([[1, 'one'], [2, 'two'], [3, 'three'],]);
var second = new Map([[1, 'uno'], [2, 'dos']]);
 
var merged = new Map([...first, ...second]);// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three

```

## Set

存储值，不可重复，类型可以是任意的

Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：

* +0 与 -0 在存储判断唯一性的时候是恒等的；
* undefined 与 undefined 是恒等的；
* NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个。

### Set使用

```javascript
//------------创建

let mySet = new Set();
mySet.add(1); // Set(1) {1}
mySet.add(5); // Set(2) {1, 5}
mySet.add(5); // Set(2) {1, 5} 这里体现了值的唯一性

//---------------类型转换

var mySet = new Set(["value1", "value2", "value3"]);// Array 转 Set

var myArray = [...mySet];// 用...操作符，将 Set 转 Array
String

var mySet = new Set('hello'); // String 转 Set， Set(4) {"h", "e", "l", "o"}，注：Set 中 toString 方法是不能将 Set 转换成 String

//----------------Set对象作用

//1. 数组去重
var mySet = new Set([1, 2, 3, 4, 4]);
[...mySet]; // [1, 2, 3, 4]

//2.并集
var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var union = new Set([...a, ...b]); // {1, 2, 3, 4}

//3.交集
var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var intersect = new Set([...a].filter(x => b.has(x))); // {2, 3}

//4.差集
var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var difference = new Set([...a].filter(x => !b.has(x))); // {1}
```

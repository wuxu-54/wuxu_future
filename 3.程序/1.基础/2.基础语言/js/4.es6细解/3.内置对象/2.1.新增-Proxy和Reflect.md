# 新增-Proxy和Reflect对象

* Proxy 代理对象，对目标对象的读取、函数调用等操作拦截，然后再处理。 代理设计模式。
* Reflect 用于Object对象的大多方法，后续再有新增，会放到此对象中。

## Proxy

Proxy对象两部分组成：target、handler。

target:目标对象，handler:真正的代理

```javascript
let target={name:'tom',age:24}
let handler = {
    //receiver 可选参数，一般指 Proxy实例本身（操作行为时针对的对象）
    get:function(taget,key,receiver){
        return target[key];
    },
    set:function(target,key,value,receiver){
        target[key]=value;
    }
}
//target 可以是个空对象，handler也可以是空 表示不拦截直接操作
let proxy = new Proxy(target, handler)
proxy.name     // 实际执行 handler.get
proxy.age = 25 // 实际执行 handler.set
```

**实例方法**：

Proxy支持拦截的操作，一共有13种：

* **get(target, propKey, receiver)**：拦截对象属性的读取，比如`proxy.foo`和`proxy['foo']`，receiver是可选参数。

* **set(target, propKey, value, receiver)**：拦截对象属性的设置，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值。

    注意：

    1. 用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。
    2. 严格模式下，set代理如果没有返回true，就会报错。

* **has(target, propKey)**：拦截propKey in proxy的操作，返回一个布尔值。

* **deleteProperty(target, propKey)**：拦截`delete proxy[propKey]`的操作，返回一个布尔值。如果这个方法抛出错误或者返回 false ，propKey 属性就无法被 delete 命令删除。

* **ownKeys(target)**：拦截对象自身属性的读取，返回一个数组。

    包括以下操作：

    1. Object.getOwnPropertyNames()
    2. Object.getOwnPropertySymbols()
    3. Object.keys()
    4. for...in

    注意：

    1. 方法返回的数组成员，只能是字符串或 Symbol 值，否则会报错。
    2. 若目标对象中含有不可配置的属性，则必须将这些属性在结果中返回，否则就会报错。
    3. 若目标对象不可扩展，则必须全部返回且只能返回目标对象包含的所有属性，不能包含不存在的属性，否则也会报错。

* **getOwnPropertyDescriptor(target, propKey)**：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象或undefined。

* **defineProperty(target, propKey, propDesc)**：拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。

* **preventExtensions(target)**：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。

* **getPrototypeOf(target)**：拦截`Object.getPrototypeOf(proxy)`，用于拦截获取对象原型的操作，返回一个对象。

    包括以下操作：  

    1. Object.prototype._proto_  
    2. Object.prototype.isPrototypeOf()  
    3. Object.getPrototypeOf()  
    4. Reflect.getPrototypeOf()  
    5. instanceof  

    注意：

    返回值必须是对象或者 null ，否则报错。另外，如果目标对象不可扩展（non-extensible），getPrototypeOf 方法必须返回目标对象的原型对象。

* **setPrototypeOf(target, proto)**：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。其余同getPrototypeOf，如果目标对象是函数，那么还有两种额外操作可以拦截。

* **isExtensible(target)**：拦截`Object.isExtensible(proxy)`，返回一个布尔值。

* **apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。

* **construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`。

## Reflect

`Reflect` 是 JavaScript 中的一个内置对象，它提供了一系列静态方法，这些方法可以用来拦截和操作 JavaScript 对象的底层元操作，如属性访问、函数调用、对象构造等。下面从多个方面详细介绍 `Reflect` 对象。

个人理解： 分担Object的职责，将Object与外部解耦，其内部方法都交给Reflect处理。都是代理模式的使用

* Reflect.get(target, name, receiver)
* Reflect.set(target, name, value, receiver)
* Reflect.has(obj, name)
* Reflect.deleteProperty(obj, property)
* Reflect.construct(obj, args)
* Reflect.getPrototypeOf(obj)  用于读取 obj 的 _proto_ 属性。在 obj 不是对象时不会像 Object 一样把 obj 转为对象，而是会报错。
* Reflect.setPrototypeOf(obj, newProto)
* Reflect.apply(func, thisArg, args) 等同于 Function.prototype.apply.call(func, thisArg, args)
* Reflect.defineProperty(target, propertyKey, attributes)
* Reflect.getOwnPropertyDescriptor(target, propertyKey)
* Reflect.isExtensible(target)
* Reflect.preventExtensions(target)
* Reflect.ownKeys(target)

### 基本概述

* **静态对象**：`Reflect` 是一个内置的静态对象，不能使用 `new` 关键字来实例化，只能直接调用其静态方法。

* **设计目的**
  * 将一些原本属于语言内部的操作以函数的形式暴露出来，让代码更具可读性和可维护性。
  * 与 `Proxy` 对象的拦截方法紧密配合，使得在实现代理时能够方便地调用原始对象的默认行为。

### 常用方法及示例

#### 1. 函数调用相关

* **`Reflect.apply(target, thisArgument, argumentsList)`**
  * **作用**：调用一个函数，并指定函数执行时的 `this` 值和参数列表，类似于 `Function.prototype.apply()` 方法。
  * **示例**

```javascript
function sum(a, b) {
    return a + b;
}
const result = Reflect.apply(sum, null, [2, 3]);
console.log(result); // 输出: 5
```

* **`Reflect.construct(target, argumentsList[, newTarget])`**
  * **作用**：使用 `new` 关键字调用构造函数，创建一个新对象。`newTarget` 是可选参数，用于指定构造函数的 `[[Constructor]]` 内部方法。
  * **示例**

```javascript
class Person {
    constructor(name) {
        this.name = name;
    }
}
const person = Reflect.construct(Person, ['Alice']);
console.log(person.name); // 输出: Alice
```

#### 2. 属性操作相关

* **`Reflect.defineProperty(target, propertyKey, attributes)`**
  * **作用**：在一个对象上定义一个新属性，或者修改一个现有属性的配置，并返回一个布尔值表示操作是否成功，类似于 `Object.defineProperty()` 方法。
  * **示例**

```javascript
const obj = {};
const success = Reflect.defineProperty(obj, 'age', {
    value: 25,
    writable: false,
    enumerable: true,
    configurable: false
});
console.log(success); // 输出: true
console.log(obj.age); // 输出: 25
```

* **`Reflect.deleteProperty(target, propertyKey)`**
  * **作用**：删除对象的一个属性，并返回一个布尔值表示操作是否成功，类似于 `delete target[propertyKey]`。
  * **示例**

```javascript
const obj = { name: 'Bob' };
const result = Reflect.deleteProperty(obj, 'name');
console.log(result); // 输出: true
console.log(obj.name); // 输出: undefined
```

* **`Reflect.get(target, propertyKey[, receiver])`**
  * **作用**：获取对象的一个属性值，类似于 `target[propertyKey]`。`receiver` 是可选参数，用于指定 `getter` 函数的 `this` 值。
  * **示例**

```javascript
const obj = { name: 'Charlie' };
const value = Reflect.get(obj, 'name');
console.log(value); // 输出: Charlie
```

* **`Reflect.set(target, propertyKey, value[, receiver])`**
  * **作用**：设置对象的一个属性值，类似于 `target[propertyKey] = value`。`receiver` 是可选参数，用于指定 `setter` 函数的 `this` 值。
  * **示例**

```javascript
const obj = { name: 'David' };
const success = Reflect.set(obj, 'name', 'Eve');
console.log(success); // 输出: true
console.log(obj.name); // 输出: Eve
```

#### 3. 属性检查相关

* **`Reflect.has(target, propertyKey)`**
  * **作用**：检查对象是否具有某个属性，类似于 `propertyKey in target`。
  * **示例**

```javascript
const obj = { name: 'Frank' };
const hasName = Reflect.has(obj, 'name');
console.log(hasName); // 输出: true
```

* **`Reflect.ownKeys(target)`**
  * **作用**：返回对象的所有自有属性键，包括字符串键和符号键，类似于 `Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))`。
  * **示例**

```javascript
const symbol = Symbol('test');
const obj = { name: 'Grace', [symbol]: 'value' };
const keys = Reflect.ownKeys(obj);
console.log(keys); // 输出: ['name', Symbol(test)]
```

#### 4. 其他方法

* **`Reflect.getPrototypeOf(target)`**
  * **作用**：返回对象的原型，类似于 `Object.getPrototypeOf()` 方法。
  * **示例**

```javascript
const obj = {};
const prototype = Reflect.getPrototypeOf(obj);
console.log(prototype === Object.prototype); // 输出: true
```

* **`Reflect.setPrototypeOf(target, prototype)`**
  * **作用**：设置对象的原型，并返回一个布尔值表示操作是否成功。
  * **示例**

```javascript
const obj = {};
const newPrototype = { foo: 'bar' };
const success = Reflect.setPrototypeOf(obj, newPrototype);
console.log(success); // 输出: true
console.log(obj.foo); // 输出: bar
```

### 与 `Proxy` 对象的配合使用

`Reflect` 对象的方法与 `Proxy` 对象的拦截方法一一对应，这使得在 `Proxy` 的拦截处理中可以方便地调用原始对象的默认行为。

```javascript
const target = {
    name: 'Hank',
    age: 40
};

const handler = {
    get(target, propertyKey, receiver) {
        console.log(`Getting property ${propertyKey}`);
        return Reflect.get(target, propertyKey, receiver);
    },
    set(target, propertyKey, value, receiver) {
        console.log(`Setting property ${propertyKey} to ${value}`);
        return Reflect.set(target, propertyKey, value, receiver);
    }
};

const proxy = new Proxy(target, handler);

console.log(proxy.name); 
// 输出: Getting property name
// 输出: Hank

proxy.age = 41; 
// 输出: Setting property age to 41
```

### 总结

`Reflect` 对象为 JavaScript 提供了一套强大且一致的 API，用于操作对象的底层元操作。通过使用 `Reflect` 的方法，可以使代码更加清晰、可维护，并且方便与 `Proxy` 对象结合使用，实现对对象操作的拦截和自定义处理。

# 扩展-对象

本文是ES6对【对象类型】的扩展的内容说明

## 对象字面量

### 属性简写

ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值

```javascript
const age = 12;
const name = "Amy";
const person = {age, name};
person   //{age: 12, name: "Amy"}
//等同于
const person = {age: age, name: name}
```

### 方法名简写

```javascript
const person = {
  sayHi(){
    console.log("Hi");
  }
}
person.sayHi();  //"Hi"
//等同于
const person = {
  sayHi:function(){
    console.log("Hi");
  }
}
person.sayHi();//"Hi"
```

如果是Generator 函数(此函数指异步函数)，则要在前面加一个星号:

```javascript
const obj = {
  * myGenerator() {
    yield 'hello world';
  }
};
//等同于
const obj = {
  myGenerator: function* () {
    yield 'hello world';
  }
};
```

补充知识，Generator函数介绍：

1. function 关键字和函数之间有一个星号(*),且内部使用yield表达式，定义不同的内部状态。
2. 调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。
3. yield表达式和next()方法： yield表示暂停，Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态
4. yield语句只能用于`function*` 的作用域，如果function* 的内部还定义了其他的普通函数，则函数内部不允许使用yield语句。yield语句如果参与运算，必须用括号括起来。

### 属性名表达式

ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内。

```javascript
const obj = {
 ["he"+"llo"](){
   return "Hi";
  }
}
obj.hello();  //"Hi"
```

注意点：属性的简洁表示法和属性名表达式不能同时使用，否则会报错。

```javascript
const hello = "Hello";
const obj = {
 [hello]
};
obj  //SyntaxError: Unexpected token }
 
const hello = "Hello";
const obj = {
 [hello+"2"]:"world"
};
obj  //{Hello2: "world"}
```

---

## 对象拓展运算符

(...) 拓展运算符用于取出对象所有可遍历属性然后拷贝到当前对象

```javascript
let age = {age: 15};
let name = {name: "Amy"};
let person = {...age, ...name}; // 也可用于合并对象
person;  //{age: 15, name: "Amy"}
```

注意：

1. 对象自定义属性与拓展运算符有同名属性，后设置会覆盖先设置的值。
2. 拓展运算符后面是空对象，没有任何效果也不会报错。
    >let a = {...{}, a: 1, b: 2}; a;  //{a: 1, b: 2}
3. 拓展运算符后面是null或者undefined，没有效果也不会报错。
    >let b = {...null, ...undefined, a: 1, b: 2};  b;  //{a: 1, b: 2}

## 对象新方法

### Object.is(value1, value2)

用来比较两个值是否严格相等，与（===）基本类似。

与（===）的区别：

```javascript
//一是+0不等于-0
Object.is(+0,-0);  //false
+0 === -0  //true
//二是NaN等于本身
Object.is(NaN,NaN); //true
NaN === NaN  //false
```

### Object.assign(target, source_1, ···)

用于将源对象的所有可枚举属性复制到目标对象中。(assign 的属性拷贝是**浅拷贝**)

```javascript
let target = {a: 1};
let object2 = {b: 2};
let object3 = {c: 3};
Object.assign(target,object2,object3);  
// 第一个参数是目标对象，后面的参数是源对象
target;  // {a: 1, b: 2, c: 3
```

注意：

1. 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。
2. 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。
    >Object.assign(3);         // Number {3}  
    >typeof Object.assign(3);  // "object"

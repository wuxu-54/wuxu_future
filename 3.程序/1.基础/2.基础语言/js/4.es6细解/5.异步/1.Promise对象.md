# Promise

Promise 是 JavaScript 中用于异步编程的一个重要概念。它代表了一个尚未完成但预期在未来某个时刻会完成的操作的最终结果。使用 Promise 可以更优雅地处理异步任务，如网络请求、文件读写等，而不必依赖于深层次的回调函数（回调地狱）。

## 基本特性

1. **状态**：Promise 有三种状态：

    * **Pending（等待中）**：初始状态，既不是成功，也不是失败。
    * **Fulfilled（已成功）**：意味着操作成功完成。
    * **Rejected（已失败）**：意味着操作失败。

    >Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。

    ```js
    const p1 = new Promise(function(resolve,reject){
    resolve('success1');
    resolve('success2');
    }); 
    const p2 = new Promise(function(resolve,reject){  
        resolve('success3'); 
        reject('reject');
    });
    p1.then(function(value){  
        console.log(value); // success1
    });
    p2.then(function(value){ 
        console.log(value); // success3
    });
    ```

2. **链式调用**：Promise 支持链式调用，可以依次执行多个操作，每个操作都可以根据前一个 Promise 的结果进行处理。

3. **异常处理**：Promise 可以使用 `.catch()` 方法来捕获错误，并且错误会沿着链式调用传递，直到被捕获或到达链尾。

### 缺点

* 无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。
* 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。
* 当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

## 创建和使用 Promise

创建一个 Promise 对象通常有两种方式：

1. 使用新的 Promise 构造函数：

    ```js
    const myPromise = new Promise((resolve, reject) => {
        // 异步操作的代码
        if (/* 异步操作成功 */) {
            resolve(value); // 异步操作成功时调用，将 Promise 状态改为 Fulfilled
        } else {
            reject(error); // 异步操作失败时调用，将 Promise 状态改为 Rejected
        }
    });
    ```

2. 使用 Promise 的静态方法：

    * **Promise.resolve(value)**：返回一个状态为 Fulfilled 的 Promise 对象。
    * **Promise.reject(reason)**：返回一个状态为 Rejected 的 Promise 对象。
    * **Promise.all(iterable)**：接受一个 Promise 对象的集合（如数组），并返回一个新的 Promise 实例，该实例在所有给定的 Promise 都成功时才会成功，如果任何一个失败，则立即失败。
    * **Promise.race(iterable)**：同样接受一个 Promise 对象的集合，但只要其中的一个 Promise 成功或失败，返回的 Promise 就会立即成功或失败。

## 处理 Promise

Promise 有三种方法来处理结果：`.then()`、`.catch()` 和 `.finally()`。

* **.then()**：在 Promise 成功（Fulfilled）时调用，接收 Promise 结果作为参数。
* **.catch()**：在 Promise 失败（Rejected）时调用，接收拒绝的原因作为参数。
* **.finally()**：无论 Promise 最终状态如何，都会执行，通常用于清理资源。

示例：

```js
myPromise
  .then(result => {
      // 处理成功的结果
  })
  .catch(error => {
      // 处理失败的原因
  })
  .finally(() => {
      // 无论成功还是失败都会执行
  });
```

## async/await 与 Promise

`async` 和 `await` 是基于 Promise 的语法糖，可以让异步代码的编写更加简洁。`async` 关键字声明了一个函数可以包含 `await` 表达式，而 `await` 会暂停函数的执行，等待 Promise 解决。

```js
async function asyncFunction() {
  try {
    const result = await myPromise; // 等待 Promise 解决
    console.log(result); // 处理结果
  } catch (error) {
    console.error(error); // 处理错误
  }
}
```

使用 `async` 和 `await` 可以避免复杂的回调和链式 `.then()` 调用，使代码更加直观和易于维护。同时，它们也使得异步逻辑的错误处理更加直观，类似于同步代码的 **try/catch** 异常处理。

---

## then方法

then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。

### then方法特点

1. 在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。

    ```javascript
    const p = new Promise(function(resolve,reject){
    resolve('success');
    });
    
    p.then(function(value){
    console.log(value);
    });
    
    console.log('first');
    // first
    // success
    ```

2. 通过 .then 形式添加的回调函数，不论什么时候，都会被调用。(then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。)

    ```javascript
    const p = new Promise(function(resolve,reject){
    resolve(1);
    }).then(function(value){ // 第一个then // 1
    console.log(value);
    return value * 2;
    }).then(function(value){ // 第二个then // 2
    console.log(value);
    }).then(function(value){ // 第三个then // undefined
    console.log(value);
    return Promise.resolve('resolve'); 
    }).then(function(value){ // 第四个then // resolve
    console.log(value);
    return Promise.reject('reject'); 
    })
    .then(
    function(value){ 
        // 第五个then //reject:reject !!!这里不会打印,因为上一个then方法返回的是一个reject状态的promise
        console.log('resolve:' + value);
    }, 
    function(err) {
        // 此行会打印, 因第五个than只能接受 resolve状态的promise, 而第四个than返回的是reject状态的promise
        // 所以会被本行 err 捕获
        console.log('reject:' + err);
    }
    );
    ```

### then 方法注意点

1. 简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。
2. 注意总是返回或终止 Promise 链。

    ```javascript
    const p1 = new Promise(function(resolve,reject){
    resolve(1);
    }).then(function(result) {
      p2(result).then(newResult => p3(newResult));
    }).then(() => p4());
    ```

    创建新 Promise 但忘记返回它时，对应链条被打破，导致 p4 会与 p2 和 p3 同时进行。

    大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 .catch(error => console.log(error));

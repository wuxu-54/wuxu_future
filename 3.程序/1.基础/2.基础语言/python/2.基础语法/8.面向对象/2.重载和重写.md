# 重写、重载

在面向对象编程中，重写（Overriding）和重载（Overloading）是两种常用的概念，用于实现多态性。Python 支持重写，但不支持传统意义上的重载。

## 重写（Overriding）

重写是指子类提供了与父类同名的方法的行为。在 Python 中，重写是通过在子类中定义一个与父类中同名的方法来实现的。

**示例：**

```python
class Parent:
    def show(self):
        print("Parent's show()")

class Child(Parent):  # Child 继承自 Parent
    def show(self):  # Child 重写了 Parent 的 show() 方法
        print("Child's show()")

child = Child()
child.show()  # 输出: Child's show()
```

在这个例子中，`Child` 类重写了 `Parent` 类的 `show` 方法。当调用 `child.show()` 时，将执行 `Child` 类中定义的 `show` 方法。

## 重载（Overloading）

重载通常指允许类有多个同名方法，这些方法的参数列表不同（例如，参数的数量或类型不同）。Python 不支持基于参数列表差异的编译时重载，因为它是一种动态类型语言，不通过参数类型来区分方法。

然而，Python 可以通过以下方式模拟重载的行为：

1. **使用可变参数列表 `*args` 和关键字参数列表 `**kwargs`**：
   这两个特殊的参数可以捕获任意数量和类型的参数，从而允许你编写能够接受不同参数的方法。

    **示例：**

    ```python
    class Math:
        def add(self, *args):
            return sum(args)

        def add(self, x, y=0):
            return x + y

    # 调用 add 方法
    math = Math()
    print(math.add(1, 2, 3))  # 使用可变参数列表，输出: 6
    print(math.add(1))        # 使用关键字参数列表，输出: 1 (y 默认为 0)
    ```

    注意：在上面的示例中，因为 Python 的名称解析机制（C3 线性化），实际上不能定义两个同名且参数列表不同的方法。这仅用于演示目的。

2. **使用函数注解（Type Hints）**：
   Python 3.5+ 引入了类型提示，允许你为函数的参数和返回值指定类型。类型提示不会强制执行重载，但它们有助于代码的可读性和静态类型检查。

    **示例：**

    ```python
    from typing import Union

    class Example:
        def process(self, value: Union[int, str]):
            if isinstance(value, int):
                return value * 2
            elif isinstance(value, str):
                return value.upper()

    example = Example()
    print(example.process(10))  # 输出: 20
    print(example.process("hello"))  # 输出: HELLO
    ```

    在这个例子中，`process` 方法可以接受整数或字符串类型的参数，根据参数类型执行不同的操作。

## 注意事项

- 重写时，可以使用 `super()` 函数来调用父类的方法，以扩展父类的功能。
- Python 不支持基于参数的重载，但通过使用 `*args`、`**kwargs` 和默认参数，你可以实现类似的行为。
- 函数注解主要用于提供类型提示，不会强制参数类型或改变函数的行为。
- 模拟重载时，通常需要在函数内部检查参数的数量或类型，并据此执行不同的逻辑。

通过这些方法，Python 类可以在一定程度上模拟重写和重载的行为，尽管语言的设计哲学倾向于动态性和灵活性，而不是静态类型检查。

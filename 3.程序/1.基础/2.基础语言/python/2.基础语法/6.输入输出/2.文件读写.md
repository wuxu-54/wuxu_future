# 文件读写

在 Python 中，文件读写是一个基本操作，可以通过内置的 `open` 函数实现。以下是文件读写的基本步骤和示例：

## 打开文件

使用 `open` 函数打开文件，需要指定文件名和模式。常见的文件打开模式包括：

- `'r'`：读取模式，默认值。如果文件不存在，抛出 `FileNotFoundError`。
- `'w'`：写入模式。如果文件存在，会被覆盖。如果文件不存在，创建新文件。
- `'a'`：追加模式。如果文件存在，写入的数据会被添加到文件末尾。如果文件不存在，创建新文件。
- `'b'`：二进制模式。用于读写二进制文件。
- `'+'`：更新模式。可以读取和写入。

## 读取文件

使用 `'r'` 模式打开文件后，可以使用 `read()`、`readline()` 或 `readlines()` 等方法读取文件内容。

```python
# 打开文件并读取全部内容
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)

# 逐行读取文件
with open('example.txt', 'r') as file:
    for line in file:
        print(line.strip())  # 使用 strip() 去除行尾的换行符
```

## 写入文件

使用 `'w'` 或 `'a'` 模式打开文件后，可以使用 `write()` 或 `writelines()` 方法写入文件内容。

```python
# 写入文本到文件
with open('example.txt', 'w') as file:
    file.write('Hello, world!\n')
    file.write('This is a test file.\n')

# 追加文本到文件
with open('example.txt', 'a') as file:
    file.write('Appending another line.\n')
```

## 二进制文件读写

使用 `'b'` 模式可以读写二进制文件，如图片、音频等。

```python
# 读取二进制文件
with open('image.png', 'rb') as file:
    data = file.read()

# 写入二进制文件
with open('image.png', 'wb') as file:
    file.write(data)
```

## 使用 `with` 语句

推荐使用 `with` 语句来处理文件操作，因为它可以自动关闭文件，即使发生异常也是如此。`with` 语句创建了一个上下文环境，确保文件在使用后正确关闭。

## 文件的其他操作

- `seek(offset, whence)`：移动文件读取/写入的光标到指定位置。
- `tell()`：返回当前文件光标的位置。
- `close()`：关闭文件。在 `with` 语句中，这一步会自动执行。

## 错误处理

在文件操作中，可能会遇到各种错误，如文件不存在、权限问题等。可以使用 `try...except` 语句来捕获并处理这些异常。

```python
try:
    with open('non_existent_file.txt', 'r') as file:
        content = file.read()
except FileNotFoundError:
    print('File not found.')
except Exception as e:
    print(f'An error occurred: {e}')
```

---

## file对象常用函数

Python 的 `file` 对象（通常通过 `open` 函数创建）提供了多种方法来对文件进行读写操作。以下是一些常用的 `file` 对象方法：

1. **`open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`**：
   - 打开文件并返回文件对象。需要指定文件名和模式。

2. **`close()`**：
   - 关闭文件。关闭后，文件不能再进行读写操作。

3. **`read(size=-1)`**：
   - 读取文件内容。`size` 指定要读取的字符数。如果未指定或为负数，读取整个文件。

4. **`readline(size=-1)`**：
   - 读取文件的一行或 `size` 指定的字符数。默认读取整行。

5. **`readlines(sizehint=-1)`**：
   - 读取所有行，返回一个包含每行作为元素的列表。

6. **`write(str)`**：
   - 将字符串写入文件。如果文件是以追加模式打开的，则写入文件末尾。

7. **`writelines(sequence)`**：
   - 将序列中的每个字符串元素写入文件。

8. **`seek(offset, whence=0)`**：
   - 移动文件游标到指定位置。`offset` 是偏移量，`whence` 指定偏移基准（0 为文件开头，1 为当前位置，2 为文件末尾）。

9. **`tell()`**：
   - 返回当前文件游标的位置。

10. **`flush()`**：
    - 刷新文件缓冲区，确保所有缓冲中的数据都被写出。

11. **`truncate([size])`**：
    - 截断文件。如果指定 `size`，则将文件大小截断到 `size` 字节。如果未指定或为负数，则截断到当前游标位置。

12. **`isatty()`**：
    - 检查文件是否是一个终端设备（交互式控制台）。

13. **`next()`**：
    - 用于迭代文件对象，获取下一行。

14. **`__iter__()`**：
    - 返回迭代器对象，允许使用 `for` 循环遍历文件。

15. **`__next__()`**：
    - 用于迭代，返回下一行。

16. **`__enter__()` 和 `__exit__()`**：
    - 支持上下文管理器协议，允许使用 `with` 语句自动管理文件的打开和关闭。

17. **`fileno()`**：
    - 返回文件的文件描述符。

18. **`flush()`**：
    - 刷新文件对象的内部缓冲。在写入操作后调用此方法，确保数据被写入到文件中。

19. **`seekable()`**：
    - 返回布尔值，指示文件对象是否可寻址。

20. **`readable()`**：
    - 返回布尔值，指示文件对象是否可读。

21. **`writable()`**：
    - 返回布尔值，指示文件对象是否可写。

使用 `with` 语句可以自动管理文件的打开和关闭，即使在发生异常时也能确保文件正确关闭。例如：

```python
with open('example.txt', 'r') as f:
    content = f.read()
    # 文件会在 with 语句块结束时自动关闭
```

这些方法提供了对文件进行各种操作的能力，包括读写、定位、缓冲管理等。

---

## os模块

Python 的 `os` 模块提供了许多用于操作系统交互的功能，包括文件和目录的创建、删除、移动、文件属性的获取等。以下是一些 `os` 模块的常用方法：

1. **`os.name`**：
   - 一个字符串，用于表示正在使用的操作系统。例如，在Windows上是 `'nt'`，在Unix/Linux上是 `'posix'`。

2. **`os.getcwd()`**：
   - 获取当前工作目录。

3. **`os.chdir(path)`**：
   - 更改当前工作目录。

4. **`os.listdir(path='.')`**：
   - 列出指定目录下的文件和子目录。

5. **`os.mkdir(path, mode=0o777)`**：
   - 创建一个目录，`mode` 指定目录的权限。

6. **`os.makedirs(path, mode=0o777, exist_ok=False)`**：
   - 递归地创建目录。如果 `exist_ok` 为 `True`，并且目录已经存在，不会抛出异常。

7. **`os.rmdir(path)`**：
   - 删除一个空目录。

8. **`os.removedirs(path)`**：
   - 递归地删除目录。

9. **`os.remove(path)`**：
   - 删除一个文件或符号链接。

10. **`os.rename(src, dst)`**：
    - 重命名或移动文件或目录。

11. **`os.link(src, dst, *, _src_st=None)`**：
    - 创建一个硬链接。

12. **`os.symlink(src, dst)`**：
    - 创建一个符号链接。

13. **`os.stat(path)`**：
    - 获取文件或目录的详细信息。

14. **`os.path.join(path, *paths)`**：
    - 连接两个或多个路径部分。

15. **`os.path.split(path)`**：
    - 分割路径，返回头和尾。

16. **`os.path.exists(path)`**：
    - 检查给定路径是否存在。

17. **`os.path.isfile(path)`**：
    - 检查给定路径是否为文件。

18. **`os.path.isdir(path)`**：
    - 检查给定路径是否为目录。

19. **`os.path.abspath(path)`**：
    - 返回路径的绝对路径。

20. **`os.path.realpath(path)`**：
    - 返回路径的解析形式，解析所有符号链接。

21. **`os.path.basename(path)`**：
    - 返回路径中的最后一个部分。

22. **`os.path.dirname(path)`**：
    - 返回路径中的目录名。

23. **`os.environ`**：
    - 一个代表当前操作系统环境变量的字典。

24. **`os.system(command)`**：
    - 执行 shell 命令并等待其完成，返回命令的退出状态码。

25. **`os.walk(top, topdown=True, onerror=None, followlinks=False)`**：
    - 生成目录树中的文件名。遍历 `top` 目录下的所有效文件和目录。

26. **`os.path.getsize(path)`**：
    - 返回指定文件的大小，单位是字节。

27. **`os.chmod(path, mode)`**：
    - 更改文件或目录的权限。

28. **`os.path.splitext(path)`**：
    - 分离路径，返回文件名和扩展名。

29. **`os.execvp(program, arguments)`**：
    - 执行一个程序，替换当前的进程。

30. **`os.path.expanduser(path)`**：
    - 扩展初始的 `~` 到用户的主目录。

这些方法提供了与操作系统交互的强大工具集，允许你在 Python 程序中执行文件和目录操作、环境变量管理、路径操作等。使用 `os` 模块可以编写出跨平台的代码，因为许多方法都考虑了不同操作系统之间的差异。

# python中的多线程

多线程常用的模块：

- **_thread**（原py2中的thread已被废弃，py3中不能使用，为了兼容性，py3将thread重命名为_thread）
- **threading(推荐使用)**

## _thread

_thread 只提供了低级别、简单的线程及锁的使用，功能较少。

特点：

- _thread 模块的 API 较为底层，主要提供创建线程和互斥锁的功能。
- 它没有 threading 模块中的高级功能，如线程池、条件变量、事件等。
- 由于 _thread 模块基于 C，它的接口设计较为简单，但使用起来可能不如 threading 模块方便。

常用函数：

- **start_new_thread(function, args[,kwargs])**：启动一个新线程，function 是线程要执行的函数，args 是传递给该函数的参数。
  - function：线程函数
  - args：传递给线程函数的参数，tuple类型
  - kwargs：可选参数
- **allocate_lock()**：分配一个互斥锁。
- **lock()**：获取锁。
- **unlock()**：释放锁。

注意事项：

- 由于 _thread 模块的 API 较为底层，它没有 threading 模块中的异常处理和线程管理功能。
- 在使用 _thread 模块时，需要手动管理线程的生命周期和异常。
- _thread 模块的互斥锁没有 threading 模块中的 Lock 对象那么强大，例如，它不支持超时机制。

### 示例

使用 _thread 模块创建线程和使用互斥锁的示例

```python
import _thread

# 一个简单的线程函数
def print_numbers():
    for i in range(1, 6):
        # 获取锁
        lock.acquire()
        try:
            print(i)
        finally:
            # 释放锁
            lock.release()

# 创建一个互斥锁
lock = _thread.allocate_lock()

# 启动线程
_thread.start_new_thread(print_numbers, ())

# 同时主线程也打印数字
for i in range(1, 6):
    lock.acquire()
    try:
        print(f"Main thread: {i}")
    finally:
        lock.release()
```

在这个示例中，我们创建了一个互斥锁 lock，然后在线程函数 print_numbers 和主线程中都使用了这个锁来同步对共享资源（控制台输出）的访问。

---

## threading

`threading` 模块是一个基于线程的并发库，它提供了丰富的接口来创建和管理线程。这个模块是 Python 标准库的一部分，适用于实现多线程应用程序。

### 主要组件

1. **线程（Thread）**：
   - `threading.Thread` 是线程的基类，用于创建和管理线程。

2. **锁（Locks）**：
   - `threading.Lock` 提供了互斥锁的功能，用于线程同步。

3. **事件（Events）**：
   - `threading.Event` 用于在某个条件满足时通知线程。

4. **条件（Conditions）**：
   - `threading.Condition` 提供了更高级的同步机制，允许一个或多个线程等待某个条件。

5. **信号量（Semaphores）**：
   - `threading.Semaphore` 用于控制对一定数量资源的访问。

6. **屏障（Barriers）**：
   - `threading.Barrier` 用于同步固定数量的线程。

7. **定时器（Timers）**：
   - `threading.Timer` 用于设置定时器，在指定时间后执行某个函数。

### 常用方法简介

除了包含 _thread 模块中的所有方法外，还提供的其他方法：

- **threading. current_thread()**: 返回当前的线程变量。
- **threading.enumerate()**: 返回一个包含正在运行的线程的列表。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
- **threading.active_count()**: 返回正在运行的线程数量，与 len(threading.enumerate()) 有相同的结果。
- **threading.Thread(target, args=(), kwargs={}, daemon=None)**：创建Thread类的实例。
  - target：线程将要执行的目标函数。
  - args：目标函数的参数，以元组形式传递。
  - kwargs：目标函数的关键字参数，以字典形式传递。
  - daemon：指定线程是否为守护线程。

**threading.Thread 类**提供了以下方法与属性:

- `__init__(self, group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)`：初始化Thread对象。
  - group：线程组，暂时未使用，保留为将来的扩展。
  - target：线程将要执行的目标函数。
  - name：线程的名称。
  - args：目标函数的参数，以元组形式传递。
  - kwargs：目标函数的关键字参数，以字典形式传递。
  - daemon：指定线程是否为守护线程。
- `start(self)`：启动线程。将调用线程的run()方法。
- `run(self)`：线程在此方法中定义要执行的代码。
- `join(self, timeout=None)`：等待线程终止。默认情况下，join()会一直阻塞，直到被调用线程终止。如果指定了timeout参数，则最多等待timeout秒。
- `is_alive(self)`：返回线程是否在运行。如果线程已经启动且尚未终止，则返回True，否则返回False。
- `getName(self)`：返回线程的名称。
- `setName(self, name)`：设置线程的名称。
- `ident`属性：线程的唯一标识符。
- `daemon`属性：线程的守护标志，用于指示是否是守护线程。
- `isDaemon()`：判断是否是守护线程

### 主要特性

- **易于使用**：`threading` 模块提供了简单易用的高级接口，使得多线程编程更加方便。
- **丰富的线程管理**：支持线程的创建、启动、同步和结束等操作。
- **内置同步原语**：提供了锁（Locks）、事件（Events）、条件（Conditions）和信号量（Semaphores）等同步机制。
- **支持守护线程**：可以设置线程为守护线程（Daemon threads），在主程序结束时自动结束。

### threading示例

以下是一个使用 `threading` 模块创建线程的简单示例：

```python
import threading
import time

# 线程要执行的目标函数
def print_numbers():
    for i in range(1, 6):
        time.sleep(1)
        print(f"Thread: {i}")

# 创建线程
thread = threading.Thread(target=print_numbers)

# 启动线程
thread.start()

# 等待线程结束
thread.join()
print("Main program continues after thread terminates.")
```

### 注意事项

- **全局解释器锁（GIL）**：由于 Python 的 GIL，同一时刻只有一个线程可以执行 Python 字节码。这意味着在 CPU 密集型任务中，多线程可能不会带来性能上的提升。然而，在 I/O 密集型任务中，多线程可以提高性能，因为线程可以在等待 I/O 操作时让其他线程运行。
- **线程安全**：在设计多线程程序时，需要确保共享数据的访问是线程安全的，避免竞态条件。
- **线程管理**：合理管理线程的生命周期，包括线程的创建、启动、同步和结束。
- **异常处理**：在多线程程序中，异常处理尤为重要，需要确保线程中的异常能够被捕获和处理。

### 线程同步

使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法。

示例：

```python
#!/usr/bin/python3

import threading
import time

class myThread (threading.Thread):
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = delay
    def run(self):
        print ("开启线程： " + self.name)
        # 获取锁，用于线程同步
        threadLock.acquire()
        print_time(self.name, self.delay, 3)
        # 释放锁，开启下一个线程
        threadLock.release()

def print_time(threadName, delay, counter):
    while counter:
        time.sleep(delay)
        print ("%s: %s" % (threadName, time.ctime(time.time())))
        counter -= 1

threadLock = threading.Lock()
threads = []

# 创建新线程
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

# 开启新线程
thread1.start()
thread2.start()

# 添加线程到线程列表
threads.append(thread1)
threads.append(thread2)

# 等待所有线程完成
for t in threads:
    t.join()
print ("退出主线程")
```

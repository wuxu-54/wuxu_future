# 变量与常量

在 Rust 中，变量和常量是两种不同的存储数据的方式，它们有显著的区别和使用场景。以下是详细解释：

---

## 一、变量 (Variables)

### 1. 默认不可变性 (Immutability)

Rust 的变量默认是 **不可变的**（immutable），这是 Rust 安全性的核心特性之一。一旦赋值后不可修改：

```rust
let x = 5;
x = 6; // 编译错误！不能修改不可变变量
```

在 Rust 里，变量默认是不可变的，这一设计理念主要基于以下几点考量：

1. 安全性： 1. 减少bug：防止意外修改变量 2. 并发更安全：不可变数据可以安全地在线程间共享
2. 代码的可维护性：代码更清晰：明确标识可变性，当你看到一个变量被声明时，你能确定它的值在后续不会被改变，这使得代码的行为更具可预测性。
3. 性能优化：编译器能够对不可变变量进行更多的优化。因为变量的值不会改变，编译器可以提前进行一些计算和优化，从而提升程序的性能。

### 2. 可变变量 (Mutable Variables)

使用 `mut` 关键字声明可变变量：

```rust
let mut y = 5;
y = 10; // 允许修改
```

### 3. 变量遮蔽 (Shadowing)

允许用 `let` 重新声明同名变量，**覆盖之前的变量**，甚至可以改变类型：
>也叫阴影，设计这个逻辑的原因是什么呢~ ，我猜是为了减少内存占用

```rust
let x = 5;
let x = x + 1;      // 遮蔽：新的 x = 6（仍然是不可变的）
let x = "hello";     // 类型从 i32 变为 &str
```

### 4. 变量作用域

变量的作用域是块级（由 `{}` 定义），离开作用域后变量会被销毁：

```rust
{
    let inner = 42;
    println!("{}", inner); // 有效
}
println!("{}", inner); // 错误！inner 已离开作用域
```

---

## 二、常量 (Constants)

### 1. `const` 常量

- 必须显式标注类型。
- 值必须是编译时可确定的常量表达式。
- 命名规范：全大写 + 下划线分隔。

```rust
const MAX_POINTS: u32 = 100_000;
```

### 2. `static` 静态变量

- 生命周期为整个程序运行期间。
- 可以声明为可变（`static mut`），但操作它需要 `unsafe` 块。

```rust
static HELLO: &str = "Hello";
static mut COUNTER: u32 = 0;

fn main() {
    unsafe {
        COUNTER += 1; // 只能在 unsafe 块中修改
    }
}
```

### 3. 常量与变量的区别

| 特性               | 变量 (`let`)       | 常量 (`const`)      | 静态变量 (`static`)     |
|--------------------|-------------------|--------------------|------------------------|
| 可变性             | 默认不可变 (`mut` 可变) | 永远不可变         | 默认不可变 (`mut` 可变需 `unsafe`) |
| 生命周期           | 作用域内有效       | 编译时替换         | 整个程序运行期间       |
| 是否允许遮蔽       | 允许              | 不允许             | 不允许                 |
| 是否允许运行时计算 | 允许              | 必须编译时确定     | 必须编译时确定         |

这里多补充一句：既然不可变变量是不可变的，那不就是常量吗？为什么叫变量？

答：

变量和常量还是有区别的。在 Rust 中，以下程序是合法的：

```txt
let a = 123;   // 可以编译，但可能有警告，因为该变量没有被使用
let a = 456;
```

但是如果 a 是常量就不合法：

```txt
const a: i32 = 123;
let a = 456;
```

变量的值可以"重新绑定"，但在"重新绑定"以前不能私自被改变，这样可以确保在每一次"绑定"之后的区域里编译器可以充分的推理程序逻辑。 虽然 Rust 有自动判断类型的功能，但有些情况下声明类型更加方便：

```txt
let a: u64 = 123;
```

这里声明了 a 为无符号 64 位整型变量，如果没有声明类型，a 将自动被判断为有符号 32 位整型变量，这对于 a 的取值范围有很大的影响。

---

## 三、何时使用？

1. **变量**：
   - 需要可变状态时用 `mut`。
   - 需要临时遮蔽变量时用 `let` 遮蔽。
2. **常量**：
   - 用于全局配置（如 `MAX_THREADS`）。
   - 需要编译时确定的值（如数学常量）。
3. **静态变量**：
   - 需要全局唯一的实例（如日志句柄）。
   - 可变全局状态（需谨慎使用 `unsafe`）。

---

## 四、示例对比

```rust
// 不可变变量
let name = "Alice";

// 可变变量
let mut score = 100;
score += 10;

// 变量遮蔽
let count = 5;
let count = count.to_string(); // 类型变为 String

// 常量
const PI: f64 = 3.14159;

// 静态变量
static mut REQUEST_COUNT: u64 = 0;

fn increment() {
    unsafe { REQUEST_COUNT += 1 } // 需要 unsafe
}
```

---

## 五、总结

- **变量**：默认不可变，通过 `mut` 可变，允许遮蔽。
- **常量**：编译时确定，不可变，无内存地址。
- **静态变量**：全局生命周期，可变操作需 `unsafe`。

Rust 通过这些设计强制开发者显式声明意图，避免意外修改和内存安全问题。

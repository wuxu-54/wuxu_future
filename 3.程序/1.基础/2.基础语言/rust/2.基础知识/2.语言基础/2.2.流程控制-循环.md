# 流程控制-循环

以下是 Rust 中循环控制流程的全面解析，涵盖基础语法、高级用法及最佳实践，特别针对 Rust 独特设计进行深入说明：

---

## 一、**基础循环类型**

### 1. **`loop` 无限循环**

- **核心用途**：需要明确控制退出条件的场景（如事件轮询、重试机制）。
- **返回值**：可通过 `break` 返回结果（其他语言罕见特性）。

```rust
let mut counter = 0;
let result = loop {
    counter += 1;
    if counter == 5 {
        break counter * 2; // 返回 10
    }
};
println!("Result: {}", result);
```

### 2. **`while` 条件循环**

- **特点**：每次循环前检查条件，适合不确定迭代次数的场景。
- **模式匹配增强**：结合 `if let` 处理 `Option`/`Result`：

```rust
let mut stack = vec![1, 2, 3];
while let Some(top) = stack.pop() {
    println!("Popped: {}", top);
}
```

### 3. **`for` 迭代循环**

- **底层机制**：基于迭代器 (`IntoIterator` trait)，确保内存安全。
- **范围表达式**：

  ```rust
  for i in 1..=5 {          // 闭区间 [1,5]
      println!("{}", i); 
  }
  ```

- **集合遍历**：

  ```rust
  let names = ["Alice", "Bob"];
  for name in names.iter() { // 显式借用，避免所有权转移
      println!("Name: {}", name);
  }
  ```

---

## 二、**高级循环控制**

### 1. **循环标签（Loop Labels）**

- **解决嵌套循环控制**：精确指定 `break` 或 `continue` 的目标循环。

```rust
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x + y > 15 {
            break 'outer; // 直接退出外层循环
        }
    }
}
```

### 2. **迭代器方法替代传统循环**

- **函数式风格**：更简洁且避免索引错误。

```rust
(1..10).filter(|x| x % 2 == 0)
        .for_each(|x| println!("Even: {}", x));
```

### 3. **循环中的所有权管理**

- **所有权转移**：直接遍历集合会转移所有权，使用引用避免：

```rust
let nums = vec![1, 2, 3];
for num in &nums {  // 借用，nums 仍可用
    println!("{}", num);
}
```

---

## 三、**错误处理与循环**

### 1. **`?` 操作符在循环中的使用**

```rust
let results = vec![Ok(1), Err("error"), Ok(3)];
for res in results {
    let val = res?; // 遇到 Err 提前退出函数
    println!("Value: {}", val);
}
```

### 2. **`loop` 与 `Result` 结合的重试机制**

```rust
let mut retries = 3;
let result = loop {
    retries -= 1;
    match fetch_data() {
        Ok(data) => break Ok(data),
        Err(_) if retries > 0 => continue,
        Err(e) => break Err(e),
    }
};
```

---

## 四、**性能优化技巧**

### 1. **避免循环中的重复计算**

```rust
// 错误示例：每次循环都计算长度
for i in 0..vec.len() { ... }

// 正确做法：缓存长度
let len = vec.len();
for i in 0..len { ... }
```

### 2. **预分配集合容量**

```rust
let mut data = Vec::with_capacity(1000); // 预分配内存
for i in 0..1000 {
    data.push(i);
}
```

### 3. **使用 `while let` 替代 `loop + match`**

```rust
// 更简洁的写法
while let Some(item) = queue.pop() {
    process(item);
}
```

---

## 五、**常见陷阱与解决方案**

### 1. **无限循环意外**

```rust
// 错误：缺少 break 条件
loop {
    println!("Running forever...");
}
// 解决方案：确保存在可达的 break 分支
```

### 2. **循环中的借用冲突**

```rust
let mut vec = vec![1, 2, 3];
for num in &vec {      // 不可变借用
    vec.push(*num);    // 错误！同时可变借用
}
// 解决方案：分离读写阶段
```

---

## 六、**循环对比表**

| 循环类型 | 适用场景                   | 优点                      | 缺点                |
|----------|---------------------------|---------------------------|---------------------|
| `loop`   | 精确控制退出/重试逻辑      | 可返回值，灵活控制流      | 需手动管理退出条件  |
| `while`  | 条件不确定（如读取流）     | 条件前置，避免无效迭代    | 可能遗漏退出条件    |
| `for`    | 遍历已知集合/范围          | 自动处理迭代，内存安全    | 无法直接修改迭代器  |

---

## 七、**实战示例**

### 1. **实现自定义迭代器**

```rust
struct Countdown(u32);

impl Iterator for Countdown {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        if self.0 == 0 {
            None
        } else {
            self.0 -= 1;
            Some(self.0 + 1)
        }
    }
}

for num in Countdown(3) {
    println!("T-{}", num); // 输出 T-3, T-2, T-1
}
```

### 2. **并行循环 (`rayon` 库)**

```rust
use rayon::prelude::*;

let nums = vec![1, 2, 3, 4];
nums.par_iter().for_each(|n| {
    println!("Processing {} in parallel", n);
});
```

---

## 八、**总结**

1. **Rust 循环哲学**：通过类型系统和所有权机制，在保证安全性的同时提供高性能。
2. **优先选择**：
   - 使用 `for` 替代手动索引循环
   - 用迭代器方法 (`map`/`filter`/`fold`) 替代复杂循环逻辑
3. **特别注意**：
   - 循环中的所有权转移问题
   - 避免在循环中创建不必要的临时对象

通过深入理解这些特性，您可以编写出既安全又高效的 Rust 循环代码！

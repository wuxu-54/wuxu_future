# Rust 可变引用规则详解

Rust 通过**所有权系统**和**借用规则**确保内存安全，其中可变引用（`&mut T`）是核心机制之一。以下是其核心规则及原理：

---

## 一、基本规则

1. **独占性**  
   同一时间，一个数据只能存在 **一个可变引用** 或 **多个不可变引用**，二者不可共存。  
   **目的**：防止数据竞争（Data Race），避免同时读写导致的不确定性。

   ```rust
   let mut s = String::from("hello");
   
   // 正确：仅一个可变引用
   let r1 = &mut s;
   
   // 错误！同一作用域内第二个可变引用
   // let r2 = &mut s; 
   ```

2. **作用域隔离**  
   可变引用与不可变引用的生命周期不得重叠。若不可变引用仍在使用，可变引用无法创建。

   ```rust
   let mut x = 5;
   let y = &x; // 不可变引用
   // let z = &mut x; // 错误！存在不可变引用时不能创建可变引用
   println!("{}", y); // y 使用结束后，z 方可创建
   ```

3. **显式可变性**  
   变量必须声明为 `mut` 才能创建可变引用。

   ```rust
   let mut s = String::from("hello");
   let r = &mut s; // 正确
   ```

---

## 二、作用域与生命周期优化（NLL）

Rust 编译器通过 **Non-Lexical Lifetimes (NLL)** 优化，允许引用在不再使用时提前结束生命周期，而非严格依赖代码块作用域。

**示例**：  

```rust
let mut s = String::from("hello");
let r1 = &mut s; // r1 生命周期开始
r1.push_str(" world");
// r1 在此后不再使用，生命周期结束

let r2 = &mut s; // 正确：r1 的生命周期已结束
r2.push_str("!");
```

即使 `r1` 和 `r2` 在同一代码块内，由于 `r1` 不再被使用，编译器允许 `r2` 的创建。

---

## 三、悬垂引用（Dangling References）

Rust 在编译时阻止返回无效引用，确保引用始终指向有效内存。

**错误示例**：  

```rust
fn dangle() -> &String {
    let s = String::from("hello");
    &s // 错误！s 在函数结束时被释放，返回的引用无效
}
```

**正确方式**：转移所有权而非返回引用。  

```rust
fn no_dangle() -> String {
    let s = String::from("hello");
    s // 返回所有权，内存由调用者管理
}
```

---

## 四、可变引用的典型场景

1. **修改数据结构**  

   ```rust
   let mut vec = vec![1, 2, 3];
   let r = &mut vec;
   r.push(4); // 修改 Vec
   ```

2. **跨函数传递可变性**  

   ```rust
   fn modify(s: &mut String) {
       s.push_str(", world");
   }
   
   let mut s = String::from("hello");
   modify(&mut s);
   ```

---

## 五、总结

| 规则                  | 可变引用 (`&mut T`)       | 不可变引用 (`&T`)         |
|-----------------------|--------------------------|--------------------------|
| **数量限制**          | 同一时间仅一个           | 允许多个                 |
| **读写权限**          | 可读可写                 | 只读                     |
| **共存性**            | 不能与任何引用共存       | 可与其他不可变引用共存   |
| **作用域要求**        | 生命周期严格隔离         | 允许重叠                 |

Rust 通过这些规则在编译期消除内存安全问题，开发者需遵循借用检查器的提示调整代码结构，例如缩小可变引用的作用域或延后不可变引用的使用。

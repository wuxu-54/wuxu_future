# 闭包

以下是关于 Rust 闭包的全面解析，涵盖核心机制、捕获变量、作为参数/返回值及实际应用场景：

---

## 一、闭包基础

### 1. 定义与语法

- **闭包**是匿名函数，可捕获环境变量，语法灵活
- 参数和返回值类型可自动推断（也可显式标注）

```rust
// 基本形式
let add = |a, b| a + b;
println!("3 + 5 = {}", add(3, 5));

// 显式类型标注
let print = |s: String| -> () { println!("{}", s) };
```

### 2. 闭包 vs 函数

| **特性**          | **闭包**                  | **函数**                |
|--------------------|--------------------------|-------------------------|
| **环境变量捕获**   | 支持（通过引用或所有权） | 不支持                  |
| **类型推断**       | 参数/返回值可省略类型     | 必须显式声明所有类型    |
| **存储方式**       | 可存储在变量、结构体中    | 只能通过函数名调用      |
| **性能**           | 零成本抽象（与函数等效）  | 等效                   |

---

## 二、捕获变量机制

### 1. 捕获方式

- **默认按引用捕获**，但可通过 `move` 强制获取所有权

```rust
let x = 10;

// 不可变借用（Fn）
let get_x = || x;
println!("x = {}", get_x()); // x 仍可用

// 移动捕获（FnOnce）
let consume_x = move || {
    println!("Consumed x: {}", x);
    // x 的所有权被移动到闭包内
};
consume_x();
// println!("{}", x); // 错误！x 已被移动
```

### 2. 可变性控制

- **可变借用**需声明 `mut`

```rust
let mut counter = 0;

// 闭包修改外部变量（FnMut）
let mut incr = || {
    counter += 1;
    println!("Counter: {}", counter);
};
incr();
incr();
```

### 3. 捕获模式总结

| **Trait**   | 捕获方式          | 使用场景               |
|-------------|------------------|-----------------------|
| `Fn`        | 不可变借用       | 只读环境变量          |
| `FnMut`     | 可变借用         | 需修改外部变量        |
| `FnOnce`    | 移动所有权       | 变量需转移到闭包内部  |

---

## 三、闭包作为函数参数

### 1. 泛型 + Trait 约束

- 使用 `Fn`、`FnMut`、`FnOnce` 约束闭包类型

```rust
fn apply_twice<F>(mut f: F, x: i32) -> i32 
where
    F: FnMut(i32) -> i32 
{
    let tmp = f(x);
    f(tmp)
}

let mut offset = 10;
let result = apply_twice(
    |x| { 
        offset += 5; // 捕获并修改外部变量
        x + offset 
    }, 
    2
);
println!("Result: {}", result); // 2 +15 → 17 +20 = 37
```

### 2. 闭包与迭代器结合

```rust
let nums = vec![1, 2, 3, 4];
let squared: Vec<_> = nums.iter()
    .map(|x| x * x) // 闭包作为参数传递给 map
    .collect();
println!("{:?}", squared); // [1, 4, 9, 16]
```

---

## 四、闭包作为返回值

### 1. 返回闭包的挑战

- 需要明确生命周期，常用 `Box` 包装或静态生命周期

```rust
// 返回 Box<dyn Fn> 闭包
fn multiplier(factor: i32) -> Box<dyn Fn(i32) -> i32> {
    Box::new(move |x| x * factor)
}

let double = multiplier(2);
println!("Double 5: {}", double(5)); // 10
```

### 2. 使用 impl Trait（Rust 1.26+）

```rust
fn create_printer() -> impl Fn() {
    let text = String::from("Hello");
    move || println!("{}", text) // 捕获 text 的所有权
}

let printer = create_printer();
printer(); // 输出 "Hello"
```

---

## 五、实际应用场景

### 1. 延迟计算（Lazy Evaluation）

```rust
let expensive_closure = || {
    // 模拟耗时计算
    std::thread::sleep(std::time::Duration::from_secs(2));
    42
};

println!("准备执行...");
println!("结果: {}", expensive_closure());
```

### 2. 错误处理

```rust
let default = 0;
let value = Some(5).unwrap_or_else(|| {
    // 动态生成默认值
    println!("使用默认值");
    default
});
```

### 3. 线程间传递闭包

```rust
use std::thread;

let data = vec![1, 2, 3];
thread::spawn(move || { // 必须用 move 获取所有权
    println!("子线程数据: {:?}", data);
}).join().unwrap();
```

---

## 六、高级技巧

### 1. 闭包与生命周期

- 闭包捕获的变量生命周期必须不短于闭包自身

```rust
fn invalid_closure() -> impl Fn() {
    let s = String::from("临时字符串");
    || println!("{}", s) // 错误！s 的生命周期不够长
}
```

### 2. 闭包结构体存储

```rust
struct Cache<T> 
where
    T: Fn(i32) -> i32 
{
    calculation: T,
    value: Option<i32>,
}

let mut cache = Cache {
    calculation: |x| x * x,
    value: None,
};
```

---

## 总结

1. **核心价值**：闭包通过捕获环境变量，提供了比函数更灵活的逻辑封装能力
2. **所有权控制**：通过 `Fn`/`FnMut`/`FnOnce` 明确闭包对环境的访问权限
3. **性能优势**：Rust 闭包编译后与普通函数等效，无额外运行时开销
4. **典型应用**：迭代器适配、回调机制、并发编程、延迟计算等场景

通过合理使用闭包，可以编写出既高效又富有表达力的 Rust 代码。

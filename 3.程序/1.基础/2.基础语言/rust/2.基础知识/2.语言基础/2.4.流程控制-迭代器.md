# 流程控制-迭代器

Rust 中的迭代器机制是其高效处理集合数据的核心工具，结合惰性求值、所有权系统和丰富的适配器方法，提供了高性能且安全的编程范式。以下是其核心原理和使用方法的系统总结：

---

## **一、迭代器机制原理**

1. **Iterator Trait 核心**
   Rust 的迭代器基于 `Iterator` trait，所有迭代器必须实现 `next` 方法：

   ```rust
   pub trait Iterator {
       type Item;
       fn next(&mut self) -> Option<Self::Item>;
   }
   ```

   - `Item` 为迭代元素的类型。
   - `next()` 返回 `Some(Item)` 或 `None`（终止迭代）。

2. **惰性求值 (Lazy Evaluation)**
   - 迭代器操作（如 `map`、`filter`）不会立即执行，只有调用消费器（如 `collect`、`sum`）时才会触发实际计算。
   - 优势：避免中间集合的创建，节省内存和计算资源。

3. **所有权与迭代器类型**
   - **`iter()`**: 生成元素的不可变引用 (`&T`)，不转移所有权。
   - **`iter_mut()`**: 生成可变引用 (`&mut T`)，允许修改元素。
   - **`into_iter()`**: 转移所有权，遍历后原集合不可再用。

---

## **二、迭代器使用方法**

### **1. 创建迭代器**

```rust
let vec = vec![1, 2, 3];

// 不可变引用迭代
let iter = vec.iter();        // 类型: Iter<i32>

// 可变引用迭代
let iter_mut = vec.iter_mut();// 类型: IterMut<i32>

// 转移所有权迭代
let into_iter = vec.into_iter(); // 类型: IntoIter<i32>
```

### **2. 常用适配器（中间操作）**

适配器对迭代器进行转换，返回新迭代器：

- **`map`**: 元素转换。

  ```rust
  vec.iter().map(|x| x * 2); // 生成 [2, 4, 6]
  ```

- **`filter`**: 条件过滤。

  ```rust
  vec.iter().filter(|&x| x % 2 == 0); // 保留偶数
  ```

- **`enumerate`**: 添加索引。

  ```rust
  vec.iter().enumerate(); // 生成 (0,1), (1,2), (2,3)
  ```

- **`zip`**: 合并两个迭代器。

  ```rust
  (1..4).zip(vec!["a", "b", "c"]); // 生成 (1,"a"), (2,"b"), (3,"c")
  ```

### **3. 消费器（终止操作）**

触发计算并返回最终结果：

- **`collect()`**: 收集为集合。

  ```rust
  let doubled: Vec<_> = vec.iter().map(|x| x * 2).collect(); // [2,4,6]
  ```

- **`sum()`/`count()`**: 求和或计数。

  ```rust
  let sum: i32 = vec.iter().sum(); // 6
  ```

- **`fold()`**: 累积计算。

  ```rust
  vec.iter().fold(0, |acc, x| acc + x); // 等价于 sum()
  ```

- **`all()`/`any()`**: 检查所有/任意元素满足条件。

  ```rust
  vec.iter().all(|x| *x > 0); // true
  ```

---

## **三、性能优势**

1. **零成本抽象 (Zero-Cost Abstractions)**
   - 迭代器代码通常编译为与手写循环等效的机器码，无额外开销。
   - 示例：`map` + `filter` 组合的链式调用会被优化为单次循环。

2. **避免边界检查**
   - 使用迭代器遍历集合（如 `Vec`）时，直接通过指针移动访问元素，无需每次索引检查。

3. **内存效率**
   - 惰性求值避免创建中间集合，减少内存分配。

---

## **四、高级用法示例**

### **自定义迭代器**

```rust
struct Counter {
    current: u32,
    max: u32,
}

impl Iterator for Counter {
    type Item = u32;
    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.max {
            let val = self.current;
            self.current += 1;
            Some(val)
        } else {
            None
        }
    }
}

let counter = Counter { current: 0, max: 5 };
counter.collect(); // [0,1,2,3,4]
```

### **错误处理**

使用 `Result` 时，`collect` 可汇总结果：

```rust
let results = vec![Ok(1), Err("error"), Ok(3)];
let res: Result<Vec<_>, _> = results.into_iter().collect(); // 遇到第一个 Err 停止
```

---

## **五、总结**

Rust 的迭代器通过以下特性成为高效编程的核心工具：

- **简洁性**: 链式调用替代复杂循环。
- **安全性**: 编译时检查避免越界和所有权错误。
- **高性能**: 零成本抽象与惰性求值。
- **通用性**: 适配器组合支持复杂数据处理。

掌握迭代器的原理和方法，能够显著提升 Rust 代码的表达力和执行效率。

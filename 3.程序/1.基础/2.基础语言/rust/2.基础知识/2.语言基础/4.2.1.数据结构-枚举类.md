# 枚举

Rust 的枚举（`enum`）是一种强大的代数数据类型，允许定义一组命名的变体（variants），每个变体可携带不同类型和数量的关联数据。以下是其核心定义与使用方法：

---

## **1. 定义枚举**

### **基本定义**

```rust
enum Direction {
    North,
    South,
    East,
    West,
}
```

- 每个变体（如 `North`）表示一个可能的值。
- 变体可包含数据，支持多种数据类型（结构体、元组、字符串等）。

### **复杂数据变体**

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },  // 匿名结构体
    Write(String),            // 字符串
    ChangeColor(i32, i32, i32), // 元组
}
```

- `Move` 包含两个 `i32` 字段。
- `Write` 包含一个 `String`。
- `ChangeColor` 包含三个 `i32`。

---

## **2. 使用枚举**

### **创建枚举实例**

```rust
let home = IpAddr::V4(String::from("127.0.0.1"));
let msg = Message::Write(String::from("Hello"));
```

### **模式匹配（`match`）**

通过 `match` 处理所有可能的变体，确保逻辑完整：

```rust
fn process_message(msg: Message) {
    match msg {
        Message::Quit => println!("Quitting..."),
        Message::Move { x, y } => println!("Move to ({}, {})", x, y),
        Message::Write(s) => println!("Write: {}", s),
        Message::ChangeColor(r, g, b) => println!("Color: ({}, {}, {})", r, g, b),
    }
}
```

- **穷尽性**：`match` 必须覆盖所有变体，或用 `_` 通配符处理剩余情况。
- **解构数据**：直接提取变体中的值（如 `x`、`y`）。

### **条件匹配**

```rust
match color {
    Message::ChangeColor(r, g, b) if r == g && g == b => {
        println!("Gray color");
    }
    _ => println!("Other color"),
}
```

---

## **3. `Option` 枚举**

用于处理值可能存在或缺失的场景，避免空指针问题：

```rust
enum Option<T> {
    Some(T),
    None,
}
```

### **使用示例**

```rust
let some_value = Some(42);
let absent_value: Option<i32> = None;

match some_value {
    Some(value) => println!("Value: {}", value),
    None => println!("No value"),
}
```

- **安全性**：非 `Option` 类型保证不为空，强制显式处理 `None`。

---

## **4. `if let` 语法**

简化仅关注单一变体的匹配：

```rust
if let Some(5) = some_value {
    println!("Found 5");
} else {
    println!("Other value");
}
```

---

## **5. 为枚举添加方法**

通过 `impl` 块为枚举定义方法：

```rust
impl Message {
    fn call(&self) {
        match self {
            Message::Write(s) => println!("Called: {}", s),
            _ => (),
        }
    }
}

let msg = Message::Write(String::from("Hello"));
msg.call(); // 输出：Called: Hello
```

---

## **总结**

- **定义灵活**：枚举变体可包含任意类型数据，支持结构体、元组等。
- **模式匹配**：`match` 确保逻辑完整，`if let` 简化单分支处理。
- **空值安全**：`Option` 类型强制显式处理空值，避免运行时错误。
- **方法支持**：通过 `impl` 为枚举添加行为，类似结构体。

通过枚举和模式匹配，Rust 实现了类型安全和代码健壮性，适用于复杂数据结构的建模。

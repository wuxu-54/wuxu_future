# `Option`和`Result`

Rust中的`Option`和`Result`是处理可能缺失的值和错误的两种核心类型，它们通过类型系统强制开发者显式处理所有可能性，从而避免空指针异常和未处理的运行时错误。

>Option 是提前说明某个值可能存在也可能不存在。 Result 是明确执行流程结果，比如在函数中返回Result枚举数据。

## Option 类型

- **定义**：`Option<T>` 是一个枚举，表示一个值可能存在（`Some(T)`）或不存在（`None`）。
- **适用场景**：当函数可能返回一个值或没有值时使用，例如查找元素、可选配置等。
- **常用方法**：
  - `map`：转换内部值（若为`Some`）。
  - `and_then`：链式操作多个可能返回`Option`的函数。
  - `unwrap_or`：提供默认值处理`None`。
  - `ok_or`：将`Option`转换为`Result`，指定错误类型。
- **示例**：

  ```rust
  fn find_index(list: &[i32], target: i32) -> Option<usize> {
      list.iter().position(|&x| x == target)
  }

  let result = find_index(&[1, 2, 3], 2);
  match result {
      Some(i) => println!("Found at index {}", i),
      None => println!("Not found"),
  }
  ```

## Result 类型

- **定义**：`Result<T, E>` 也是一个枚举，表示操作可能成功（`Ok(T)`）或失败（`Err(E)`）。
- **适用场景**：用于错误处理，例如文件操作、网络请求等可能失败的操作。
- **常用方法**：
  - `map`：转换成功值（若为`Ok`）。
  - `map_err`：转换错误值（若为`Err`）。
  - `?` 操作符：自动传播错误。
  - `unwrap_or_else`：提供闭包处理错误。
- **示例**：

  ```rust
  use std::fs::read_to_string;

  fn read_config(path: &str) -> Result<String, std::io::Error> {
      read_to_string(path)
  }

  match read_config("config.toml") {
      Ok(content) => println!("Config: {}", content),
      Err(e) => println!("Error reading config: {}", e),
  }
  ```

## 关键区别与转换

- **选择依据**：
  - 使用`Option`表示值的有无，不涉及错误原因。
  - 使用`Result`表示操作的成功或失败，需携带错误信息。
- **相互转换**：
  - `Option`转`Result`：使用`ok_or`或`ok_or_else`，将`None`转为指定错误。

    ```rust
    let opt: Option<i32> = Some(5);
    let res: Result<i32, &str> = opt.ok_or("No value");
    ```

  - `Result`转`Option`：使用`ok`（丢弃错误）或`err`（丢弃成功值）。

    ```rust
    let res: Result<i32, &str> = Ok(5);
    let opt: Option<i32> = res.ok(); // Some(5)
    ```

## 错误传播与简洁处理

- **`?` 操作符**：自动返回错误或解包成功值。

  ```rust
  fn process_file(path: &str) -> Result<String, std::io::Error> {
      let content = read_to_string(path)?;
      Ok(content.trim().to_uppercase())
  }
  ```

  若`read_to_string`失败，`?`会直接返回错误；否则继续执行。

## 最佳实践

- **避免`unwrap`/`expect`**：在库代码或可能引发不可恢复错误时慎用，优先通过模式匹配或组合方法处理。
- **组合方法链**：利用`map`、`and_then`等链式调用，提升代码可读性。

  ```rust
  let result = Some(3)
      .map(|x| x * 2)
      .and_then(|x| if x > 5 { Some(x) } else { None });
  ```

通过合理使用`Option`和`Result`，可以编写出更安全、更健壮的Rust代码，有效避免运行时错误，同时明确表达函数的可能行为。

---

## `unwrap()` 和 `expect()`

在 Rust 里，`unwrap()` 和 `expect()` 属于 `Result` 与 `Option` 类型常用的方法，它们能对值进行提取。以下为你详细介绍：

### `unwrap()` 方法

`unwrap()` 方法的用途是从 `Result<T, E>` 或者 `Option<T>` 类型里提取出内部的值。要是 `Result` 是 `Ok` 变体，或者 `Option` 是 `Some` 变体，`unwrap()` 就会返回内部的值；要是 `Result` 是 `Err` 变体，或者 `Option` 是 `None` 变体，`unwrap()` 就会触发程序崩溃并给出一个错误信息。

以下是一个简单的示例：

```rust
fn main() {
    let some_number: Option<i32> = Some(42);
    let number = some_number.unwrap();
    println!("The number is: {}", number);

    let none_value: Option<i32> = None;
    // 这行代码会导致程序崩溃
    // let _ = none_value.unwrap();
}
```

在这个示例中，`some_number` 是 `Some(42)`，调用 `unwrap()` 方法后可以正常获取到内部的值 `42`。而 `none_value` 是 `None`，如果调用 `unwrap()` 方法，程序会崩溃。

### `expect()` 方法

`expect()` 方法和 `unwrap()` 方法类似，也是用于从 `Result<T, E>` 或者 `Option<T>` 类型中提取内部的值。不同的是，`expect()` 方法允许你提供一个自定义的错误信息，当 `Result` 是 `Err` 变体，或者 `Option` 是 `None` 变体时，程序崩溃时会显示你提供的错误信息。

以下是一个使用 `expect()` 方法的示例：

```rust
fn main() {
    let some_number: Option<i32> = Some(42);
    let number = some_number.expect("Expected a number");
    println!("The number is: {}", number);

    let none_value: Option<i32> = None;
    // 这行代码会导致程序崩溃，并显示自定义的错误信息
    let _ = none_value.expect("Expected a number, but got None");
}
```

在这个示例中，当 `none_value` 调用 `expect()` 方法时，程序会崩溃并显示自定义的错误信息 `"Expected a number, but got None"`。

### 总结

- `unwrap()` 方法简单直接，但是当出现错误时，给出的错误信息不够明确。
- `expect()` 方法允许你提供自定义的错误信息，当程序崩溃时能更清晰地知道问题所在。

在实际开发中，建议尽量避免使用 `unwrap()` 和 `expect()` 方法，因为它们会导致程序崩溃。可以使用 `match` 语句、`if let` 语句或者 `?` 运算符来处理可能出现的错误。

---

## 处理`Option`和`Result`

在Rust中，`Option`和`Result`是处理值缺失和错误的核心枚举类型。以下是它们的详细处理方式：

---

### **1. `Option<T>` 枚举**

表示一个值可能存在（`Some(T)`）或不存在（`None`）。

#### **常见操作：**

- **模式匹配（`match`）**：安全处理所有情况。

  ```rust
  let value: Option<i32> = Some(5);
  match value {
      Some(v) => println!("值为：{}", v),
      None => println!("无值"),
  }
  ```

- **`if let` 语法**：简洁处理单一情况。

  ```rust
  if let Some(v) = value {
      println!("值为：{}", v);
  } else {
      println!("无值");
  }
  ```

- **组合方法**：链式处理值。
  - **`map`**：对 `Some` 值进行转换，`None` 保持。

    ```rust
    let doubled = value.map(|v| v * 2); // Some(10) 或 None
    ```

  - **`and_then`**：链式调用返回 `Option` 的函数。

    ```rust
    let result = Some(5).and_then(|v| Some(v + 1)); // Some(6)
    ```

  - **`unwrap_or`**：提供默认值。

    ```rust
    let value = Some(5).unwrap_or(0); // 5
    let none_value = None.unwrap_or(0); // 0
    ```

  - **`unwrap_or_else`**：通过闭包生成默认值。

    ```rust
    let value = None.unwrap_or_else(|| {
        println!("生成默认值");
        0
    });
    ```

- **`?` 操作符**：在返回 `Option` 的函数中提前返回 `None`。

  ```rust
  fn find_element() -> Option<i32> {
      let arr = [1, 2, 3];
      let value = arr.get(5)?; // 若越界，直接返回 None
      Some(*value)
  }
  ```

---

### **2. `Result<T, E>` 枚举**

表示操作可能成功（`Ok(T)`）或失败（`Err(E)`）。

#### `Result<T, E>`**常见操作：**

- **模式匹配**：

  ```rust
  let result: Result<i32, String> = Ok(10);
  match result {
      Ok(v) => println!("成功：{}", v),
      Err(e) => println!("错误：{}", e),
  }
  ```

- **`?` 操作符**：传播错误，简化错误处理。

  ```rust
  fn read_file() -> Result<String, io::Error> {
      let mut file = File::open("file.txt")?; // 出错时直接返回 Err
      let mut contents = String::new();
      file.read_to_string(&mut contents)?;
      Ok(contents)
  }
  ```

- **组合方法**：
  - **`map`**：转换成功值，保持错误。

    ```rust
    let doubled = Ok(5).map(|v| v * 2); // Ok(10)
    ```

  - **`map_err`**：转换错误类型。

    ```rust
    let result = Ok(5).map_err(|e: io::Error| e.kind());
    ```

  - **`and_then`**：链式调用返回 `Result` 的函数。

    ```rust
    let result = Ok(5).and_then(|v| Ok(v + 1)); // Ok(6)
    ```

- **错误类型转换**：通过 `From` trait 统一错误。

  ```rust
  enum MyError { Io(io::Error), Parse(ParseIntError) }
  
  impl From<io::Error> for MyError {
      fn from(e: io::Error) -> Self { MyError::Io(e) }
  }
  
  fn process() -> Result<(), MyError> {
      let _ = File::open("file.txt")?; // io::Error 自动转为 MyError
      Ok(())
  }
  ```

---

### **3. 混合处理 `Option` 和 `Result`**

- **`Option` 转 `Result`**：使用 `ok_or` 或 `ok_or_else`。

  ```rust
  let some_value: Option<i32> = Some(5);
  let result: Result<i32, &str> = some_value.ok_or("无值");
  ```

- **`Result` 转 `Option`**：使用 `ok`（忽略错误）或 `err`（提取错误）。

  ```rust
  let result: Result<i32, &str> = Ok(5);
  let option: Option<i32> = result.ok(); // Some(5)
  ```

---

### **4. 错误处理最佳实践**

- **避免 `unwrap()`**：仅在原型或确定不会失败时使用。
- **使用 `expect()`**：提供有意义的错误信息。

  ```rust
  let value = Some(5).expect("不应为 None");
  ```

- **自定义错误类型**：统一错误处理逻辑。
- **组合子链式调用**：提升代码可读性。

  ```rust
  let output = some_function()
      .and_then(process_data)
      .map(format_output)
      .unwrap_or_else(|e| {
          log_error(e);
          default_output
      });
  ```

---

### **5. 示例场景**

#### **场景1：文件读取并解析数值**

```rust
use std::fs::File;
use std::io::{self, Read};
use std::num::ParseIntError;

fn read_and_parse() -> Result<i32, MyError> {
    let mut file = File::open("data.txt")?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    let num = contents.trim().parse::<i32>()?;
    Ok(num)
}

enum MyError {
    Io(io::Error),
    Parse(ParseIntError),
}

impl From<io::Error> for MyError {
    fn from(e: io::Error) -> Self { MyError::Io(e) }
}

impl From<ParseIntError> for MyError {
    fn from(e: ParseIntError) -> Self { MyError::Parse(e) }
}
```

#### **场景2：安全访问数组成员**

```rust
fn get_element(arr: &[i32], index: usize) -> Option<i32> {
    arr.get(index).copied()
}

fn main() {
    let arr = [1, 2, 3];
    let value = get_element(&arr, 5).unwrap_or(-1);
    println!("值：{}", value); // 输出：-1
}
```

---

### **总结**

- **`Option`**：用于值可能缺失的场景，避免 `null` 引发的错误。
- **`Result`**：用于可能失败的操作，强制显式处理错误。
- **组合子与 `?` 操作符**：提升代码简洁性和安全性。
- **自定义错误类型**：统一错误处理，提升代码可维护性。

通过灵活运用这些方法，可以编写出健壮且易维护的Rust代码。

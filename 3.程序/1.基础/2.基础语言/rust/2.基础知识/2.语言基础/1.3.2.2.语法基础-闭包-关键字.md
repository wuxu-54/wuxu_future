# 与闭包相关的关键字

在 Rust 中，与闭包相关的关键字和特性有多个，它们在不同方面影响着闭包的行为和使用，下面为你详细介绍。

## 1. `move` 关键字

- **作用**：`move` 关键字强制闭包获取其捕获变量的所有权，而非借用。这样可以避免闭包的生命周期依赖于外部变量的生命周期，尤其适用于将闭包传递到其他作用域或线程的场景。
- **示例**：

```rust
fn main() {
    let data = vec![1, 2, 3];
    // 使用 move 关键字，闭包获取 data 的所有权
    let closure = move || {
        println!("{:?}", data);
    };
    // 下面这行代码会报错，因为 data 的所有权已经被闭包拿走
    // println!("{:?}", data);
    closure();
}
```

## 2. 隐式关联的 `Fn`、`FnMut` 和 `FnOnce` 特性

虽然它们不是严格意义上的关键字，但在闭包的行为定义中起着关键作用。

- **`Fn`**
  - **作用**：实现 `Fn` 特性的闭包以不可变引用的方式捕获环境变量，意味着闭包内部不会改变捕获的变量。
  - **示例**：

```rust
fn main() {
    let num = 10;
    let closure = || println!("The number is: {}", num);
    // 闭包实现了 Fn 特性，可以多次调用
    closure();
    closure();
}
```

- **`FnMut`**
  - **作用**：实现 `FnMut` 特性的闭包以可变引用的方式捕获环境变量，所以闭包内部能够修改捕获的变量。
  - **示例**：

```rust
fn main() {
    let mut num = 10;
    let mut closure = || {
        num += 1;
        println!("The updated number is: {}", num);
    };
    // 闭包实现了 FnMut 特性
    closure();
    closure();
}
```

- **`FnOnce`**
  - **作用**：实现 `FnOnce` 特性的闭包会获取捕获变量的所有权，并且只能被调用一次，因为调用后变量的所有权就转移到闭包内部了。
  - **示例**：

```rust
fn main() {
    let data = vec![1, 2, 3];
    let closure = move || {
        println!("{:?}", data);
    };
    // 闭包实现了 FnOnce 特性，只能调用一次
    closure();
    // 再次调用会报错
    // closure();
}
```

## 3. `async` 关键字

- **作用**：在异步编程中，`async` 关键字用于定义异步闭包。异步闭包返回一个 `Future`，该 `Future` 可以在异步运行时中被执行。
- **示例**：

```rust
use std::time::Duration;
use tokio::time::sleep;

#[tokio::main]
async fn main() {
    let async_closure = async || {
        sleep(Duration::from_secs(1)).await;
        println!("Async closure completed");
    };
    async_closure().await;
}
```

## 4. `const` 关键字

- **作用**：从 Rust 1.57 版本开始，支持使用 `const` 关键字定义常量闭包。常量闭包可以在编译时执行，有助于在编译时进行计算。
- **示例**：

```rust
const ADD: fn(i32, i32) -> i32 = |a, b| a + b;

fn main() {
    const RESULT: i32 = ADD(2, 3);
    println!("The result is: {}", RESULT);
}
```

这些关键字和特性赋予了 Rust 闭包强大的灵活性和安全性，使开发者能够根据不同的需求编写高效且安全的代码。

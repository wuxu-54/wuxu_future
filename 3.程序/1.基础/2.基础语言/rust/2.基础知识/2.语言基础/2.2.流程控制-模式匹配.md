# 流程控制-模式匹配（Pattern Matching）

在 Rust 中，**模式匹配（Pattern Matching）** 是核心语言特性之一，通过 `match` 和 `if let` 表达式实现，提供强大的代码控制能力。以下是其核心机制的详细解析：

---

## 一、基础语法：`match` 表达式

`match` 是 Rust 中实现模式匹配的主要方式，**必须穷尽所有可能性**，确保代码的安全性。

### 基本结构

```rust
match 目标值 {
    模式1 => 表达式或代码块,
    模式2 => 表达式或代码块,
    _ => 默认处理
}
```

>类似java中的switch，但又有自己的特性，具体看下面的说明

### 示例

```rust
fn main() {
    let x = 5;
    match x {
        1 => println!("一"),
        2 | 3 => println!("二或三"),  // 匹配多个值
        4..=6 => println!("四到六"),  // 范围匹配
        _ => println!("其他"),
    }
}
```

### 核心特性

1. **穷尽性检查**：必须处理所有可能的模式，否则编译报错。
2. **模式组合**：支持 `|` 或、范围 `..=` 等组合模式。
3. **值绑定**：使用 `@` 将匹配的值绑定到变量。

---

## 二、高级模式匹配特性

### 1. 模式守卫（Pattern Guards）

通过 `if` 条件添加额外逻辑：

```rust
let num = 10;
match num {
    n @ 1..=9 => println!("1-9: {}", n),
    n if n % 2 == 0 => println!("偶数: {}", n), // 守卫条件
    _ => println!("其他"),
}
```

### 2. 解构复杂类型

匹配并解构结构体、枚举、元组等：

```rust
struct Point { x: i32, y: i32 }
let p = Point { x: 0, y: 7 };

match p {
    Point { x, y: 0 } => println!("在x轴上: {}", x),
    Point { x: 0, y } => println!("在y轴上: {}", y),
    Point { x, y } => println!("坐标: ({}, {})", x, y),
}
```

### 3. `if let` 简化单一模式匹配

处理单个模式时替代 `match`：

```rust
let some_value = Some(5);
if let Some(x) = some_value {
    println!("值为: {}", x); // 输出 5
}
```

解释：

- `if let` 是一种特殊的条件语句，用于进行模式匹配。
- `Some(v)` 是一个模式，表示匹配 `Option` 类型中包含值的情况。`x` 是一个绑定变量，用于捕获 Some 变体中包含的值。
- `some_value` 是要进行匹配的变量。
- 当 `some_value` 的值为 `Some` 变体时，模式匹配成功，将 `Some` 中包含的值绑定到变量 `x` 上，并执行 `{}` 内的代码块。

---

## 三、应用场景

### 1. 枚举处理

处理 `Option<T>` 或自定义枚举的多种状态：

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

let msg = Message::Write(String::from("hello"));
match msg {
    Message::Quit => println!("退出"),
    Message::Move { x, y } => println!("移动到 ({}, {})", x, y),
    Message::Write(text) => println!("消息: {}", text),
}
```

### 2. 错误处理

结合 `Result<T, E>` 处理成功或错误：

```rust
let result: Result<i32, &str> = Ok(42);
match result {
    Ok(value) => println!("成功: {}", value),
    Err(e) => println!("错误: {}", e),
}
```

### 3. 复杂条件分支

替代多层 `if-else`，提升可读性：

```rust
let pair = (0, -2);
match pair {
    (0, y) => println!("在y轴上: {}", y),
    (x, 0) => println!("在x轴上: {}", x),
    (x, y) => println!("坐标: ({}, {})", x, y),
}
```

---

## 四、对比传统 `switch` 的优势

| 特性                | Rust `match`           | 传统 `switch`          |
|---------------------|------------------------|------------------------|
| **穷尽性检查**      | 强制覆盖所有可能       | 可能遗漏未处理分支     |
| **模式灵活性**      | 支持范围、解构、守卫等 | 仅支持常量值匹配       |
| **表达式返回值**    | 可返回统一类型值       | 无返回值               |
| **类型安全**        | 编译时严格校验类型     | 依赖隐式类型转换       |

---

## 总结

Rust 的模式匹配通过 `match` 和 `if let` 提供了：

- **安全性**：编译时穷尽性检查避免逻辑遗漏。
- **表达力**：支持复杂模式、解构和守卫条件。
- **简洁性**：替代多层 `if-else`，提升代码可读性。

它是处理枚举、错误、状态机等场景的核心工具，是 Rust 类型安全和表达能力的基石。

# 数据类型

Rust 是静态类型语言，在变量声明时可以显式指定类型，但通常可以依赖类型推断。

- 基本类型: i32 (32位有符号整数), u32 (32位无符号整数), f64 (64位浮点数), bool (布尔类型), char (字符)

```rust
//实例
let x: i32 = 42;
let y: f64 = 3.14;
let is_true: bool = true;
let letter: char = 'A';
```

- 复合类型：元组、数组、动态数组
- 字符串类型
- 自定义类型
- 引用与指针类型
- 特殊类型
- 动态大小类型 (DST)

以下是 Rust 数据类型的详细分类和说明，包含基础类型、复合类型、自定义类型及高级特性的完整解析：

---

## 一、**基础类型 (Scalar Types)**

### 1. **整数类型**

| 类型       | 有符号范围                | 无符号范围       | 示例         |
|------------|---------------------------|------------------|--------------|
| `i8`       | -128 ~ 127                | `u8`: 0 ~ 255    | `42i8`       |
| `i16`      | -32768 ~ 32767            | `u16`: 0 ~ 65535 | `-100i16`    |
| `i32`      | -2^31 ~ 2^31-1            | `u32`: 0 ~ 2^32-1| `0x1a3u32`   |
| `i64`      | -2^63 ~ 2^63-1            | `u64`: 0 ~ 2^64-1| `1_000_000`  |
| `i128`     | -2^127 ~ 2^127-1          | `u128`: 0 ~ 2^128-1 | `999u128`  |
| `isize`    | 目标平台指针大小的有符号整数 | `usize`: 无符号   | `usize::MAX` |

**注意**：

- 默认推断类型为 `i32`。
- `isize`/`usize` 用于集合索引（如数组长度）。

### 2. **浮点类型**

| 类型   | 精度   | 范围                | 示例          |
|--------|--------|---------------------|---------------|
| `f32`  | 单精度 | ~1.2e-38 ~ ~3.4e38  | `3.14f32`     |
| `f64`  | 双精度 | ~2.2e-308 ~ ~1.8e308| `2.71828`     |

**注意**：

- 默认推断类型为 `f64`（精度更高）。
- 遵循 IEEE-754 标准。

### 3. **布尔类型**

```rust
let is_true: bool = true;
let is_false = false;
```

- 仅有两个值：`true` 和 `false`。
- 用于条件判断（如 `if`、`while`）。

### 4. **字符类型**

```rust
let c = 'A';        // Unicode 字符（4字节）
let emoji = '😀';    // 支持任意 Unicode
```

- 单引号定义，占 **4** 字节（UTF-32）。    这里与c不同，竟然占4个字节
- 与字符串切片 `&str` 不同。

---

## 二、**复合类型 (Compound Types)**

### 1. **元组 (Tuple)**

```rust
let tuple: (i32, f64, char) = (500, 6.4, 'Z');
let (x, y, z) = tuple;      // 解构
let first = tuple.0;        // 索引访问
```

- 固定长度，可包含不同类型。
- 用于临时组合数据。

### 2. **数组 (Array)**

```rust
let arr = [1, 2, 3, 4, 5];      // 类型推断为 [i32; 5]
let arr2: [i32; 3] = [10; 3];   // [10, 10, 10]
let first = arr[0];             // 访问元素
```

- **固定长度**，元素类型相同。
- 数据存储在栈上。
- 越界访问会 panic。

### 3. **动态数组 (Vector)**

```rust
let mut vec = vec![1, 2, 3];    // 使用宏创建
vec.push(4);                     // 添加元素
let first = vec[0];              // 访问元素
```

- 堆分配的动态数组（`Vec<T>`）。
- 长度可变，可动态扩容。

---

## 三、**字符串类型**

### 1. **字符串切片 (`&str`)**

```rust
let s: &str = "Hello, Rust!";   // 不可变，编译时已知
let sub = &s[0..5];             // 切片 "Hello"
```

- 指向 UTF-8 编码字符串的不可变引用。
- 通常用于函数参数传递。

### 2. **字符串对象 (`String`)**

```rust
let mut s = String::from("Hello");
s.push_str(", Rust!");           // 修改字符串
let s2 = s.clone();              // 深拷贝
```

- 堆分配的可变字符串。
- 支持动态修改（追加、删除等）。

---

## 四、**自定义类型**

### 1. **结构体 (`struct`)**

```rust
struct Point {
    x: i32,
    y: i32,
}

let p = Point { x: 0, y: 10 };
println!("({}, {})", p.x, p.y);
```

### 2. **枚举 (`enum`)**

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

let msg = Message::Write(String::from("Hello"));
```

### 3. **联合体 (`union`)** （需 `unsafe` 操作）

```rust
union MyUnion {
    i: i32,
    f: f32,
}

let u = MyUnion { i: 42 };
unsafe { println!("{}", u.i) };
```

---

## 五、**引用与指针类型**

### 1. **引用 (`&T` / `&mut T`)**

```rust
let x = 5;
let r = &x;                     // 不可变引用
let mut y = 10;
let rm = &mut y;                // 可变引用
```

### 2. **裸指针 (`*const T` / `*mut T`)**

```rust
let raw_ptr: *const i32 = &x as *const i32; // 不安全的裸指针
```

### 3. **智能指针**

- **`Box<T>`**：堆分配数据，唯一所有权。

  ```rust
  let b = Box::new(5);         // 堆上存储整数
  ```

- **`Rc<T>`**：引用计数共享所有权。

  ```rust
  let rc = Rc::new(42);        // 多不可变引用共享
  ```

- **`Arc<T>`**：线程安全的引用计数。

  ```rust
  let arc = Arc::new(42);      // 跨线程共享
  ```

---

## 六、**特殊类型**

### 1. **Never 类型 (`!`)**

```rust
fn forever() -> ! {
    loop {} // 永不返回
}
```

- 表示函数永远不会返回（如 panic 或无限循环）。

### 2. **类型别名 (`type`)**

```rust
type Meters = i32;
let distance: Meters = 100;
```

---

## 七、**生命周期标注**

```rust
fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s1.len() > s2.len() { s1 } else { s2 }
}
```

- 用于标注引用的有效作用域。

---

## 八、**动态大小类型 (DST)**

- **`str`**：未确定大小的字符串切片。
- **`[T]`**：未确定大小的数组切片。
- **`dyn Trait`**：动态分发的特征对象。

  ```rust
  let trait_obj: &dyn Debug = &42;
  ```

---

## 九、**类型转换**

### 1. **显式转换 (`as`)**

```rust
let x = 42i32 as u64;       // 整数类型转换
```

### 2. **`From`/`Into` Trait**

```rust
let s = String::from("hello");  // 实现 From<&str>
let num = i32::from_str("42");  // 解析字符串
```

---

## 十、**示例代码**

```rust
// 结构体与枚举结合
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

enum Shape {
    Circle(f64),
    Rect(Rectangle),
}

fn main() {
    let rect = Rectangle { width: 30, height: 50 };
    let shape = Shape::Rect(rect);
    match shape {
        Shape::Circle(r) => println!("Area: {}", 3.14 * r * r),
        Shape::Rect(r) => println!("Area: {}", r.area()),
    }
}
```

---

## 总结

1. **严格类型系统**：Rust 要求显式处理类型转换和生命周期。
2. **所有权与借用**：通过类型系统管理内存安全。
3. **灵活组合**：结构体和枚举允许创建复杂数据结构。
4. **高效与安全**：智能指针和 DST 类型平衡性能与灵活性。

建议通过实际项目练习掌握类型系统的细节！

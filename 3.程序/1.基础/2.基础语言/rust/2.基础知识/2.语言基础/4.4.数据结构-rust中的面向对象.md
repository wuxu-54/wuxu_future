# 数据结构-rust中的面向对象

Rust 虽然不是传统的面向对象编程（OOP）语言，但它通过以下特性和设计模式实现了面向对象的核心思想（封装、多态、代码复用），同时结合其独有的内存安全机制，形成了一套独特的面向对象编程范式：

---

## **一、核心特性**

### 1. **封装（Encapsulation）**

- **结构体（Struct）**：封装数据和行为，字段默认私有，通过 `pub` 关键字控制可见性。
- **方法（`impl` 块）**：通过 `impl` 块为结构体或枚举定义方法，支持 `self` 访问实例数据。

  ```rust
  pub struct Person {
      name: String,    // 私有字段
      age: u32,
  }
  
  impl Person {
      // 公有构造函数
      pub fn new(name: String, age: u32) -> Self {
          Person { name, age }
      }
  
      // 公有方法
      pub fn greet(&self) {
          println!("Hello, I'm {} and {} years old.", self.name, self.age);
      }
  }
  ```

### 2. **多态（Polymorphism）**

- **Trait（特征）**：类似接口，定义共享行为，通过 `impl Trait` 为类型实现具体逻辑。
- **Trait 对象**：通过 `dyn Trait` 实现动态分发，支持运行时多态。

  ```rust
  trait Draw {
      fn draw(&self);
  }
  
  struct Circle { radius: f64 }
  struct Square { side: f64 }
  
  impl Draw for Circle {
      fn draw(&self) { println!("Drawing circle with radius {}", self.radius); }
  }
  
  impl Draw for Square {
      fn draw(&self) { println!("Drawing square with side {}", self.side); }
  }
  
  // 动态分发：使用 trait 对象
  fn render(items: &Vec<Box<dyn Draw>>) {
      for item in items {
          item.draw();
      }
  }
  ```

### 3. **代码复用与组合（Composition over Inheritance）**

- **组合**：通过将类型作为字段嵌入其他结构体实现功能复用。

  ```rust
  struct Engine { power: u32 }
  struct Car {
      engine: Engine,  // 组合代替继承
      brand: String,
  }
  
  impl Car {
      fn start(&self) {
          println!("{} car starts with {} HP.", self.brand, self.engine.power);
      }
  }
  ```

- **Trait 默认实现**：通过 `trait` 的默认方法减少重复代码。

  ```rust
  trait Loggable {
      fn log(&self) {
          println!("Default log message.");
      }
  }
  
  struct User;
  impl Loggable for User {}  // 使用默认实现
  ```

---

## **二、与传统 OOP 的差异**

1. **无类继承**  
   Rust 不支持类继承，但通过 **组合** 和 **Trait 继承**（`trait SubTrait: SuperTrait {}`）实现类似功能。

   ```rust
   trait Animal {
       fn speak(&self);
   }
   
   trait Dog: Animal {  // Trait 继承
       fn bark(&self) { println!("Woof!"); }
   }
   
   struct Labrador;
   impl Animal for Labrador {
       fn speak(&self) { self.bark(); }
   }
   impl Dog for Labrador {}
   ```

2. **所有权与生命周期**  
   内存安全机制（所有权、借用、生命周期）天然融入面向对象设计，避免悬垂指针和数据竞争。

   ```rust
   struct DataProcessor<'a> {
       data: &'a mut Vec<i32>,  // 显式生命周期注解
   }
   
   impl<'a> DataProcessor<'a> {
       fn process(&mut self) {
           self.data.push(42);  // 确保 data 的生命周期有效
       }
   }
   ```

---

## **三、典型应用场景**

### 1. **GUI 框架**

- 使用 **Trait 对象** 统一处理不同组件（按钮、文本框）的渲染逻辑：

  ```rust
  trait Widget {
      fn render(&self);
  }
  
  struct Button { label: String }
  impl Widget for Button {
      fn render(&self) { println!("Button: {}", self.label); }
  }
  
  struct TextBox { content: String }
  impl Widget for TextBox {
      fn render(&self) { println!("TextBox: {}", self.content); }
  }
  
  let ui_elements: Vec<Box<dyn Widget>> = vec![
      Box::new(Button { label: "Submit".into() }),
      Box::new(TextBox { content: "Type here".into() }),
  ];
  
  for element in ui_elements {
      element.render();
  }
  ```

### 2. **插件系统**

- 通过 **动态分发** 加载不同插件：

  ```rust
  trait Plugin {
      fn execute(&self);
  }
  
  #[derive(Default)]
  struct Calculator;
  impl Plugin for Calculator {
      fn execute(&self) { println!("Calculating..."); }
  }
  
  struct Logger;
  impl Plugin for Logger {
      fn execute(&self) { println!("Logging..."); }
  }
  
  let plugins: Vec<Box<dyn Plugin>> = vec![
      Box::new(Calculator::default()),
      Box::new(Logger),
  ];
  
  for plugin in plugins {
      plugin.execute();
  }
  ```

---

## **四、总结**

- **面向对象特性**：通过 **结构体（数据） + 方法（行为） + Trait（多态）** 实现封装、多态和代码复用。
- **优势**：
  - 内存安全：所有权系统避免常见内存错误。
  - 零成本抽象：Trait 和泛型在编译期优化，无运行时开销。
  - 组合优先：避免继承的脆弱性，提升代码灵活性。
- **适用领域**：系统编程、游戏引擎、GUI 框架、并发服务等对安全性和性能要求高的场景。

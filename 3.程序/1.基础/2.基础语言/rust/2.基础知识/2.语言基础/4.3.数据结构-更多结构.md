# 更多结构-Vec/String/HashMap/元组

在Rust中，`Vec`、`String`、`HashMap`和元组是核心数据结构，各有独特的设计目标与应用场景。以下是对它们的详细解析及实际应用示例：

---

## 1. **`Vec<T>`（动态数组）**

**特点**：

- **动态增长**：内存连续分配，支持高效随机访问（O(1)时间复杂度）。
- **类型统一**：所有元素类型必须相同。
- **迭代器支持**：提供丰富的迭代方法（如`map`、`filter`）。

**应用场景**：

- 需要动态调整长度的集合（如日志缓存、实时数据流）。
- 高频随机访问或遍历（利用CPU缓存局部性）。
- 算法实现（如排序、搜索）。

**示例**：

```rust
let mut numbers = vec![1, 2, 3];
numbers.push(4); // 添加元素
let first = numbers[0]; // 直接索引访问
for num in &numbers {
    println!("{}", num); // 遍历
}
```

---

## 2. **`String`（字符串）**

**特点**：

- **可变且拥有所有权**：基于堆分配的UTF-8编码，支持动态修改。
- **高效操作**：提供拼接（`push_str`）、切片（`&str`）和格式化等方法。
- **内存安全**：编译时检查有效UTF-8，避免运行时错误。

**应用场景**：

- 用户输入处理或文本解析（如配置文件读取）。
- 动态构建复杂字符串（如HTML生成）。
- 需要所有权管理的文本数据。

**示例**：

```rust
let mut s = String::from("Hello");
s.push_str(", world!"); // 追加字符串
let slice = &s[0..5]; // 获取子切片
println!("{}", s); // 输出完整字符串
```

---

## 3. **`HashMap<K, V>`（哈希映射）**

**特点**：

- **键值对存储**：基于哈希表实现，平均O(1)时间复杂度的查找、插入。
- **唯一键约束**：键必须唯一，值可重复。
- **灵活更新**：支持`entry`API处理键的存在性（插入、更新、或计算）。

**应用场景**：

- 缓存机制（如存储计算结果避免重复计算）。
- 数据统计（如词频统计）。
- 快速查找关联数据（如数据库索引模拟）。

**示例**：

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert("Alice", 100); // 插入键值对
scores.entry("Bob").or_insert(50); // 存在则忽略，不存在则插入

if let Some(score) = scores.get("Alice") {
    println!("Alice's score: {}", score); // 安全访问
}
```

---

## 4. **元组（Tuple）**

**特点**：

- **固定大小与类型**：长度和元素类型在编译时确定。
- **轻量级**：栈分配，无额外内存开销。
- **多类型支持**：可组合不同类型的数据。

**应用场景**：

- 函数返回多个值（如同时返回结果和状态码）。
- 临时组合少量数据（如坐标点`(x, y)`）。
- 模式匹配解构数据（如解析枚举变体）。

**示例**：

```rust
fn get_user() -> (u32, String) {
    (1, String::from("Alice")) // 返回ID和用户名
}

let (id, name) = get_user(); // 解构元组
println!("User {}: {}", id, name);
```

---

## **总结**

- **`Vec`**：动态数据集合的首选，适合需要灵活扩容的场景。
- **`String`**：处理可修改文本，注意与`&str`切片区分。
- **`HashMap`**：键值关联数据的高效管理，需注意哈希冲突与性能权衡。
- **元组**：轻量级多值组合，适用于简单数据打包。

根据Rust的所有权机制，合理选择数据结构能显著提升代码安全性与性能。例如，优先使用切片（`&[T]`或`&str`）避免不必要的复制，或在需要修改字符串时选择`String`而非`&mut str`。

# `Sync` trait

在 Rust 中，`Sync` trait 用于标记一个类型可以安全地在多个线程中共享引用（即 `&T` 是线程安全的）。以下是关键点：

---

## **核心概念**

1. **线程安全的共享引用**  
   若类型 `T` 实现了 `Sync`，则其不可变引用 `&T` 可以安全地被多个线程**并发访问**（无需额外同步机制）。

2. **自动实现规则**  
   - 大多数原始类型（如 `i32`、`bool`）和不可变类型自动实现 `Sync`。
   - 复合类型（如结构体、元组）若所有字段均为 `Sync`，则自动实现 `Sync`。

3. **非 `Sync` 类型示例**  
   - `Rc<T>`：引用计数非原子操作，无法跨线程安全共享。
   - `RefCell<T>`：内部可变性无锁机制，存在数据竞争风险。

---

## **如何实现线程安全共享**

对于非 `Sync` 类型，需通过同步原语包装：

1. **`Mutex<T>` / `RwLock<T>`**  
   提供互斥锁或读写锁，确保独占访问。  

   ```rust
   use std::sync::{Arc, Mutex};
   let data = Arc::new(Mutex::new(0));
   // 多线程中通过 lock() 获取写锁修改数据
   ```

2. **原子类型（`AtomicUsize` 等）**  
   使用原子操作保证线程安全，无需显式锁。  

   ```rust
   use std::sync::atomic::{AtomicU64, Ordering};
   let counter = AtomicU64::new(0);
   counter.fetch_add(1, Ordering::SeqCst);
   ```

3. **`Arc<T>`**  
   原子引用计数，允许多线程共享所有权（需内部类型为 `Sync`）。  

   ```rust
   use std::sync::Arc;
   let shared_data = Arc::new(5); // i32 是 Sync，可直接共享
   ```

---

## **与 `Send` 的区别**

- **`Send`**：允许类型的所有权跨线程传递（如 `Mutex<T>` 是 `Send`）。
- **`Sync`**：允许类型的不可变引用跨线程共享（如 `&Mutex<T>` 是 `Sync`）。

---

## **最佳实践**

- 优先使用 `Mutex`、`RwLock` 或原子类型处理共享可变状态。
- 避免手动实现 `Sync`，除非明确保证线程安全（易引发未定义行为）。

通过 `Sync` trait，Rust 在编译期阻止非线程安全的共享，强制使用同步机制，从根本上避免数据竞争。

# `Send` trait

以下是关于 Rust 中 `Send` trait 的核心要点：

---

## **Send Trait 的定义与作用**

1. **线程安全的所有权转移**  
   `Send` trait 表示类型可以**安全地跨线程边界转移所有权**。实现了 `Send` 的类型，其值的所有权可以在线程之间传递，而不会引发数据竞争或内存安全问题。

2. **自动实现与例外**  
   - 大多数 Rust 原生类型（如 `i32`、`bool`、`String`、`Vec<T>`）自动实现 `Send`。  
   - **非 `Send` 的典型类型**：  
     - `Rc<T>`：引用计数非原子操作，无法跨线程安全共享。  
     - 包含裸指针的类型：需手动保证线程安全。  

3. **使用场景**  

   ```rust
   use std::thread;
   let data = vec![1, 2, 3]; // Vec<T> 实现了 Send
   thread::spawn(move || {
       println!("Data: {:?}", data); // 所有权转移到新线程
   });
   ```

---

## **关键规则与注意事项**

1. **复合类型的 `Send` 继承**  
   若复合类型的所有成员均实现 `Send`，则该类型自动实现 `Send`。若任一成员未实现，则类型本身也无法实现。

2. **非 `Send` 类型的替代方案**  
   - 使用 `Arc<T>`（原子引用计数）替代 `Rc<T>` 以实现线程间共享。  
   - 通过 `Mutex<T>` 或 `RwLock<T>` 包装数据，提供同步访问。

3. **手动实现的风险**  
   `Send` 和 `Sync` 是 `unsafe` trait，手动实现需严格保证线程安全。例如，包含裸指针的自定义类型需确保无数据竞争。

---

## **与 `Sync` 的区别**

- `Send` 关注**所有权跨线程转移**，`Sync` 关注**不可变引用的多线程共享**。  
- 类型 `T` 实现 `Sync` 当且仅当 `&T` 是 `Send`（即共享引用可安全传递）。

---

## 总结

`Send` trait 是 Rust 保证线程安全的核心机制之一，通过编译器检查阻止非线程安全的类型跨线程传递。在涉及多线程时，优先使用标准库提供的线程安全类型（如 `Arc`、`Mutex`），避免直接操作非 `Send` 类型。

# 文件读写

以下为 Rust 文件读写的详细解析，涵盖核心模块、同步/异步操作、错误处理及优化策略：

---

## 一、文件操作基础流程

### 1. 核心步骤

```rust
打开文件 → 读写操作 → 关闭文件（自动）
```

Rust 通过所有权机制自动管理文件资源，无需手动调用关闭方法。

### 2. 标准库模块

- **`std::fs`**：文件系统操作（创建/删除/移动文件等）
- **`std::io`**：输入输出 trait（Read/Write）
- **`std::path`**：路径处理（Path/PathBuf）

---

## 二、同步文件操作

### 1. 文件读取

```rust
use std::fs::File;
use std::io::Read;

fn read_file(path: &str) -> std::io::Result<String> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?; // 全量读取
    Ok(contents)
}
```

### 2. 文件写入

```rust
use std::fs::File;
use std::io::Write;

fn write_file(path: &str, data: &[u8]) -> std::io::Result<()> {
    let mut file = File::create(path)?; // 覆盖写入
    file.write_all(data)?;
    Ok(())
}
```

### 3. 追加写入

```rust
use std::fs::OpenOptions;
use std::io::Write;

fn append_file(path: &str, data: &str) -> std::io::Result<()> {
    let mut file = OpenOptions::new()
        .append(true)
        .create(true) // 文件不存在时创建
        .open(path)?;
    writeln!(file, "{}", data)?; // 换行追加
    Ok(())
}
```

### 4. 缓冲区优化

```rust
use std::io::{BufReader, BufWriter};

// 缓冲读取（适合大文件）
let reader = BufReader::new(File::open("bigfile.txt")?);

// 缓冲写入（提升吞吐量）
let writer = BufWriter::new(File::create("output.log")?);
```

---

## 三、异步文件操作

### 1. 使用 tokio 实现

```toml
# Cargo.toml
[dependencies]
tokio = { version = "1.0", features = ["full"] }
```

```rust
use tokio::fs::File;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

async fn async_read(path: &str) -> std::io::Result<Vec<u8>> {
    let mut file = File::open(path).await?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer).await?;
    Ok(buffer)
}

async fn async_write(path: &str, data: &[u8]) -> std::io::Result<()> {
    let mut file = File::create(path).await?;
    file.write_all(data).await?;
    Ok(())
}
```

### 2. 同步 vs 异步场景对比

| 特性               | 同步操作                     | 异步操作                          |
|--------------------|----------------------------|----------------------------------|
| 适用场景           | 简单脚本、小文件处理          | 高并发服务、大文件/网络IO密集型任务 |
| 线程阻塞           | 会阻塞当前线程               | 非阻塞，可配合多任务并发          |
| 性能特点           | 实现简单，吞吐量低           | 高吞吐量，资源利用率高            |
| 典型库             | 标准库 std::fs             | tokio::fs / async-std::fs        |

---

## 四、错误处理策略

### 1. 错误传播模式

```rust
fn read_config() -> std::io::Result<String> {
    let path = "config.toml";
    let mut file = File::open(path)
        .map_err(|e| format!("打开文件失败: {} ({})", path, e))?;
    // ...处理逻辑
}
```

### 2. 错误类型匹配

```rust
match File::open("data.bin") {
    Ok(file) => {/* 正常处理 */},
    Err(e) => match e.kind() {
        std::io::ErrorKind::NotFound => println!("文件不存在"),
        std::io::ErrorKind::PermissionDenied => println!("权限不足"),
        _ => println!("未知错误: {}", e),
    }
}
```

---

## 五、优化策略

1. **缓冲区使用**：
   - 读取大文件时使用 `BufReader`（默认 8KB 缓冲）
   - 高频写入时使用 `BufWriter`

2. **分块处理**：

    ```rust
    const CHUNK_SIZE: usize = 1024 * 1024; // 1MB

    let mut buffer = vec![0; CHUNK_SIZE];
    while let Ok(n) = file.read(&mut buffer) {
        if n == 0 { break; }
        process_chunk(&buffer[..n]);
    }
    ```

3. **零拷贝技术**：
   使用 `std::fs::read` 直接读取到 `Vec<u8>`

4. **元数据缓存**：

    ```rust
    let metadata = file.metadata()?;
    if metadata.is_file() {
        println!("文件大小: {} bytes", metadata.len());
    }
    ```

---

## 六、高级操作

### 1. 内存映射文件

```rust
use memmap2::Mmap;

let file = File::open("data.bin")?;
let mmap = unsafe { Mmap::map(&file)? };
process_data(&mmap[..]);
```

### 2. 文件锁机制

```rust
use fs4::FileExt;

let file = File::open("db.lock")?;
file.lock_exclusive()?; // 排他锁
// 执行关键操作
file.unlock()?;
```

---

## 常见问题解决方案

1. **文件不存在错误**：
   - 使用 `OpenOptions::create(true)`
   - 检查路径权限 `metadata.permissions()`

2. **跨平台路径处理**：
   - 优先使用 `PathBuf` 的 `push()` 方法
   - 避免硬编码路径分隔符（`/` vs `\`）

3. **大文件处理**：
   - 使用流式处理（streaming）替代全量加载
   - 启用异步 IO 提高吞吐量

通过结合标准库与第三方库（如 `tokio`、`memmap2`），Rust 可应对从简单文本处理到高性能二进制操作的各种场景，其所有权系统和强类型检查能有效避免多数文件操作中的常见错误。

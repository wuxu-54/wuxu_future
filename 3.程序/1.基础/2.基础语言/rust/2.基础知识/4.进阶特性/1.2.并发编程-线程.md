# 线程

在 Rust 中，线程是并发编程的核心工具之一，其设计通过所有权系统和类型检查机制保障了线程安全。以下是从创建、管理到同步的完整指南，结合 Rust 语言特性与最佳实践：

---

## 一、线程的创建与管理

### 1. **基础线程创建**

使用 `std::thread::spawn` 创建线程，并通过 `JoinHandle` 管理线程生命周期：

```rust
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        println!("子线程执行中...");
        42 // 返回结果
    });

    println!("主线程继续运行...");
    
    let result = handle.join().unwrap(); // 阻塞等待子线程结束
    println!("子线程返回值: {}", result);
}
```

### 2. **所有权与 `move` 闭包**

通过 `move` 关键字转移外部变量所有权到线程：

```rust
let data = vec![1, 2, 3];
let handle = thread::spawn(move || {
    println!("子线程数据: {:?}", data); // data 所有权转移至此
});
// 主线程不能再使用 data
```

---

## 二、线程同步与共享数据

### 1. **互斥锁 (Mutex)**

使用 `Mutex<T>` 和 `Arc<T>` 实现线程间共享可变数据：

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("最终计数: {}", *counter.lock().unwrap());
}
```

### 2. **通道 (Channel)**

使用 `mpsc` 模块实现线程间消息传递（多生产者-单消费者模式）：

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        tx.send("Hello from thread").unwrap();
    });

    let received = rx.recv().unwrap();
    println!("收到消息: {}", received);
}
```

---

## 三、避免典型并发问题

### 1. **原子操作**

对于简单共享状态（如计数器），使用原子类型避免锁开销：

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;
use std::thread;

fn main() {
    let count = Arc::new(AtomicUsize::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let count = Arc::clone(&count);
        let handle = thread::spawn(move || {
            count.fetch_add(1, Ordering::SeqCst);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("最终计数: {}", count.load(Ordering::SeqCst));
}
```

### 2. **解决竞态条件**

以用户提供的 Java `Vector` 问题为例，在 Rust 中实现安全的 `addIfNotExist`：

```rust
use std::sync::{Arc, Mutex};

fn add_if_not_exist<T: PartialEq>(v: Arc<Mutex<Vec<T>>>, item: T) {
    let mut vec = v.lock().unwrap(); // 获取锁，保证原子性
    if !vec.contains(&item) {
        vec.push(item);
    }
}

// 使用示例
let vec = Arc::new(Mutex::new(vec![1, 2, 3]));
add_if_not_exist(vec.clone(), 3); // 不会添加
add_if_not_exist(vec.clone(), 4); // 成功添加
```

---

## 四、线程与异步编程对比

| **特性**         | **线程**                     | **异步 (async/await)**       |
|------------------|-----------------------------|-----------------------------|
| **适用场景**      | CPU 密集型任务               | I/O 密集型任务 (如网络请求)  |
| **开销**          | 较高（系统线程）             | 极低（用户态协程）           |
| **并发能力**      | 受限于 CPU 核心数            | 可处理数千/万级并发          |
| **典型库**        | `std::thread`               | `tokio`, `async-std`        |

---

## 五、最佳实践

1. **最小化锁粒度**：缩短锁的持有时间，避免死锁。
2. **优先选择消息传递**：通过通道 (Channel) 减少共享状态。
3. **使用 `Arc` + `Mutex` 组合**：安全共享可变数据。
4. **避免阻塞操作**：在异步上下文中，避免长时间阻塞线程。

通过 Rust 的所有权机制和类型系统，开发者能以编译期保障的安全性实现高效并发，避免传统语言中常见的数据竞争和内存错误。

# 并发编程中的共享状态管理

在 Rust 并发编程中，**共享状态管理**通过所有权系统和同步原语实现线程安全。以下是核心机制与实现细节：

---

## 一、核心工具与机制

### 1. **互斥锁（`Mutex<T>`）**

- **作用**：确保同一时间只有一个线程访问共享数据。
- **实现示例**：

  ```rust
  use std::sync::{Mutex, Arc};
  use std::thread;

  fn main() {
      let counter = Arc::new(Mutex::new(0)); // 用 Arc 包装 Mutex 以共享所有权
      let mut handles = vec![];

      for _ in 0..10 {
          let counter = Arc::clone(&counter);
          let handle = thread::spawn(move || {
              let mut num = counter.lock().unwrap();
              *num += 1; // 通过解引用操作符修改数据
          });
          handles.push(handle);
      }

      for handle in handles {
          handle.join().unwrap();
      }

      println!("Result: {}", *counter.lock().unwrap()); // 输出: Result: 10
  }
  ```

- **关键点**：
  - `Mutex::lock()` 阻塞线程直到获取锁，返回 `MutexGuard`（自动释放锁）。
  - `Arc<T>`（原子引用计数）允许跨线程共享所有权，结合 `Mutex` 实现线程间安全共享。

### 2. **读写锁（`RwLock<T>`）**

- **适用场景**：读多写少的情况，允许多个读或单个写。

  ```rust
  use std::sync::RwLock;

  let data = RwLock::new(5);
  {
      let r1 = data.read().unwrap(); // 共享读
      let r2 = data.read().unwrap();
  } // 读锁自动释放
  {
      let mut w = data.write().unwrap(); // 独占写
      *w += 1;
  }
  ```

### 3. **原子类型（`Atomic` Types）**

- **无锁操作**：通过 CPU 原子指令实现线程安全的数值操作。
- **常用类型**：`AtomicBool`、`AtomicUsize`、`AtomicIsize` 等。

  ```rust
  use std::sync::atomic::{AtomicUsize, Ordering};
  use std::thread;

  let counter = AtomicUsize::new(0);
  thread::scope(|s| {
      for _ in 0..10 {
          s.spawn(|| {
              counter.fetch_add(1, Ordering::SeqCst); // 原子递增
          });
      }
  });
  println!("Counter: {}", counter.load(Ordering::SeqCst));
  ```

- **内存序（`Ordering`）**：控制原子操作的内存可见性，常用 `SeqCst`（严格顺序一致性）。

---

## 二、所有权与线程安全

### 1. **`Send` 与 `Sync` Trait**

- **`Send`**：允许类型的所有权跨线程传递（如 `Mutex<T>`）。
- **`Sync`**：允许类型的不可变引用跨线程共享（如 `Arc<T>`）。
- **编译器检查**：Rust 在编译时确保共享类型满足 `Send`/`Sync`，防止数据竞争。

### 2. **共享模式**

- **`Arc<Mutex<T>>`**：最常见的共享模式，结合引用计数与互斥锁。
- **`Arc<RwLock<T>>`**：优化读多写少场景。
- **无锁结构**：基于原子类型或第三方库（如 `crossbeam`、`parking_lot`）。

---

## 三、高级模式与优化

### 1. **条件变量（`Condvar`）**

- **线程协调**：与 `Mutex` 配合，实现等待特定条件的线程唤醒。

  ```rust
  use std::sync::{Mutex, Condvar};

  let pair = (Mutex::new(false), Condvar::new());
  let (lock, cvar) = &pair;

  // 线程1：修改条件并通知
  let mut started = lock.lock().unwrap();
  *started = true;
  cvar.notify_one();

  // 线程2：等待条件成立
  let mut started = lock.lock().unwrap();
  while !*started {
      started = cvar.wait(started).unwrap();
  }
  ```

### 2. **无锁数据结构**

- **适用场景**：高频更新的计数器、队列等。
- **示例**：使用 `crossbeam` 的无锁队列：

  ```rust
  use crossbeam::queue::SegQueue;

  let queue = SegQueue::new();
  queue.push(1);
  let item = queue.pop().unwrap(); // 线程安全弹出
  ```

---

## 四、对比消息传递

| **特性**         | **共享状态**                          | **消息传递**               |
|------------------|---------------------------------------|----------------------------|
| **数据竞争防护** | 需显式使用锁或原子类型                | 天然通过所有权转移避免     |
| **性能**         | 高频操作更快（直接内存访问）          | 通道开销可能更高           |
| **复杂度**       | 需处理死锁、竞态条件                  | 更简单（无锁管理）         |
| **适用场景**     | 复杂状态管理、高频数据更新            | 任务解耦、流水线处理       |

---

## 五、最佳实践

1. **最小化共享**：优先使用消息传递，仅在必要时共享状态。
2. **细粒度锁**：缩小锁的作用范围，减少竞争。
3. **避免死锁**：
   - 按固定顺序获取锁。
   - 使用 `try_lock` 或超时机制。
4. **原子类型优先**：对简单类型（如计数器）优先使用原子操作。
5. **性能分析**：使用 `perf` 或 `flamegraph` 定位锁竞争热点。

---

## 六、常见陷阱

- **误用未实现 `Sync` 的类型**：如 `Rc<T>` 非线程安全，需用 `Arc<T>`。
- **锁的生命周期管理**：避免因提前释放导致数据竞争。
- **递归锁**：Rust 标准库不提供，需手动实现或使用第三方库。

通过合理选择同步原语和遵循所有权规则，Rust 的共享状态管理能在保证安全性的同时实现高效并发。

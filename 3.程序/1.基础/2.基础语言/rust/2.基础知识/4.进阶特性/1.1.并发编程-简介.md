# 并发编程

在Rust中，并发编程是其核心优势之一，通过结合所有权、生命周期和类型系统，Rust能够在编译期避免数据竞争等常见并发问题。以下是从学习到实践的系统化指南：

---

## **一、Rust并发编程核心概念**

说白了是指并发编程包括以下内容：

1. **线程与异步模型**
   - **线程（`std::thread`）**：基于操作系统线程，适合CPU密集型任务。

     ```rust
     use std::thread;
     thread::spawn(|| {
         println!("子线程运行");
     }).join().unwrap();
     ```

   - **异步（`async/await`）**：基于协程，适合IO密集型任务，依赖运行时（如`tokio`）。

     ```rust
     #[tokio::main]
     async fn main() {
         tokio::spawn(async { println!("异步任务") }).await.unwrap();
     }
     ```

2. **数据共享与同步**
   - **所有权机制**：确保数据在多个线程间安全移动或共享。
   - **`Arc<Mutex<T>>`**：原子引用计数与互斥锁，用于跨线程共享可变数据。

     ```rust
     use std::sync::{Arc, Mutex};
     let data = Arc::new(Mutex::new(0));
     let data_clone = data.clone();
     thread::spawn(move || {
         *data_clone.lock().unwrap() += 1;
     });
     ```

   - **通道（`mpsc`）**：多生产者单消费者模型，通过消息传递避免共享状态。

     ```rust
     use std::sync::mpsc;
     let (tx, rx) = mpsc::channel();
     thread::spawn(move || tx.send(42).unwrap());
     println!("接收: {}", rx.recv().unwrap());
     ```

3. **原子操作**
   - **`Atomic`类型**：如`AtomicUsize`，无需锁实现线程安全操作。

     ```rust
     use std::sync::atomic::{AtomicUsize, Ordering};
     let counter = AtomicUsize::new(0);
     counter.fetch_add(1, Ordering::SeqCst);
     ```

---

## **二、实践场景与选择策略**

| **场景**              | **推荐工具**            | **示例**                          |
|-----------------------|-------------------------|-----------------------------------|
| **计算密集型**        | 多线程（`std::thread`） | 并行计算、图像处理               |
| **IO密集型**          | 异步（`tokio`/`async-std`） | 网络请求、文件读写               |
| **任务间通信**        | 通道（`mpsc`）          | 生产者-消费者模型                |
| **共享状态**          | `Arc<Mutex<T>>`         | 全局计数器、缓存共享             |

---

## **三、最佳实践与避坑指南**

1. **避免阻塞异步任务**  
   在异步代码中，避免使用`std::thread::sleep`，改用`tokio::time::sleep`以保持非阻塞。

2. **合理选择锁粒度**  
   使用细粒度锁（如拆分多个`Mutex`）减少竞争，避免死锁。

3. **优先消息传递**  
   通过通道传递数据而非共享状态，减少复杂性和潜在错误。

4. **处理线程Panic**  
   使用`catch_unwind`捕获线程panic，防止主程序崩溃。

   ```rust
   thread::spawn(|| {
       let result = std::panic::catch_unwind(|| { /* 可能panic的代码 */ });
   });
   ```

5. **异步运行时选择**  
   - **`tokio`**：功能丰富，适合网络应用。
   - **`async-std`**：更接近标准库API，学习曲线平缓。

---

## **四、实战案例：并发Web请求**

```rust
use tokio::{task, time};
use reqwest;

#[tokio::main]
async fn main() {
    let urls = vec!["https://api.example.com/data1", "https://api.example.com/data2"];
    
    let tasks: Vec<_> = urls.into_iter().map(|url| {
        task::spawn(async move {
            let resp = reqwest::get(url).await.unwrap().text().await.unwrap();
            println!("响应: {}", &resp[0..20]);
        })
    }).collect();

    for task in tasks {
        task.await.unwrap();
    }
}
```

---

## **五、学习资源推荐**

- **官方文档**  
  [The Rust Programming Language - 并发章节](https://doc.rust-lang.org/book/ch16-00-concurrency.html)
- **书籍**  
  《Rust编程语言》（“The Book”）、《Rust并发编程实战》
- **社区资源**  
  Rust论坛、GitHub开源项目（如`tokio`源码）

---

通过理解Rust的并发模型并实践上述案例，你可以高效编写安全且高性能的并发程序。建议从简单任务入手，逐步尝试复杂场景，如构建高并发Web服务器或实时数据处理系统。

---

## 线程安全机制

Rust的线程安全机制主要通过以下核心机制实现：

1. **所有权系统与生命周期**

    - 所有权规则确保每个变量有明确的作用域，自动管理内存释放，避免内存泄漏和悬垂指针
    - 生命周期注解（如`'a`）在编译期跟踪引用有效性，防止跨线程使用悬垂引用

2. **同步原语**

    - `Mutex`：提供互斥锁机制，保证同一时间只有一个线程访问共享数据
    - `RwLock`：允许多线程并发读取或单线程独占写入，平衡性能与安全性

3. **原子操作**

    - 提供`AtomicUsize`等原子类型，支持无锁的线程安全操作（如`fetch_add`）
    - 通过内存排序参数（如`Ordering::SeqCst`）保证操作顺序一致性

4. **智能指针**

    - `Arc`（原子引用计数）：实现跨线程共享数据所有权，自动管理内存释放
    - 需配合`Mutex`使用实现可变共享：`Arc<Mutex<T>>`组合模式

5. **线程闭包安全**

    - 使用`move`关键字强制转移变量所有权到线程闭包
    - 编译器严格检查闭包捕获变量的生命周期，防止跨线程引用失效

6. **线程管理**

    - `JoinHandle::join`确保主线程等待子线程完成，防止资源泄漏
    - 自动处理线程panic传播，可通过`Result`类型捕获异常

这些机制在编译期通过借用检查器强制实施，可消除数据竞争、内存错误等常见并发问题，同时保持零成本抽象特性。

# 高级Trait特性

下面为你介绍一些 Rust 高级 Trait 特性：

## 1. 关联类型（Associated Types）

关联类型是在 Trait 内部定义的类型占位符，它能让你在实现 Trait 时指定具体类型。

```rust
trait Container {
    type Item;

    fn get(&self) -> Self::Item;
}

struct IntContainer(i32);

impl Container for IntContainer {
    type Item = i32;

    fn get(&self) -> Self::Item {
        self.0
    }
}

fn main() {
    let container = IntContainer(42);
    println!("{}", container.get());
}
```

在上述代码里，`Container` Trait 定义了关联类型 `Item`，`IntContainer` 实现 `Container` Trait 时，把 `Item` 指定为 `i32`。

## 2. 默认泛型类型参数和运算符重载

你可以给泛型类型参数设置默认值，还能借助 Trait 实现运算符重载。

```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point<T = i32> {
    x: T,
    y: T,
}

impl<T: Add<Output = T>> Add for Point<T> {
    type Output = Point<T>;

    fn add(self, other: Point<T>) -> Point<T> {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = p1 + p2;
    println!("{:?}", p3);
}
```

在这段代码中，`Point` 结构体的泛型参数 `T` 默认是 `i32`。通过实现 `Add` Trait，`Point` 结构体支持了 `+` 运算符。

## 3. 高级 Trait 约束（Trait Bounds）

你可以使用更复杂的 Trait 约束，像 `where` 子句。

```rust
fn longest<'a, T>(x: &'a T, y: &'a T) -> &'a T
where
    T: std::fmt::Display + PartialOrd,
{
    if x >= y {
        x
    } else {
        y
    }
}

fn main() {
    let s1 = "hello";
    let s2 = "world";
    let result = longest(s1, s2);
    println!("The longest string is {}", result);
}
```

这里的 `longest` 函数运用 `where` 子句，规定泛型参数 `T` 必须实现 `std::fmt::Display` 和 `PartialOrd` Trait。

## 4. 超 Trait（Super Traits）

超 Trait 能够让一个 Trait 依赖于另一个 Trait。

```rust
trait OutlinePrint: std::fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

struct Point {
    x: i32,
    y: i32,
}

impl std::fmt::Display for Point {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

impl OutlinePrint for Point {}

fn main() {
    let p = Point { x: 1, y: 2 };
    p.outline_print();
}
```

`OutlinePrint` Trait 依赖于 `std::fmt::Display` Trait，这意味着实现 `OutlinePrint` 的类型也得实现 `std::fmt::Display`。

## 5. 完全限定语法

当多个 Trait 定义了相同名称的方法时，使用完全限定语法可以明确指定要调用的方法。

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}

fn main() {
    let person = Human;
    person.fly();
    Pilot::fly(&person);
    Wizard::fly(&person);
}
```

在这个例子中，`Human` 结构体实现了 `Pilot` 和 `Wizard` 两个 Trait，并且自身也有一个 `fly` 方法。使用完全限定语法 `Trait::method(&instance)` 可以明确调用哪个 Trait 的方法。

### 6. 动态分发（Trait 对象）

Trait 对象允许你在运行时根据实际类型调用相应的方法，实现多态性。

```rust
trait Draw {
    fn draw(&self);
}

struct Button;
impl Draw for Button {
    fn draw(&self) {
        println!("Drawing a button.");
    }
}

struct SelectBox;
impl Draw for SelectBox {
    fn draw(&self) {
        println!("Drawing a select box.");
    }
}

fn draw_components(items: &[&dyn Draw]) {
    for item in items {
        item.draw();
    }
}

fn main() {
    let button = Button;
    let select_box = SelectBox;
    let components = [&button as &dyn Draw, &select_box as &dyn Draw];
    draw_components(&components);
}
```

这里，`Draw` 是一个 Trait，`Button` 和 `SelectBox` 都实现了 `Draw` Trait。`draw_components` 函数接受一个 `&[&dyn Draw]` 类型的切片，通过 Trait 对象实现了多态调用。

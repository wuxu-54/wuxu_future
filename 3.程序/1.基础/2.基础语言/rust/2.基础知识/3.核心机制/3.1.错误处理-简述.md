# Rust 的错误处理机制

>Rust 有一套独特的处理异常情况的机制，它并不像其它语言中的 try 机制那样简单。

首先，程序中一般会出现两种错误：可恢复错误和不可恢复错误。

可恢复错误的典型案例是文件访问错误，如果访问一个文件失败，有可能是因为它正在被占用，是正常的，我们可以通过等待来解决。

但还有一种错误是由编程中无法解决的逻辑错误导致的，例如访问数组末尾以外的位置。

大多数编程语言不区分这两种错误，并用 Exception （异常）类来表示错误。在 Rust 中没有 Exception。

对于可恢复错误用 `Result<T, E>` 类来处理，对于不可恢复错误使用 `panic!` 宏来处理。

简单来说：

1. Result：
    - 用于可恢复的错误
    - 包含Ok(T)和Err(E)两种状态
    - 强制开发者处理错误情况
    - 适用场景：IO操作、解析等可能失败的操作

2. Option：
    - 处理可能为空的值
    - 包含Some(T)和None两种状态
    - 避免空指针问题
    - 适用场景：可选值、查找操作

3. panic!：
    - 用于不可恢复的错误
    - 导致程序终止
    - 适用于程序无法继续执行的情况
    - 使用场景：断言、不可能发生的情况

---

Rust 的错误处理机制和最佳实践可分为以下几个核心部分，结合了其独特的设计哲学和实践经验：

## 一、错误分类与核心机制

1. **不可恢复错误（Unrecoverable Errors）**
   - **机制**：使用 `panic!` 宏终止程序
   - 适用场景：
     - 数组越界访问
     - 线程创建失败（如内存耗尽）
     - 代码逻辑存在不可修复的缺陷
   - **行为**：
     - 默认展开调用栈（unwind），清理资源
     - 可通过 `Cargo.toml` 配置为立即中止（abort）以减小二进制体积：

       ```toml
       [profile.release]
       panic = 'abort'
       ```

2. **可恢复错误（Recoverable Errors）**
   - **机制**：使用 `Result<T, E>` 枚举

   ```rust
   enum Result<T, E> {
       Ok(T),
       Err(E),
   }
   ```

   - 适用场景：
     - 文件未找到
     - 网络请求超时
     - 用户输入验证失败

---

## 二、最佳实践指南

### 1. `panic!` 的合理使用

- **避免滥用**：仅在程序无法继续执行时使用（如启动时配置文件缺失）
- **调试辅助**：

  ```bash
  RUST_BACKTRACE=1 cargo run # 显示完整调用栈
  ```

- **示例**：

  ```rust
  // 被动触发（如数组越界）
  let v = vec![1, 2, 3];
  v[99]; // 触发 panic!

  // 主动调用
  panic!("Critical database connection lost");
  ```

### 2. `Result` 处理策略

- **模式匹配（基础方案）**：

  ```rust
  use std::fs::File;

  let f = File::open("hello.txt");
  match f {
      Ok(file) => process_file(file),
      Err(error) => match error.kind() {
          std::io::ErrorKind::NotFound => create_file(),
          other_error => log_error(other_error),
      }
  }
  ```

- **链式方法（推荐方案）**：

  ```rust
  File::open("hello.txt")
      .and_then(|f| parse_file(f))
      .unwrap_or_else(|e| {
          eprintln!("Error processing file: {}", e);
          default_content()
      });
  ```

- **错误传播（`?` 运算符）**：

  ```rust
  fn read_config() -> Result<String, io::Error> {
      let mut f = File::open("config.toml")?;
      let mut s = String::new();
      f.read_to_string(&mut s)?;
      Ok(s)
  }
  ```

### 3. 错误包装与自定义

- **自定义错误类型**：

  ```rust
  use thiserror::Error;

  #[derive(Error, Debug)]
  enum AppError {
      #[error("I/O error: {0}")]
      Io(#[from] std::io::Error),
      #[error("Parse error: {0}")]
      Parse(String),
  }
  ```

- **错误转换**：

  ```rust
  fn parse_data(input: &str) -> Result<Data, AppError> {
      serde_json::from_str(input)
          .map_err(|e| AppError::Parse(e.to_string()))
  }
  ```

### 4. 实用技巧

- **Option 处理**：

  ```rust
  // 替代 if let Some(x) = ...
  value.ok_or(AppError::MissingValue)?;

  // 默认值处理
  let result = optional_value.unwrap_or(default_value);
  ```

- **组合方法**：

  ```rust
  // 合并多个 Result
  let (v1, v2) = (result1.and(result2))?;

  // 错误映射
  let parsed = input.parse::<i32>()
      .map_err(|_| AppError::InvalidNumber)?;
  ```

- **防御性开发**：

  ```rust
  // 使用 assert! 捕获开发阶段错误
  assert!(value >= 0, "Value cannot be negative");

  // 使用 debug_assert! 仅调试模式检查
  debug_assert!(complex_invariant());
  ```

---

## 三、性能优化

1. **错误类型设计**：
   - 优先实现 `Copy` trait 避免堆分配
   - 使用 `Box<dyn Error>` 处理异构错误

2. **避免过度包装**：

   ```rust
   // 直接返回底层错误而非过度包装
   fn read_data() -> Result<Data, std::io::Error> {
       // ...
   }
   ```

---

## 四、错误处理模式对比

| 场景                 | 推荐方案                      | 替代方案                |
|----------------------|-----------------------------|-------------------------|
| 必须处理所有错误分支 | `match` 全模式匹配          | `if let` 简化           |
| 快速原型开发         | `.unwrap()`/.`expect()`     | `?` 运算符传播          |
| 组合多个操作         | `.and_then()` 链式调用      | `match` 嵌套            |
| 错误上下文记录       | `error-chain`/`anyhow` 库   | 自定义错误类型          |

通过合理运用这些机制和实践，开发者可以构建既安全又易于维护的 Rust 应用程序，在保证内存安全的同时实现优雅的错误处理流程。

# 泛型

>跟其他语言的**泛型**在设计思想上没区别。

## 作用和优势

1. 代码复用：
    - 允许编写可以处理不同类型的通用代码
    - 减少重复代码，提高维护性
    - 在编译时进行类型检查

2. 类型安全：
    - 编译器确保类型正确使用
    - 避免运行时类型错误
    - 零成本抽象，无运行时开销

3. 灵活性：
    - 可以用于结构体、函数、方法、特征等
    - 支持多个类型参数
    - 可以通过特征约束限制类型

示例：

```rust
// 不使用泛型
fn largest_i32<T>(list: &[i32]) -> i32 { ... }
fn largest_char<T>(list: &[char]) -> char { ... }

// 使用泛型 `largest<T>` 不能省略 `<T>`，这个声明是必须的。
fn largest<T>(list: &[T]) -> T { ... } 
```

## 注意

rust中的泛型必须在结构体或函数声明处写明`<替代符>`，不可以不写，除非这个泛型是全局的。

## Rust 泛型详解：定义、使用与应用场景

### **一、泛型的定义**

泛型（Generics）是 Rust 中用于编写**类型无关的通用代码**的机制，允许在编译时通过占位符类型（如 `T`）抽象具体类型。泛型的核心目的是**提高代码复用性**，避免为不同类型重复编写相同逻辑。

### **二、泛型的使用方法**

#### **1. 泛型函数**

通过 `<T>` 声明泛型参数，适用于多种类型：

```rust
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let nums = vec![34, 50, 25];
    let chars = vec!['y', 'm', 'a'];
    println!("最大数: {}", largest(&nums)); // 50
    println!("最大字符: {}", largest(&chars)); // y
}
```

- **特性约束**：通过 `T: PartialOrd` 确保类型可比较，避免运行时错误。

#### **2. 泛型结构体**

结构体字段使用泛型类型：

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let int_point = Point { x: 5, y: 10 };
    let float_point = Point { x: 1.0, y: 4.0 };
}
```

- **多泛型参数**：支持不同类型字段：

  ```rust
  struct Pair<T, U> {
      first: T,
      second: U,
  }
  ```

#### **3. 泛型枚举**

标准库中的 `Option<T>` 和 `Result<T, E>` 是典型示例：

```rust
enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

#### **4. 泛型方法**

为结构体/枚举实现泛型方法：

```rust
impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

// 特定类型的方法实现
impl Point<f64> {
    fn distance_from_origin(&self) -> f64 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

### **三、特性约束（Trait Bounds）**

通过 `Trait` 约束泛型的行为，确保类型具备特定能力：

```rust
use std::fmt::Display;

fn print_item<T: Display>(item: T) {
    println!("Item: {}", item);
}

// 使用 where 简化复杂约束
fn combine<T, U>(a: T, b: U) -> String
where
    T: Display + Clone,
    U: Display,
{
    format!("{} + {}", a.clone(), b)
}
```

### **四、应用场景**

1. **容器类型**  
   如 `Vec<T>`、`HashMap<K, V>`，可存储任意类型数据。

2. **通用算法**  
   如排序、搜索，适用于任何实现 `PartialOrd` 的类型。

3. **代码抽象**  
   避免重复逻辑，例如处理不同数值类型的数学运算。

4. **Trait 多态**  
   结合 `dyn Trait` 实现运行时多态，增强灵活性。

### **五、性能与单态化**

Rust 在编译时执行**单态化（Monomorphization）**，将泛型代码转换为具体类型的副本。例如：

```rust
// 泛型函数
fn generic<T>(t: T) { ... }

// 编译后生成：
fn generic_i32(t: i32) { ... }
fn generic_f64(t: f64) { ... }
```

- **零运行时开销**：性能与手写具体类型代码一致。

### **六、最佳实践**

- **合理使用约束**：避免过度约束，保持代码灵活性。
- **命名泛型参数**：使用 `T`、`U` 等惯例，或更具描述性的名称（如 `Key`、`Value`）。
- **结合 Trait 对象**：在需要动态分发时使用 `Box<dyn Trait>`。

### **示例：自定义泛型容器**

```rust
struct Container<T> {
    items: Vec<T>,
}

impl<T> Container<T> {
    fn new() -> Self {
        Container { items: Vec::new() }
    }

    fn push(&mut self, item: T) {
        self.items.push(item);
    }
}

fn main() {
    let mut c = Container::new();
    c.push(42);
    c.push("hello");
}
```

### **总结**

Rust 的泛型通过编译时类型安全检查和单态化，实现了高性能与高复用性。结合 Trait 约束，可在保证灵活性的同时，精确控制类型行为。适用于容器、算法、抽象数据类型等场景，是 Rust 系统级编程的核心工具之一。

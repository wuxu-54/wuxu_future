# `?` 运算符

在 Rust 中，`?` 运算符是错误处理的核心语法糖，用于**简化错误传播**。它专门用于返回 `Result<T, E>` 或 `Option<T>` 的函数中，能自动处理错误/空值的传播逻辑，大幅减少样板代码。以下是其详细行为和工作原理：

---

## 一、基本行为

### 1. 当表达式成功时（`Ok`/`Some`）

- **解包取值**：自动提取 `Ok(value)` 或 `Some(value)` 中的值
- **继续执行**：将值赋给左侧变量，继续执行后续代码

### 2. 当表达式失败时（`Err`/`None`）

- **提前返回**：立即终止当前函数，将 `Err(e)` 或 `None` 作为返回值向上传播

---

## 二、核心规则

### 1. 使用条件

- 只能在返回 `Result` 或 `Option` 的函数中使用
- 若函数返回 `Result<T, E1>`，则 `?` 处理的表达式必须是 `Result<_, E2>`，且 `E2` 能转换为 `E1`

### 2. 错误类型转换

通过实现 `From` trait，`?` 会自动转换错误类型：

```rust
use std::fs::File;

#[derive(Debug)]
enum MyError {
    Io(std::io::Error),
    Other,
}

impl From<std::io::Error> for MyError {
    fn from(e: std::io::Error) -> Self {
        MyError::Io(e)
    }
}

fn read_file() -> Result<String, MyError> {
    let mut s = String::new();
    File::open("file.txt")?.read_to_string(&mut s)?; // io::Error → MyError
    Ok(s)
}
```

---

## 三、具体用法示例

### 1. 基础用法

```rust
// 读取文件内容 → 解析为整数 → 乘以 2
fn process_file(path: &str) -> Result<i32, std::io::Error> {
    let content = std::fs::read_to_string(path)?; // 错误时直接返回
    let num: i32 = content.trim().parse().map_err(|e| {
        std::io::Error::new(std::io::ErrorKind::InvalidData, e)
    })?; // 需要手动转换 ParseIntError → io::Error
    Ok(num * 2)
}
```

### 2. 与 `Option` 配合

```rust
// 查找第一个非空行
fn find_non_empty(lines: &[&str]) -> Option<&str> {
    for line in lines {
        if !line.trim().is_empty() {
            return Some(line);
        }
    }
    None
}

fn process_data(data: &[&str]) -> Option<String> {
    let line = find_non_empty(data)?; // None 时直接返回
    Some(line.to_uppercase())
}
```

---

## 四、工作机制（脱糖后等价代码）

### `Result` 的 `?` 等价于

```rust
match result {
    Ok(v) => v,
    Err(e) => return Err(e.into()), // 自动调用 From trait 转换
}
```

### `Option` 的 `?` 等价于

```rust
match option {
    Some(v) => v,
    None => return None,
}
```

---

## 五、高级用法

### 1. 与 `try` 块配合（Nightly 特性）

```rust
#![feature(try_blocks)]

fn complex_operation() -> Result<i32, String> {
    let result: Result<i32, _> = try {
        let a = "42".parse::<i32>()?;
        let b = "100".parse::<i32>()?;
        a + b
    };
    result.map_err(|e: std::num::ParseIntError| e.to_string())
}
```

### 2. 自定义错误上下文

```rust
use anyhow::{Context, Result};

fn load_config() -> Result<String> {
    let path = "config.toml";
    let content = std::fs::read_to_string(path)
        .with_context(|| format!("Failed to read {}", path))?;
    Ok(content)
}
// 错误时会显示：Failed to read config.toml: No such file or directory (os error 2)
```

---

## 六、关键注意事项

| 场景                     | 正确处理方式                                                                 |
|--------------------------|-----------------------------------------------------------------------------|
| 非 `Result/Option` 返回值 | 修改函数返回类型或使用 `.ok_or()?` 转换                                     |
| 需要添加错误上下文       | 结合 `map_err` 或 `anyhow::Context`                                        |
| 处理多种错误类型         | 定义统一的错误枚举并实现 `From` trait                                      |
| 需要记录错误日志         | 在传播前使用 `log::error!` 记录，或用 `error-stack` 等库携带上下文          |

---

## 七、与 `unwrap()` 的对比

| **特性**       | **`?` 运算符**                          | **`unwrap()`**                  |
|----------------|----------------------------------------|----------------------------------|
| 错误处理       | 显式传播错误，类型安全                 | 直接 panic，导致线程终止         |
| 代码位置       | 只能在返回 `Result/Option` 的函数中使用 | 任意位置                        |
| 错误信息       | 保留原始错误信息                       | 携带简单信息（可通过 `expect`）  |
| 推荐使用场景   | 生产代码中的错误传播                   | 快速原型开发或绝对确定成功的场景 |

---

## 八、最佳实践总结

1. **统一错误类型**：通过自定义错误类型整合不同错误源
2. **及时转换错误**：利用 `From` trait 保持代码简洁
3. **添加丰富上下文**：使用 `anyhow` 或自定义错误携带调试信息
4. **避免嵌套地狱**：用 `?` 替代多层 `match` 使代码扁平化
5. **区分场景**：
   - 库代码：定义明确的错误类型
   - 应用代码：使用 `anyhow` 简化错误处理

通过合理使用 `?` 运算符，可以写出既安全又简洁的错误处理代码，同时保持完整的错误传播链。

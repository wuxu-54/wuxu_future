# 属性宏

Rust 属性宏是一种强大的元编程工具，它允许开发者在代码项（如函数、结构体、模块等）上附加自定义属性，并在编译时对这些代码项进行转换或生成额外的代码。下面从多个方面详细介绍 Rust 属性宏。

## 基本概念

属性宏本质上是一种过程宏（Procedural Macros）。它以 `#[attribute_name(...)]` 的形式附着在代码项上，编译器在编译时会调用属性宏的实现代码，对被标记的代码项进行处理，以此实现代码的自动生成、修改或验证等功能。

## 内置属性宏

Rust 标准库提供了一些内置属性宏，常见的如下：

### `#[inline]`

建议编译器对函数进行内联展开，以此减少函数调用开销。不过这只是一个建议，编译器可能会根据实际情况决定是否进行内联。

```rust
#[inline]
fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

### `#[deprecated]`

标记某个代码项（如函数、结构体等）为弃用状态。当其他代码使用该代码项时，编译器会发出警告，提示开发者该代码项已不再推荐使用。

```rust
#[deprecated(note = "This function is deprecated, use new_function instead.")]
fn old_function() {
    // 旧函数的实现
}
```

### `#[test]`

用于标记一个函数作为测试函数。在运行 `cargo test` 时，Rust 测试框架会自动执行这些被标记的函数。

```rust
#[test]
fn test_add() {
    assert_eq!(add(2, 3), 5);
}
```

## 自定义属性宏

自定义属性宏需要使用 `proc_macro` 包，并遵循一定的实现步骤。

### 实现步骤

1. **创建 `proc-macro` 包**：在项目中创建一个新的 `proc-macro` 包，用于实现属性宏。
2. **引入依赖**：在 `Cargo.toml` 中引入 `syn` 和 `quote` 依赖，`syn` 用于解析输入的代码，`quote` 用于生成新的代码。
3. **实现属性宏**：定义一个函数，使用 `#[proc_macro_attribute]` 标记，该函数接受两个 `TokenStream` 参数，分别是属性宏的参数和被标记的代码项。
4. **解析和生成代码**：使用 `syn` 解析输入的 `TokenStream`，使用 `quote` 生成新的 `TokenStream`。
5. **返回结果**：将生成的 `TokenStream` 返回给编译器。

### 示例：为函数添加日志记录功能

以下是一个简单的自定义属性宏示例，用于为函数添加日志记录功能：

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

// 自定义属性宏实现
#[proc_macro_attribute]
pub fn log(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    let name = &input.sig.ident;
    let block = &input.block;

    let expanded = quote! {
        fn #name() {
            println!("Entering function: {}", stringify!(#name));
            #block
            println!("Exiting function: {}", stringify!(#name));
        }
    };

    expanded.into()
}

// 使用自定义属性宏
#[log]
fn my_function() {
    println!("Inside my_function");
}

fn main() {
    my_function();
}    
```

## 代码解释

- **引入必要的包**：
  - `proc_macro`：用于处理编译器传入的 `TokenStream`。
  - `quote`：用于生成新的 `TokenStream`。
  - `syn`：用于解析输入的 `TokenStream` 为语法树。
- **定义属性宏**：使用 `#[proc_macro_attribute]` 标记一个函数作为属性宏的实现。该函数接受两个 `TokenStream` 参数，`_attr` 是属性宏的参数部分，`item` 是被标记的代码项。
- **解析输入**：使用 `syn::parse_macro_input` 将输入的 `TokenStream` 解析为 `ItemFn` 类型，即函数项。
- **生成新代码**：使用 `quote` 宏生成新的代码，在原函数的前后添加日志记录代码。
- **返回新的 `TokenStream`**：将生成的代码转换为 `TokenStream` 并返回给编译器。

## 带参数的属性宏

属性宏也可以接受参数，以下是一个带参数的属性宏示例，用于为函数添加指定前缀的日志记录：

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, AttributeArgs, ItemFn, LitStr};

// 带参数的自定义属性宏实现
#[proc_macro_attribute]
pub fn log_with_prefix(attr: TokenStream, item: TokenStream) -> TokenStream {
    let args = parse_macro_input!(attr as AttributeArgs);
    let input = parse_macro_input!(item as ItemFn);
    let name = &input.sig.ident;
    let block = &input.block;

    let prefix = if let Some(arg) = args.first() {
        if let syn::NestedMeta::Lit(syn::Lit::Str(lit_str)) = arg {
            lit_str.value()
        } else {
            panic!("Expected a string literal as the prefix");
        }
    } else {
        panic!("Missing prefix argument");
    };

    let expanded = quote! {
        fn #name() {
            println!("{} Entering function: {}", #prefix, stringify!(#name));
            #block
            println!("{} Exiting function: {}", #prefix, stringify!(#name));
        }
    };

    expanded.into()
}

// 使用带参数的自定义属性宏
#[log_with_prefix("DEBUG")]
fn another_function() {
    println!("Inside another_function");
}

fn main() {
    another_function();
}    
```

## 注意事项

- **编译环境**：自定义属性宏需要在单独的 `proc-macro` 包中实现，然后在主项目中引入使用。
- **错误处理**：在属性宏实现中，需要注意错误处理，避免因为解析或生成代码失败导致编译错误。
- **性能影响**：属性宏在编译时会进行代码生成和转换，可能会增加编译时间。因此，要谨慎使用，避免过度使用导致编译性能下降。

# 宏编程

## Rust 宏编程详解：元编程、代码生成与编译时执行

---

### 一、宏的核心概念

Rust 宏是一种 **元编程（Metaprogramming）** 工具，允许在编译时生成或转换代码。通过宏，开发者可以：

1. **减少重复代码**：通过模式匹配生成通用代码。
2. **扩展语言功能**：实现编译器原生不支持的特性（如自定义语法）。
3. **编译时计算**：在编译阶段执行逻辑（如验证 SQL 语句合法性）。

---

### 二、宏的分类与特性

在 Rust 中，宏（Macro）是一种元编程工具，允许你在编译时生成代码。Rust 的宏系统分为两种主要类型：**声明宏**（Declarative Macros）和**过程宏**（Procedural Macros）。以下是它们的核心规则和用法：

#### 声明宏（Declarative Macros）

使用 `macro_rules!` 定义，通过模式匹配生成代码。

##### 1. 基本语法

```rust
macro_rules! macro_name {
    (pattern) => { /* 生成的代码 */ };
    // 更多匹配规则...
}
```

##### 2. 模式匹配规则

- **匹配输入**：宏通过模式匹配输入代码的结构。
- **片段分类符（Fragment Specifiers）**：指定匹配的代码类型，如：
  - `expr`：表达式（如 `1 + 1`）
  - `ident`：标识符（如变量名 `x`）
  - `ty`：类型（如 `i32`）
  - `block`：代码块（如 `{ ... }`）
  - `pat`：模式（如 `Some(x)`）
  - 其他：`item`, `stmt`, `path`, `meta`, `literal` 等。

##### 3. 重复模式

使用 `$(...)sep*` 或 `$(...)sep+` 匹配重复结构：

- `*` 表示 0 次或多次。
- `+` 表示 1 次或多次。
- `sep` 是分隔符（如 `,`、`;` 等）。

示例：

```rust
macro_rules! vec {
    ($($x:expr),*) => { // 匹配逗号分隔的表达式
        {
            let mut temp_vec = Vec::new();
            $(temp_vec.push($x);)* // 为每个表达式生成 push 代码
            temp_vec
        }
    };
}
```

示例：声明宏

```rust
macro_rules! assert_eq_len {
    ($a:expr, $b:expr) => {
        if $a.len() != $b.len() {
            panic!("长度不匹配");
        }
    };
}

fn main() {
    let a = vec![1, 2];
    let b = vec![3, 4];
    assert_eq_len!(a, b); // 通过则无输出，否则 panic
}
```

##### 4. 卫生性（Hygiene）

Rust 宏是**卫生的**（Hygienic），自动避免变量名冲突，无需手动处理作用域。

---

#### 过程宏（Procedural Macros）

更强大的宏，基于函数生成代码，需在单独的 crate 中定义。

##### 1. 三种类型

1. **自定义派生宏（Derive Macros）**：
   - 为 `struct` 或 `enum` 自动实现 trait。
   - 示例：`#[derive(Debug)]`。

   ```rust
   use proc_macro::TokenStream;
   
   #[proc_macro_derive(MyTrait)]
   pub fn my_derive(input: TokenStream) -> TokenStream {
       // 解析 input 并生成代码
   }
   ```

2. **属性宏（Attribute Macros）**：
   - 为代码添加自定义属性。
   - 示例：`#[route(GET, "/")]`。

   ```rust
   #[proc_macro_attribute]
   pub fn my_attr(attr: TokenStream, item: TokenStream) -> TokenStream {
       // attr 是属性参数，item 是被标记的代码
   }
   ```

3. **函数式宏（Function-like Macros）**：
   - 类似声明宏，但更灵活。
   - 示例：`sql!(SELECT * FROM table)`。

   ```rust
   #[proc_macro]
   pub fn my_macro(input: TokenStream) -> TokenStream {
       // 处理输入并生成代码
   }
   ```

##### 2. 依赖

需在 `Cargo.toml` 中添加：

```toml
[lib]
proc-macro = true
```

#### 关键注意事项

1. **作用域和导出**：
   - 声明宏需用 `#[macro_export]` 导出，才能被外部使用。
   - 过程宏需通过 crate 公开。

2. **调试工具**：
   - 使用 `cargo expand` 查看宏展开后的代码。

3. **错误处理**：
   - 在过程宏中，可使用 `panic!` 或 `syn`/`quote` 库生成友好错误。

#### 总结

- **声明宏**：适合简单模式匹配，语法类似 `macro_rules!`。
- **过程宏**：更复杂，需处理 `TokenStream`，适合生成复杂代码或 DSL。
- **卫生性**：Rust 自动管理宏中的变量作用域，避免冲突。

通过合理使用宏，可以显著减少重复代码，但需注意可读性！

---

### 三、宏与函数的对比

| 特性                | 函数                      | 宏                          |
|---------------------|--------------------------|-----------------------------|
| **执行时机**         | 运行时                   | 编译时展开                  |
| **参数灵活性**       | 固定类型和数量           | 可变参数，接受任意代码片段  |
| **代码生成能力**     | 无法生成新代码           | 可生成任意 Rust 代码        |
| **性能影响**         | 运行时开销               | 无运行时开销（编译时完成）  |
| **卫生性（Hygiene）**| 不涉及                   | 自动避免标识符冲突          |

---

### 四、元编程与编译时执行

- **AST 操作**：过程宏通过 `syn` 解析输入的 TokenStream，生成新代码。
- **编译时验证**：如 SQLx 在编译时连接数据库验证 SQL 语法。
- **性能优化**：通过宏展开消除运行时分支，如生成特定类型的方法。

**示例**：编译时计算斐波那契数列

```rust
macro_rules! const_fib {
    ($n:expr) => {{
        const fn fib(n: u32) -> u32 {
            if n <= 1 { n } else { fib(n-1) + fib(n-2) }
        }
        fib($n)
    }};
}

const FIB_10: u32 = const_fib!(10); // 编译时计算为 55
```

---

### 五、最佳实践与注意事项

1. **优先使用函数**：宏会增加代码复杂性和编译时间。
2. **合理选择宏类型**：
   - 简单代码生成 → 声明宏。
   - 复杂 AST 操作 → 过程宏。
3. **卫生性处理**：使用 `gensym` 或 `quote!` 避免变量冲突。
4. **调试工具**：通过 `cargo expand` 查看宏展开结果。

---

### 六、学习资源

1. **官方文档**：[Rust Book - Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
2. **实战指南**：["The Little Book of Rust Macros"](https://veykril.github.io/tlborm/)
3. **高级库**：`syn` 和 `quote` 的文档与示例。

通过掌握宏编程，你可以解锁 Rust 的深层能力，实现更高效、灵活的代码设计。

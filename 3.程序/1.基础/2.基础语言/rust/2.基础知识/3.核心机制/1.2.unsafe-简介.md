
# unsafe

在 Rust 中，`unsafe` 关键字用于执行需要绕过编译器安全检查的低级操作。以下是其核心要点：

## 1. **核心作用**

- **绕过安全检查**：允许执行编译器无法验证安全性的操作（如裸指针解引用、调用外部函数等）。
- **显式标记风险**：通过 `unsafe` 块或函数明确标识潜在危险代码，提醒开发者需自行确保安全性。

## 2. **使用场景**

- **底层系统编程**：直接操作硬件或特定内存布局（如操作系统开发、嵌入式系统）。
- **跨语言交互**：调用 C/C++ 等外部库时，需通过 `unsafe` 桥接（如 `extern "C"` 函数）。
- **性能优化**：在关键路径中绕过安全检查以提升性能（需谨慎验证安全性）。

## 3. **五大允许操作**

1. 解引用裸指针（`*const T`/`*mut T`）。
2. 调用 `unsafe` 函数（包括外部函数）。
3. 访问或修改可变静态变量。
4. 实现 `unsafe trait`。
5. 操作 `union` 类型。

## 4. **安全实践**

- **最小化作用域**：将 `unsafe` 代码限制在最小范围（如单个块内）。
- **封装抽象**：用安全接口封装 `unsafe` 操作（如提供安全的 API 隐藏底层指针操作）。
- **严格验证**：确保指针有效性、内存生命周期等，避免未定义行为。
- **文档契约**：在 `unsafe` 函数文档中明确调用前提和不变条件。

## 示例代码

```rust
// 解引用裸指针
let num = 5;
let ptr: *const i32 = &num as *const i32;
unsafe {
    println!("Value: {}", *ptr); // 需确保 ptr 有效
}

// 调用外部 C 函数
extern "C" {
    fn abs(input: i32) -> i32;
}
unsafe {
    println!("abs(-42) = {}", abs(-42));
}
```

## 5. **注意事项**

- **非完全“不安全”**：`unsafe` 仅表示编译器不检查，正确实现的代码仍可保证安全。
- **责任转移**：开发者需自行确保 `unsafe` 代码符合 Rust 内存安全规则（如无数据竞争、有效指针等）。

通过合理使用 `unsafe`，可在需要时突破语言限制，但仍需遵循最佳实践以维持整体代码安全性。

# 错误处理模式

在 Rust 中，错误处理是显式的、类型安全的，强调「错误也是值」的理念。其核心模式围绕 `Result` 类型展开，结合丰富的语言特性和生态系统工具，形成了灵活的错误处理体系。以下是 Rust 错误处理的详细模式和最佳实践：

---

## 一、基础错误处理工具

### 1. `Option<T>` 与 `Result<T, E>`

| **类型**          | **适用场景**                     | **示例**                              |
|--------------------|----------------------------------|---------------------------------------|
| `Option<T>`        | 处理可能存在或不存在的值         | `find()` 返回 `Option<Item>`          |
| `Result<T, E>`     | 处理可能失败的操作               | `File::open("file.txt")` 返回 `Result` |

### 2. `panic!` 宏

- **适用场景**：不可恢复错误（如程序逻辑错误）
- **行为**：终止当前线程，展开栈

```rust
// 严重错误时使用
if config_file.is_empty() {
    panic!("配置文件不能为空！");
}
```

---

## 二、错误传播模式

### 1. 显式错误处理（`match`）

```rust
let file = match File::open("data.txt") {
    Ok(f) => f,
    Err(e) => {
        eprintln!("打开文件失败: {}", e);
        return; // 或处理错误
    }
};
```

### 2. `?` 运算符（错误传播简写）

```rust
fn read_file() -> Result<String, io::Error> {
    let mut s = String::new();
    File::open("file.txt")?.read_to_string(&mut s)?;
    Ok(s)
}
```

### 3. 组合方法（`map`, `and_then`, `or_else`）

```rust
"42"
    .parse::<i32>()
    .map(|n| n * 2)          // 成功时转换
    .or_else(|_| Ok(0))      // 失败时默认值
```

---

## 三、自定义错误类型

### 1. 基础自定义错误

```rust
#[derive(Debug)]
enum MyError {
    Io(std::io::Error),
    Parse(String),
    InvalidInput,
}

impl std::fmt::Display for MyError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            MyError::Io(e) => write!(f, "IO错误: {}", e),
            MyError::Parse(s) => write!(f, "解析失败: {}", s),
            MyError::InvalidInput => write!(f, "输入无效"),
        }
    }
}

impl std::error::Error for MyError {} // 实现 Error trait
```

### 2. 错误类型转换（`From` trait）

```rust
impl From<std::io::Error> for MyError {
    fn from(e: std::io::Error) -> Self {
        MyError::Io(e)
    }
}

// 现在可以直接使用 ? 转换错误类型
fn load_config() -> Result<Config, MyError> {
    let s = std::fs::read_to_string("config.toml")?; // 自动转换为 MyError
    // ...
}
```

---

## 四、错误处理生态系统

### 1. 常用错误处理库

| **库**       | **特点**                              | **适用场景**                   |
|--------------|---------------------------------------|-------------------------------|
| `thiserror`  | 派生宏简化自定义错误定义              | 库开发，需要明确错误类型       |
| `anyhow`     | 提供易用的动态错误类型                | 应用程序开发，快速原型         |
| `snafu`      | 上下文增强的错误处理                  | 需要错误链追踪                 |

### 2. `thiserror` 示例

```rust
use thiserror::Error;

#[derive(Error, Debug)]
enum DataError {
    #[error("IO错误: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("无效数据格式: {0}")]
    ParseError(String),
    
    #[error("数值超出范围: {value} (允许范围 {min}-{max})")]
    OutOfRange {
        value: i32,
        min: i32,
        max: i32,
    },
}
```

---

## 五、错误处理最佳实践

### 1. 错误类型设计原则

| **原则**                | **说明**                              |
|-------------------------|---------------------------------------|
| 明确错误分类            | 使用枚举区分不同错误类型              |
| 携带上下文信息          | 错误应包含足够调试信息（如文件路径）  |
| 实现 `Error` trait       | 允许与其他错误处理工具兼容            |

### 2. 错误处理策略选择

| **场景**                | **推荐方案**                          |
|-------------------------|---------------------------------------|
| 库开发                  | 定义明确的错误类型 + `thiserror`      |
| 应用程序开发            | 使用 `anyhow` 或组合错误类型          |
| 需要错误链追踪          | `snafu` 或 `std::error::Error::source`|
| 快速原型开发            | 使用 `Box<dyn Error>` 作为错误类型    |

---

## 六、高级错误处理技巧

### 1. 错误上下文增强

```rust
use anyhow::{Context, Result};

fn process_file(path: &str) -> Result<()> {
    let data = std::fs::read(path)
        .with_context(|| format!("无法读取文件: {}", path))?;
    // ...
}
```

### 2. 错误类型擦除

```rust
fn generic_error() -> Result<(), Box<dyn std::error::Error>> {
    let x: i32 = "123".parse()?;  // ParseIntError → Box<Error>
    let _file = File::open("file.txt")?;  // io::Error → Box<Error>
    Ok(())
}
```

### 3. 自定义错误日志

```rust
fn handle_error(error: &MyError) {
    match error {
        MyError::Io(e) => log::error!("IO错误: {} - {}", e, e.kind()),
        MyError::Parse(s) => log::warn!("解析警告: {}", s),
        _ => log::info!("一般错误"),
    }
}
```

---

## 七、错误处理模式对比

| **模式**          | **优点**                      | **缺点**                    | **适用场景**             |
|--------------------|-------------------------------|-----------------------------|-------------------------|
| 显式 `match`       | 完全控制错误处理流程          | 代码冗长                    | 需要精细处理不同错误分支 |
| `?` 运算符         | 简洁，自动传播错误            | 错误类型需兼容              | 大多数常规场景           |
| 错误转换           | 统一错误类型                  | 需要定义转换逻辑            | 多错误类型整合           |
| `unwrap`/`expect` | 快速开发                      | 导致 panic（生产环境避免）  | 原型开发或绝对确定成功时 |

---

## 八、完整错误处理示例

```rust
use std::{fs::File, io::Read};
use thiserror::Error;

#[derive(Error, Debug)]
enum AppError {
    #[error("文件 {0} 未找到")]
    FileNotFound(String),
    
    #[error("IO操作失败")]
    Io(#[from] std::io::Error),
    
    #[error("数据格式无效")]
    InvalidFormat,
}

fn load_data(path: &str) -> Result<String, AppError> {
    let mut file = File::open(path)
        .map_err(|_| AppError::FileNotFound(path.to_string()))?;
    
    let mut data = String::new();
    file.read_to_string(&mut data)?;  // 自动转换 io::Error → AppError
    
    if data.is_empty() {
        return Err(AppError::InvalidFormat);
    }
    
    Ok(data)
}

fn main() {
    match load_data("data.txt") {
        Ok(data) => println!("数据内容: {}", data),
        Err(e) => eprintln!("错误: {}", e),
    }
}
```

---

通过合理选择错误处理模式，开发者可以在代码安全性、可维护性和开发效率之间取得平衡。核心原则是：

1. **显式优于隐式**：强制处理所有可能的错误路径
2. **类型驱动**：利用类型系统保证错误处理正确性
3. **上下文丰富**：提供足够信息用于调试和错误恢复
4. **分层抽象**：根据应用场景选择合适的错误处理粒度

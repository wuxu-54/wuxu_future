# 指针简介

在Rust中，指针是管理内存和数据访问的核心工具，但受所有权系统的严格约束，确保内存安全。以下是Rust指针的主要类型及其用途的总结：

## 1. **引用（References）**

- **不可变引用 `&T`**  
     允许多个读取操作，但不能修改数据。遵循共享不可变原则。
- **可变引用 `&mut T`**  
     唯一且独占，允许修改数据。同一作用域内不能与其他引用共存。
- **规则**  
  - 作用域内要么有多个不可变引用，要么仅有一个可变引用。
  - 引用必须始终有效（无悬垂指针）。

   ```rust
   let x = 10;
   let r1 = &x;
   let r2 = &x; // 允许多个不可变引用
   let mut y = 20;
   let rm = &mut y; // 唯一可变引用
   *rm += 5;// 解引用
   ```

## 2. **智能指针（Smart Pointers）**

- **`Box<T>`**  
     堆分配数据，拥有唯一所有权。用于动态大小类型（如递归结构）或转移所有权。

     ```rust
     let b = Box::new(42);
     println!("{}", *b); // 解引用
     ```

- **`Rc<T>`**  
     单线程引用计数，允许多所有者。`clone()`增加计数，计数归零时释放。

     ```rust
     use std::rc::Rc;
     let rc = Rc::new(42);
     let rc2 = rc.clone();
     println!("Count: {}", Rc::strong_count(&rc)); // 2
     ```

- **`Arc<T>`**  
     线程安全的原子引用计数，用于多线程共享数据。

     ```rust
     use std::sync::Arc;
     let arc = Arc::new(42);
     let arc2 = arc.clone();
     ```

- **`RefCell<T>`**  
     提供内部可变性，运行时检查借用规则（单写或多读）。与`Rc`配合使用。

     ```rust
     use std::cell::RefCell;
     let cell = RefCell::new(42);
     *cell.borrow_mut() += 10; // 运行时可变借用
     ```

- **`Mutex<T>`**  
     多线程互斥锁，保证线程间安全访问。

     ```rust
     use std::sync::Mutex;
     let m = Mutex::new(42);
     let mut guard = m.lock().unwrap();
     *guard += 10;
     ```

## 3. **裸指针（Raw Pointers）**

>又名：原始指针

- **`*const T` 和 `*mut T`**  
     绕过编译器安全检查，需在`unsafe`块中使用。用于FFI或底层操作。

     ```rust
     let x = 5;
     let ptr = &x as *const i32;
     unsafe {
         println!("{}", *ptr); // 需确保指针有效
     }
     ```

## 关键特性

- **`Deref` 和 `Drop` Trait**  
  - `Deref` 实现自动解引用（如 `*b` 访问 `Box` 内容）。
  - `Drop` 定义析构逻辑（如释放堆内存）。
- **所有权与借用规则**  
     智能指针如 `Box` 转移所有权，`Rc`/`Arc` 共享所有权，`RefCell` 在运行时检查借用。

## 选择指针类型的场景

- **唯一所有权** → `Box<T>`
- **多线程共享** → `Arc<T>` + `Mutex<T>`
- **单线程共享** → `Rc<T>` + `RefCell<T>`
- **底层操作/FFI** → 裸指针（谨慎使用）

理解这些指针类型及其安全规则，是编写高效且安全的Rust代码的关键。

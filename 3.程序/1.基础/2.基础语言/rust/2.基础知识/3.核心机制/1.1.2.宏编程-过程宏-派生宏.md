# 派生宏

在 Rust 里，派生宏（Derive Macros）是一种强大的元编程工具，它能自动为类型实现特定的 Trait。借助派生宏，你可以避免编写大量重复的样板代码。下面详细介绍 Rust 派生宏。

## 1. 基本概念

派生宏是 Rust 宏系统的一部分，它使用 `#[derive]` 注解来工作。当你在结构体、枚举或联合体定义前加上 `#[derive(TraitName)]` 时，编译器会自动为该类型生成 `TraitName` Trait 的实现代码。

## 2. 常见的内置派生宏

Rust 标准库提供了一些常用的内置派生宏，下面是一些例子：

### `#[derive(Debug)]`

为类型生成 `Debug` Trait 的实现，方便调试时打印类型信息。

```rust
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 1, y: 2 };
    println!("{:?}", p);
}
```

### `#[derive(Clone, Copy)]`

`Clone` Trait 允许类型复制自身，`Copy` Trait 则让类型在赋值或传参时自动复制。

```rust
#[derive(Clone, Copy)]
struct Coordinate {
    latitude: f64,
    longitude: f64,
}

fn main() {
    let c1 = Coordinate {
        latitude: 37.7749,
        longitude: -122.4194,
    };
    let c2 = c1;
    println!("{:?}", c2);
}
```

### `#[derive(PartialEq, Eq)]`

`PartialEq` Trait 用于比较两个值是否相等，`Eq` Trait 是 `PartialEq` 的加强版，用于定义严格相等性。

```rust
#[derive(PartialEq, Eq)]
struct Book {
    title: String,
    author: String,
}

fn main() {
    let book1 = Book {
        title: String::from("The Rust Programming Language"),
        author: String::from("Steve Klabnik and Carol Nichols"),
    };
    let book2 = Book {
        title: String::from("The Rust Programming Language"),
        author: String::from("Steve Klabnik and Carol Nichols"),
    };
    if book1 == book2 {
        println!("The two books are the same.");
    }
}
```

### `#[derive(PartialOrd, Ord)]`

`PartialOrd` Trait 用于比较两个值的大小，`Ord` Trait 是 `PartialOrd` 的加强版，用于定义全序关系。

```rust
#[derive(PartialOrd, Ord)]
struct Score {
    value: u32,
}

fn main() {
    let score1 = Score { value: 80 };
    let score2 = Score { value: 90 };
    if score1 < score2 {
        println!("Score 1 is less than Score 2.");
    }
}
```

## 3. 自定义派生宏

除了使用内置派生宏，你还能自定义派生宏。自定义派生宏需要使用 `proc_macro_derive` 来实现。以下是一个简单的示例：

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyTrait)]
pub fn my_trait_derive(input: TokenStream) -> TokenStream {
    // 解析输入的语法树
    let ast = parse_macro_input!(input as DeriveInput);

    // 获取类型名称
    let name = &ast.ident;

    // 生成实现代码
    let gen = quote! {
        impl MyTrait for #name {
            fn my_method(&self) {
                println!("MyTrait is implemented for {}", stringify!(#name));
            }
        }
    };

    // 将生成的代码转换为 TokenStream 并返回
    gen.into()
}

// 定义自定义 Trait
pub trait MyTrait {
    fn my_method(&self);
}

// 使用自定义派生宏
#[derive(MyTrait)]
struct MyStruct;

fn main() {
    let s = MyStruct;
    s.my_method();
}
```

在这个例子中，定义了一个名为 `MyTrait` 的自定义 Trait，并实现了一个派生宏 `my_trait_derive` 来自动为类型实现 `MyTrait`。使用 `#[derive(MyTrait)]` 注解，就能为 `MyStruct` 结构体自动生成 `MyTrait` 的实现代码。

## 4. 注意事项

- **成员类型要求**：使用派生宏时，类型的所有成员都必须实现派生宏所依赖的 Trait。例如，使用 `#[derive(Debug)]` 时，所有成员都要实现 `Debug` Trait。
- **代码膨胀**：派生宏会在编译时生成大量代码，可能导致编译时间增加和可执行文件变大。

# 特性约束（Trait Bounds）

类似kotlin中的：`T:Parent类`，即表明某个类型是实现自某个特性Trait

## Rust 特性约束（Trait Bounds）使用详解

### 1. **基础语法**

特性约束通过 `T: Trait` 语法或 `where` 子句指定泛型类型需满足的 Trait 要求。

**示例：**

```rust
use std::fmt::Display;

// 方法1：直接约束泛型参数
fn print<T: Display>(value: T) {
    println!("{}", value);
}

// 方法2：where 子句约束
fn debug_print<T>(value: T)
where
    T: Display + Debug, 
{
    println!("Display: {}, Debug: {:?}", value, value);
}
```

---

### 2. **关联类型约束**

Trait 中的关联类型（Associated Types）允许定义占位类型，实现时需指定具体类型。

**示例：**

```rust
trait Iterator {
    type Item; // 关联类型占位符
    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter(u32);

impl Iterator for Counter {
    type Item = u32; // 具体类型指定
    fn next(&mut self) -> Option<Self::Item> {
        if self.0 < 5 {
            self.0 += 1;
            Some(self.0)
        } else {
            None
        }
    }
}
```

---

### 3. **默认泛型参数**

通过 `<T = DefaultType>` 语法为泛型参数指定默认类型。

**示例：**

```rust
trait Add<Rhs = Self> { // Rhs 默认为 Self 类型
    type Output;
    fn add(self, rhs: Rhs) -> Self::Output;
}

impl Add for i32 {
    type Output = i32;
    fn add(self, other: i32) -> i32 {
        self + other
    }
}
```

---

### 4. **多约束组合**

使用 `+` 符号或 `where` 子句组合多个 Trait 约束。

**示例：**

```rust
// 方法1：直接组合
fn process<T: Display + Clone>(data: T) {
    let cloned = data.clone();
    println!("{}", cloned);
}

// 方法2：where 子句
fn analyze<T>(data: T)
where
    T: Serialize + DeserializeOwned + Debug,
{
    let json = serde_json::to_string(&data).unwrap();
    println!("{:?} as JSON: {}", data, json);
}
```

---

### 5. **孤儿规则（Orphan Rule）**

Rust 强制要求：只有当 Trait 或类型至少有一个定义在当前 crate 时，才能为该类型实现 Trait。防止外部库之间的实现冲突。

**合法示例（当前 crate 定义类型）：**

```rust
struct MyType;

impl std::fmt::Display for MyType { // 合法：MyType 定义在本地
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "MyType")
    }
}
```

**非法示例（外部类型实现外部 Trait）：**

```rust
impl std::fmt::Display for Vec<i32> { // 错误！Vec 和 Display 均非本地定义
    // ...
}
```

---

### 6. **实际应用案例**

**案例1：泛型结构体约束**：

```rust
use std::ops::Add;

struct Point<T: Add<Output = T>> { // 约束 T 必须实现 Add 且输出类型为 T
    x: T,
    y: T,
}

impl<T: Add<Output = T>> Point<T> {
    fn sum(self) -> T {
        self.x + self.y
    }
}

let p = Point { x: 10, y: 20 };
assert_eq!(p.sum(), 30);
```

**案例2：Trait 对象动态分发**：

```rust
trait Draw {
    fn draw(&self);
}

struct Button;
struct Slider;

impl Draw for Button {
    fn draw(&self) { println!("Drawing a button"); }
}

impl Draw for Slider {
    fn draw(&self) { println!("Drawing a slider"); }
}

fn render_ui(components: &Vec<Box<dyn Draw>>) { // 动态 Trait 对象
    for comp in components {
        comp.draw();
    }
}

let ui: Vec<Box<dyn Draw>> = vec![
    Box::new(Button),
    Box::new(Slider),
];
render_ui(&ui);
```

---

## 关键总结

- **核心作用**：通过 Trait 约束确保泛型类型具有特定行为，实现编译时多态。
- **灵活组合**：支持多约束、关联类型、默认泛型参数，适应复杂场景。
- **安全机制**：孤儿规则防止实现冲突，所有权系统保障内存安全。
- **性能优势**：零成本抽象，无运行时开销。

通过合理使用特性约束，可以构建类型安全且高效的 Rust 代码，同时保持代码的灵活性和可维护性。

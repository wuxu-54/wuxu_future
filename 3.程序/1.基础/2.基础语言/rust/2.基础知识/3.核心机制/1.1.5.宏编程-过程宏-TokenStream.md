# TokenStream

在 Rust 中，`TokenStream` 是过程宏（Procedural Macros）的核心数据类型，表示代码的标记流（Token Stream）。它是宏开发中解析输入和生成代码的桥梁。以下是操作 `TokenStream` 的详细指南，涵盖核心概念、工具库和实际示例。

---

## 一、`TokenStream` 基础

### 1. **定义与作用**

- `TokenStream` 是编译器提供的类型（位于 `proc_macro` 模块），表示一段代码的标记序列。
- **输入**：宏接收的代码（如 `#[derive(MyMacro)]` 标记的结构体）。
- **输出**：宏生成的代码（如自动实现的 trait 方法）。

### 2. **不可变性与所有权**

- `TokenStream` 是不可变的，操作时会生成新的实例。
- 过程宏函数接收 `TokenStream` 作为输入，并返回新的 `TokenStream`。

---

## 二、核心工具库

操作 `TokenStream` 主要依赖以下库：

| 库名          | 功能                                                                 |
|---------------|----------------------------------------------------------------------|
| **`syn`**     | 将 `TokenStream` 解析为结构化的语法树（AST），支持精确操作代码元素。  |
| **`quote`**   | 将 Rust 代码模板转换为 `TokenStream`，支持插值和重复模式。           |
| **`proc_macro2`** | 提供与 `proc_macro` 兼容的 API，便于在非宏代码（如测试）中操作标记流。 |

### 1. **`syn` 的核心类型**

- `DeriveInput`：解析 `#[derive(...)]` 宏的输入（结构体或枚举）。
- `ItemFn`：解析函数定义。
- `LitStr`、`LitInt`：解析字符串、整数等字面量。
- `Expr`：解析表达式。

### 2. **`quote` 的语法**

- 使用 `#var` 插入变量。
- 使用 `#(...)*` 处理重复模式（类似 `macro_rules!` 的 `$(...)`）。

---

## 三、操作 `TokenStream` 的流程

### 1. **解析输入**

将 `TokenStream` 解析为结构化类型（如 `DeriveInput`）：

```rust
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(MyMacro)]
pub fn my_macro(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let struct_name = input.ident; // 获取结构体名称
    // ...
}
```

### 2. **生成代码**

使用 `quote!` 生成新代码：

```rust
use quote::quote;

let output = quote! {
    impl MyTrait for #struct_name {
        fn print_name(&self) {
            println!("Struct name: {}", stringify!(#struct_name));
        }
    }
};
output.into() // 转换为 TokenStream
```

### 3. **处理重复模式**

生成重复代码块（如为多个字段生成方法）：

```rust
let fields = match input.data {
    syn::Data::Struct(s) => s.fields,
    _ => panic!("仅支持结构体"),
};

// 为每个字段生成代码
let field_prints = fields.iter().map(|f| {
    let field_name = &f.ident;
    quote! {
        println!("Field: {}", stringify!(#field_name));
    }
});

let output = quote! {
    impl MyTrait for #struct_name {
        fn print_fields(&self) {
            #(#field_prints)*
        }
    }
};
```

---

## 四、错误处理

### 1. **解析错误**

使用 `syn::Result` 或 `panic!` 提供友好的错误信息：

```rust
let input = match syn::parse::<DeriveInput>(input) {
    Ok(v) => v,
    Err(e) => return e.to_compile_error().into(),
};
```

### 2. **生成错误**

在生成的代码中插入编译错误：

```rust
let error = quote! {
    compile_error!("仅支持带有命名字段的结构体");
};
error.into()
```

---

## 五、调试技巧

### 1. **打印 `TokenStream`**

在开发过程中打印中间结果：

```rust
println!("Input: {:#?}", input);
```

### 2. **使用 `cargo expand`**

查看宏展开后的代码：

```bash
cargo install cargo-expand
cargo expand
```

---

## 六、实际示例

### 1. **自定义派生宏：自动实现 `Builder` 模式**

```rust
#[proc_macro_derive(Builder)]
pub fn builder_derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = input.ident;
    let builder_name = format_ident!("{}Builder", name);

    // 生成 Builder 结构体和方法
    let output = quote! {
        impl #name {
            pub fn builder() -> #builder_name {
                #builder_name::default()
            }
        }

        #[derive(Default)]
        struct #builder_name {
            // 根据字段生成对应的 Option 类型
            #( #field_names: Option<#field_types>, )*
        }

        impl #builder_name {
            #(
                pub fn #field_names(&mut self, value: #field_types) -> &mut Self {
                    self.#field_names = Some(value);
                    self
                }
            )*

            pub fn build(&self) -> Result<#name, String> {
                Ok(#name {
                    #(
                        #field_names: self.#field_names.clone().ok_or(format!("字段 {} 未设置", stringify!(#field_names)))?,
                    )*
                })
            }
        }
    };

    output.into()
}
```

### 2. **属性宏：添加函数日志**

```rust
#[proc_macro_attribute]
pub fn log_attr(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input_fn = parse_macro_input!(item as syn::ItemFn);
    let fn_name = &input_fn.sig.ident;

    quote! {
        #input_fn

        fn log_wrapper() {
            println!("调用函数: {}", stringify!(#fn_name));
            #fn_name();
        }
    }.into()
}
```

---

## 七、注意事项

1. **性能**：复杂宏会增加编译时间，尽量保持简洁。
2. **卫生性（Hygiene）**：Rust 自动处理宏变量的作用域，无需手动重命名。
3. **测试**：为宏编写单元测试，验证生成的代码逻辑。
4. **版本兼容性**：`syn` 和 `quote` 的 API 可能随版本变化，注意版本锁定。

---

## 八、总结

- **`TokenStream`** 是过程宏操作代码的底层类型，直接操作复杂，需依赖 `syn` 和 `quote`。
- **核心步骤**：解析输入 → 生成代码 → 返回结果。
- **工具链**：
  - `syn` 用于解析结构化的语法树。
  - `quote` 用于生成代码模板。
  - `proc_macro2` 用于非宏环境下的兼容操作。

通过合理利用这些工具，可以实现强大的代码生成能力（如 DSL、自动 trait 实现等），但需权衡代码可读性和编译性能。

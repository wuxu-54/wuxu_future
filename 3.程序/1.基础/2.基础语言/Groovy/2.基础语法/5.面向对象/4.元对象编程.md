# 元对象编程

Groovy 元对象编程（Meta-Object Programming，简称 MOP）是一种强大的编程技术，它允许开发者在运行时访问和修改对象的行为。Groovy 的 MOP 基于 Groovy 的元对象协议（MetaClass），这是 Groovy 对 Java 反射 API 的扩展。
>Java的反射，直接操作对象的元数据，如反射中使用的属性、方法等

## 基本概念

- **MetaClass**：每个 Groovy 类在运行时都有一个与之关联的 MetaClass 对象，它定义了类的动态行为。
- **方法拦截**：可以通过拦截方法调用来改变方法的行为，例如添加日志、验证参数等。
- **属性拦截**：可以拦截属性的读取和赋值操作。
- **动态方法和属性**：可以在运行时动态地添加方法和属性。

## 使用 MetaClass

Groovy 的 MetaClass 可以通过 `metaClass` 属性访问：

```groovy
class MyClass {
    def myMethod() {
        "Original Method"
    }
}

def instance = new MyClass()

// 访问 MetaClass
def metaClass = instance.metaClass

// 修改方法行为
metaClass.myMethod = { ->
    "Modified Method"
}

println instance.myMethod() // 输出 "Modified Method"
```

## 方法拦截

Groovy 允许使用 `use` 方法来注册一个或多个方法拦截器：

```groovy
class MyInterceptor {
    def doSomethingBefore() {
        println "Before method call"
    }
    def doSomethingAfter() {
        println "After method call"
    }
}

instance.metaClass.invokeMethod = { String name, args ->
    MyInterceptor.metaClass.static.doSomethingBefore()
    try {
        delegate.invokeMethod(name, args)
    } finally {
        MyInterceptor.metaClass.static.doSomethingAfter()
    }
}
```

## 属性拦截

属性拦截可以用来修改属性的读取和赋值操作：

```groovy
instance.metaClass.getSomeProperty = { ->
    println "Getting someProperty"
    delegate.someProperty
}

instance.metaClass.setSomeProperty = { value ->
    println "Setting someProperty to $value"
    delegate.someProperty = value
}
```

## 动态方法和属性

可以在运行时动态地添加方法和属性：

```groovy
metaClass.dynamicMethod = { ->
    println "This is a dynamic method"
}

instance.dynamicMethod() // 输出 "This is a dynamic method"

metaClass.getDynamicProperty = { ->
    "Dynamic property value"
}

println instance.dynamicProperty // 输出 "Dynamic property value"
```

## 应用场景

元对象编程在以下场景中非常有用：

- **框架开发**：许多 Groovy 框架（如 Grails）使用 MOP 来提供约定优于配置的特性。
- **动态行为修改**：可以在不修改原始代码的情况下改变对象的行为。
- **AOP（面向切面编程）**：可以用于实现日志、事务管理等横切关注点。

Groovy 的元对象编程是一个高级特性，它为开发者提供了极大的灵活性和强大的能力，但同时也需要谨慎使用，以避免过度复杂化代码。

---

## 补充示例

让我们考虑一个名为 Student 的类，它是一个没有成员变量或方法的空类。 假设您必须在此类上调用以下语句。

```groovy
def myStudent = new Student() 
myStudent.Name = ”Joe”; 
myStudent.Display()
```

现在在元对象编程中，即使类没有成员变量 Name 或方法 Display()，上面的代码仍然可以工作。这怎么行? 好吧，要实现这一点，必须实现 `GroovyInterceptable` 接口以挂钩到 Groovy 的执行过程。 以下是此接口可用的方法。

```groovy
Public interface GroovyInterceptable { 
   Public object invokeMethod(String methodName, Object args) 
   Public object getproperty(String propertyName) 
   Public object setProperty(String propertyName, Object newValue) 
   Public MetaClass getMetaClass() 
   Public void setMetaClass(MetaClass metaClass) 
}
```

让我们看一个更具体示例，说明如何针对缺失的属性实现元对象编程。 以下代码需要注意以下关键事项。

- Student 类没有定义名为 Name 或 ID 的成员变量。
- Student 类实现了 GroovyInterceptable 接口。
- 有一个名为dynamicProps的参数，用于保存动态创建的成员变量的值。
- 已实现 getproperty 和 setproperty 方法，用于在运行时获取和设置类的属性值。

```groovy
class Example {
   static void main(String[] args) {
      Student mst = new Student();
      mst.Name = "Joe";
      mst.ID = 1;

      println(mst.Name);
      println(mst.ID);
      mst.AddMarks();
   } 
} 

class Student implements GroovyInterceptable {
   protected dynamicProps = [:]  
    
   void setProperty(String pName, val) {
      dynamicProps[pName] = val
   }
   
   def getProperty(String pName) {
      dynamicProps[pName]
   }
   
   def methodMissing(String name, def args) {         
      println "Missing method"
   }  
}
```

输出结果：

```txt
Joe 
1 
Missing method 
```

总结上面示例：如果学过js、ts即可知，这是使用类似的处理。动态的将参数、方法设置到类里。

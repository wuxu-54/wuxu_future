# 异常及处理

Groovy 的异常处理机制与 Java 类似，因为它们都运行在 JVM 上，并且遵循相同的异常处理规则。以下是 Groovy 中异常处理的关键概念和用法：

## 1. Try-Catch-Finally 语句

这是最基本的异常处理结构，与 Java 中的使用方式相同。

```groovy
try {
    // 尝试执行的代码，可能会抛出异常
} catch (SomeException e) {
    // 处理特定类型的异常
} catch (OtherException e) {
    // 可以有多个 catch 块来处理不同类型的异常
} finally {
    // 无论是否发生异常都会执行的代码
}
```

## 2. 多重 Catch

Groovy 允许在一个 catch 块中捕获多个异常类型。

```groovy
try {
    // 可能会抛出多种类型的异常
} catch (IOException | SQLException e) {
    // 处理 IOException 或 SQLException
}
```

## 3. 抛出异常

使用 `throw` 关键字抛出异常。

```groovy
if (someCondition) {
    throw new IllegalArgumentException("Invalid argument")
}
```

## 4. 必须处理的异常

对于 Java 中的受检查异常（checked exceptions），Groovy 也要求必须被捕获或声明抛出。

```groovy
try {
    // 可能会抛出受检查异常的代码
} catch (IOException e) {
    // 必须处理
}
```

## 5. 运行时异常

对于 Java 中的非受检查异常（unchecked exceptions），Groovy 不强制要求捕获或声明抛出。

```groovy
try {
    // 可能会抛出运行时异常的代码
} catch (RuntimeException e) {
    // 不需要显式捕获
}
```

## 6. 重新抛出异常

在 catch 块中，可以使用 `throw` 重新抛出当前捕获的异常。

```groovy
try {
    // 某些代码
} catch (Exception e) {
    println "An error occurred: " + e.message
    throw e // 重新抛出异常
}
```

## 7. 异常链

可以使用 `cause` 属性来创建异常链。

```groovy
try {
    // 某些代码
} catch (IOException e) {
     // 访问原始异常
    Throwable cause = re.cause
    println "Caused by: ${cause.class.name}: ${cause.message}"
    
    throw new RuntimeException("Failed to read file", e) // 将 IOException 设置为原因
}
```

## 8. 自定义异常

可以创建自定义的异常类。

```groovy
class MyException extends Exception {
    MyException(String message, Throwable cause) {
        super(message, cause)
    }
}

try {
    throw new MyException("Custom error", null)
} catch (MyException e) {
    println e.message
}
```

## 9. Groovy 异常处理特性

Groovy 的异常处理机制与 Java 一致，但由于 Groovy 的动态特性，它提供了一些额外的便利，例如：

- 在闭包中使用 try-catch。
- 使用 Groovy 的闭包特性简化异常处理代码。

## 示例

以下是使用 Groovy 闭包特性简化异常处理的示例：

```groovy
def riskyOperation = {
    // 可能会抛出异常的代码
}

try {
    riskyOperation.call()
} catch (Exception e) {
    println "Caught an exception: ${e.message}"
}
```

# 闭包

Groovy 的闭包是一个功能强大的特性，它将代码（一段逻辑）和外部环境（定义时的作用域）捆绑在一起。闭包类似于其他编程语言中的匿名函数或函数式接口。
>[更具体的解释](/3.%E7%A8%8B%E5%BA%8F/1.%E5%9F%BA%E7%A1%80/3.开发小知识/%E9%97%AD%E5%8C%85%E8%A7%A3%E9%87%8A.md)

以下是 Groovy 闭包的一些关键特性和用法：

## 1. 定义闭包

闭包使用大括号 `{}` 定义，可以包含一个或多个语句。

```groovy
def closure = {
    println "Hello from closure!"
}
```

## 2. 参数和返回值

闭包可以有参数，并可以返回一个值。

```groovy
def add = { a, b -> a + b }
def result = add(5, 3) // 结果为 8
```

## 3. 闭包作为参数

闭包可以作为参数传递给其他方法。

```groovy
def execute(Closure c) {
    c()
}

execute(closure)
```

## 4. 闭包作为返回值

方法可以返回闭包。

```groovy
def createClosure() {
    { it * 2 }
}

def doubler = createClosure()
println doubler(5) // 输出 10
```

## 5. 闭包与外部变量

闭包可以捕获定义时作用域中的变量。

```groovy
def multiplier = 2
def scale = { item -> item * multiplier }
println scale(10) // 输出 20
```

## 6. 闭包的委托

闭包可以显式设置其委托对象，这意味着闭包可以直接访问委托对象的属性和方法。

```groovy
class Greeter {
    String greeting = "Hello"
}

def greeter = new Greeter()
def greet = { "${greeter.greeting}, World!" }()
```

## 7. 闭包的属性

闭包是对象，因此它们可以有自己的属性。

```groovy
def greet = {
    greeting = "Hello"
    -> "$greeting, World!"
}
```

## 8. 闭包的 `delegate` 参数

当将闭包作为参数传递给方法时，可以显式指定闭包的 `delegate` 参数。

```groovy
def greet(Closure c) {
    c.delegate = new Greeter(greeting: "Hi")
    c()
}

greet {
    println "$greeting, there!"
}
```

## 9. 闭包的 `resolveStrategy` 参数

可以指定闭包的 `resolveStrategy` 来控制变量解析的顺序。

```groovy
def name = "Alice"
def greet = { owner, Closure c ->
    c.delegate = owner
    c.resolveStrategy = Closure.DELEGATE_FIRST
    c()
}

greet([name: "Bob"] as Map) {
    println "My name is $name"
}
```

## 10. 闭包的 `call()` 方法

闭包是对象，可以使用 `call()` 方法执行。

```groovy
def add = { a, b -> a + b }
add.call(3, 4) // 输出 7
```

## 11. 闭包的内存占用

闭包持有定义时的作用域的引用，如果不正确管理，可能会导致内存泄漏。

## 示例

以下是一些使用 Groovy 闭包的示例：

```groovy
// 简单的闭包
def simpleClosure = {
    println "This is a simple closure"
}
simpleClosure()

// 带参数的闭包
def addClosure = { a, b -> a + b }
println addClosure(5, 3)

// 闭包作为参数和返回值
def applyClosure(Closure c, a, b) {
    return c(a, b)
}
println applyClosure(addClosure, 7, 8)

// 闭包与外部变量
def multiplier = 5
def scaleClosure = { it * multiplier }
println scaleClosure(10)

// 使用闭包的 `delegate` 和 `resolveStrategy`
def map = [name: "Alice"]
def printName = {
    println "Name: $name"
}
printName.delegate = map
printName.resolveStrategy = Closure.DELEGATE_FIRST
printName()
```

Groovy 的闭包提供了一种非常灵活的方式来编写和传递代码块，它们在函数式编程和事件驱动编程中非常有用。

---

## 总结

1. 闭包本身是个对象。
2. 闭包有个delegate属性，接收对象，此时这个对象就是委托对象。
3. 闭包可以直接访问委托对象的属性和方法。

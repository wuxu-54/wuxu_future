# 关键字

Kotlin 是一种现代的、静态类型的编程语言，它设计了许多关键字来支持其语言特性。以下是一些 Kotlin 中的常用关键字：

## 类型和声明

- `class`：声明一个类。
- `interface`：声明一个接口。
- `object`：声明一个单例对象。
- `typealias`：为现有类型定义一个新名称（类型别名）。
- `enum`：声明一个枚举类。

## 函数和返回

- `fun`：声明一个函数。
- `return`：从函数返回一个值。

## 变量和常量

- `var`：声明一个可变的变量。
- `val`：声明一个不可变的变量（常量）。

## 控制流

- `if`：条件语句。
- `else`：与 `if` 配合使用的否定分支。
- `when`：类似于 switch-case 的条件选择语句。
- `for`：遍历循环。
- `while`：条件循环。
- `do`：至少执行一次的循环，与 `while` 配合使用。
- `break`：跳出最近的循环或 switch-case。
- `continue`：跳过当前循环的剩余部分，开始下一次循环。
- `try`：尝试执行可能抛出异常的代码块。
- `catch`：捕获并处理异常。
- `finally`：无论是否发生异常，都会执行的代码块。
- `throw`：抛出一个异常。

## 范围和集合

- `in`：检查一个值是否存在于一个范围内或集合中。
- `!in`：检查一个值不存在于一个范围内或集合中。

## 其他

- `package`：声明代码所属的包。
- `import`：导入其他包中的类、函数等。
- `as`：类型转换或导入别名。
- `is`：类型检查。
- `!is`：否定类型检查。
- `null`：表示空值。
- `true` 和 `false`：布尔逻辑值。
- `this`：引用当前对象或当前作用域。
- `super`：引用超类。

## 函数参数和类型系统

- `constructor`：类的构造函数。
- `param`：函数参数。
- `set` 和 `get`：用于定义属性的访问器和修改器。

## 扩展和委托

- `by`：委托属性的实现给另一个对象。
- `delagate`：定义委托。

## 内联函数

- `inline`：内联函数，避免函数调用的开销。(编译时将内联函数、内联类插入到调用位置。等同于TS中的命名空间、C++中的命名空间)

## 修饰符

- `public`、`private`、`protected`、`internal`：访问修饰符。
- `override`：覆盖超类中的方法或属性。
- `lateinit`：声明一个非空的可变变量，可以在初始化之前使用。
- `data`：声明一个数据类。
- `sealed`：密封类，限制类的继承。

## 智能转换

- `smartcast`：Kotlin 类型系统的一部分，允许在某些条件下自动转换变量的类型。

---

## 关键字`expect`和`actual`

在Kotlin中，`actual` 是一个与平台特定实现相关的关键字，它主要用于多平台项目中。Kotlin/Native和Kotlin/JVM等不同的Kotlin平台可以共享相同的Kotlin代码，但有时需要为不同的平台提供特定的实现。为了解决这个问题，Kotlin引入了`expect`和`actual`这两个关键字。

- `expect` 关键字用于声明一个期望的声明，它告诉编译器在某个平台上会有一个对应的实际实现。这通常用于库的开发中，库作者会定义一些接口或抽象类，并标记为`expect`，以便在不同的平台上提供具体的实现。

- `actual` 关键字则用于提供`expect`声明的具体实现。对于每个平台，你都可以使用`actual`关键字来提供该平台上特定的实现。

这里有一个简单的例子来说明`expect`和`actual`的用法：

```kotlin
// 定义一个期望的接口，这个接口在不同的平台上会有不同的实现
expect fun platformSpecificFunction(): String

// 在JVM平台上的实际实现
actual fun platformSpecificFunction(): String {
    // JVM平台上的具体实现
    return "This is JVM implementation"
}

// 在Native平台上的实际实现（假设有一个对应的源文件）
// actual fun platformSpecificFunction(): String {
//     // Native平台上的具体实现
//     return "This is Native implementation"
// }
```

在这个例子中，`platformSpecificFunction`是一个期望的函数，它在不同的平台上会有不同的实现。在JVM平台上，我们提供了一个返回字符串"This is JVM implementation"的实际实现。对于Native平台，我们也会在相应的源文件中提供一个返回不同字符串的实际实现（在这个例子中，Native平台的实现被注释掉了，但你可以想象它存在并且与JVM平台的实现不同）。

需要注意的是，`expect`和`actual`关键字主要用于Kotlin的多平台项目中，并且它们通常与`@file:JvmName`、`@file:JvmMultifileClass`等注解一起使用，以便更好地控制生成的字节码和Java类的结构。此外，`expect`和`actual`还可以用于类、对象、类型别名和顶层属性的声明中。

总之，`actual`关键字在Kotlin多平台项目中扮演着提供具体实现的重要角色，它与`expect`关键字一起使用，使得开发者能够为不同的平台提供定制化的代码实现。

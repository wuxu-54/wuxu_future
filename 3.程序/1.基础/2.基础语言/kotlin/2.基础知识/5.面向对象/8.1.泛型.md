# 泛型

Kotlin 的泛型系统是一种支持类型参数化的强大特性，它允许在定义类、接口、函数和类型别名时使用占位符类型（称为类型参数）。泛型提供了编译时类型安全，并允许代码重用。

## 泛型类

泛型类使用类型参数来定义，这些类型参数在类的实例化时可以被具体类型替代。

```kotlin
class Box<T>(t: T) {
    var value = t
}

fun main() {
    val boxInt = Box<Int>(1)
    val boxString = Box<String>("Hello")
    println(boxInt.value) // 输出 1
    println(boxString.value) // 输出 Hello
}
```

在这个例子中，`Box` 是一个泛型类，它有一个类型参数 `T`。这个类型参数用于定义 `value` 属性的类型。

## 泛型函数

泛型函数可以定义类型参数，这些参数在函数调用时被指定。

```kotlin
fun <T> identity(value: T): T {
    return value
}

fun main() {
    val resultInt = identity(42)
    val resultString = identity("Hello")
    println(resultInt) // 输出 42
    println(resultString) // 输出 Hello
}
```

在这个例子中，`identity` 是一个泛型函数，它接受一个类型参数 `T` 并返回相同类型的值。

## 泛型接口

泛型接口允许定义类型参数，这些参数在实现接口时被指定。

```kotlin
interface Producer<out T> {
    fun produce(): T
}

class IntegerProducer : Producer<Int> {
    override fun produce(): Int = 42
}

class StringProducer : Producer<String> {
    override fun produce(): String = "Hello"
}

fun main() {
    val intProducer = IntegerProducer()
    val stringProducer = StringProducer()
    println(intProducer.produce()) // 输出 42
    println(stringProducer.produce()) // 输出 Hello
}
```

在这个例子中，`Producer` 是一个泛型接口，它定义了一个类型参数 `T`。`IntegerProducer` 和 `StringProducer` 是实现 `Producer` 接口的具体类，它们分别生产 `Int` 和 `String` 类型的值。

## 类型参数的约束

在定义泛型时，可以对类型参数施加约束，以限制它们可以被哪些类型替代。

```kotlin
fun <T> printList(list: List<T>) {
    for (item in list) {
        println(item)
    }
}

fun main() {
    val intList = listOf(1, 2, 3)
    val stringList = listOf("Hello", "World")
    printList(intList) // 正确
    printList(stringList) // 正确
}
```

在这个例子中，`printList` 函数接受一个 `List<T>` 类型的参数，其中 `T` 没有特定的约束。

## 泛型的类型投影

在 Kotlin 中，可以使用类型投影来指定泛型类型的边界。

- **星号投影**（`*`）：表示对类型参数没有任何信息。当你不确定泛型类型参数的具体变体时，可以使用星投影（如 `Producer<*>` 或 `Consumer<*>`），但要注意星投影会丢失一些类型信息。
- **in 投影**：表示类型参数是逆变的，父类赋值给子类，只能作为输入。等同于java中的`<? super 某个子类>`  
- **out 投影**：表示类型参数是协变的，子类赋值给父类，只能作为输出。等同于java中的`<? extends 某个超类>`

>关于逆变和协变请看java篇[逆变与协变](../../../java/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/4.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.%E6%B3%9B%E5%9E%8B/1.%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98.md)

```kotlin
fun <T> copyWhenGreater Than(
    list: List<T>,
    threshold: T
): List<T> where T : Comparable<T> {
    return list.filter { it > threshold }
}

fun main() {
    val numbers = listOf(1, 5, 10, 15)
    val strings = listOf("a", "bb", "ccc")
    println(copyWhenGreaterThan(numbers, 5)) // 输出 [10, 15]
    println(copyWhenGreaterThan(strings, "a")) // 输出 [bb, ccc]
}
```

在这个例子中，`copyWhenGreaterThan` 函数使用 `where` 子句来约束类型参数 `T` 必须是 `Comparable` 类型的实例。

## 泛型的类型别名

可以使用泛型类型别名来简化泛型类型的声明。

```kotlin
typealias IntList = List<Int>
typealias StringMap = Map<String, String>

fun main() {
    val intList: IntList = listOf(1, 2, 3)
    val stringMap: StringMap = mapOf("key" to "value")
}
```

## 泛型的类型擦除

在 Kotlin 中，泛型在运行时会被擦除到它们的边界或 `Any?`。这意味着泛型信息在运行时是不可用的。

## 泛型的使用场景

泛型在多种场景下非常有用，例如：

- 定义通用的数据结构，如集合类。
- 创建灵活的函数，可以处理不同类型的数据。
- 实现泛型接口和抽象类，以提供类型安全的组件。

泛型是 Kotlin 语言的核心特性之一，它提供了强大的类型安全和代码重用能力。

# 封装

在 Kotlin 中，封装是一种面向对象编程的基本原则，它指的是将数据（属性）和能够操作这些数据的方法（函数）组合在一起，并隐藏内部实现的细节。封装有助于提高代码的安全性和可维护性，同时减少系统中各部分之间的耦合。

以下是 Kotlin 中实现封装的一些关键概念和实践：

## 1. 私有属性和方法

在 Kotlin 中，你可以使用 `private` 修饰符来限制类成员的可见性，使得它们只能在定义它们的类内部访问。

```kotlin
class Person {
    private var _age: Int = 0

    fun setAge(age: Int) {
        if (age > 0) {
            _age = age
        }
    }

    fun getAge(): Int {
        return _age
    }
}
```

在这个例子中，`_age` 属性是私有的，外部代码不能直接访问它，而是通过 `setAge` 和 `getAge` 方法来修改和获取年龄。

## 2. 属性访问器

Kotlin 允许你为属性定义自定义的访问器（getter 和 setter），这可以用来控制属性的读取和赋值操作。

```kotlin
class Person(var name: String) {
    var nickname: String = ""
        get() = field.toUpperCase()
        set(value) {
            field = value.toLowerCase()
        }
}
```

在这个例子中，`nickname` 属性的 getter 将其转换为大写，而 setter 将其转换为小写。

## 3. 构造函数

Kotlin 的类可以有一个主构造函数和多个次构造函数。主构造函数的参数默认是 `private` 的，而次构造函数可以提供不同的初始化方式。

```kotlin
class Person private constructor(val name: String, var age: Int) {
    constructor(name: String) : this(name, 0) {
        // 初始化代码
    }
}
```

## 4. 伴生对象

伴生对象（Companion Object）是一种特殊的单例对象，它与类共享相同的名称空间，并且可以访问类的私有成员。

```kotlin
class Person {
    companion object {
        const val MAX_AGE = 100
    }
}
```

## 5. 扩展函数

扩展函数允许你为现有类添加新的方法，而不需要修改原始类。它们不是封装的一部分，但提供了一种在不破坏封装的情况下扩展功能的方式。

```kotlin
fun Person.greet() {
    println("Hello, my name is $name.")
}

fun main() {
    val person = Person("John")
    person.greet()
}
```

## 6. 数据类

数据类是 Kotlin 中用于存储数据的特化类，它们自动为所有属性生成 `equals()`、`hashCode()` 和 `toString()` 方法。

```kotlin
data class Person(val name: String, var age: Int)
```

## 7. 封装的最佳实践

- 尽可能使属性私有。
- 使用访问器来控制对属性的访问。
- 为类提供公共接口，如函数和属性，以允许受控的访问和操作。
- 避免使用 `public` 或 `open` 修饰符，除非你确实需要公开某个成员。

通过这些方法，Kotlin 支持强大的封装机制，使得代码更加安全、模块化和易于维护。

---

## 访问权限控制

在 Kotlin 中，访问权限控制是面向对象编程的一个重要方面，它决定了类、接口、函数、属性和其他声明的可见性和可访问性。Kotlin 提供了四种访问权限修饰符：`private`、`protected`、`internal` 和无修饰符（默认访问权限）。

### 1. private

- **访问限制**：仅在声明它的文件内可见。
- **使用场景**：当你想限制某个函数或属性只能在当前文件内被访问时使用。

```kotlin
class Outer {
    private val a = 1

    fun test() {
        println(a) // 可以访问
    }
}

fun test() {
    println(Outer().a) // 编译错误：'a' is private in 'Outer'
}
```

### 2. protected

- **访问限制**：在同一个类以及它的子类中可见。
- **使用场景**：当你想允许子类访问父类的某些成员时使用。

```kotlin
open class Base {
    protected val b = 2
}

class Derived : Base() {
    fun test() {
        println(b) // 可以访问
    }
}

fun test() {
    println(Base().b) // 编译错误：'b' is protected in 'Base'
}
```

### 3. internal

- **访问限制**：在同一个模块内可见。
- **使用场景**：当你想限制成员只能在当前模块内被访问时使用。

```kotlin
class MyClass {
    internal val c = 3
}

fun test() {
    println(MyClass().c) // 可以访问，如果 'test' 在同一个模块内
}
```

### 4. 默认访问权限（无修饰符）

- **访问限制**：在同一个包内可见，对于子类没有限制。
- **使用场景**：当你想在同一个包内允许自由访问，但不想公开 API 时使用。

```kotlin
class MyClass {
    val d = 4
}

fun test() {
    println(MyClass().d) // 可以访问，如果 'test' 在同一个包内
}
```

### 5. public

- **访问限制**：无限制，任何地方都可以访问。
- **使用场景**：当你想公开 API 或确保成员可以被任何代码访问时使用。

```kotlin
class MyClass {
    public val e = 5
}

fun test() {
    println(MyClass().e) // 可以访问，任何地方都可以
}
```

### 注意事项

- 在 Kotlin 中，顶层声明（不在类或对象内部的函数和属性）不能被声明为 `protected`。
- `internal` 修饰符在 Kotlin 中是独特的，它提供了模块级别的访问控制，这在 Java 中是没有的。
- 访问权限修饰符对于理解代码的组织结构和维护代码的封装性非常重要。

通过合理使用访问权限控制，你可以保护类的内部状态，同时提供必要的接口供外部使用，从而提高代码的安全性和可维护性。

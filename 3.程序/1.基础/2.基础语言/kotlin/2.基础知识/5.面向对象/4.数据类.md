# 数据类

在 Kotlin 中，数据类（Data Class）是一种特殊的类，它主要用于存储数据。当你创建一个数据类时，Kotlin 会自动为你生成 `equals()`、`hashCode()` 和 `toString()` 方法，这些方法是基于类中声明的所有主构造函数的参数生成的。这使得数据类的使用非常方便，尤其是在需要比较对象或打印对象信息时。

以下是数据类的一些关键特性和用法：

## 定义数据类

使用 `data class` 关键字来定义一个数据类：

```kotlin
data class Person(val name: String, var age: Int)
```

在这个例子中，`Person` 是一个数据类，它有两个属性：`name` 和 `age`。`val` 关键字表示 `name` 是一个不可变属性，而 `var` 关键字表示 `age` 是一个可变属性。

## 自动生成的方法

当你定义一个数据类时，Kotlin 会自动为你生成以下方法：

- `equals()`
- `hashCode()`
- `toString()`

这些方法是基于数据类的所有主构造函数参数生成的。

## 拷贝功能

Kotlin 还为数据类提供了一个 `copy()` 函数，它允许你创建数据对象的副本，并在必要时修改一些属性：

```kotlin
val person = Person("John", 30)
val newPerson = person.copy(age = 31)
```

在这个例子中，`newPerson` 是 `person` 的一个副本，但 `age` 属性被修改为 31。

## 组件和解构

数据类允许你使用 `componentN()` 函数和解构声明来轻松访问属性：

```kotlin
val (name, age) = person
```

这行代码将 `person` 对象的 `name` 和 `age` 属性分别赋值给 `name` 和 `age` 变量。

## 数据类的限制

- 数据类不能包含任何 `abstract` 函数。
- 数据类的所有属性都必须是可计算的（即它们必须有初始值）。
- 数据类可以有自定义的 `equals()`、`hashCode()` 或 `toString()` 方法，但要遵循规则，重写`equals()`时必须同时重新hasCode`()`。

## 示例

```kotlin
data class Person(val name: String, var age: Int)

fun main() {
    val person = Person("John Doe", 30)
    println(person) // 输出：Person(name=John Doe, age=30)

    val copyOfPerson = person.copy(name = "Jane Doe")
    println(copyOfPerson) // 输出：Person(name=Jane Doe, age=30)

    val (name, age) = person
    println("Name: $name, Age: $age") // 输出：Name: John Doe, Age: 30
}
```

数据类是 Kotlin 中一个非常实用的功能，它简化了数据存储和处理的代码，使得代码更加简洁和易于维护。

---

## 补充

在 Kotlin 中，**数据类（data class）是可以有自定义的 `equals()`、`hashCode()` 或 `toString()` 方法的**，但需要遵循特定的规则。以下是详细说明：

### **一、数据类的自动生成方法**

数据类默认会由编译器自动生成以下方法：

1. **`equals()` 和 `hashCode()`**：基于所有主构造函数的属性进行比较和哈希计算。
2. **`toString()`**：格式为 `类名(属性1=值, 属性2=值, ...)`。
3. **`copy()` 函数**：用于创建数据类的副本。
4. **解构声明**：支持通过 `val (a, b) = 数据类实例` 提取属性值。

**示例**：

```kotlin
data class User(val name: String, val age: Int)
// 自动生成的 toString() 类似：User(name=Alice, age=30)
```

### **二、自定义方法的规则**

#### **1. 重写 `equals()` 和 `hashCode()`**

- **规则**：若要自定义 `equals()`，必须同时重写 `hashCode()`，否则会编译报错（遵循 Kotlin 的 `equals-hashCode` 约定）。
- **原因**：Java/Kotlin 的 `equals()` 和 `hashCode()` 需要保持一致性（相等的对象必须具有相同的哈希码）。
- **示例**：

  ```kotlin
  data class User(val name: String, val age: Int) {
      // 自定义 equals 和 hashCode（需同时重写）
      override fun equals(other: Any?): Boolean {
          if (this === other) return true
          if (other !is User) return false
          // 仅比较 name，忽略 age
          return name == other.name
      }

      override fun hashCode(): Int {
          return name.hashCode() // 根据 name 计算哈希码
      }

      // 若不重写 hashCode()，会报错：
      // "Must override hashCode() if equals() is overridden"
  }
  ```

#### **2. 重写 `toString()`**

- **规则**：可自由重写 `toString()`，无需遵循任何强制约定。
- **示例**：

  ```kotlin
  data class User(val name: String, val age: Int) {
      override fun toString(): String {
          return "User(name='$name')" // 仅显示 name
      }
  }

  // 使用时：
  val user = User("Alice", 30)
  println(user) // 输出：User(name='Alice')
  ```

### **三、注意事项**

1. **自动生成方法的优先级**：  
   一旦手动重写了某个方法（如 `equals()`），编译器将不再生成对应的自动实现，需完全由开发者负责逻辑。

2. **与解构声明的兼容性**：  
   若重写了 `equals()` 和 `hashCode()`，需确保属性的逻辑与解构行为一致（通常建议保留主构造函数的属性作为核心标识）。

3. **数据类的不可变性**：  
   数据类通常用于表示不可变数据，自定义方法时应避免破坏这一语义（例如，不要在 `equals()` 中引入可变状态）。

### **四、总结**

- **原说法错误**：Kotlin 数据类**允许自定义** `equals()`、`hashCode()` 和 `toString()` 方法。
- **关键限制**：重写 `equals()` 时必须同时重写 `hashCode()`，以满足语言规范。
- **最佳实践**：若无需复杂逻辑，建议使用数据类的自动生成方法；如需自定义，需确保方法逻辑正确且符合语义。

通过合理重写这些方法，可灵活适配业务需求（如自定义对象相等规则、优化日志输出等）。

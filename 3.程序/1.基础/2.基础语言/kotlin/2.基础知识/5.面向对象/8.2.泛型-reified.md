# 泛型-reified

在 Kotlin 中，`reified`（具象化类型参数）是一个与**内联函数（inline functions）** 结合使用的关键字，用于解决 JVM 泛型擦除带来的限制，允许在运行时访问泛型的具体类型信息。下面通过对比、原理、用法和限制详细解释：

---

## 一、问题背景：泛型擦除（Type Erasure）

在 JVM 中，泛型信息在编译后会被擦除（例如 `List<String>` 会变成 `List<Any?>`）。这导致：

```kotlin
fun <T> checkType(obj: Any) {
    if (obj is T) { ... } // 错误：Cannot check for instance of erased type: T
}
```

---

## 二、`reified` 的解决方案

通过 `reified + inline` 组合，编译器会将泛型类型替换为实际类型，保留运行时类型信息：

```kotlin
inline fun <reified T> checkType(obj: Any) {
    if (obj is T) { ... } // 正确：T 在运行时可知
}
```

---

## 三、核心原理

1. **内联函数（inline）**：函数体直接嵌入调用处，避免函数调用开销。
2. **具象化（reified）**：编译器用**实际类型替换泛型参数**，生成具体化的字节码。

例如：

```kotlin
checkType<String>("Hello") // 编译后：生成检查 obj is String 的代码
```

---

## 四、主要用途

### 1. 类型检查（`is`）和转换（`as`）

```kotlin
inline fun <reified T> isInstanceOf(obj: Any): Boolean {
    return obj is T
}

println(isInstanceOf<String>("Kotlin")) // true
```

### 2. 获取类对象（`T::class`）

```kotlin
inline fun <reified T> getTypeName(): String {
    return T::class.simpleName ?: "Unknown"
}

println(getTypeName<List<String>>()) // 输出：List
```

### 3. 依赖具体类型的逻辑

```kotlin
inline fun <reified T> parseJson(json: String): T {
    val type = object : TypeToken<T>() {}.type // Gson 需要类型
    return Gson().fromJson(json, type)
}

val user = parseJson<User>(jsonString) // 直接返回 User 对象
```

### 4. Android 的 Intent 启动

```kotlin
inline fun <reified T : Activity> Context.startActivity() {
    startActivity(Intent(this, T::class.java))
}

// 调用
startActivity<MainActivity>()
```

---

## 五、使用限制

1. **必须与 `inline` 函数一起使用**：普通函数无法使用 `reified`。
2. **不能用于普通类或属性**：

   ```kotlin
   class Box<reified T> { ... } // 错误：Not allowed
   ```

3. **类型需在调用处显式或推导确定**：

   ```kotlin
   val list = listOf(1, 2, 3)
   isInstanceOf<List<Int>>(list) // 必须显式指定泛型类型
   ```

---

## 六、底层实现（反编译 Java 代码）

Kotlin 代码：

```kotlin
inline fun <reified T> printType() {
    println(T::class.java)
}
```

反编译后的 Java 伪代码：

```java
// 每次调用生成一个独立函数
public static final void printType(Class<?> T) {
    System.out.println(T);
}

// 调用处
printType(String.class); // 直接传入 String.class
```

---

## 七、实际应用场景

1. **JSON 反序列化工具**（如 Moshi、Gson 的封装）
2. **依赖注入框架**（获取具体类信息）
3. **Activity 跳转简化**（免传 `Class` 对象）
4. **类型安全的 Adapter 或 Factory 模式**

---

## 总结

| 特性          | 说明                                                                 |
|---------------|----------------------------------------------------------------------|
| **解决问题**   | 泛型擦除导致运行时无法获取类型信息                                     |
| **组合关键字** | `inline fun` + `<reified T>`                                          |
| **核心能力**   | 运行时访问泛型类型（`is`/`as`/`T::class`）                            |
| **使用场景**   | 类型检查、反射、序列化、Android 跳转等                                |
| **限制**       | 仅限内联函数、无法用于类/属性、类型需在调用时确定                      |

通过 `reified`，Kotlin 在编译期智能生成类型代码，为泛型提供了更安全的运行时操作能力，是 Kotlin 类型系统的重要补充。

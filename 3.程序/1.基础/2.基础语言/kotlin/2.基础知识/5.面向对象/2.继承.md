# 继承

在 Kotlin 中，继承是一种面向对象编程的核心概念，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。Kotlin 支持类继承，但与 Java 不同，Kotlin 没有接口（interface）和抽象类（abstract class）之间的区别，它使用接口来实现多重继承。

## 基本继承

在 Kotlin 中，你可以通过在类名前使用 `:` 符号后跟父类名来实现继承。

```kotlin
open class Animal(val name: String) {
    open fun speak() {
        println("$name makes a noise.")
    }
}

class Dog(name: String) : Animal(name) {
    override fun speak() {
        println("$name barks.")
    }
}

fun main() {
    val dog = Dog("Buddy")
    dog.speak() // 输出 "Buddy barks."
}
```

在这个例子中，`Dog` 类继承了 `Animal` 类，并重写了 `speak` 方法。

## 构造函数继承

子类的构造函数可以通过 `super` 关键字调用父类的构造函数。

```kotlin
class Cat(name: String) : Animal(name) {
    init {
        println("A cat named $name is created.")
    }
}

fun main() {
    val cat = Cat("Whiskers")
    // 输出 "A cat named Whiskers is created."
    // 然后输出 "Whiskers makes a noise."
}
```

## 重写方法

子类可以使用 `override` 关键字重写父类的方法。

```kotlin
class Bird(name: String) : Animal(name) {
    override fun speak() {
        println("$name tweets.")
    }
}
```

## 属性重写

子类也可以重写父类的属性。

```kotlin
open class Animal(val name: String)

class Dog(name: String) : Animal(name) {
    override val name: String = "Rover"
}
```

## 访问修饰符

- `open` 关键字：允许类被继承，并且类中的方法和属性可以被重写。
- `final` 关键字：阻止类被继承，或者阻止方法和属性被重写。

```kotlin
final class Sheep {
    // 这个类不能被继承
}

open class Animal(val name: String) {
    open fun speak() {
        // 这个方法可以被重写
    }
}

class Horse(name: String) : Animal(name) {
    final override fun speak() {
        // 这个方法不能被进一步重写
    }
}
```

## 多重继承

虽然 Kotlin 不允许直接多重继承类，但可以通过接口实现类似的功能。

```kotlin
interface Flyable {
    fun fly()
}

interface Swimmable {
    fun swim()
}

class Duck(name: String) : Animal(name), Flyable, Swimmable {
    override fun fly() {
        println("$name is flying.")
    }

    override fun swim() {
        println("$name is swimming.")
    }

    override fun speak() {
        println("$name quacks.")
    }
}
```

在这个例子中，`Duck` 类实现了 `Flyable` 和 `Swimmable` 接口，从而获得了多重继承的效果。

## 伴生对象和继承

Kotlin 允许使用伴生对象（companion object）来提供静态方法和属性，但伴生对象不支持继承。（等同于java中的静态方法、静态变量。看编译成的.class文件，其实就是static标记的）

```kotlin
class Animal {
    companion object {
        fun newAnimal(name: String): Animal {
            return Animal(name)
        }
    }
}

fun main() {
    val animal = Animal.newAnimal("Leo")
}
```

继承是 Kotlin 中一个强大的特性，它允许你创建可重用和可扩展的代码。通过合理使用继承，你可以构建出清晰和高效的类层次结构。

---

## open、final在继承中的作用

在 Kotlin 中，`open` 和 `final` 关键字在类和成员（如方法和属性）的继承中扮演着不同的角色：

### open 关键字

- **类**：当一个类被声明为 `open` 时，它允许被其他类继承。如果没有使用 `open` 关键字，类默认是封闭的，不能被继承。
- **成员**：当一个类的成员（方法或属性）被声明为 `open` 时，它允许在子类中被重写。如果成员不是 `open` 的，那么它不能在子类中被重写。

### final 关键字

- **类**：在 Kotlin 中，使用 `final` 关键字来声明一个类是不必要的，因为默认情况下，所有类都是封闭的，不能被继承。`final` 关键字在类上没有实际作用，因为 Kotlin 的设计哲学是默认封闭类，以避免 Java 那样的继承滥用问题。
- **成员**：当一个类的成员被声明为 `final` 时，它不能在子类中被重写。这通常用于库的设计中，当你希望确保某个方法或属性的行为在继承链中保持一致时。

### 示例

```kotlin
// 一个可继承的开放类
open class Animal {
    open fun speak() {
        println("The animal makes a sound")
    }
}

// 一个继承 Animal 并重写 speak 方法的子类
class Dog : Animal() {
    override fun speak() {
        println("The dog barks")
    }
}

// 一个封闭的类，不能被继承
class Cat {
    fun speak() {
        println("The cat meows")
    }
}

// 一个成员被声明为 final，不能被重写
open class Bird {
    final fun fly() {
        println("The bird flies")
    }
}

// 尝试重写 final 方法将导致编译错误
class Parrot : Bird() {
    // override fun fly() {  // 这将导致编译错误
    //     println("The parrot flies differently")
    // }
}
```

在这个例子中，`Animal` 是一个开放类，可以被继承，并且它的 `speak` 方法可以被重写。`Cat` 是一个默认封闭的类，不能被继承。`Bird` 类中的 `fly` 方法被声明为 `final`，因此它不能在子类 `Parrot` 中被重写。

总结来说，`open` 关键字用于开启类的继承性和成员的可重写性，而 `final` 关键字用于阻止成员的重写，以确保库的使用者不能改变某些行为。在类级别，`final` 关键字没有实际作用，因为 Kotlin 默认不允许继承。

# 多态

在 Kotlin 中，多态是一种面向对象编程的特性，它允许你使用一个接口来引用不同类型的对象，并在运行时确定对象的实际类型。多态使得同一个操作可以作用于不同的对象类型上，而具体的行为则取决于对象的实际类型。

Kotlin 支持两种主要的多态形式：

1. **子类型多态**：这是最常见的多态形式，它允许子类对象被视为其父类或接口类型的实例。

2. **委托多态**：通过使用委托，可以将一个对象的方法调用转发给另一个对象。

## 子类型多态

在 Kotlin 中，子类可以重写父类的方法，这使得父类的引用可以指向子类的对象，从而在运行时表现出多态性。

```kotlin
open class Animal {
    open fun sound() {
        println("Some sound")
    }
}

class Dog : Animal() {
    override fun sound() {
        println("Woof!")
    }
}

class Cat : Animal() {
    override fun sound() {
        println("Meow")
    }
}

fun makeSound(animal: Animal) {
    animal.sound()
}

fun main() {
    val myDog = Dog()
    val myCat = Cat()
    makeSound(myDog) // 输出: Woof!
    makeSound(myCat) // 输出: Meow
}
```

在这个例子中，`Animal` 是一个父类，`Dog` 和 `Cat` 是子类。`makeSound` 函数接受一个 `Animal` 类型的参数，但是它可以接收任何 `Animal` 的子类对象。

## 委托多态

委托多态涉及到使用委托模式，其中一个对象将方法调用委托给另一个对象。

```kotlin
class Engine(val power: Int)

class Car(val brand: String, engine: Engine) {
    var engine: Engine by Delegates.observable(engine) { _, old, new ->
        println("Engine changed from $old to $new")
    }
}

fun main() {
    val engine = Engine(120)
    val car = Car("Toyota", engine)
    car.engine = Engine(150) // 输出: Engine changed from Engine(power=120) to Engine(power=150)
}
```

在这个例子中，`Car` 类的 `engine` 属性使用了 `Delegates.observable` 委托，这样当 `engine` 属性的值发生变化时，会打印出变化的信息。

## 泛型多态

Kotlin 还支持泛型多态，允许你编写与具体类型无关的代码。

```kotlin
fun <T> printList(list: List<T>) {
    for (item in list) {
        println(item)
    }
}

fun main() {
    printList(listOf(1, 2, 3)) // 整型列表
    printList(listOf("a", "b", "c")) // 字符串列表
}
```

在这个例子中，`printList` 函数接受一个 `List<T>` 类型的参数，它可以处理任何类型的列表。

多态是 Kotlin 中一个强大的特性，它提高了代码的灵活性和可重用性，使得同一个函数或操作可以适用于不同的对象类型。

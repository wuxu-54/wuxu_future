# 委托

在 Kotlin 中，委托（Delegation）是一种设计模式，它允许一个类（称为委托类）将某些任务转发给另一个对象（称为委托对象）。这种模式增强了代码的复用性和灵活性，使得可以在运行时动态地改变对象的行为。

Kotlin 提供了几种委托方式：

## 1. 属性委托

属性委托允许你将属性的获取和设置操作委托给一个对象。Kotlin 标准库中提供了一些实用的委托类，如 `lazy`、`observable`、`vetoable` 等。

```kotlin
val propertyName: String by Delegates.notNull()
```

这里，`Delegates.notNull()` 是一个委托，它确保属性不会设置为 `null`。

## 2. 函数委托

函数委托允许你将函数调用转发给另一个对象。

```kotlin
class MyClass {
    var _value: Int = 0
    fun getValue(): Int {
        return _value
    }
}

fun main() {
    val myObject by MyClass()
    println(myObject.getValue()) // 输出：0
}
```

在这个例子中，`myObject` 委托给 `MyClass` 的实例，可以直接调用 `getValue()` 函数。

## 3. 委托模式

Kotlin 支持传统的委托模式，你可以创建一个自定义的委托类来实现复杂的逻辑。

```kotlin
class DelegationExample {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "$thisRef, thank you for delegating '${property.name}' to me!"
    }

    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        println("$value has been assigned to '${property.name}' in $thisRef.")
    }
}

fun main() {
    val delegatedProperty = DelegationExample()
    val a by delegatedProperty
    println(a) // 输出：null, thank you for delegating 'a' to me!
    delegatedProperty["Hello"] = "World"
}
```

在这个例子中，`DelegationExample` 是一个委托类，它实现了 `getValue` 和 `setValue` 操作符函数。

## 4. 委托属性

Kotlin 允许你使用 `by` 语法来声明委托属性。

```kotlin
class User(val name: String) {
    var _age: Int = 0
        get() = field
        set(value) {
            if (value > 0) field = value
        }
}

val user = User("John")
val age: Int by user::_age
```

在这个例子中，`age` 属性委托给 `User` 对象的 `_age` 属性。

## 5. 委托实现接口

你可以使用委托来实现接口，这在实现设计模式时非常有用。

```kotlin
interface Printable {
    fun print()
}

class Printer : Printable {
    override fun print() {
        println("Printing document...")
    }
}

fun main() {
    val printer = Printer()
    val document by printer
    document.print() // 输出：Printing document...
}
```

在这个例子中，`document` 委托给 `Printer` 对象，并调用其 `print()` 方法。

委托是 Kotlin 中一个非常强大的特性，它允许你在不增加类数量的情况下扩展类的行为。通过委托，你可以编写更简洁、更灵活的代码。

# 类

在 Kotlin 中，类（Class）是对象（Object）的蓝图，它定义了对象的状态（属性）和行为（方法）。以下是 Kotlin 类的一些关键特性和详细说明：

## 类的基本结构

```kotlin
class ClassName(primaryConstructorParameters) : SuperclassName {
    // 属性
    val propertyName: PropertyType = propertyInitializer

    // 构造函数
    constructor(constructorParameters) : this(primaryConstructorParameter) {
        // 构造函数体
    }

    // 方法
    fun methodName(parameters): ReturnType {
        // 方法体
    }
}
```

## 构造函数

- **主构造函数**：在类名后面的括号内定义，不能有访问修饰符和返回类型。
- **次构造函数**：使用 `constructor` 关键字定义，可以有参数，可以调用主构造函数或另一个次构造函数。

## 属性

- **val**：定义一个只读属性。
- **var**：定义一个可变属性。

## 方法

- 使用 `fun` 关键字定义方法。
- 方法可以有参数，可以返回值。

## 继承

- 使用 `:` 指定超类。
- 子类可以重写（override）超类的方法。

## 抽象类

- 使用 `abstract` 关键字定义抽象类，不能实例化。
- 抽象类可以有抽象方法，没有实现体。

## 接口

- 使用 `interface` 关键字定义接口。
- 接口可以包含常量、抽象方法和默认方法。

## 数据类

- 使用 `data` 关键字定义数据类，通常用于存储数据。
- 数据类自动生成 `equals()`、`hashCode()` 和 `toString()` 方法。

## 枚举类

- 使用 `enum` 关键字定义枚举类。
- 枚举类是特殊的单例类，每个枚举实例都是唯一的。

## 嵌套类

- 类内部可以定义其他类，称为嵌套类。

## 伴生对象

- 使用 `companion object` 定义伴生对象，它与外部类共享相同的名称空间。

### 伴生对象的init

在 Kotlin 里，`companion object { init {} }` 中的 `init` 块被称作伴生对象初始化块，下面详细介绍其含义、用途和相关特性。

#### 含义

`companion object` 表示伴生对象，它是类的一个特殊成员，与类相关联但独立于类的实例存在，类似于 Java 中的静态成员。而 `init` 块则是用于初始化伴生对象的代码块，当伴生对象被首次访问时，`init` 块中的代码会被执行。

#### 用途

- **初始化伴生对象的属性**：可以在 `init` 块里对伴生对象的属性进行初始化操作，这些属性可以是常量或者需要进行复杂计算的变量。
- **执行一次性的初始化逻辑**：当伴生对象需要在首次使用时执行一些一次性的初始化操作，例如加载配置文件、建立数据库连接等，就可以把这些逻辑放在 `init` 块中。

#### 示例代码

```kotlin
class MyClass {
    companion object {
        // 定义伴生对象的属性
        lateinit var configValue: String

        // 伴生对象的初始化块
        init {
            println("Companion object is being initialized.")
            // 初始化属性
            configValue = "Some configuration value"
        }

        // 伴生对象的方法
        fun printConfigValue() {
            println("Config value: $configValue")
        }
    }
}

fun main() {
    // 首次访问伴生对象的方法，触发 init 块的执行
    MyClass.printConfigValue()
}
```

#### 代码解释

1. **`companion object`**：在 `MyClass` 类中定义了一个伴生对象，它包含了一个属性 `configValue`、一个初始化块 `init` 和一个方法 `printConfigValue`。
2. **`init` 块**：当首次访问伴生对象的任何成员（如 `printConfigValue` 方法）时，`init` 块会被执行，打印出初始化信息并对 `configValue` 属性进行初始化。
3. **`main` 函数**：在 `main` 函数中调用 `MyClass.printConfigValue()` 方法，由于这是首次访问伴生对象的成员，所以 `init` 块会先执行，然后再执行 `printConfigValue` 方法，最终输出配置值。

#### 注意事项

- **执行时机**：`init` 块只会在伴生对象首次被访问时执行一次，后续再次访问伴生对象的成员时，`init` 块不会再次执行。
- **访问权限**：`init` 块可以访问伴生对象的所有属性和方法，也可以访问类的静态属性和方法（在 Kotlin 中通过伴生对象实现）。

---

## 属性委托

- 使用 `by` 关键字实现属性委托，可以将属性的存储和访问委托给其他对象。

## 扩展函数

- 使用 `fun ClassName.extensionFunction()` 定义扩展函数，为现有类添加新的方法。

## 属性和方法的可见性

- 使用 `public`、`private`、`protected` 和 `internal` 关键字指定成员的可见性。

## 类的实例化

- 使用 `ClassName()` 语法创建类的实例。

## 单例模式

- 使用 `object` 关键字定义单例类。

## 内联类

- 使用 `inline` 关键字定义内联类，它们在编译时会被插入到使用它们的地方。

## 密封类

- 使用 `sealed` 关键字定义密封类，限制类的继承。

## 泛型

- 类和函数可以使用类型参数，支持泛型编程。

## 例子

```kotlin
class Person(val name: String, var age: Int) {
    fun greet() {
        println("Hello, my name is $name and I am $age years old.")
    }

    companion object {
        const val MAX_AGE = 100
    }
}

fun main() {
    val person = Person("John Doe", 30)
    person.greet()
    println("Max age is ${Person.MAX_AGE}")
}
```

Kotlin 的类设计非常灵活，支持现代编程语言的许多特性，如数据类、伴生对象、扩展函数等，使得代码更加简洁和易于维护。

---

## 内联类详解

在 Kotlin 中，内联类（Inline class）是一种特殊的类，它允许将类类型的值作为基本类型来处理。内联类的主要目的是提供一种方式，使得在编译时可以替换类实例为它们所包含的底层值，这样可以减少对象的创建和内存占用，同时提高性能。

要定义一个内联类，你需要在类定义前加上 `inline` 关键字。内联类只能有一个主构造函数，并且这个构造函数只能有一个属性。这个属性的类型将被用作内联类的底层类型。

下面是一个内联类的例子：

```kotlin
inline class Username(val name: String)

fun main() {
    val user = Username("Kimi")
    println(user.name)  // 访问内联类的属性
}
```

在这个例子中，`Username` 是一个内联类，它有一个名为 `name` 的属性。当你创建 `Username` 类的实例时，实际上你创建的是一个包含 `String` 值的实例。

### 内联类的使用场景

1. **性能优化**：内联类可以减少对象创建的开销，因为它们在编译时会被替换为它们的底层值。
2. **数据传递**：在需要传递基本数据类型值时，使用内联类可以保持类型安全。
3. **API设计**：在设计库或API时，内联类可以用来隐藏实现细节，同时提供类型安全的接口。

### 内联类的注意事项

- 内联类不能有方法，除了主构造函数之外也不能有其他属性。
- 内联类不能是抽象的、密封的、枚举的或者数据类的。
- 内联类不能有伴生对象。
- 内联类不能实现接口。

内联类是 Kotlin 1.3 版本中引入的特性，它为性能敏感的应用程序提供了一种有效的数据传递方式。

---

## 密封类详解

在 Kotlin 中，密封类（Sealed Class）是一种特殊的类，它限制了类的继承结构，使得某个类只能由特定的几个子类继承。这种特性使得编译器能够检查所有可能的实例，从而在编译时提供更严格的控制。密封类在处理有限状态机、定义受限的枚举类型或者控制复杂的逻辑分支时非常有用。

### 定义密封类

要定义一个密封类，你需要使用 `sealed` 关键字：

```kotlin
sealed class Shape {
    class Circle : Shape()
    class Rectangle : Shape()
    class Square : Shape()
}
```

在这个例子中，`Shape` 是一个密封类，它有三个子类：`Circle`、`Rectangle` 和 `Square`。

### 使用密封类

由于密封类的子类数量是已知的，你可以在 `when` 表达式中使用它们：

```kotlin
fun describeShape(shape: Shape) = when (shape) {
    is Shape.Circle -> "This is a circle"
    is Shape.Rectangle -> "This is a rectangle"
    is Shape.Square -> "This is a square"
}
```

在这个例子中，`describeShape` 函数使用 `when` 表达式来检查 `shape` 参数的具体类型，并返回相应的描述。

### 密封类的子类

密封类的子类可以包含构造函数、属性和方法。它们也可以是数据类：

```kotlin
sealed class Shape {
    data class Circle(val radius: Double) : Shape()
    data class Rectangle(val width: Double, val height: Double) : Shape()
    data class Square(val side: Double) : Shape()
}
```

### 密封类的嵌套

密封类可以嵌套在其他类或密封类中：

```kotlin
class Geometry {
    sealed class Shape : Geometry() {
        data class Circle(val radius: Double) : Shape()
        data class Rectangle(val width: Double, val height: Double) : Shape()
        data class Square(val side: Double) : Shape()
    }
}
```

### 密封类的实现

在 Kotlin 中，密封类是通过特殊的字节码实现的，它们在运行时没有特殊的对象模型。编译器生成的代码会检查所有可能的子类，确保在 `when` 表达式中覆盖了所有情况。

### 密封类的限制

- 密封类不能是 `abstract` 的。
- 密封类的所有子类都必须在同一个源文件中定义，或者在同一个文件中的嵌套类中定义。

### 密封类与枚举

密封类和枚举都是 Kotlin 中用于表示有限集合的工具。枚举更适合表示没有复杂状态或行为的固定集合，而密封类提供了更多的灵活性，允许包含状态和行为。

### 总结

密封类是 Kotlin 中一个强大的特性，它允许你创建受控的类层次结构，并且可以在编译时提供更严格的检查。这使得它们在处理有限状态机或复杂逻辑分支时非常有用。

# Calendar

## 项目实际案例

```kotlin
enum class MsgDateType(val typeDesc: String) {
    MSG_DATE_TYPE_TODAY("今天"),
    MSG_DATE_TYPE_YESTERDAY("昨天"),
    MSG_DATE_TYPE_LAST_TWO_WEEKS("三天到两周"),
    MSG_DATE_TYPE_OLDER("更早")
}

private fun categorizeByDate() {
    val date = Date(ts)
    val calendar = Calendar.getInstance()
    calendar.time = date
    val today = Calendar.getInstance()
    val yesterday = Calendar.getInstance().apply { add(Calendar.DAY_OF_YEAR, -1) }
    val twoWeeksAgo = Calendar.getInstance().apply { add(Calendar.DAY_OF_YEAR, -14) }

    val messageYear = calendar.get(Calendar.YEAR)
    val messageMonth = calendar.get(Calendar.MONTH)
    val messageDay = calendar.get(Calendar.DAY_OF_MONTH)

    val todayYear = today.get(Calendar.YEAR)
    val todayMonth = today.get(Calendar.MONTH)
    val todayDay = today.get(Calendar.DAY_OF_MONTH)

    val yesterdayYear = yesterday.get(Calendar.YEAR)
    val yesterdayMonth = yesterday.get(Calendar.MONTH)
    val yesterdayDay = yesterday.get(Calendar.DAY_OF_MONTH)

    val twoWeeksAgoYear = twoWeeksAgo.get(Calendar.YEAR)
    val twoWeeksAgoMonth = twoWeeksAgo.get(Calendar.MONTH)
    val twoWeeksAgoDay = twoWeeksAgo.get(Calendar.DAY_OF_MONTH)

    val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
    val formattedDate = dateFormat.format(date)
    dateFormatString = formattedDate
    dateCategory = when {
        messageYear == todayYear && messageMonth == todayMonth && messageDay == todayDay -> MsgDateType.MSG_DATE_TYPE_TODAY
        messageYear == yesterdayYear && messageMonth == yesterdayMonth && messageDay == yesterdayDay -> MsgDateType.MSG_DATE_TYPE_YESTERDAY
        calendar.after(twoWeeksAgo) -> MsgDateType.MSG_DATE_TYPE_LAST_TWO_WEEKS
        else -> MsgDateType.MSG_DATE_TYPE_OLDER
    }
    //两周的日期格式：2023-05-01
    lastTwoWeeksDateFormatString = "$twoWeeksAgoYear-$twoWeeksAgoMonth-$twoWeeksAgoDay"
}
```

上面示例，是实际开发中的需求：根据时间戳对数据进行分类为 今天+日期，昨天+日期，三天到两周（前天日期+两周日期）。通过Calendar即可实现，先获取到年月日，然后对比即可。

## Calendar介绍

在 Java 和 Kotlin 中，`Calendar` 是一个用于操作日期和时间的抽象基类，它提供了丰富的方法和字段来进行日期和时间的计算、比较和格式化等操作。以下是对 `Calendar` 的详细解释：

**1. 创建 `Calendar` 实例**：

```kotlin
import java.util.Calendar

val calendar = Calendar.getInstance()
```

`Calendar.getInstance()` 方法会根据系统的默认时区和语言环境创建一个 `Calendar` 对象。

**2. 基本操作**：

- **设置时间**：

    ```kotlin
    calendar.set(Calendar.YEAR, 2025)
    calendar.set(Calendar.MONTH, Calendar.JANUARY) // 注意：月份是从 0 开始的，所以 0 表示一月，11 表示十二月
    calendar.set(Calendar.DAY_OF_MONTH, 1)
    calendar.set(Calendar.HOUR_OF_DAY, 12)
    calendar.set(Calendar.MINUTE, 0)
    calendar.set(Calendar.SECOND, 0)
    calendar.set(Calendar.MILLISECOND, 0)
    ```

    你可以使用 `set` 方法设置 `Calendar` 对象的年、月、日、时、分、秒和毫秒。

- **获取时间**：

    ```kotlin
    val year = calendar.get(Calendar.YEAR)
    val month = calendar.get(Calendar.MONTH)
    val day = calendar.get(Calendar.DAY_OF_MONTH)
    val hour = calendar.get(Calendar.HOUR_OF_DAY)
    val minute = calendar.get(Calendar.MINUTE)
    val second = calendar.get(Calendar.SECOND)
    val millisecond = calendar.get(Calendar.MILLISECOND)
    ```

    使用 `get` 方法可以从 `Calendar` 对象中获取相应的时间部分。

- **时间计算**：

    ```kotlin
    calendar.add(Calendar.DAY_OF_MONTH, 1) // 增加一天
    calendar.add(Calendar.HOUR_OF_DAY, -2) // 减少两小时
    ```

    使用 `add` 方法可以对日期和时间进行加减操作，它会自动处理日期和时间的进位和借位。

- **比较时间**：

    ```kotlin
    val anotherCalendar = Calendar.getInstance()
    anotherCalendar.set(2025, Calendar.JANUARY, 2)
    val isAfter = calendar.after(anotherCalendar)
    val isBefore = calendar.before(anotherCalendar)
    val isEqual = calendar.equals(anotherCalendar)
    ```

    使用 `after`、`before` 和 `equals` 方法可以比较两个 `Calendar` 对象的时间先后顺序或是否相等。

**3. 重要的字段和常量**：

- **常量**：
  - `Calendar.YEAR`：表示年。
  - `Calendar.MONTH`：表示月，范围是 0 到 11，0 表示一月，11 表示十二月。
  - `Calendar.DAY_OF_MONTH`：表示月中的第几天。
  - `Calendar.HOUR_OF_DAY`：表示一天中的第几个小时（24 小时制）。
  - `Calendar.MINUTE`：表示分钟。
  - `Calendar.SECOND`：表示秒。
  - `Calendar.MILLISECOND`：表示毫秒。
  - `Calendar.DAY_OF_WEEK`：表示一周中的第几天，范围是 1（周日）到 7（周六）。

- **字段**：

    ```kotlin
    calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)
    ```

    你可以使用这些字段来设置或获取特定的时间部分。

**4. 时间戳和 `Calendar` 的转换**：

- **从时间戳转换为 `Calendar`**：

    ```kotlin
    val timestamp = System.currentTimeMillis()
    calendar.timeInMillis = timestamp
    ```

    通过设置 `timeInMillis` 属性将时间戳转换为 `Calendar` 对象。

- **从 `Calendar` 转换为时间戳**：

    ```kotlin
    val timestamp = calendar.timeInMillis
    ```

    通过 `timeInMillis` 属性获取 `Calendar` 对象对应的时间戳。

**5. 注意事项**：

- `Calendar` 是一个抽象类，通常使用 `getInstance()` 方法获取其具体的实现类对象，如 `GregorianCalendar`。
- 在进行日期和时间的操作时，要注意月份从 0 开始计数，而不是 1。
- 对于复杂的日期和时间操作，如计算两个日期之间的天数差、格式化日期和时间等，可能需要结合 `SimpleDateFormat` 等类一起使用。

**6. 示例代码**：

```kotlin
import java.text.SimpleDateFormat
import java.util.Calendar


fun main() {
    val calendar = Calendar.getInstance()
    calendar.set(2025, Calendar.JANUARY, 1)

    // 增加一天
    calendar.add(Calendar.DAY_OF_MONTH, 1)

    val sdf = SimpleDateFormat("yyyy-MM-dd")
    val dateString = sdf.format(calendar.time)
    println(dateString)

    // 比较两个日期
    val anotherCalendar = Calendar.getInstance()
    anotherCalendar.set(2025, Calendar.JANUARY, 2)
    val isAfter = calendar.after(anotherCalendar)
    println("Is after: $isAfter")

    // 从时间戳转换为 Calendar
    val timestamp = System.currentTimeMillis()
    val timestampCalendar = Calendar.getInstance()
    timestampCalendar.timeInMillis = timestamp
    println("Timestamp calendar: ${sdf.format(timestampCalendar.time)}")
}
```

**7. 与 `SimpleDateFormat` 的结合使用**：
`SimpleDateFormat` 可以将 `Calendar` 对象的日期和时间转换为特定的字符串表示，也可以将字符串日期解析为 `Calendar` 对象。

```kotlin
import java.text.SimpleDateFormat
import java.util.Calendar


fun main() {
    val calendar = Calendar.getInstance()
    calendar.set(2025, Calendar.JANUARY, 1)

    val sdf = SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
    val dateString = sdf.format(calendar.time)
    println(dateString)

    try {
        val parsedCalendar = Calendar.getInstance()
        parsedCalendar.time = sdf.parse("2025-01-01 12:00:00")
        println("Parsed calendar: ${sdf.format(parsedCalendar.time)}")
    } catch (e: Exception) {
        println("Error parsing date")
    }
}
```

总之，`Calendar` 是一个强大的日期和时间操作工具，它提供了许多方法和字段来满足各种日期和时间的操作需求，但在使用时要注意月份的表示和一些细节，同时在处理复杂的日期和时间转换和格式化时，可能需要结合其他类如 `SimpleDateFormat` 等。它为你提供了灵活的方式来处理日期和时间的操作，例如在日程安排、日期范围计算、时间比较等场景中都非常有用。

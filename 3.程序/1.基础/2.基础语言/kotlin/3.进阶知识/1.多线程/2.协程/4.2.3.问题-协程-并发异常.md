# 协程多个发射器导致并发异常

日志：

```log
failed: java.lang.IllegalStateException: Flow invariant is violated:
Emission from another coroutine is detected.
Child of StandaloneCoroutine{Active}@41f126d, expected child of StandaloneCoroutine{Active}@6263ea2.
FlowCollector is not thread-safe and concurrent emissions are prohibited.
To mitigate this restriction please use 'channelFlow' builder instead of 'flow' , Flow invariant is violated:
Emission from another coroutine is detected.
Child of StandaloneCoroutine{Active}@41f126d, expected child of StandaloneCoroutine{Active}@6263ea2.
FlowCollector is not thread-safe and concurrent emissions are prohibited.
To mitigate this restriction please use 'channelFlow' builder instead of 'flow'
```

具体情况：

```kotlin
flow<AccountInfo?> {
    components.forEachIndexed{index, component->
        component.getAccountInfo { //这是个挂起函数
                emit(it)
        }
    }
}
```

我在挂起函数`getAccountInfo`调用了`emit`，从打印日志的提示看，这样是不被允许的。

## 原因及解决办法

这个错误表明你在使用 Kotlin Flow 时违反了关键规则：**Flow 发射（emit）必须是顺序且线程安全的**。错误信息明确指出检测到来自不同协程的并发发射（`Emission from another coroutine`），而 Flow 的设计不允许这种操作。

### 错误原因分析

1. **非法并发发射**  
   - 你在 `flow { ... }` 构建器中启动了**多个协程**（例如通过 `launch`），并尝试在这些协程中同时调用 `emit()`。
   - Flow 的 `Collector` 不是线程安全的，强制要求所有发射操作在**同一个协程上下文**中顺序执行。

2. **协程上下文不匹配**  
   - 错误日志中的 `expected child of StandaloneCoroutine@6263ea2` vs `detected child of StandaloneCoroutine@41f126d` 表明：  
     - 收集器（Collector）运行在协程 `@6263ea2` 中。
     - 但实际发射操作却发生在另一个协程 `@41f126d` 中，违反了 Flow 的单协程发射约束。

---

### 解决方案：使用 `channelFlow` 替代 `flow`

错误信息已给出明确建议：**用 `channelFlow` 代替 `flow`**。`channelFlow` 内部通过 Channel 机制支持多协程并发发射，完美解决此问题。

#### 修改代码示例

**错误写法**（引发并发发射）：

```kotlin
flow {
    launch { // ❌ 在子协程中并发 emit
        emit(data1)
    }
    launch { // ❌ 另一个子协程并发 emit
        emit(data2)
    }
}
```

**正确写法**（使用 `channelFlow`）：

```kotlin
channelFlow { // ✅ 使用 channelFlow 支持并发发送
    launch {
        send(data1) // 注意：channelFlow 中用 send 而非 emit
    }
    launch {
        send(data2)
    }
    // 可选：等待所有发送完成（根据业务需求）
    awaitClose { /* 清理资源 */ }
}
```

#### 关键修改点

1. **替换构建器**  
   `flow { ... }` → `channelFlow { ... }`

2. **替换发射方法**  
   `emit(value)` → `send(value)`

3. **处理生命周期**（可选）  
   在 `channelFlow` 结束时调用 `awaitClose { ... }` 防止协程泄漏。

---

### 替代方案：避免并发发射

如果不需并发，可保持 `flow` 但确保**所有 `emit` 在同一个协程中顺序执行**：

```kotlin
flow {
    // ✅ 在同一个协程中顺序 emit
    emit(fetchData1())
    emit(fetchData2())
}
```

---

### 总结

| 方案                | 适用场景                           | 注意事项                     |
|---------------------|----------------------------------|----------------------------|
| **`channelFlow`**   | 需要多协程并发发射数据时          | 用 `send()` 代替 `emit()`   |
| **顺序 `flow`**     | 所有发射操作可线性执行时          | 禁止在子协程中调用 `emit()` |

**永远记住**：  
⚠️ 在 `flow { ... }` 内，绝对不能在多个协程中调用 `emit()`！  
✅ 需要并发发射时，`channelFlow` 是官方推荐的线程安全解决方案。

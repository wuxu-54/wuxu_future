# suspendCancellableCoroutine

`suspendCancellableCoroutine` 是 Kotlin 协程中用于将回调式 API 转换为挂起函数的核心工具，它比普通的 `suspendCoroutine` 提供了更精细的取消控制。以下是详细介绍：

## **核心作用**

将传统的回调式 API（如 Android 的 `getAccountInfo { callback -> ... }`）转换为协程友好的挂起函数，同时支持协程取消时的资源清理。

## **基本语法**

```kotlin
suspend fun <T> suspendCancellableCoroutine(
    block: (CancellableContinuation<T>) -> Unit
): T
```

- **参数**：接收一个 lambda，其中 `CancellableContinuation` 提供了：
  - `resume(value)`：返回成功结果
  - `resumeWithException(exception)`：返回异常
  - `invokeOnCancellation { ... }`：注册协程取消时的回调

## **与 `suspendCoroutine` 的区别**

| 特性                  | `suspendCoroutine`       | `suspendCancellableCoroutine` |
|-----------------------|--------------------------|-------------------------------|
| 协程取消支持          | 不支持（需手动检查）     | 原生支持，提供取消回调         |
| 自动资源清理          | 无                       | 可注册取消时的清理逻辑         |
| 取消异常传递          | 需手动处理               | 自动传递 `CancellationException` |
| 适用场景              | 不可取消的操作           | 可取消的异步操作（如网络请求） |

## **典型用法示例**

### **1. 将回调转换为挂起函数**

```kotlin
suspend fun getAccountInfo(): AccountInfo? = suspendCancellableCoroutine { cont ->
    // 启动异步操作
    val listener = object : AccountListener {
        override fun onSuccess(account: AccountInfo) {
            cont.resume(account)
        }
        
        override fun onError(error: Throwable) {
            cont.resumeWithException(error)
        }
    }
    
    // 注册监听器
    accountApi.getAccountInfo(listener)
    
    // 关键：注册取消回调
    cont.invokeOnCancellation {
        // 协程被取消时的清理逻辑
        accountApi.removeListener(listener)
    }
}
```

### **2. 处理可取消的网络请求**

```kotlin
suspend fun fetchData(url: String): Response = suspendCancellableCoroutine { cont ->
    val call = httpClient.newCall(Request.Builder().url(url).build())
    
    call.enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            if (!cont.isCancelled) cont.resumeWithException(e)
        }
        
        override fun onResponse(call: Call, response: Response) {
            if (!cont.isCancelled) cont.resume(response)
        }
    })
    
    // 取消时取消网络请求
    cont.invokeOnCancellation {
        call.cancel()
    }
}
```

## **关键方法详解**

### **`invokeOnCancellation`**

注册一个回调，当协程被取消时执行：

```kotlin
cont.invokeOnCancellation { cause ->
    // cause 是 CancellationException 或 null
    // 执行清理操作（如关闭连接、取消订阅）
}
```

### **`resume` vs `resumeWithException`**

- `cont.resume(value)`：正常返回结果
- `cont.resumeWithException(exception)`：返回异常，会被 `catch` 捕获

### **`isCancelled` 检查**

在回调中检查协程是否已取消，避免无效操作：

```kotlin
if (!cont.isCancelled) {
    cont.resume(result)
}
```

## **注意事项**

1. **避免泄漏**：必须在 `invokeOnCancellation` 中取消未完成的操作（如网络请求、定时器）。
2. **线程安全**：`resume` 和 `resumeWithException` 只能调用一次，多次调用会抛出异常。
3. **异常处理**：取消时默认抛出 `CancellationException`，可通过 `catch` 捕获：

   ```kotlin
   try {
       fetchData()
   } catch (e: CancellationException) {
       // 处理取消
   }
   ```

4. **非阻塞操作**：`suspendCancellableCoroutine` 本身不会阻塞线程，仅挂起协程。

## **常见应用场景**

- 将 Android 的 `SharedPreferences.edit().apply()` 转换为挂起函数。
- 封装 RxJava 的 `Observable`/`Single` 为协程友好的 API。
- 处理需要手动取消的异步操作（如动画、长任务）。

## **总结**

`suspendCancellableCoroutine` 是协程与回调 API 交互的桥梁，通过它可以：

1. 将回调转换为挂起函数。
2. 自动处理协程取消逻辑。
3. 确保资源正确释放，避免泄漏。

使用时需特别注意在 `invokeOnCancellation` 中注册清理逻辑，以保证协程取消时的安全性。

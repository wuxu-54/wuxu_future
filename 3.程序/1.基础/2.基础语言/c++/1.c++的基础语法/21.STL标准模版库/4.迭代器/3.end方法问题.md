# end方法问题

```cpp
class Solution {
public:
    int calPoints(vector<string>& operations) {
        vector<int> res;

        for(int i = 0;i<operations.size();i++){
            //x
            if(operations[i] == "+"){
                res.push_back(res[res.size()-1]+res[res.size()-2]);//新数等于前两个的和
            }else if(operations[i] == "C"){
                res.pop_back();//移除前一个
            }else if(operations[i] == "D"){
                cout<<*res.end()<<endl;//这里使用end(),取值竟然是2，正常是5.
                res.push_back((res[res.size()-1]) * 2);//最后一个数的2倍
            }else{
                res.push_back(std::stoi(operations[i]));
            }

            cout<<"[";
            for(int a : res){
                cout<<a<<",";
            }
            cout<<"]"<<endl;
        }


        int nums = 0;
        for(int a : res){
            nums+=a;
        }
        return nums;
    }
};
```

输入：["5","2","C","D","+"] 结果如下：

```txt
[5,]
[5,2,]
[5,]
2
[5,10,]
[5,10,15,]
```

问题：第4行应该是5不能是2，问题出现在end()方法，如果使用back()打印是5

原因：迭代器在遇到元素修改时，end()访问的是最后一个位置不是元素本身，上面代码执行了pop_back(),导致最后一位其实要被释放的，但end()仍然指向他。

## end()问题原理

在C++中，`vector.end()` 返回的是一个迭代器，它指向向量（`vector`）中最后一个元素之后的位置，而不是最后一个元素本身。因此，你不能直接通过解引用 `vector.end()` 来获取值，因为这样做会尝试访问一个不存在的元素，导致未定义行为（通常是程序崩溃）。

如果你想要获取 `vector` 中最后一个元素的值，你应该使用 `vector.back()` 方法。这个方法返回向量的最后一个元素的引用，前提是向量不为空。如果向量是空的，调用 `vector.back()` 会导致未定义行为。

这里有一个简单的例子来说明如何使用 `vector.back()`：

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};

    if (!numbers.empty()) {
        int lastNumber = numbers.back();
        std::cout << "The last number is: " << lastNumber << std::endl;
    } else {
        std::cout << "The vector is empty." << std::endl;
    }

    return 0;
}
```

在这个例子中，我们首先检查向量 `numbers` 是否为空。如果不为空，我们使用 `numbers.back()` 来获取最后一个元素的值，并将其打印出来。

如果你确实需要使用迭代器来访问向量中的元素，并且你想要从后向前遍历向量，你可以从 `vector.end()` 开始，并在每次迭代中将迭代器递减（使用 `--iterator`）。但是，请注意，你必须在递减之前确保迭代器不是 `vector.begin()` 之前的位置，否则你会再次访问不存在的元素。一个常见的做法是使用一个不等于 `vector.begin()` 的条件来在循环中继续迭代。但是，由于从后向前遍历通常不常见，而且容易出错，因此更推荐使用 `vector.rbegin()` 和 `vector.rend()` 来获取一个指向向量末尾的反向迭代器，并从那里开始遍历。

# `unordered_map`

在C++标准库中，`std::unordered_map`是一个关联容器，它存储的是键值对（key-value pairs），与`std::map`类似，但`std::unordered_map`不保证元素的顺序，它是基于哈希表实现的。这意味着`std::unordered_map`在平均情况下提供了常数时间复杂度的插入、删除和查找操作，尽管在最坏情况下这些操作的时间复杂度可能会退化。

`std::unordered_map`使用哈希函数来组织元素，哈希函数将键映射到表中的桶（bucket）位置。默认情况下，`std::unordered_map`使用`std::hash`作为哈希函数，并使用`std::equal_to`作为键相等比较函数。然而，您可以自定义这些函数以满足特定需求。

以下是一些`std::unordered_map`的常用成员函数和操作：

1. **插入元素**：
   * `insert`：插入一个键值对。如果键已经存在，则不会插入新元素，但会更新对应的值（取决于实现，有些实现可能不更新值）。
   * `emplace`：与`insert`类似，但更高效，因为它直接在容器中构造元素，避免了不必要的复制或移动。
   * `operator[]`：通过键来访问值。如果键不存在，则插入一个具有该键和默认构造值的元素。

2. **删除元素**：
   * `erase`：删除指定位置的元素、指定键的元素或删除一个范围内的元素。
   * `clear`：删除所有元素。

3. **查找元素**：
   * `find`：查找具有指定键的元素。
   * `count`：返回具有指定键的元素的数量（对于`std::unordered_map`，要么是0要么是1）。
   * `operator[]`：也可以用于查找值，但如果键不存在，则会插入一个新元素。
   * `at`：通过键访问值，如果键不存在则抛出`std::out_of_range`异常。

4. **桶和负载因子**：
   * `bucket`：返回键所在桶的索引。
   * `bucket_count`：返回容器中的桶数。
   * `load_factor`：返回容器的负载因子（即元素数与桶数的比值）。
   * `max_load_factor`：获取或设置容器的最大负载因子。
   * `rehash`：改变容器的桶数，以适应元素数。

5. **大小和容量**：
   * `size`：返回容器中元素的数量。
   * `empty`：检查容器是否为空。

6. **观察者**：
   * `begin`、`end`、`cbegin`、`cend`：返回指向容器开始和结束位置的迭代器。
   * `rbegin`、`rend`、`crbegin`、`crend`：返回指向容器反向开始和结束位置的迭代器。
   * `hash_function`：返回用于哈希键的函数对象。
   * `key_eq`：返回用于比较键相等性的函数对象。

以下是一个简单的`std::unordered_map`使用示例：

```cpp
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    std::unordered_map<std::string, int> myUnorderedMap;

    // 插入元素
    myUnorderedMap["apple"] = 5;
    myUnorderedMap.insert(std::pair<std::string, int>("banana", 3));
    myUnorderedMap.emplace("orange", 4);

    // 访问元素
    std::cout << "Number of apples: " << myUnorderedMap["apple"] << std::endl;
    std::cout << "Number of bananas: " << myUnorderedMap.at("banana") << std::endl; // 如果键不存在，at 会抛出异常

    // 查找元素
    auto it = myUnorderedMap.find("orange");
    if (it != myUnorderedMap.end()) {
        std::cout << "Number of oranges: " << it->second << std::endl;
    } else {
        std::cout << "Oranges not found!" << std::endl;
    }

    // 输出桶数和负载因子
    std::cout << "Bucket count: " << myUnorderedMap.bucket_count() << std::endl;
    std::cout << "Load factor: " << myUnorderedMap.load_factor() << std::endl;

    // 遍历元素（注意：顺序是不确定的）
    for (const auto& pair : myUnorderedMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

在这个示例中，我们创建了一个`std::unordered_map<std::string, int>`，插入了几个元素，访问了这些元素，查找了一个元素，输出了桶数和负载因子，并遍历了所有的键值对（注意，由于`std::unordered_map`不保证顺序，因此遍历的顺序是不确定的）。

---

## `unordered_map`与`map`区别

`unordered_map`与`map`都是C++标准模板库（STL）中的关联容器，用于存储键值对（key-value pairs）。尽管它们的功能相似，但在实现方式、性能特性和使用场景上存在一些显著的差异。以下是`unordered_map`与`map`的主要区别：

### 1. 实现方式

* **`unordered_map`**：基于哈希表（hash table）实现。哈希表通过哈希函数将键映射到表中的特定位置（桶），从而实现快速的查找、插入和删除操作。
* **`map`**：基于红黑树（red-black tree）实现。红黑树是一种自平衡的二叉搜索树，能够确保元素按照键值自动排序。

### 2. 性能特性

* **查找、插入和删除操作**：

  * `unordered_map`：在平均情况下，这些操作的时间复杂度为O(1)。然而，在最坏情况下（例如，哈希函数导致大量冲突），时间复杂度可能会退化到O(n)。
  * `map`：这些操作的时间复杂度为O(logn)，因为红黑树在插入、删除和查找时需要维护树的平衡性。

* **空间占用**：

  * `unordered_map`：通常需要更多的内存来存储哈希表和哈希桶，以减少冲突并提高查找效率。
  * `map`：由于红黑树的节点结构相对简单，空间占用通常较少。

### 3. 元素顺序

* **`unordered_map`**：不保证元素的顺序。元素的排列顺序取决于哈希函数和哈希表的实现。
* **`map`**：保证元素按照键值自动排序。这使得`map`在需要有序访问元素的场景中非常有用。

### 4. 适用场景

* **`unordered_map`**：适用于需要快速查找、插入和删除操作的场景，且不关心元素顺序的情况。
* **`map`**：适用于需要按照键值排序或需要保证元素顺序稳定的场景。

### 5. 迭代器失效

* **`unordered_map`**：在插入元素后，指向容器的迭代器可能会失效（因为哈希表可能需要重新分配和重新哈希）。然而，在删除元素后，指向非删除元素的迭代器仍然有效。
* **`map`**：在插入元素时，指向容器的迭代器不会失效（因为红黑树在插入时不需要重新分配内存）。但在删除元素后，指向被删除元素及其后续元素的迭代器可能会失效。

综上所述，`unordered_map`和`map`各有优缺点，选择哪个容器取决于具体的应用场景和需求。如果需要快速查找、插入和删除操作，且不关心元素顺序，可以选择`unordered_map`；如果需要按照键值排序或需要保证元素顺序稳定，可以选择`map`。

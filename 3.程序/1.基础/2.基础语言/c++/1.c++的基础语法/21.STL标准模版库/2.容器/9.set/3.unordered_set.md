# unordered_set

## `unordered_set` 核心API介绍  

`unordered_set` 是 C++ STL 中基于**哈希表**实现的无序集合容器，元素唯一且不重复，不保证元素顺序。其核心 API 如下：  

### 1. 构造与析构  

| 函数声明 | 作用 |  
|----------|------|  
| `unordered_set()` | 默认构造空集合 |  
| `unordered_set(size_type n)` | 构造空集合，预分配至少 `n` 个桶（哈希表的存储单元） |  
| `unordered_set(InputIt first, InputIt last)` | 用迭代器范围 `[first, last)` 中的元素构造集合（自动去重） |  
| `unordered_set(const unordered_set& other)` | 拷贝构造 |  
| `~unordered_set()` | 析构函数，销毁所有元素并释放内存 |  

### 2. 迭代器（遍历元素）  

| 函数声明 | 作用 |  
|----------|------|  
| `iterator begin()` | 返回指向第一个元素的前向迭代器（无序） |  
| `iterator end()` | 返回指向末尾（最后一个元素后）的迭代器 |  
| `const_iterator cbegin() const` | 返回 const 前向迭代器（不可修改元素） |  
| `const_iterator cend() const` | 返回 const 末尾迭代器 |  

**注意**：`unordered_set` 的迭代器是**前向迭代器**（只能用 `++` 移动，不能用 `--`），且遍历顺序与插入顺序无关（由哈希函数决定）。  

- 迭代器遍历示例

    ```cpp
    #include <iostream>
    #include <unordered_set>

    int main() {
        std::unordered_set<int> mySet = {10, 20, 30, 40, 50};
        
        // 使用正向迭代器遍历
        for (auto it = mySet.begin(); it != mySet.end(); ++it) {
            // 通过解引用迭代器获取元素值
            std::cout << *it << " ";
            
            // 可以直接使用元素值进行操作
            int value = *it;
            if (value > 30) {
                std::cout << "(大于30) ";
            }
        }
        // 输出：40 (大于30) 50 (大于30) 10 20 30 （顺序可能不同，因为unordered_set无序）
        return 0;
    }
    ```

- 使用范围 for 循环（C++11 及以上）,这是一种更简洁的遍历方式：

    ```cpp
    #include <iostream>
    #include <unordered_set>

    int main() {
        std::unordered_set<std::string> mySet = {"apple", "banana", "cherry"};
        
        // 范围for循环直接获取元素
        for (const auto& element : mySet) {  // 建议用const引用，避免拷贝
            std::cout << element << " ";
            
            // 使用元素进行操作
            if (element.size() > 5) {
                std::cout << "(长度大于5) ";
            }
        }
        // 输出：apple banana (长度大于5) cherry (长度大于5) （顺序可能不同）
        return 0;
    }
    ```

### 3. 容量相关  

| 函数声明 | 作用 |  
|----------|------|  
| `bool empty() const` | 判断集合是否为空（返回 `true` 表示空） |  
| `size_type size() const` | 返回当前元素个数 |  
| `size_type max_size() const` | 返回容器可容纳的最大元素个数（受系统限制） |  

### 4. 修改操作（添加/删除元素）  

| 函数声明 | 作用 |  
|----------|------|  
| `pair<iterator, bool> insert(const T& value)` | 插入元素 `value`，返回 `pair`：<br>- 若插入成功，`first` 是新元素迭代器，`second` 为 `true`；<br>- 若元素已存在，`first` 是已有元素迭代器，`second` 为 `false`。 |  
| `iterator insert(const_iterator hint, const T& value)` | 带“提示位置”的插入（`hint` 是建议插入的位置，可能优化性能），返回新元素迭代器（或已有元素迭代器） |  
| `void insert(InputIt first, InputIt last)` | 插入迭代器范围 `[first, last)` 中的元素（去重后插入） |  
| `template<class... Args> pair<iterator, bool> emplace(Args&&... args)` | 直接在容器中构造元素（避免临时对象拷贝，比 `insert` 高效），参数为元素构造函数的参数 |  
| `iterator erase(iterator pos)` | 删除迭代器 `pos` 指向的元素，返回下一个元素的迭代器 |  
| `size_type erase(const T& value)` | 删除值为 `value` 的元素，返回删除的个数（0 或 1，因元素唯一） |  
| `iterator erase(const_iterator first, const_iterator last)` | 删除迭代器范围 `[first, last)` 中的元素，返回下一个元素的迭代器 |  
| `void clear()` | 清空所有元素（容器变为空） |  
| `void swap(unordered_set& other)` | 交换两个集合的元素（高效，仅交换内部指针） |  

### 5. 查找操作  

| 函数声明 | 作用 |  
|----------|------|  
| `iterator find(const T& value)` | 查找值为 `value` 的元素，返回其迭代器；若不存在，返回 `end()` |  
| `const_iterator find(const T& value) const` | 常量版本的查找（返回 `const_iterator`） |  
| `size_type count(const T& value) const` | 返回值为 `value` 的元素个数（0 或 1，因元素唯一） |  

### 6. 哈希表相关（`unordered_set` 特有）  

因底层是哈希表，提供以下与哈希桶相关的函数：  

| 函数声明 | 作用 |  
|----------|------|  
| `size_type bucket_count() const` | 返回当前哈希表的桶数量 |  
| `size_type bucket_size(size_type n) const` | 返回第 `n` 个桶中元素的个数 |  
| `size_type bucket(const T& value) const` | 返回元素 `value` 所在的桶索引 |  
| `float load_factor() const` | 返回当前负载因子（`size() / bucket_count()`，哈希表拥挤程度） |  
| `float max_load_factor() const` | 返回最大负载因子（超过此值会触发哈希表扩容） |  
| `void max_load_factor(float z)` | 设置最大负载因子 |  
| `void rehash(size_type n)` | 重新分配哈希表，使桶数量至少为 `n`（减少哈希冲突） |  

## `unordered_set` 与 `set` 的核心区别  

`set` 基于**红黑树**（平衡二叉搜索树）实现，`unordered_set` 基于**哈希表**实现，两者的差异源于底层数据结构：  

| 特性 | `unordered_set` | `set` |  
|------|----------------|-------|  
| **底层实现** | 哈希表（数组+链表/红黑树，解决哈希冲突） | 红黑树（平衡二叉搜索树） |  
| **元素顺序** | 无序（遍历顺序与插入顺序无关，由哈希函数决定） | 有序（默认按 `less<T>` 升序排列，支持自定义比较器） |  
| **查找效率** | 平均 O(1)，最坏 O(n)（哈希冲突严重时） | O(log n)（红黑树的二分查找） |  
| **插入/删除效率** | 平均 O(1)，最坏 O(n)（可能触发哈希表扩容或重建） | O(log n)（红黑树的节点插入/删除，需维持平衡） |  
| **迭代器类型** | 前向迭代器（仅支持 `++`，不支持 `--`） | 双向迭代器（支持 `++` 和 `--`） |  
| **支持的操作** | 不支持范围查询（如 `lower_bound`、`upper_bound`） | 支持范围查询（`lower_bound` 找第一个 ≥ value 的元素，`upper_bound` 找第一个 > value 的元素） |  
| **元素要求** | 元素必须可哈希（需提供 `hash<T>` 函数），且支持 `==` 比较 | 元素必须支持比较运算符（默认 `less<T>`，可自定义比较器） |  
| **内存占用** | 通常更高（哈希表需要预留桶空间，可能有较多空闲内存） | 较低（红黑树节点紧凑，无冗余空间） |  

## 适用场景  

- 若需要**快速的插入、删除、查找**（且不关心元素顺序），优先用 `unordered_set`（如缓存、去重场景）。  
- 若需要**元素有序**，或频繁使用**范围查询**（如找某个区间的元素），必须用 `set`（如排序去重、区间统计场景）。

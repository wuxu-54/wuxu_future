# 字符串

c语言中字符串使用 char[] 字符数组表示，但是c++中不只可以用c语言方式，同时因为有了对象的概念，其封装了一个string 类型，来特地的表示字符串，内部提供了方便使用的api。

* c 语言风格

    ```cpp
    int main() {
        char string[] = "1234dsfs";
        cout<<string<<endl;
        return 0;
    }
    ```

* c++风格

    ```cpp
    int main() {
        string s = "1123";
        cout << s;
        return 0;
    }
    ```

## 注意

字符类型char 是单引号，字符串类型是双引号。

---

## API

C++标准库中的`std::string`类提供了丰富的API来处理字符串。以下是一些常用的`std::string`成员函数和相关操作：

### 构造和赋值

* `string()`: 默认构造函数。
* `string(const char* s)`: 从C风格字符串构造。
* `string(const string& str)`: 复制构造函数。
* `string(size_type count, char ch)`: 从重复字符构造。
* `string(const char* s, size_type n)`: 从C风格字符串的前n个字符构造。
* `string(const string& other, size_type pos = 0, size_type len = npos)`: 从另一个字符串的子串构造。
* `operator=`: 赋值运算符。
* `assign()`: 重新赋值。

### 容量

* `empty()`: 检查字符串是否为空。
* `size()`: 返回字符串的长度。
* `length()`: 同`size()`。
* `max_size()`: 返回可以容纳的最大字符串长度。
* `resize()`: 调整字符串长度。
* `shrink_to_fit()`: 减少容量以匹配大小。

### 访问元素

* `operator[]`: 通过索引访问字符。
* `at()`: 访问指定位置的字符，带边界检查。
* `front()`: 访问第一个字符。
* `back()`: 访问最后一个字符。

### 修改字符串

* `append()`: 追加字符串或字符。
* `push_back()`: 添加一个字符到字符串末尾。
* `insert()`: 插入字符串或字符。
* `erase()`: 移除字符或子串。
* `clear()`: 清除所有字符。
* `replace()`: 替换子串。
* `swap()`: 交换两个字符串的内容。

### 比较

* `operator==`, `operator!=`, `operator<`, `operator>`, `operator<=`, `operator>=`: 比较操作符。

### 查找

* `find()`: 查找子串或字符。
* `rfind()`: 从末尾开始查找子串。
* `find_first_of()`: 查找第一个匹配的字符。
* `find_last_of()`: 查找最后一个匹配的字符。
* `find_first_not_of()`: 查找第一个不匹配的字符。
* `find_last_not_of()`: 查找最后一个不匹配的字符。

### 子串

* `substr()`: 返回子串。

### 转换

* `c_str()`: 返回C风格字符串。
* `data()`: 返回指向字符串数据的指针。

### 其他

* `begin()`, `end()`: 返回迭代器。
* `cbegin()`, `cend()`: 返回常量迭代器。
* `rbegin()`, `rend()`: 返回逆向迭代器。
* `crbegin()`, `crend()`: 返回常量逆向迭代器。
* `get_allocator()`: 返回分配器。

### 非成员函数

* `std::swap`: 交换两个字符串的内容。
* `std::getline`: 从输入流中读取一行并存储到字符串中。
* `std::operator+`: 连接两个字符串。

请注意，这里列出的API是C++标准库中`std::string`类的一部分，具体实现可能因编译器和标准库实现而异。要获取最准确的信息，请参考你所使用的编译器和标准库的文档。
>这里的api 在c++低版本中其实是没有的。比如`string.append("");`,要使用`string+="";`的方式

---

## 遍历

在C++中，遍历字符串可以通过几种不同的方法实现。以下是一些常见的遍历字符串的方法：

### 1. 使用迭代器

C++ 标准库提供了字符串迭代器，允许你遍历字符串中的每个字符。

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello, World!";
    for (std::string::iterator it = str.begin(); it != str.end(); ++it) {
        std::cout << *it;
    }
    std::cout << std::endl;
    return 0;
}
```

### 2. 使用范围基(for)循环

C++11 引入了范围基(for)循环，使得遍历字符串更加简洁。

```cpp
for (char ch : str) {
    std::cout << ch;
}
std::cout << std::endl;
```

### 3. 使用索引

如果你需要访问字符串的特定索引，可以使用下标运算符。

```cpp
for (size_t i = 0; i < str.size(); ++i) {
    std::cout << str[i];
}
std::cout << std::endl;
```

### 4. 使用 `std::for_each` 算法

`std::for_each` 是一个STL算法，可以用来遍历容器中的每个元素并应用一个函数或操作。

```cpp
#include <algorithm>

// 定义一个函数或lambda表达式来处理每个字符
auto print_char = [](char ch) { std::cout << ch; };

std::for_each(str.begin(), str.end(), print_char);
std::cout << std::endl;
```

### 5. 使用 `std::string` 的成员函数

`std::string` 提供了 `begin()` 和 `end()` 成员函数，分别返回指向字符串开始和结束的迭代器。

```cpp
auto it = str.begin();
while (it != str.end()) {
    std::cout << *it;
    ++it;
}
std::cout << std::endl;
```

### 示例代码

以下是一个示例，展示如何使用范围基(for)循环遍历字符串：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str = "Hello, World!";
    for (char ch : str) {
        std::cout << ch;
    }
    std::cout << std::endl; // 输出换行

    // 遍历时修改字符串内容
    for (char& ch : str) {
        if (ch == 'l') {
            ch = 'L'; // 将小写的 'l' 替换为大写的 'L'
        }
    }
    std::cout << str << std::endl; // 输出修改后的字符串

    return 0;
}
```

在上述示例中，我们首先使用范围基(for)循环遍历字符串并打印每个字符。然后，我们再次使用范围基(for)循环，这次我们在遍历时修改字符串，将所有的小写 'l' 替换为大写 'L'。

---

## 字符串获取单个位置的字符串类型，不是char类型

在C++中，若您想从字符串中提取某个位置的子字符串（而非单一的`char`字符），您需要明确该子字符串的起始位置和长度。标准库`std::string`类提供了一个名为`substr`的成员函数，它允许您根据指定的起始索引和长度来截取字符串的一部分。

以下是一个简单的示例，演示了如何使用`substr`函数从一个字符串中提取子字符串：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string text = "Hello, World!";
    size_t position = 7; // 设定我们感兴趣的起始位置（基于0的索引）
    size_t length = 5;   // 设定我们想要提取的子字符串的长度

    // 使用substr函数提取子字符串
    // 注意：如果length超出了从position到字符串末尾的长度，substr会自动截取到字符串的末尾
    std::string substring = text.substr(position, length);

    // 输出结果
    std::cout << "Extracted substring: " << substring << std::endl;

    return 0;
}
```

在上述代码中，我们尝试从字符串`"Hello, World!"`中提取从索引7开始、长度为5的子字符串。运行程序后，您将看到输出为`"World"`，这正是我们期望的结果。

但如果您只想获取字符串中某个特定位置的单个“字符串类型”的元素（尽管这听起来有些矛盾，因为单个元素通常表示为`char`），那么您实际上是在寻找一个只包含一个字符的字符串。这种情况下，您仍然可以使用`substr`函数，但只需指定长度为1：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string text = "Hello, World!";
    size_t position = 7; // 我们感兴趣的字符位置

    // 提取从指定位置开始、长度为1的子字符串
    std::string singleCharString = text.substr(position, 1);

    // 输出结果
    std::cout << "Character at position " << position << " as string: " << singleCharString << std::endl;

    return 0;
}
```

此代码将输出`"Character at position 7 as string: W"`，表明我们已成功地从字符串中提取了位于索引7的字符，并将其作为只包含一个字符的字符串进行了处理。尽管这种操作在多数情况下并不必要（因为直接使用`char`类型可能更为简便），但在某些特定场景下，它可能符合您的需求。

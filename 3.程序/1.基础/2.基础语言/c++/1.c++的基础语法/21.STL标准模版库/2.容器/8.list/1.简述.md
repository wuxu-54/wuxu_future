# list简述

C++中的`std::list`是一个双向链表（doubly linked list）容器，以下是对其的详细解释：

## 一、基本介绍

* `std::list`包含在C++标准模板库（STL）的`<list>`头文件中。
* 它是由多个节点组成的双向链表结构，每个节点包含数据元素和指向前一个节点及后一个节点的指针。
* `std::list`中的节点是动态分配的，可以根据需要动态增加或减少节点数量，因此不需要提前指定大小。

## 二、构造函数

* **默认构造函数**：创建一个空的`std::list`容器。
* **拷贝构造函数**：创建一个与已存在的`std::list`容器相同的副本。
* **迭代器区间初始化**：使用迭代器范围 `[first, last)` 中的元素创建一个`std::list`容器。
* **填充构造函数**：创建一个包含n个元素的`std::list`容器，并将这些元素初始化为val。

## 三、迭代器

* `std::list`提供了迭代器（iterator）来遍历容器中的元素，包括正向迭代器和逆向迭代器。
* 由于`std::list`的底层结构是链表，其迭代器与数组的迭代器（原生指针）不同，需要进行特定的封装和运算符重载。

## 四、容量和大小

* `empty()`：判断容器中是否为空，若为空则返回true，否则返回false。
* `size()`：返回容器中元素的个数。
* `max_size()`：返回`std::list`容器能容纳的最大元素数量。

## 五、元素访问

* `front()`：返回对列表容器中第一个元素的引用。
* `back()`：返回对列表容器中最后一个元素的引用。

注意：在空容器上调用`front()`或`back()`函数会导致未定义的行为。

## 六、增删查改

* **插入操作**：

  * `push_back()`：在`std::list`的末尾添加一个元素。
  * `push_front()`：在`std::list`的头部添加一个元素。
  * `insert()`：在指定位置插入一个或多个元素。

* **删除操作**：

  * `pop_back()`：删除`std::list`的最后一个元素。
  * `pop_front()`：删除`std::list`的第一个元素。
  * `erase()`：删除指定位置的元素。
  * `clear()`：删除`std::list`中的所有元素。

* **查找操作**：虽然`std::list`不支持通过下标来访问元素，但可以使用迭代器或范围基于的for循环来遍历并查找元素。此外，还可以使用STL中的`find`算法来查找元素。
* **修改操作**：由于`std::list`中的元素是通过迭代器访问的，因此可以直接通过迭代器来修改元素的值。

## 七、其他操作函数

* `splice()`：合并两个`std::list`。
* `unique()`：删除`std::list`中重复的元素。
* `remove()`：从`std::list`中删除所有匹配给定值的元素。
* `remove_if()`：按指定条件删除`std::list`中的元素。
* `merge()`：对两个已排序的`std::list`进行合并。
* `sort()`：对`std::list`中的元素进行排序。
* `reverse()`：把`std::list`的元素倒转。
* `swap()`：交换两个`std::list`的内容。

## 八、注意事项

* 由于`std::list`的底层结构是链表，因此其空间利用率较低，容易造成内存碎片。同时，其缓存利用率也较低，因为无法像数组那样一次将一个数据附近的空间都加载到缓存中。
* 在进行删除操作时，`std::list`的迭代器会失效。但是，与`std::vector`不同，`std::list`的插入操作不会导致其他迭代器失效。

总的来说，`std::list`是一个非常灵活的容器，特别适合需要频繁进行插入和删除操作的场景。然而，在需要频繁随机访问元素的场景中，其效率可能不如`std::vector`等线性容器。

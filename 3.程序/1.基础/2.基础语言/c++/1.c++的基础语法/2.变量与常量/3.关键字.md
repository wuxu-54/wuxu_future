# c++关键字

C++的关键字具有特定的语言含义，用于定义语言的语法结构和行为。以下是一些C++关键字及其基本含义的列表：

1. **`asm`**: 允许在C++代码中嵌入汇编语言代码。

2. **`auto`**: 用于自动类型推断，编译器会根据初始化表达式推断变量类型。

3. **`bool`**: 布尔类型，可以是`true`或`false`。

4. **`break`**: 用于立即退出最近的`for`、`while`或`do-while`循环。

5. **`case`**: 用于`switch`语句中的条件分支。

6. **`catch`**: 用于异常处理，捕获并处理在`try`块中抛出的异常。

7. **`char`**: 用于声明字符类型的变量。

8. **`class`**: 用于定义类类型。

9. **`const`**: 用于声明常量，其值在初始化后不能被修改。

10. **`const_cast`**: 用于修改类型的const属性。

11. **`continue`**: 用于跳过当前循环的剩余部分，直接开始下一次循环迭代。

12. **`default`**: 用于`switch`语句中的默认分支，当没有匹配的`case`时执行。

13. **`delete`**: 用于释放之前使用`new`分配的内存。

14. **`do`**: 用于`do-while`循环，循环体至少执行一次。

15. **`double`**: 用于声明双精度浮点类型的变量。

16. **`else`**: 用于条件语句，如果`if`中的条件不满足则执行`else`块。

17. **`enum`**: 用于定义枚举类型。

18. **`explicit`**: 防止隐式类型转换。

19. **`export`**: 用于模块编程，指定模块的导出。

20. **`extern`**: 用于声明在其他文件或编译单元定义的变量或函数。

21. **`false`**: 布尔值，表示逻辑假。

22. **`float`**: 用于声明单精度浮点类型的变量。

23. **`for`**: 用于`for`循环，一种基于初始化、条件和迭代表达式的循环结构。

24. **`friend`**: 允许类外部的函数访问类的私有和受保护成员。

25. **`goto`**: 无条件跳转到程序中的指定标签位置。

26. **`if`**: 条件语句，根据条件表达式的结果执行不同的代码块。

27. **`inline`**: 用于定义内联函数，以减少函数调用的开销。

28. **`int`**: 用于声明整数类型的变量。

29. **`long`**: 用于声明长整型变量，通常比标准`int`类型有更大的范围。

30. **`mutable`**: 允许在const上下文中修改的成员变量。

31. **`namespace`**: 用于定义命名空间，以避免名称冲突。

32. **`new`**: 用于在堆上分配内存。

33. **`noexcept`**: 指定函数是否可以抛出异常。

34. **`operator`**: 允许定义或重载操作符。

35. **`private`**: 类的访问修饰符，限制成员只能被类本身访问。

36. **`protected`**: 类的访问修饰符，允许派生类访问。

37. **`public`**: 类的访问修饰符，允许所有代码访问。

38. **`register`**: 建议编译器将变量存储在寄存器中，而不是内存中（现代编译器通常忽略此关键字）。

39. **`reinterpret_cast`**: 用于执行低级别的重新解释类型的强制类型转换。

40. **`return`**: 从函数返回值。

41. **`short`**: 用于声明短整型变量。

42. **`sizeof`**: 用于获取类型或对象的内存大小。

43. **`static`**: 用于定义静态变量或函数。

44. **`static_assert`**: 用于编译时断言。

45. **`static_cast`**: 用于执行安全的类型转换。

46. **`struct`**: 用于定义结构体类型。

47. **`switch`**: 用于基于不同情况执行不同代码块的选择结构。

48. **`template`**: 用于定义模板函数或类。

49. **`this`**: 指向类当前对象的指针。

50. **`throw`**: 用于抛出异常。

51. **`true`**: 布尔值，表示逻辑真。

52. **`try`**: 用于异常处理，包含可能抛出异常的代码。

53. **`typedef`**: 为类型创建一个新的名称。

54. **`typeid`**: 用于运行时类型识别。

55. **`typename`**: 用于模板编程中指定类型名称。

56. **`union`**: 用于定义联合体类型。

57. **`using`**: 用于引入命名空间中的名称或类型。

58. **`virtual`**: 用于声明虚函数。

59. **`void`**: 用于声明不返回值的函数或无类型指针。

60. **`volatile`**: 用于声明可能被系统硬件或其他线程修改的变量。

61. **`wchar_t`**: 用于声明宽字符类型的变量。

62. **`while`**: 用于`while`循环，循环体在每次迭代前都会检查条件。

请注意，这个列表包括了C++11及以前版本的关键字。C++20引入了一些新的关键字，如`consteval`, `constinit`, `requires`等，这些可能需要根据具体的C++版本进行考虑。

---

## c++20以上新关键字

C++20是C++语言的最新标准，它引入了一些新的关键字和特性。以下是C++20中新增的关键字及其含义：

1. **`consteval`**: 用于声明一个constexpr函数，该函数可以在编译时求值，并且其返回类型必须是字面类型。

2. **`constinit`**: 用于声明具有常量初始化的变量，这意味着变量的初始化可以在编译时完成，并且可以在程序启动之前初始化。

3. **`requires`**: 用于模板编程中的约束子句，允许对模板参数施加更复杂的约束。

4. **概念（Concepts）**: 虽然`concept`不是一个关键字，但它是C++20中引入的一个核心特性，用于定义类型或模板参数需要满足的条件。

5. **`module`**: 用于模块编程，`export`和`import`关键字与模块一起使用，分别用于导出和导入模块。

6. **`spaceship operator` `<=>`**: 这不是一个关键字，而是C++20中引入的一个新运算符，用于定义自定义类型的比较逻辑。

7. **`char8_t`**: 用于表示UTF-8编码的字符，是C++20中新增的字符类型。

8. **`concept`**: 用于定义概念，它是一种模板编程的约束，用于指定模板参数需要满足的条件。

9. **`requires`**: 用于在函数、类模板或变量模板之前指定约束条件。

10. **`co_await`**: 用于协程中的挂起操作，允许编译器识别协程的挂起点。

11. **`co_return`**: 用于协程中的返回操作，从协程中返回一个值。

12. **`co_yield`**: 用于协程中的yield操作，从协程中产生一个值。

13. **`module`**: 用于声明模块，模块是C++20中引入的一种新的代码组织方式。

14. **`import`**: 用于导入模块中的实体，而不是整个模块。

15. **`export`**: 用于模块中声明可以被其他模块导入的部分。

16. **`inline`**: 虽然不是C++20新增的关键字，但C++20扩展了`inline`的用法，允许在类定义中使用`inline`。

17. **`const`** 和 **`volatile`**: C++20对这些现有关键字的含义进行了扩展，允许在更广泛的情况下使用它们。

请注意，C++20标准还在不断发展中，可能会有更多的关键字和特性被加入。此外，一些特性可能需要编译器的支持才能使用。

---

## constexpr

`constexpr` 是 C++11 引入的关键字，它用于声明一个在编译时可以求值的表达式、函数或变量。`constexpr` 的使用允许编译器优化程序，因为它可以在编译时计算出一些值，而不是在程序运行时计算。

以下是 `constexpr` 的一些关键点：

1. **编译时常量**: `constexpr` 可以声明一个变量，其值必须在编译时已知，并且是常量表达式。

   ```cpp
   constexpr int importantNumber = 42; // 正确的使用
   ```

2. **编译时计算**: `constexpr` 可以用于函数，这些函数必须保证它们的返回值在编译时可以确定。

   ```cpp
   constexpr int add(int a, int b) {
       return a + b;
   }
   ```

3. **类型限制**: 从 C++14 开始，`constexpr` 函数可以返回非字面类型，但必须在编译时可以确定。

4. **循环和条件**: 从 C++17 开始，`constexpr` 函数可以包含循环和条件语句，但这些循环和条件必须在编译时可以完全求值。

5. **模板参数**: `constexpr` 可以作为模板参数，模板参数的值必须在编译时已知。

6. **类和对象**: C++20 允许在类定义中使用 `constexpr`，这意味着类的所有成员函数都可以在编译时调用，并且对象可以作为编译时常量。

   ```cpp
   class ConstantClass {
   public:
       constexpr int getValue() const { return 10; }
   };
   ```

7. **模块**: C++20 引入了模块（module），`export` 关键字与模块一起使用，`constexpr` 可以用于模块中的全局变量和函数，以确保它们在整个程序中都是编译时常量。

8. **`consteval`**: C++20 引入了 `consteval` 关键字，用于声明一个只能在编译时实例化的函数，即使它包含运行时才能确定的逻辑。

   ```cpp
   consteval int compileTimeFunction() {
       return 42; // 必须保证在编译时可以确定
   }
   ```

`constexpr` 的使用可以提高程序的性能，因为它允许编译器在编译时进行更多的计算，减少了运行时的负担。此外，它也有助于编写更安全、更可预测的代码，因为编译时常量的值在编译时就已经确定，不依赖于运行时的输入。

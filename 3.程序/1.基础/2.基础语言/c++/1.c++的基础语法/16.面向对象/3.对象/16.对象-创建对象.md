# 创建对象的几种方式

在 C++ 中，创建并使用对象类型有多种方式，下面从栈上创建、堆上创建、拷贝创建、移动创建等多个方面详细介绍：

## 1. 在栈上直接创建对象

### 1.1 默认构造函数初始化

```cpp
#include <iostream>

class MyClass {
public:
    MyClass() {
        std::cout << "Default constructor called." << std::endl;
    }
};

int main() {
    // 方式一：显式调用默认构造函数
    MyClass obj1 = MyClass(); 
    // 方式二：隐式调用默认构造函数
    MyClass obj2; 

    return 0;
}
```

**解释**：在栈上创建对象时，对象的内存分配和释放由编译器自动管理。当对象超出其作用域时，会自动调用析构函数释放资源。

### 1.2 带参数的构造函数初始化

```cpp
#include <iostream>

class MyClass {
public:
    MyClass(int value) : data(value) {
        std::cout << "Parameterized constructor called with value: " << data << std::endl;
    }
private:
    int data;
};

int main() {
    // 方式一：显式调用带参数的构造函数
    MyClass obj1 = MyClass(10); 
    // 方式二：隐式调用带参数的构造函数
    MyClass obj2(20); 

    return 0;
}
```

**解释**：当类有带参数的构造函数时，可以通过传入相应的参数来初始化对象。

## 2. 在堆上使用指针创建对象

### 2.1 使用 `new` 操作符

```cpp
#include <iostream>

class MyClass {
public:
    MyClass() {
        std::cout << "Default constructor called." << std::endl;
    }
    ~MyClass() {
        std::cout << "Destructor called." << std::endl;
    }
};

int main() {
    // 创建对象
    MyClass* ptr = new MyClass(); 
    // 使用对象
    // ...
    // 释放对象
    delete ptr; 

    return 0;
}
```

**解释**：使用 `new` 操作符在堆上动态分配内存来创建对象，需要手动使用 `delete` 操作符释放内存，否则会导致内存泄漏。

### 2.2 使用智能指针

```cpp
#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() {
        std::cout << "Default constructor called." << std::endl;
    }
    ~MyClass() {
        std::cout << "Destructor called." << std::endl;
    }
};

int main() {
    // 使用 std::unique_ptr
    std::unique_ptr<MyClass> uniquePtr = std::make_unique<MyClass>();
    // 使用 std::shared_ptr
    std::shared_ptr<MyClass> sharedPtr = std::make_shared<MyClass>();

    return 0;
}
```

**解释**：智能指针可以自动管理堆上对象的生命周期，避免手动管理内存带来的风险。`std::unique_ptr` 表示独占所有权，而 `std::shared_ptr` 可以实现多个指针共享同一个对象。

## 3. 拷贝创建对象

### 3.1 拷贝构造函数

```cpp
#include <iostream>

class MyClass {
public:
    MyClass() {
        std::cout << "Default constructor called." << std::endl;
    }
    MyClass(const MyClass& other) {
        std::cout << "Copy constructor called." << std::endl;
    }
};

int main() {
    MyClass obj1;
    MyClass obj2(obj1); 

    return 0;
}
```

**解释**：拷贝构造函数用于创建一个新对象，该对象是另一个同类型对象的副本。

### 3.2 拷贝赋值运算符

```cpp
#include <iostream>

class MyClass {
public:
    MyClass() {
        std::cout << "Default constructor called." << std::endl;
    }
    MyClass& operator=(const MyClass& other) {
        std::cout << "Copy assignment operator called." << std::endl;
        return *this;
    }
};

int main() {
    MyClass obj1;
    MyClass obj2;
    obj2 = obj1; 

    return 0;
}
```

**解释**：拷贝赋值运算符用于将一个对象的值赋给另一个已存在的对象。

## 4. 移动创建对象

### 4.1 移动构造函数

```cpp
#include <iostream>
#include <utility>

class MyClass {
public:
    MyClass() {
        std::cout << "Default constructor called." << std::endl;
    }
    MyClass(MyClass&& other) noexcept {
        std::cout << "Move constructor called." << std::endl;
    }
};

int main() {
    MyClass obj1;
    MyClass obj2(std::move(obj1)); 

    return 0;
}
```

**解释**：移动构造函数用于将一个临时对象的资源转移到新对象中，避免不必要的拷贝操作。

### 4.2 移动赋值运算符

```cpp
#include <iostream>
#include <utility>

class MyClass {
public:
    MyClass() {
        std::cout << "Default constructor called." << std::endl;
    }
    MyClass& operator=(MyClass&& other) noexcept {
        std::cout << "Move assignment operator called." << std::endl;
        return *this;
    }
};

int main() {
    MyClass obj1;
    MyClass obj2;
    obj2 = std::move(obj1); 

    return 0;
}
```

**解释**：移动赋值运算符用于将一个临时对象的资源转移到一个已存在的对象中。

---

## 不用指针直接定义对象

在C++中，使用对象类型不一定要用指针，`T t = T();`这种写法是可行的，以下是具体说明：

- **不用指针直接定义对象**
  - **语法及含义**：`T t = T();`这种写法是直接创建一个类型为`T`的对象`t`，并通过调用`T`的默认构造函数对其进行初始化。在C++中，这是一种合法且常见的对象创建和初始化方式。例如，对于一个简单的`class MyClass`，可以这样创建对象：

    ```cpp
    class MyClass {
    public:
        MyClass() {
            // 构造函数的实现
        }
    };

    int main() {
        MyClass myObj = MyClass();
        return 0;
    }
    ```

    - **栈内存分配**：这种方式创建的对象通常是在栈上分配内存，其生命周期由其作用域决定。当对象超出作用域时，会自动调用析构函数来释放资源。

- **使用指针定义对象**
  - **语法及含义**：使用指针定义对象通常有两种常见的形式，一种是`T* ptr = new T();`，另一种是先定义指针再进行初始化`T* ptr; ptr = new T();`。这两种方式都是在堆上分配内存来创建对象，并让指针`ptr`指向该对象。例如：

    ```cpp
    class MyClass {
    public:
        MyClass() {
            // 构造函数的实现
        }
    };

    int main() {
        MyClass* myPtr = new MyClass();
        // 使用完后需要手动释放内存
        delete myPtr;
        return 0;
    }
    ```

    - **堆内存分配**：使用指针通过`new`操作符在堆上分配内存创建对象，需要手动管理内存，即使用完后要通过`delete`操作符释放内存，以避免内存泄漏。这种方式适用于需要动态分配内存、对象的生命周期需要跨越多个作用域等情况。

---

## 对象判空

在 C++ 中，对象本身不存在“空”的概念，简单来说，c++没有类似java中对象==null的概念，都是通过指针判断是否为空来实现的。

### 1. 普通指针判空

普通指针用于指向对象的内存地址，当指针不指向任何有效对象时，通常将其赋值为 `nullptr`（C++11 及以后版本）或 `NULL`（早期 C++ 或 C 风格）。判空时，只需检查指针是否等于 `nullptr` 或 `NULL`。

```cpp
#include <iostream>

class MyClass {};

int main() {
    MyClass* ptr1 = nullptr;
    if (ptr1 == nullptr) {
        std::cout << "ptr1 is null." << std::endl;
    }

    MyClass obj;
    MyClass* ptr2 = &obj;
    if (ptr2 != nullptr) {
        std::cout << "ptr2 is not null." << std::endl;
    }

    return 0;
}
```

### 2. 智能指针判空

智能指针能自动管理对象的生命周期，不同类型的智能指针判空方式有所不同。

#### 2.1 `std::unique_ptr` 判空

`std::unique_ptr` 是独占所有权的智能指针，可通过 `operator bool()` 或直接与 `nullptr` 比较来判空。

```cpp
#include <iostream>
#include <memory>

class MyClass {};

int main() {
    std::unique_ptr<MyClass> uniquePtr1;
    if (!uniquePtr1) {
        std::cout << "uniquePtr1 is null." << std::endl;
    }

    std::unique_ptr<MyClass> uniquePtr2 = std::make_unique<MyClass>();
    if (uniquePtr2 != nullptr) {
        std::cout << "uniquePtr2 is not null." << std::endl;
    }

    return 0;
}
```

#### 2.2 `std::shared_ptr` 判空

`std::shared_ptr` 可被多个指针共享对象所有权，同样可通过 `operator bool()` 或与 `nullptr` 比较来判空。

```cpp
#include <iostream>
#include <memory>

class MyClass {};

int main() {
    std::shared_ptr<MyClass> sharedPtr1;
    if (sharedPtr1 == nullptr) {
        std::cout << "sharedPtr1 is null." << std::endl;
    }

    std::shared_ptr<MyClass> sharedPtr2 = std::make_shared<MyClass>();
    if (sharedPtr2) {
        std::cout << "sharedPtr2 is not null." << std::endl;
    }

    return 0;
}
```

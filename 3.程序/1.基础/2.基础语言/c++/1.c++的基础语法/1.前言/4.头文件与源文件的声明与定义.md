# 头文件与源文件的声明与定义

在C++中，头文件（通常以`.h`或`.hpp`为后缀）和源文件（通常以`.cpp`为后缀）的分离是“声明与定义分离”原则的具体体现，其核心目的是支持**分离编译**（每个源文件独立编译，最后链接为可执行程序），同时实现代码模块化和复用。下面详细解释两者中各类数据结构的定义方式，重点说明类的声明与实现。

## 一、头文件（.h/.hpp）的核心作用

头文件是“接口层”，主要负责**声明**（告诉编译器“存在什么”），不负责具体实现（除特殊情况外）。其内容包括：  

- 类的声明（包含成员变量和成员函数的声明）  
- 结构体、枚举等类型的声明/定义  
- 函数原型（非成员函数的声明）  
- 全局变量的声明（用`extern`）  
- 宏定义（`#define`）、类型别名（`typedef`、`using`）  
- 模板的声明（通常模板的实现也放在头文件中）  

**必须规则**：头文件必须添加**头文件保护符**（`#ifndef/#define/#endif`或`#pragma once`），防止被多个源文件重复包含时导致“重定义”错误。  

## 二、源文件（.cpp）的核心作用

源文件是“实现层”，主要负责**定义**（提供具体实现或分配内存），内容包括：  

- 头文件中声明的类成员函数的实现  
- 头文件中声明的非成员函数的实现  
- 全局变量的定义（分配内存）  
- 静态成员变量的定义（分配内存）  

## 三、常见数据结构在头文件和源文件中的定义方式

### 1. 结构体（struct）

结构体在C++中与类的区别仅在于默认访问控制（struct默认public，class默认private），其声明和实现方式类似。  

- **头文件（.h）**：声明结构体（包含成员变量和成员函数的声明）  

  ```cpp
  // MyStruct.h
  #ifndef MY_STRUCT_H
  #define MY_STRUCT_H

  // 结构体声明
  struct Point {
      // 成员变量声明（仅声明，不分配内存，内存随对象创建分配）
      int x;
      int y;

      // 成员函数声明（无函数体）
      Point(int x_, int y_);  // 构造函数声明
      void print() const;     // 普通成员函数声明
  };

  #endif  // MY_STRUCT_H
  ```

- **源文件（.cpp）**：实现结构体的成员函数  

  ```cpp
  // MyStruct.cpp
  #include "MyStruct.h"  // 包含头文件，确保声明与实现匹配
  #include <iostream>

  // 构造函数实现（用结构体名::函数名）
  Point::Point(int x_, int y_) : x(x_), y(y_) {}  // 初始化列表

  // 普通成员函数实现
  void Point::print() const {
      std::cout << "(" << x << ", " << y << ")" << std::endl;
  }
  ```

### 2. 枚举（enum）

枚举分为**不限定作用域枚举**（传统enum）和**限定作用域枚举**（enum class），通常在头文件中直接定义（声明和定义合一），因为枚举是“类型定义”，无需单独实现。  

- **头文件（.h）**：  

  ```cpp
  // MyEnum.h
  #ifndef MY_ENUM_H
  #define MY_ENUM_H

  // 不限定作用域枚举（可直接访问枚举值，如Red）
  enum Color {
      Red,
      Green,
      Blue
  };

  // 限定作用域枚举（必须用枚举名::值访问，如Direction::Up）
  enum class Direction {
      Up,
      Down,
      Left,
      Right
  };

  #endif  // MY_ENUM_H
  ```

- 枚举无需在源文件中实现，直接在其他文件中包含头文件即可使用。  

### 3. 全局函数（非成员函数）

全局函数的声明放在头文件，实现放在源文件，避免多个源文件包含时重复定义。  

- **头文件（.h）**：声明函数原型  

  ```cpp
  // MathUtils.h
  #ifndef MATH_UTILS_H
  #define MATH_UTILS_H

  // 函数声明（仅说明接口）
  int add(int a, int b);
  double square(double x);

  #endif  // MATH_UTILS_H
  ```

- **源文件（.cpp）**：实现函数  

  ```cpp
  // MathUtils.cpp
  #include "MathUtils.h"

  // 函数实现
  int add(int a, int b) {
      return a + b;
  }

  double square(double x) {
      return x * x;
  }
  ```

### 4. 全局变量

全局变量的声明放在头文件（用`extern`），定义放在**唯一的一个源文件**中（分配内存），避免重复分配。  

- **头文件（.h）**：声明全局变量（不分配内存）  

  ```cpp
  // GlobalVars.h
  #ifndef GLOBAL_VARS_H
  #define GLOBAL_VARS_H

  // 声明全局变量（表示该变量在其他地方定义）
  extern int g_totalCount;
  extern const double PI;  // 常量全局变量也需要extern声明

  #endif  // GLOBAL_VARS_H
  ```

- **源文件（.cpp）**：定义全局变量（分配内存）  

  ```cpp
  // GlobalVars.cpp
  #include "GlobalVars.h"

  // 定义全局变量（分配内存，可初始化）
  int g_totalCount = 0;
  const double PI = 3.1415926535;  // 常量必须初始化
  ```

## 四、类（class）的声明与实现（重点）

类是C++的核心，其声明与实现的分离是模块化编程的基础。  

### 1. 类的声明（头文件.h）

类的声明需包含：类名、访问控制符（`public`/`private`/`protected`）、成员变量的声明、成员函数的声明（无函数体）。  

```cpp
// Student.h
#ifndef STUDENT_H
#define STUDENT_H

#include <string>  // 包含成员变量所需的类型头文件

class Student {
private:  // 私有成员（仅类内部可访问）
    std::string m_name;  // 成员变量声明（m_前缀表示成员变量，约定）
    int m_age;
    float m_score;

public:  // 公有成员（类外部可访问）
    // 构造函数声明（与类名相同，无返回值）
    Student(std::string name, int age, float score);
    
    // 析构函数声明（~类名，无参数，无返回值）
    ~Student();

    // 普通成员函数声明
    void setScore(float score);
    float getScore() const;  // const成员函数（不修改成员变量）
    void printInfo() const;

    // 静态成员函数声明（属于类，不属于对象）
    static int getStudentCount();

private:  // 私有成员函数（仅类内部调用）
    bool isAdult() const;
};

#endif  // STUDENT_H
```

**关键说明**：  

- 成员变量仅声明（不初始化，除非是**静态常量成员**，如`static const int MAX_AGE = 100;`）。  
- 成员函数声明需指定返回值类型、参数列表，末尾加`;`（无函数体）。  
- `const`成员函数（如`getScore() const`）表示该函数不修改成员变量，否则编译报错。  
- 静态成员函数（`static`）属于类本身，而非对象，声明时需加`static`。  

### 2. 类的实现（源文件.cpp）

类的实现需在源文件中完成，通过`类名::成员名`的方式指定成员所属的类，确保与头文件中的声明匹配。  

```cpp
// Student.cpp
#include "Student.h"  // 必须包含头文件，否则编译器不知道类的声明
#include <iostream>

// 静态成员变量定义（类中仅声明，需在源文件中定义，分配内存）
int Student::s_studentCount = 0;  // 注意：头文件中需声明static int s_studentCount;

// 构造函数实现（用初始化列表初始化成员变量，效率更高）
Student::Student(std::string name, int age, float score) 
    : m_name(name), m_age(age), m_score(score) {
    s_studentCount++;  // 每次创建对象，计数+1
}

// 析构函数实现
Student::~Student() {
    s_studentCount--;  // 对象销毁时，计数-1
}

// 普通成员函数实现
void Student::setScore(float score) {
    m_score = score;  // 修改私有成员变量
}

float Student::getScore() const {  // 末尾的const必须与声明一致
    return m_score;
}

void Student::printInfo() const {
    std::cout << "Name: " << m_name 
              << ", Age: " << m_age 
              << ", Score: " << m_score 
              << ", Is adult: " << (isAdult() ? "Yes" : "No") << std::endl;
}

// 静态成员函数实现（无需加static，类名::即可）
int Student::getStudentCount() {
    return s_studentCount;  // 访问静态成员变量
}

// 私有成员函数实现（类外部无法调用，但需在类内部声明）
bool Student::isAdult() const {
    return m_age >= 18;
}
```

**关键说明**：  

- 构造函数初始化列表（`: m_name(name), m_age(age)`）用于初始化成员变量，比在函数体内赋值更高效（尤其对const成员或引用成员）。  
- 静态成员变量（如`s_studentCount`）必须在源文件中定义（`int Student::s_studentCount = 0;`），类中仅为声明。  
- 析构函数用于释放资源（如动态内存），无参数，无返回值。  
- 成员函数的实现必须与头文件中的声明完全匹配（返回值、参数列表、`const`修饰等），否则会导致链接错误（“未定义的引用”）。  

### 3. 类的使用（其他源文件）

当需要使用类时，只需包含其头文件，即可创建对象并调用成员函数：  

```cpp
// main.cpp
#include "Student.h"
#include <iostream>

int main() {
    // 创建对象（调用构造函数）
    Student s1("Alice", 20, 90.5f);
    Student s2("Bob", 17, 85.0f);

    s1.printInfo();  // 调用公有成员函数
    s2.setScore(88.5f);  // 修改分数

    // 调用静态成员函数（通过类名::调用，无需对象）
    std::cout << "Total students: " << Student::getStudentCount() << std::endl;

    return 0;
}
```

## 五、特殊情况：模板类的声明与实现

模板类（如`template <typename T> class MyVector`）的声明和实现通常**必须放在同一个头文件中**，因为模板的实例化需要知道完整的实现代码（编译器需在使用时生成具体类型的代码）。  

示例（`MyVector.h`）：  

```cpp
#ifndef MY_VECTOR_H
#define MY_VECTOR_H

template <typename T>
class MyVector {
private:
    T* m_data;
    int m_size;

public:
    // 构造函数声明
    MyVector(int size);
    // 析构函数声明
    ~MyVector();

    // 成员函数声明
    T get(int index) const;
    void set(int index, T value);
};

// 模板类的实现必须放在头文件中（与声明同文件）
template <typename T>
MyVector<T>::MyVector(int size) : m_size(size) {
    m_data = new T[size];  // 动态分配内存
}

template <typename T>
MyVector<T>::~MyVector() {
    delete[] m_data;  // 释放内存
}

template <typename T>
T MyVector<T>::get(int index) const {
    return m_data[index];
}

template <typename T>
void MyVector<T>::set(int index, T value) {
    m_data[index] = value;
}

#endif  // MY_VECTOR_H
```

## 六、核心原则总结

1. **头文件（.h）**：  
   - 放声明（类、结构体、函数原型、`extern`变量、枚举、宏等）。  
   - 必须加头文件保护符，避免重复包含。  
   - 只包含必要的头文件（减少编译依赖）。  

2. **源文件（.cpp）**：  
   - 放定义（类成员函数实现、全局函数实现、全局变量定义等）。  
   - 必须包含对应的头文件，确保声明与实现匹配。  

3. **类的声明与实现**：  
   - 声明在.h中：包含成员变量（声明）、成员函数（声明）、访问控制。  
   - 实现在.cpp中：用`类名::成员名`实现函数，静态成员变量需在此定义。  
   - 模板类特殊：声明和实现必须在同一头文件中。  

通过这种分离机制，C++支持大型项目的模块化开发，每个源文件独立编译，最终通过链接器组合为可执行程序，大幅提高编译效率和代码可维护性。

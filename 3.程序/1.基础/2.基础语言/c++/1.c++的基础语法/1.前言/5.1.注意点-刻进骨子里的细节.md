# 刻进骨子里的核心细节

C/C++ 开发的门槛和坑非常多，很多细节看似微小，却可能导致程序崩溃、内存泄漏、逻辑错误，甚至安全漏洞。以下是需要刻进骨子里的核心细节和注意点，覆盖内存管理、类型安全、编译链接、类设计等关键领域：

## 一、内存管理：C/C++ 的“生死线”

1. **指针必须初始化，用完置空**  
   - 未初始化的指针（野指针）是“定时炸弹”，可能指向任意内存，读写会导致不可预测的崩溃（如 `Segmentation Fault`）。  
   - 正确做法：定义时初始化（`int* p = nullptr;`），释放后立即置空（`delete p; p = nullptr;`），避免“垂悬指针”（指向已释放的内存）。  

2. **动态内存的“匹配原则”**  
   - `malloc/free`、`new/delete`、`new[]/delete[]` 必须严格配对，混用会导致内存泄漏或堆损坏。  
     - 例：`int* arr = new int[10]; delete arr;`（错误，应使用 `delete[] arr`）。  
   - 避免在同一指针上多次 `free/delete`，会导致堆 corruption。  

3. **警惕内存泄漏的“重灾区”**  
   - 函数中 `new` 了内存但未 `delete`，尤其在分支语句中（如 `if(...) { new ...; return; }` 忘记释放）。  
   - 类中动态分配的成员变量，必须在析构函数中释放，否则对象销毁后内存泄漏。  
   - 建议：优先使用智能指针（`std::unique_ptr`/`std::shared_ptr`）管理动态内存，而非手动 `new/delete`。  

4. **栈内存不可返回地址**  
   - 栈上的局部变量在函数返回后会被销毁，返回其地址（如 `int* func() { int x; return &x; }`）会导致野指针。  

## 二、指针与引用：最容易混淆的“双胞胎”

1. **指针 vs 引用的本质区别**  
   - 指针是“变量”，存储地址，可被重新赋值（指向其他对象），可为空（`nullptr`）。  
   - 引用是“别名”，必须在定义时初始化（绑定一个对象），不可更改绑定，不能为空（无 `null` 引用）。  
   - 场景：函数参数传递大对象时用引用（避免拷贝），需要“可选参数”时用指针（可传 `nullptr`）。  

2. **指针运算的边界检查**  
   - 指针加减运算（如 `p++`）必须确保不越界（尤其是数组场景），越界访问会破坏堆/栈结构。  
   - 例：`int arr[5]; int* p = &arr[0]; p += 10; *p = 0;`（越界，可能覆盖关键数据）。  

3. **const 与指针的组合**  
   - `const int* p`：指针指向的内容不可改（`*p = 10;` 错误），但指针可改（`p = &x;` 正确）。  
   - `int* const p`：指针本身不可改（`p = &x;` 错误），但指向的内容可改（`*p = 10;` 正确）。  
   - 记忆：`const` 靠近谁，谁就不可改。  

## 三、类型与转换：隐蔽的“陷阱制造者”

1. **有符号与无符号的“致命比较”**  
   - 有符号（`int`）和无符号（`unsigned int`）变量比较时，有符号会被隐式转换为无符号，导致逻辑错误。  
     - 例：`for (unsigned int i = 5; i >= 0; i--)`（死循环，`unsigned` 不会小于 0）。  
   - 解决：避免混合比较，必要时显式转换（如 `(int)i >= 0`）。  

2. **隐式类型转换的风险**  
   - 小类型（如 `char`）赋值给大类型（如 `int`）可能因符号位扩展出问题（ signed char 为负时，转换为 int 会补 1）。  
   - 浮点数与整数转换：`float f = 1.1; int x = f;`（截断而非四舍五入，`x` 为 1）。  

3. **sizeof 的“迷惑性”**  
   - 数组名作为函数参数时会退化为指针，`sizeof` 得到的是指针大小（而非数组长度）。  
     - 例：`void func(int arr[]) { cout << sizeof(arr); }`（输出 8 或 4，取决于平台指针大小）。  
   - `sizeof` 对引用类型时，得到的是被引用对象的大小（而非引用本身，引用本质是别名，无大小）。  

## 四、编译与链接：“找不到定义”的根源

1. **头文件的“三不原则”**  
   - 不定义变量（全局变量定义放 `.c/.cpp`，头文件中用 `extern` 声明）。  
   - 不定义函数（除非是 `inline` 函数或模板函数）。  
   - 不包含其他头文件中已包含的内容（减少编译依赖，用前向声明替代）。  

2. **头文件保护符必须加**  
   - 用 `#ifndef/#define/#endif` 或 `#pragma once` 防止头文件被重复包含，否则会导致“重定义”错误（如类、函数被多次声明）。  

3. **前向声明减少依赖**  
   - 类 A 仅需知道类 B 的存在（无需知道其成员）时，用前向声明 `class B;` 替代 `#include "B.h"`，降低编译耦合。  
   - 注意：前向声明后，只能声明 B 的指针/引用，不能调用其成员（需包含头文件）。  

4. **链接错误“未定义的引用”**  
   - 原因：只声明了函数/变量（如头文件中 `extern int x;`），但未在任何 `.c/.cpp` 中定义（`int x = 0;`）。  
   - 解决：确保声明与定义匹配（参数、返回值、类属关系一致）。  

## 五、类与对象：C++ 封装的“细节杀手”

1. **构造函数的初始化列表优先**  
   - 成员变量在进入构造函数体前已初始化，函数体内的赋值是“二次操作”，效率低。  
   - 必须用初始化列表的场景：`const` 成员、引用成员、没有默认构造函数的成员对象。  
     - 例：`class A { const int x; A(int a) : x(a) {} };`（正确，`x` 必须初始化）。  

2. **析构函数必须是虚函数（基类）**  
   - 基类析构函数非虚函数时，用基类指针删除派生类对象会导致“部分析构”（派生类成员未释放，内存泄漏）。  
   - 正确：`class Base { public: virtual ~Base() {} };`  

3. **拷贝构造与赋值运算符的“深拷贝”**  
   - 类中包含动态内存成员（如 `char* str`）时，默认的浅拷贝会导致两个对象共享同一块内存，析构时重复释放。  
   - 必须手动实现：  

     ```cpp
     class String {
     private:
         char* data;
     public:
         // 拷贝构造
         String(const String& other) {
             data = new char[strlen(other.data) + 1];
             strcpy(data, other.data);
         }
         // 赋值运算符
         String& operator=(const String& other) {
             if (this != &other) {  // 避免自赋值
                 delete[] data;
                 data = new char[strlen(other.data) + 1];
                 strcpy(data, other.data);
             }
             return *this;
         }
     };
     ```

4. **静态成员变量必须类外定义**  
   - 类内仅声明：`class A { static int x; };`，必须在 `.cpp` 中定义：`int A::x = 0;`（否则链接错误）。  

## 六、STL 容器：易用但“坑多”

1. **迭代器失效问题**  
   - `vector`：扩容后迭代器失效（内存重新分配），`push_back`/`insert` 可能导致失效。  
   - `map`/`set`：插入元素不会导致已有迭代器失效（节点结构），但删除元素时，指向该元素的迭代器失效。  
   - 解决：操作后重新获取迭代器（如 `it = vec.erase(it);`）。  

2. **容器的“拷贝代价”**  
   - 大容器（如 `vector<int> v(1000000)`）作为函数参数按值传递时，会触发深拷贝，效率极低。  
   - 正确：传引用（`const vector<int>& v`）或移动语义（`vector<int>&& v`）。  

3. **智能指针的“循环引用”**  
   - `std::shared_ptr` 相互引用（如 A 含 B 的 shared_ptr，B 含 A 的 shared_ptr）会导致引用计数无法归零，内存泄漏。  
   - 解决：一方用 `std::weak_ptr`（不增加引用计数）。  

## 七、其他“致命细节”

1. **宏的“副作用”**  
   - 宏替换是文本替换，缺乏类型检查，且可能因优先级问题出错。  
     - 例：`#define ADD(a,b) a + b`，`ADD(1,2)*3` 会被替换为 `1+2*3=7`（而非预期的 9），应加括号：`(a)+(b)`。  
   - 建议：用 `const`、`enum`、`inline` 函数替代宏。  

2. **数组越界是“静默杀手”**  
   - C/C++ 不检查数组越界，越界写入可能覆盖栈上的返回地址、函数参数，导致崩溃或安全漏洞（如缓冲区溢出攻击）。  
   - 防御：访问前检查索引（`if (i < 0 || i >= size) { /* 处理错误 */ }`）。  

3. **异常与析构函数**  
   - 析构函数中不能抛异常，若析构函数在处理异常时又抛新异常，会导致程序直接终止（`terminate()`）。  

4. **跨平台兼容性**  
   - 基本类型长度：`int` 在 32 位系统是 4 字节，64 位系统可能还是 4 字节（用 `int32_t`/`int64_t` 替代）。  
   - 字节序：大端（如 PowerPC）与小端（如 x86）的数值存储顺序不同，网络传输需统一为大端（用 `htons`/`ntohs` 转换）。  

## 总结

C/C++ 的细节本质是“对内存和类型的绝对控制”，每一个疏忽都可能导致底层错误。记住：**“严要求、细检查”是生存之道**——写代码时多问自己：内存是否释放？指针是否有效？类型转换是否安全？编译报错/警告必须全部解决（不要用 `#pragma warning(disable)` 掩盖）。这些细节不是“规则”，而是避免掉坑的“生存本能”。

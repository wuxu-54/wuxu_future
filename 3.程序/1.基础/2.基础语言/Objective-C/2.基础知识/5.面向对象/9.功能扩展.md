# 功能扩展

>注意这并不是单指：类扩展。本节主要讲与kotlin的扩展、Swift扩展、dart中的混入、TS的装饰器同样的功能，即怎么为类添加新功能或属性。

在 Objective-C 中，扩展指在不修改原始类定义的情况下，为类添加新的功能或属性。这可以通过几种方式实现：

1. **分类/类别（Categories）**：这是 Objective-C 中最常用的扩展方式。通过分类，你可以向现有的类添加新的方法，而不需要修改原始的类定义。分类不能添加属性，因为属性需要在运行时存储值，而分类不支持存储属性的实现。（XCode可以直接创建分类文件）

2. **匿名类别（Anonymous Categories）（在OC中，也称类扩展）**：与普通分类类似，但是它们在实现文件中定义，而不是接口文件中。这使得它们在编译时是隐藏的，只能在定义它们的模块内部使用。

3. **协议（Protocols）**：虽然不是直接的类扩展，但协议可以定义一个类必须实现的方法和属性的蓝图。通过实现协议，类可以扩展其功能，以符合特定的接口规范。

4. **继承（Inheritance）**：通过创建子类并重写或添加方法，可以实现类的扩展。这是面向对象编程中的基本概念。

5. **关联对象（Associated Objects）**：这是一种运行时特性，允许你为对象动态添加属性。这需要使用 Objective-C 的运行时 API，如 `objc_setAssociatedObject` 和 `objc_getAssociatedObject`。

---

## 类别（也叫分类）

**类别（Categories）**：这是 Objective-C 中最常用的扩展方式。通过分类，你可以向现有的类添加新的方法，而不需要修改原始的类定义。分类不能添加属性，因为属性需要在运行时存储值，而分类不支持存储属性的实现。（XCode可以直接创建分类文件）

定义格式：@interface 目标类名(分类名) 方法体 @end
使用：按正常类使用即可。

### 类别的使用示例

```objc
// 定义一个分类
@interface NSString (MyStringExtensions)
- (NSString *)reversedString;
@end

// 实现分类中的方法
@implementation NSString (MyStringExtensions)
- (NSString *)reversedString {
    NSUInteger length = [self length];
    NSMutableString *reversed = [NSMutableString stringWithCapacity:length];
    for (NSUInteger i = length; i != 0; i--) {
        [reversed appendString:[self substringWithRange:NSMakeRange(i - 1, 1)]];
    }
    return reversed;
}
@end

// 使用分类中的方法
NSString *originalString = @"Hello";
NSString *reversed = [originalString reversedString];
```

在这个示例中，我们为 `NSString` 类添加了一个新方法 `reversedString`，它返回字符串的反转版本。这是通过定义一个名为 `MyStringExtensions` 的分类来实现的。

---

## 关联对象

在Objective-C中，关联对象（Associated Objects）是一种允许你在运行时为现有的类添加额外属性的方法。这些属性不是通过修改类的定义来添加的，而是通过在运行时动态地关联到对象上。关联对象通常用于在不修改类定义的情况下，为对象添加自定义数据。

关联对象是通过Objective-C的运行时系统实现的，它们使用键值对的方式来存储和检索数据。你可以使用`objc_setAssociatedObject`和`objc_getAssociatedObject`这两个函数来设置和获取关联对象。

### 关联对象的主要特性

1. **键值对存储**：
   关联对象使用一个键（key）来存储和检索值（value）。

2. **动态性**：
   关联对象在运行时动态添加，不需要修改类的定义。

3. **弱引用和强引用**：
   你可以指定关联对象是弱引用还是强引用。弱引用不会增加对象的引用计数，而强引用会增加。

4. **线程安全**：
   关联对象的设置和获取是线程安全的。

5. **自定义释放**：
   你可以提供一个回调函数，在对象被销毁时释放关联对象。

### 使用关联对象的步骤

1. **定义一个键**：
   通常使用`static`变量来定义一个键，以确保键的唯一性。

   ```objc
   static char kMyAssociatedObjectKey;
   ```

2. **设置关联对象**：
   使用`objc_setAssociatedObject`函数来设置关联对象。

   ```objc
   objc_setAssociatedObject(myObject, &kMyAssociatedObjectKey, myValue, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
   ```

3. **获取关联对象**：
   使用`objc_getAssociatedObject`函数来获取关联对象。

   ```objc
   id myValue = objc_getAssociatedObject(myObject, &kMyAssociatedObjectKey);
   ```

4. **指定关联策略**：
   你可以指定关联对象的保留策略，如`OBJC_ASSOCIATION_ASSIGN`、`OBJC_ASSOCIATION_RETAIN_NONATOMIC`、`OBJC_ASSOCIATION_COPY_NONATOMIC`等。

### 示例代码

```objc
// 在类的方法中设置关联对象
- (void)setMyValue:(id)value {
    static char kMyAssociatedObjectKey;
    objc_setAssociatedObject(self, &kMyAssociatedObjectKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

// 获取关联对象
- (id)myValue {
    static char kMyAssociatedObjectKey;
    return objc_getAssociatedObject(self, &kMyAssociatedObjectKey);
}
```

### 注意事项

- 确保键是唯一的，以避免与其他关联对象冲突。
- 关联对象的内存管理取决于你选择的关联策略。
- 在ARC环境下，通常使用`OBJC_ASSOCIATION_RETAIN_NONATOMIC`或`OBJC_ASSOCIATION_COPY_NONATOMIC`。

关联对象是Objective-C运行时的一个强大特性，它提供了一种灵活的方式来扩展类的功能，而不需要修改类的定义。这在编写插件或需要向第三方类添加功能时特别有用。

---

## 类扩展（匿名类别）

在Objective-C中，扩展（Extension）是一种为现有类添加额外方法或属性的机制，这些方法和属性默认是私有的，只能在定义它们的类内部访问，不能被子类继承。扩展通常被称为匿名类别（anonymous categories），因为它们没有显式的名称。

Objective-C 允许在**实现文件中（即.m文件）**使用类扩展来声明私有方法和属性。类扩展不会在头文件中公开，因此它们是私有的。

```objective-c
@interface MyClass ()
- (void)privateMethod;
@end
```

### 扩展的特点

1. **私有方法和属性**：
   扩展中声明的方法和属性只能在定义它们的类内部访问，对外界不可见。

2. **匿名类别**：
   扩展实际上是没有名称的类别，它们在类的实现文件中定义。

3. **声明和实现**：
   扩展在类的`.m`文件中声明，通常使用`@interface`关键字，后面跟着类名和一对**空的圆括号**。

   ```objc
   @interface MyClass ()
   // 在这里声明私有方法和属性
   @end
   ```

4. **使用限制**：
   扩展只能为有`.m`文件的类使用，因为扩展实际上是在类的实现文件中添加新的方法或属性。

5. **不可用于框架类**：
   你不能为框架类（如Cocoa或Cocoa Touch中的类）声明扩展，因为这些类的实现是封闭的，你无法访问它们的`.m`文件。

6. **不继承**：
   扩展中的方法和属性不能被子类继承，因为它们被标记为私有。

### 扩展与类别（Categories）的区别

1. **类别（Categories）**：
   - 类别可以为任何类添加方法，包括框架类。
   - 类别中的方法可以被子类继承。

2. **扩展（Extensions）**：
   - 扩展只能为有源代码的类添加方法。
   - 扩展中的方法和属性默认是私有的，不能被子类继承。

### 使用扩展的实例

```objc
// MyClass.h
@interface MyClass : NSObject
@property (nonatomic, strong) NSString *name;
@end

// MyClass.m
@implementation MyClass

// 公开方法
- (void)printName {
    NSLog(@"Name: %@", self.name);
}

// 扩展声明
@interface MyClass ()
// 私有方法和属性
- (void)printInternalInfo;
@end

// 扩展实现
@implementation MyClass (Private)

// 私有方法实现
- (void)printInternalInfo {
    NSLog(@"Internal Info");
}

@end
```

在这个例子中，`MyClass`有一个公开的方法`printName`，它在类的实现文件中定义。同时，有一个扩展在`MyClass.m`中声明了一个私有方法`printInternalInfo`，这个方法只能在`MyClass`的内部访问。

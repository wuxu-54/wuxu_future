# 继承

在Objective-C中，继承是面向对象编程的一个核心概念，它允许新创建的类（子类）继承现有类（父类）的属性和方法。以下是Objective-C继承的一些关键点：

1. **定义子类**：
   使用冒号`:`语法在类定义中指定父类。

   ```objc
   @interface Subclass : Superclass
   // 子类定义
   @end
   ```

2. **继承属性**：
   子类自动继承父类的所有实例变量。

3. **继承方法**：
   子类继承父类的所有实例方法。

4. **重写方法**：
   子类可以重写父类的方法，以提供定制的行为。

   ```objc
   - (void)someMethod {
       [super someMethod]; // 调用父类的方法
       // 子类特有的实现
   }
   ```

5. **初始化**：
   子类的初始化方法应该调用父类的对应初始化方法，以确保父类被正确初始化。

   ```objc
   - (instancetype)initWithValue:(NSInteger)value {
       self = [super init];
       if (self) {
           self.value = value;
       }
       return self;
   }
   ```

6. **多态性**：
   继承允许多态性，即同一个接口可以有多个实现。

7. **消息转发**：
   当向对象发送消息时，运行时会根据对象的实际类型来调用相应的方法。

8. **内存管理**：
   子类应该遵循父类的内存管理规则，尤其是在手动管理内存的情况下。

9. **访问控制**：
   子类可以访问父类的公共（`public`）和受保护（`protected`）成员，但不能直接访问私有（`private`）成员。

10. **使用`super`**：
    在子类中，使用`super`关键字来引用父类。

11. **避免过度继承**：
    继承应该谨慎使用，避免产生复杂的继承层次结构。

12. **组合优于继承**：
    在某些情况下，使用组合（Composition）而不是继承可能是更好的设计选择。

## 示例代码

```objc
@interface Animal : NSObject
- (void)speak;
@end

@implementation Animal
- (void)speak {
    NSLog(@"The animal makes a sound");
}
@end

@interface Dog : Animal
@end

@implementation Dog

- (void)speak {
    // 重写父类方法
    NSLog(@"The dog barks");
}

@end

int main() {
    Animal *myAnimal = [[Dog alloc] init];
    [myAnimal speak]; // 输出 "The dog barks"
    return 0;
}
```

在这个示例中，`Dog`类继承自`Animal`类，并重写了`speak`方法。通过使用多态性，`myAnimal`作为`Animal`类型的指针，实际上指向了一个`Dog`类型的对象，并调用了`Dog`类的`speak`方法。

继承是Objective-C中实现代码复用和扩展现有功能的重要机制。通过合理使用继承，可以构建结构清晰、易于维护的代码。

---

## 重写

重写（Overriding）是指子类提供了与父类中相同名称的方法的实现，但行为不同。这允许子类修改或扩展父类的行为。

以下是 Objective-C 中重写的一些关键点：

1. **方法声明**：在父类中声明的方法需要使用 `+ (void)class` 或 `- (returnType)method` 来表明是类方法还是实例方法。

2. **方法实现**：父类中的方法实现使用 `+` 或 `-` 后跟方法名和参数列表，然后是花括号 `{}` 包含的代码块。

3. **重写方法**：子类重写父类的方法时，需要使用相同的方法签名（方法名和参数列表），但可以有不同的实现。

4. **使用 `super` 关键字**：在子类的方法实现中，可以使用 `super` 关键字来调用父类中的方法实现。这允许子类在扩展或修改行为的同时，仍然保持父类的行为。

5. **访问控制**：如果父类的方法声明为 `@protected` 或 `@public`，则子类可以重写它。如果声明为 `@private`，则不能在子类中重写。

6. **方法签名**：重写的方法必须具有与父类中声明的方法完全相同的签名。

下面是一个简单的 Objective-C 重写示例：

```objc
// 父类接口
@interface SuperClass : NSObject
- (void)display;
@end

// 父类实现
@implementation SuperClass
- (void)display {
    NSLog(@"Display method of SuperClass");
}
@end

// 子类接口
@interface SubClass : SuperClass
@end

// 子类实现
@implementation SubClass

- (void)display {
    // 调用父类的方法
    [super display];
    
    // 添加子类特有的行为
    NSLog(@"Display method of SubClass with additional behavior");
}
@end
```

在这个例子中，`SubClass` 重写了 `SuperClass` 的 `display` 方法。它首先调用了 `super` 的 `display` 方法来保持父类的行为，然后添加了自己的行为。

重写是多态性的一个重要方面，它允许你以统一的方式处理不同类型的对象，即使它们的方法实现可能不同。这是面向对象编程的一个核心概念。

# 类

在Objective-C中，类（Class）是一种引用类型，用于创建和管理对象。类是Objective-C面向对象编程的核心概念之一，它定义了对象的属性和行为。
>面向对象核心：封装、继承、多态

以下是Objective-C中类的基本概念和用法：

1. **定义类**：
   使用`@interface`关键字定义类的接口，使用`@implementation`关键字实现类的方法。

   ```objc
   @interface MyClass : NSObject
   @property (nonatomic, strong) NSString *name;
   - (void)sayHello;
   @end

   @implementation MyClass
   - (void)sayHello {
       NSLog(@"Hello, %@", self.name);
   }
   @end
   ```

2. **继承**：
   使用冒号`:`和父类名指定继承关系，子类可以继承父类的属性和方法。

3. **实例变量**：
   在类接口中定义的变量，通常用于存储对象的状态信息。

4. **属性**：
   使用`@property`关键字声明属性，可以指定属性的内存管理语义（如`strong`、`weak`、`assign`等）和访问控制（如`readonly`）。

5. **方法**：
   - **实例方法**：使用`-`符号定义，关联到类的每个实例。
   - **类方法**：使用`+`符号定义，关联到类本身。

6. **构造器**：
   使用`init`开头的方法作为类的构造器，用于创建和初始化对象。

7. **析构器**：
   使用`dealloc`方法作为类的析构器，用于在对象被销毁前进行清理。

8. **访问控制**：
   使用`@private`、`@protected`和`@public`关键字控制成员变量和方法的访问级别。

9. **消息传递**：
   使用对象的实例方法或类方法时，实际上是向对象发送消息。

10. **内存管理**：
    Objective-C使用引用计数进行内存管理，通过`retain`、`release`、`autorelease`等方法管理对象的生命周期。

11. **协议（Protocols）**：
    类可以实现一个或多个协议，承诺遵循特定的方法和属性。

12. **类方法创建实例**：
    使用类方法`alloc`和`init`组合来创建并初始化对象。

    ```objc
    MyClass *myObject = [[MyClass alloc] init];
    ```

13. **对象字面量**：
    使用`@`符号和类名可以创建对象字面量，简化创建对象的过程。

    ```objc
    MyClass *myObject = @"MyClass";
    ```

14. **类的元数据**：
    使用`objc_getClass`、`class_getName`等函数可以获取类的元数据。

15. **类的动态特性**：
    使用`objc_msgSend`等函数可以实现消息的动态发送和接收。

## 示例代码

```objc
// 定义一个人类
@interface Person : NSObject
@property (nonatomic, strong) NSString *name;
- (void)introduce;
@end

// 实现人类
@implementation Person
- (void)introduce {
    NSLog(@"My name is %@", self.name);
}
@end

// 使用人类
int main() {
    Person *person = [[Person alloc] init];
    person.name = @"John Doe";
    [person introduce];
    return 0;
}
```

Objective-C中的类是创建对象的蓝图，定义了对象的属性和行为。通过使用类，开发者可以利用面向对象编程的优势，如封装、继承和多态，来构建复杂和可维护的应用程序。

---

## Posing(已废弃，了解即可)

在 Mac OS X 10.5 中， Posing 已被宣布为弃用，此后将无法使用。因此，对于那些不关心这些不推荐的方法的人，可以跳过本章。

Objective-C 支持一个类完全替换程序中的另一个类。替换类被称为目标类的 Posing。对于支持 Posing 的版本，发送到目标类的所有消息都由 Posing 类接收。
>说白了就是委托设计模式，替换类即委托类

`NSObject` 包含 `poseAsClass` − 方法，使我们能够替换如上所述的现有类。

### Posing 的限制

- 类只能作为其直接或间接超类之一。
- posing 类不能定义目标类中不存在的任何新实例变量（尽管它可以定义或重写方法）。
- 目标类在 posing 之前可能没有收到任何消息。
- posing 类可以通过 super 调用重写的方法，从而合并目标类的实现。
- posing 类可以覆盖类别中定义的方法。

```objc
#import <Foundation/Foundation.h>
@interface MyString : NSString
@end
@implementation MyString
- (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target
withString:(NSString *)replacement {
  NSLog(@"The Target string is %@",target);
  NSLog(@"The Replacement string is %@",replacement);
}
@end
int main() {
  NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
  [MyString poseAsClass:[NSString class]];
  NSString *string = @"Test";
  [string stringByReplacingOccurrencesOfString:@"a" withString:@"c"];
  [pool drain];
  return 0;
}

/* 执行结果：
2022-07-07 21:23:46.829 Posing[372:303] The Target string is a
2022-07-07 21:23:46.830 Posing[372:303] The Replacement string is c 
*/
```

# 多态

在 Objective-C 中，多态性（Polymorphism）是一个重要的面向对象编程特性，它允许你通过父类类型的引用来调用子类的方法实现。多态性主要通过以下两种方式实现：

1. **方法重写（Overriding）**：子类可以重写父类的方法，即使用相同的方法名和参数列表，但提供不同的实现。当通过父类类型的引用调用该方法时，实际执行的是子类的实现。

2. **动态方法解析（Dynamic Method Resolution）**：Objective-C 允许在运行时解析方法调用，这意味着即使一个类没有实现某个方法，如果它的任何子类实现了这个方法，那么在运行时这个方法调用仍然可以被正确解析和执行。

## 多态的使用场景

- **接口的统一**：多态允许你使用统一的接口来处理不同类型的对象。
- **扩展现有类**：子类可以扩展父类的功能，而不影响使用父类类型的代码。
- **动态绑定**：在运行时，Objective-C 会根据对象的实际类型来调用相应的方法实现。

## 示例

```objc
// 父类
@interface Animal : NSObject
- (void)speak;
@end

@implementation Animal
- (void)speak {
    NSLog(@"The animal makes a sound");
}
@end

// 子类
@interface Dog : Animal
@end

@implementation Dog
- (void)speak {
    [super speak]; // 调用父类的方法
    NSLog(@"The dog barks");
}
@end

// 使用多态
Animal *myAnimal = [[Dog alloc] init];
[myAnimal speak]; // 输出：The animal makes a sound\nThe dog barks
```

在这个示例中，`Dog` 类继承自 `Animal` 类，并重写了 `speak` 方法。当我们创建一个 `Dog` 类的实例并将其赋值给 `Animal` 类型的变量时，我们仍然可以通过这个变量调用 `speak` 方法，而实际执行的是 `Dog` 类的 `speak` 方法实现。这就是多态性的表现。

## 动态方法解析

Objective-C 还支持动态方法解析，这意味着你可以调用一个对象的方法，即使该对象的类中没有定义这个方法，只要这个方法在对象的任何子类中被定义。这可以通过 `respondsToSelector:` 方法来检查，或者直接调用，如果不存在则返回 nil 或者抛出异常。

```objc
if ([myAnimal respondsToSelector:@selector(speak)]) {
    [myAnimal performSelector:@selector(speak)];
}
```

多态性是 Objective-C 中一个强大的特性，它提高了代码的灵活性和可扩展性。

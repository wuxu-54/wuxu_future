# JavaScript文件类型检查

>完全拷贝的文档，了解就行， [JavaScript 文件类型检查](https://www.tslang.cn/docs/handbook/type-checking-javascript-files.html)

JavaScript文件类型检查，主要是使用: 固定格式注释，达到TS语法检查的目的。

## 如何配置js检查

TypeScript 2.3以后的版本支持使用`--checkJs`对.js文件进行类型检查和错误提示。

* 你可以通过添加`// @ts-nocheck`注释来忽略类型检查；相反，你可以通过去掉`--checkJs`设置并添加一个`// @ts-check`注释来选则检查某些.js文件。
* 你还可以使用`// @ts-ignore`来忽略本行的错误。
* 如果你使用了tsconfig.json，JS检查将遵照一些严格检查标记，如`noImplicitAny`，`strictNullChecks`等。 但因为JS检查是相对宽松的，在使用严格标记时可能会有些出乎意料的情况。

## .js文件和.ts文件在类型检查上的差异

### 用JSDoc类型表示类型信息

.js文件里，类型可以和在.ts文件里一样被推断出来。 同样地，当类型不能被推断时，它们可以通过JSDoc来指定，就好比在.ts文件里那样。 如同TypeScript，--noImplicitAny会在编译器无法推断类型的位置报错。 （除了对象字面量的情况；后面会详细介绍）

JSDoc注解修饰的声明会被设置为这个声明的类型。比如：

```typescript
/** @type {number} */
var x;

x = 0;      // OK
x = false;  // Error: boolean is not assignable to number
```

你可以在这里找到所有JSDoc支持的模式，[JSDoc文档](https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript)。

### 属性的推断来自于类内的赋值语句

ES2015没提供声明类属性的方法。属性是动态赋值的，就像对象字面量一样。

在.js文件里，编译器从类内部的属性赋值语句来推断属性类型。 属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是undefined或null。 若是这种情况，类型将会是所有赋的值的类型的联合类型。 在构造函数里定义的属性会被认为是一直存在的，然而那些在方法，存取器里定义的属性被当成可选的。

```typescript
class C {
    constructor() {
        this.constructorOnly = 0
        this.constructorUnknown = undefined
    }
    method() {
        this.constructorOnly = false // error, constructorOnly is a number
        this.constructorUnknown = "plunkbat" // ok, constructorUnknown is string | undefined
        this.methodOnly = 'ok'  // ok, but y could also be undefined
    }
    method2() {
        this.methodOnly = true  // also, ok, y's type is string | boolean | undefined
    }
}
```

如果一个属性从没在类内设置过，它们会被当成未知的。

如果类的属性只是读取用的，那么就在构造函数里用JSDoc声明它的类型。 如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：

```typescript
class C {
    constructor() {
        /** @type {number | undefined} */
        this.prop = undefined;
        /** @type {number | undefined} */
        this.count;
    }
}

let c = new C();
c.prop = 0;          // OK
c.count = "string";  // Error: string is not assignable to number|undefined
```

### 构造函数等同于类

ES2015以前，Javascript使用构造函数代替类。 编译器支持这种模式并能够将构造函数识别为ES2015的类。 属性类型推断机制和上面介绍的一致。

```typescript
function C() {
    this.constructorOnly = 0
    this.constructorUnknown = undefined
}
C.prototype.method = function() {
    this.constructorOnly = false // error
    this.constructorUnknown = "plunkbat" // OK, the type is string | undefined
}
```

### 支持CommonJS模块

在.js文件里，TypeScript能识别出CommonJS模块。 对exports和module.exports的赋值被识别为导出声明。 相似地，require函数调用被识别为模块导入。例如：

```typescript
// same as `import module "fs"`
const fs = require("fs");

// same as `export function readFile`
module.exports.readFile = function(f) {
  return fs.readFileSync(f);
}
```

对JavaScript文件里模块语法的支持比在TypeScript里宽泛多了。 大部分的赋值和声明方式都是允许的。

### 类，函数和对象字面量是命名空间

.js文件里的类是命名空间。 它可以用于嵌套类，比如：

```typescript
class C {
}
C.D = class {
}
```

ES2015之前的代码，它可以用来模拟静态方法：

```typescript
function Outer() {
  this.y = 2
}
Outer.Inner = function() {
  this.yy = 2
}
```

它还可以用于创建简单的命名空间：

```typescript
var ns = {}
ns.C = class {
}
ns.func = function() {
}
```

同时还支持其它的变化：

```typescript
// 立即调用的函数表达式
var ns = (function (n) {
  return n || {};
})();
ns.CONST = 1

// defaulting to global
var assign = assign || function() {
  // code goes here
}
assign.extra = 1
```

### 对象字面量是开放的

.ts文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。 这个规则在.js文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。例如：

```typescript
var obj = { a: 1 };
obj.b = 2;  // Allowed
```

对象字面量的表现就好比具有一个默认的索引签名[x:string]: any，它们可以被当成开放的映射而不是封闭的对象。

与其它JS检查行为相似，这种行为可以通过指定JSDoc类型来改变，例如：

```typescript
/** @type {{a: number}} */
var obj = { a: 1 };
obj.b = 2;  // Error, type {a: number} does not have property b
```

null，undefined，和空数组的类型是any或any[]

任何用null，undefined初始化的变量，参数或属性，它们的类型是`any`，就算是在严格null检查模式下。 任何用`[]`初始化的变量，参数或属性，它们的类型是`any[]`，就算是在严格null检查模式下。 唯一的例外是像上面那样有多个初始化器的属性。

```typescript
function Foo(i = null) {
    if (!i) i = 1;
    var j = undefined;
    j = 2;
    this.l = [];
}
var foo = new Foo();
foo.l.push(foo.i);
foo.l.push("end");
```

### 函数参数是默认可选的

由于在ES2015之前无法指定可选参数，因此.js文件里所有函数参数都被当做是可选的。 使用比预期少的参数调用函数是允许的。

需要注意的一点是，使用过多的参数调用函数会得到一个错误。

例如：

```typescript

function bar(a, b) {
  console.log(a + " " + b);
}

bar(1);       // OK, second argument considered optional
bar(1, 2);
bar(1, 2, 3); // Error, too many arguments
```

使用JSDoc注解的函数会被从这条规则里移除。 使用JSDoc可选参数语法来表示可选性。比如：

```typescript
/**
 * @param {string} [somebody] - Somebody's name.
 */
function sayHello(somebody) {
    if (!somebody) {
        somebody = 'John Doe';
    }
    console.log('Hello ' + somebody);
}

sayHello();
```

### 由`arguments`推断出的var-args参数声明

如果一个函数的函数体内有对arguments的引用，那么这个函数会隐式地被认为具有一个var-arg参数`（比如:(...arg: any[]) => any)）`。使用JSDoc的var-arg语法来指定arguments的类型。

```typescript
/** @param {...number} args */
function sum(/* numbers */) {
    var total = 0
    for (var i = 0; i < arguments.length; i++) {
      total += arguments[i]
    }
    return total
}
```

### 未指定的类型参数默认为any

由于JavaScript里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为any。

**在extends语句中**：

例如，React.Component被定义成具有两个类型参数，Props和State。 在一个.js文件里，没有一个合法的方式在extends语句里指定它们。默认地参数类型为any：

```typescript
import { Component } from "react";

class MyComponent extends Component {
    render() {
        this.props.b; // Allowed, since this.props is of type any
    }
}
```

使用JSDoc的@augments来明确地指定类型。例如：

```typescript
import { Component } from "react";

/**
 * @augments {Component<{a: number}, State>}
 */
class MyComponent extends Component {
    render() {
        this.props.b; // Error: b does not exist on {a:number}
    }
}
```

**在JSDoc引用中**：

JSDoc里未指定的类型参数默认为any：

```typescript
/** @type{Array} */
var x = [];

x.push(1);        // OK
x.push("string"); // OK, x is of type Array<any>

/** @type{Array.<number>} */
var y = [];

y.push(1);        // OK
y.push("string"); // Error, string is not assignable to number
```

**在函数调用中**:

泛型函数的调用使用arguments来推断泛型参数。有时候，这个流程不能够推断出类型，大多是因为缺少推断的源；在这种情况下，类型参数类型默认为any。例如：

```typescript
var p = new Promise((resolve, reject) => { reject() });

p; // Promise<any>;
```

## 支持的JSDoc

下面的列表列出了当前所支持的JSDoc注解，你可以用它们在JavaScript文件里添加类型信息。

注意，没有在下面列出的标记（例如`@async`）都是还不支持的。

* @type
* @param (or @arg or @argument)
* @returns (or @return)
* @typedef
* @callback
* @template
* @class (or @constructor)
* @this
* @extends (or @augments)
* @enum

它们代表的意义与usejsdoc.org上面给出的通常是一致的或者是它的超集。 下面的代码描述了它们的区别并给出了一些示例。

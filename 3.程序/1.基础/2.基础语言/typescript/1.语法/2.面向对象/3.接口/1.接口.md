# 接口

TS中的接口和java中的接口不同，不是继承，而是作为对某个结构的描述，让编译器对结构进行强制校验的处理。

注意：

1. 接口可以作为对象的属性结构性描述
2. 接口可以作为函数的结构性描述
3. 接口描述索引类型结构(索引类型 数组、元组)
4. 接口可以强制类符号接口定义的结构

---

## 接口对类属性结构描述

### 描述类属性结构的接口定义

定义：

```typescript
interface SquareConfig{
    color:string;//编译器会校验，类必须包含color属性，且类型为string
}
function test(config:SquareConfig){

}

test({color:"123"});//如果没有color属性，编译器会检查报错
```

### 可选属性

接口中，有些属性不是必需要校验的。那可以设定为可选属性。

定义：

```typescript
interface Config{
    color?:string; // ?: 就是可选属性，当对象没有这个属性时也不报错
    name:string;
}
```

### 只读属性

属性一旦赋值，就无法更改。使用关键字 readonly前缀声明

定义：

```typescript
interface Config{
   readonly name:string;
}
const myConfig = {name:"123"}
function test(config:Config){
    // config.name = "1";//报错，不允许readonly 重新赋值
}
test(myConfig);
```

### 额外的属性检查

类有额外的其他属性，正常编译时会报错。针对此情况，可以使用任意属性声明

定义：

```typescript
interface Config{
    name:string;
    color:string;
    [propName:string]:any;// 可以有额外任何数量的string类型属性
}
function test(config:Config){

}
test({name:"13",age:"11"});//age就是额外的属性
```

---

## 接口对函数结构的描述

接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型

### 描述函数的接口定义

```typescript
interface Func{
    (source:string,subString:string):boolean;//描述函数结构
}
let fun :Func;//相当于签订契约
fun = function(source1:string,subString1:string):boolean{//符合契约的方法才能赋值给fun.注意： 编译器检查参数类型、返回值，但不校验参数名
      return true;
}
```

---

## 接口对索引结构的描述

与使用接口描述函数类型差不多，我们也可以描述那些能够**通过索引得到**的类型，比如`a[10]`或`ageMap["daniel"]`。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。

### 描述索引结构的定义

TypeScript支持两种索引签名：字符串和数字。

```typescript
interface IArray{
    [index:number]:string;//定义索引类型是number，返回值是string
     // [index:string]:string;//文档中说可以这样用，但是具体怎么使用string索引，没明白。打开编译器报错提示缺少string类型索引
}

let arr :IArray;
arr = ["1","2"];
let value:string = arr[0];//string类型
```

特别说明：

索引结构定义，可以确保`属性类型`与`索引返回值类型`保持一致。

```typescript
interface IArray{
    [index:string]:number;//字典模式就是这样。 因为字符串索引声明了 obj.property和obj["property"]两种形式都可以
    length:number;
    // name:string;//这个报错，因为此属性类型 与 索引结构返回值类型不一致
}
```

---

## 接口对类结构描述

与java接口作用基本一样，ts可以用接口强制使某个类符合某种契约。

```typescript
interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}

class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}
```

### 类静态区别和实例部分区别

类实例部分可以使用接口，正常约束，静态部分不受编译器检查。当接口约束了构造器时，因为构造器属于静态部分，不会被编译器检查，所以在调用时才会报错。
>编译器只检查校验非静态部分代码

例子：

```typescript
interface ClockConstructor {
    new (hour: number, minute: number);//带new声明的，是构造函数，不能直接被继承实现
}

class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }//这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。
}
```

修正上述示例：

```typescript
interface ClockConstructor {
    new (hour: number, minute: number);//这里仍然约束构造器
}
interface ClockInterface{
    tick();
}

class A implements ClockInterface{
    construct(h:number,m:number){} // 构造器符合ClockConstructor约束，即使没有实现接口

    // function tick(){} //写法错误，不应该有function

    tick(){
         console.log(`A:${h}`)
     }//实现函数
}

class B implements ClockInterface{
    construct(h:number,m:number){} // 构造器符合ClockConstructor约束，即使没有实现接口
    tick(){
        console.log(`B:${h}`)
     }//实现函数
}

//创建全局函数，通过函数进行构造器约束.
function createClockInterface(obj:ClockConstructor,param1:number,param2:number):ClockInterface{
    return new obj(param1,param2);
}

const a:A = createClockInterface(A,1,2);//obj 是ClockConstructor类型，当A、B传入时，已经通过编译器校验了
const b:B = createClockInterface(B,1,2);
```

---

## 接口定义混合类型

通过接口，对象可同时具有多种结构类型，如定义 函数类型结构、类类型结构

例子:一个对象可以同时做为函数和对象使用，并带有额外的属性。

```typescript
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = <Counter>function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```

---

## 接口继承

接口可以多继承

```typescript
interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = <Square>{};
square.color = "blue";
square.sideLength = 10;
square.penWidth = 5.0;
```

---

## 接口继承`类类型`

ts 特有  
特点：  

1. 接口可以继承`类类型`，此时接口会继承类的成员（不包括已经实现的）。
2. 可以继承受保护的成员（`private` 和 `protect`）
3. 接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被`这个类或其子类`所实现（implement）。 （这个要特别注意，是原来被继承的类及其子类才可以实现这个接口）

```typescript
class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class TextBox extends Control {
    select() { }
}

// 错误：“Image”类型缺少“state”属性。  只有Control类或其子类才能实现 SelectableControl
class Image implements SelectableControl {
    select() { }
}

class Location {

}
```

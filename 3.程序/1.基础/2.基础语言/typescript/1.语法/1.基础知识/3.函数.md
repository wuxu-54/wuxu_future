# 函数

## 函数定义

function关键字 函数名(形参列表):返回值类型{return 返回值}

1. 返回值类型可以省略,编译器可以推断出类型
2. 函数可以作为类型，也可以作为值赋给变量（此时变量的类型就是函数结构类型）

```typescript
//定义函数
function add(x:number):number{
    return x+1;
}
```

在 TypeScript 中定义方法（函数）与在 JavaScript 中非常相似，但 TypeScript 提供了类型系统，允许你为函数的参数和返回值指定类型。以下是在 TypeScript 中定义方法的一些基本示例：

### 定义一个简单函数

```typescript
function greet(name: string): void {
    console.log("Hello, " + name);
}
```

在这个例子中，`greet` 函数接受一个类型为 `string` 的参数 `name`，并且没有返回值（`void` 类型）。

### 定义一个带有返回值的函数

```typescript
function add(a: number, b: number): number {
    return a + b;
}
```

这个 `add` 函数接受两个类型为 `number` 的参数 `a` 和 `b`，并返回它们的和（类型也为 `number`）。

### 定义一个可选参数的函数

```typescript
function createUser(name: string, age?: number): User {
    let user = new User(name);
    if (age !== undefined) {
        user.age = age;
    }
    return user;
}
```

在这个例子中，`age` 参数是可选的，因为它后面有一个 `?` 标记。这意味着在调用 `createUser` 函数时，可以不提供 `age` 参数。

### 定义一个默认参数的函数

```typescript
function configureRequest(options: { url: string; method: string; headers?: { [key: string]: string } }): Request {
    // ...
}
```

在这个例子中，`headers` 是一个可选参数，它是一个对象类型，其中键是字符串，值也是字符串。

### 定义一个重载函数

TypeScript 支持函数重载，允许你为同一个函数名定义多个函数类型。

```typescript
function getUserInfo(user: User): UserInfo;
function getUserInfo(userId: number): UserInfo;
function getUserInfo(arg: any): UserInfo {
    // 实现...
}
```

在这个例子中，`getUserInfo` 函数可以接收一个 `User` 对象或一个 `number` 类型的 `userId` 作为参数。

### 定义一个箭头函数

```typescript
const sum = (a: number, b: number): number => a + b;
```

这个 `sum` 是一个箭头函数，它接受两个 `number` 类型的参数并返回它们的和。

### 定义一个函数类型

```typescript
type StringProcessor = (input: string) => string;
```

在这个例子中，定义了一个 `StringProcessor` 类型，它是一个函数类型，接受一个 `string` 类型的参数并返回一个 `string` 类型的值。

### 定义一个泛型函数

```typescript
function identity<T>(arg: T): T {
    return arg;
}
```

这个 `identity` 函数是一个泛型函数，它可以接收任何类型的参数并返回相同类型的值。

通过这些示例，你可以看到 TypeScript 提供了丰富的类型系统来增强函数的定义和使用。这有助于在编译时捕捉错误，并提高代码的可读性和可维护性。

---

## this

js中讲了this指向，这里就简单做下补充

1. ts中，可以设置形参[this:void]表示当前函数内无法使用this
2. js中this是动态变化指向的，所以回调函数一般使用箭头函数，直接确定this指向。ts可以在回调函数形参确定[this:具体指向类型]。

```typescript
let deck = {
    suits: ["hearts", "spades", "clubs", "diamonds"],
    cards: Array(52),
    createCardPicker: function() {
        return function() {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
/**
 可以看到createCardPicker是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为 createCardPicker返回的函数里的this被设置成了window而不是deck对象。 因为我们只是独立的调用了 cardPicker()。 顶级的非方法式调用会将 this视为window。 （注意：在严格模式下， this为undefined而不是window）。

 简单解释：cardPicker最终是个普通函数，调用时this指向调用者也就是window，所以报错。
*/
```

以上问题，js处理方式：

```typescript
let deck = {
    suits: ["hearts", "spades", "clubs", "diamonds"],
    cards: Array(52),
    createCardPicker: function() {
        // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here
        return () => {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
        /**
         为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的 this值，而不是调用时的值：
         */
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
```

ts处理方式：

```typescript
interface Card {
    suit: string;
    card: number;
}
interface Deck {
    suits: string[];
    cards: number[];
    createCardPicker(this: Deck): () => Card;
}
let deck: Deck = {
    suits: ["hearts", "spades", "clubs", "diamonds"],
    cards: Array(52),
    // ts中，直接确定this 类型是 Deck
    createCardPicker: function(this: Deck) {
        return () => {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert("card: " + pickedCard.card + " of " + pickedCard.suit);
```

>关于普通函数、箭头函数中this的解释可去看js章节复习

---

## 函数重载

同一作用域下，函数名相同，参数列表或返回值不同，就是函数重载。

当有多个重载函数时，编译器会匹配最符合的函数，然后调用其方法。

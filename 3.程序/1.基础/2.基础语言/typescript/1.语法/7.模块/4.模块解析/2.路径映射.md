# 路径映射

tsconfig.json 文件配置baseurl和paths，可以作为`非相对路径导入`解析时的路径配置。

例子：  

```json
{
  "compilerOptions": {
    "baseUrl": ".", // 这是baseurl，跟paths组成完整路径
    "paths": {
      "jquery": ["node_modules/jquery/dist/jquery"] // 此处映射是相对于"baseUrl"，这里会与baseurl组成：<baseurl><path值>
    }
  }
}
```

## 特殊映射

通过"paths"我们还可以指定复杂的映射，包括指定多个回退位置。 假设在一个工程配置里，有一些模块位于一处，而其它的则在另个的位置。 构建过程会将它们集中至一处。 工程结构可能如下：

```txt
projectRoot
├── folder1
│   ├── file1.ts (imports 'folder1/file2' and 'folder2/file3')
│   └── file2.ts
├── generated
│   ├── folder1
│   └── folder2
│       └── file3.ts
└── tsconfig.json
```

相应的tsconfig.json文件如下:

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "*": [
        "*",
        "generated/*"
      ]
    }
  }
}
```

它告诉编译器所有匹配"*"（所有的值）模式的模块导入会在以下两个位置查找：

1. `"*"`： 表示名字不发生改变，所以映射为`<moduleName> => <baseUrl>/<moduleName>`
2. `"generated/*"`表示模块名添加了`“generated”`前缀，所以映射为`<moduleName> => <baseUrl>/generated/<moduleName>`

按照这个逻辑，编译器将会如下尝试解析这两个导入：

* 导入'folder1/file2'
    1. 匹配'*'模式且通配符捕获到整个名字。
    2. 尝试列表里的第一个替换：'*' -> folder1/file2。
    3. 替换结果为非相对名 - 与baseUrl合并 -> projectRoot/folder1/file2.ts。
    4. 文件存在，完成。
* 导入'folder2/file3'
    1. 匹配'*'模式且通配符捕获到整个名字。
    2. 尝试列表里的第一个替换：'*' -> folder2/file3。
    3. 替换结果为非相对名 - 与baseUrl合并 -> projectRoot/folder2/file3.ts。
    4. 文件不存在，跳到第二个替换。
    5. 第二个替换：'generated/*' -> generated/folder2/file3。
    6. 替换结果为非相对名 - 与baseUrl合并 -> projectRoot/generated/folder2/file3.ts。
    7. 文件存在，完成。

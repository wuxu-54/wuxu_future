# 模块解析

模块解析指编译器在查找导入模块内容所遵循的流程。

>这块内容不涉及代码，只是编译器解析模块导入导出的一些原理，了解就行。

简要描述：

假设有个导入语句 `import{a} from "moduleA"`，编译器要明确`a`是干嘛的，所以会检索到`moduleA`

1. 编译器遵循策略（`Classic`和`Node` 二者之一），进行导入模块文件定位。
2. 步骤一未找到，同时模块名是`非相对`，编译器会尝试定位一个`外部声明`。
3. 以上步骤都不行，会抛错误。错误可能为 error TS2307: Cannot find module 'moduleA'.

---

## `相对`与`非相对`导入

编译器会根据导入方式，采用不同的解析方式。

* 相对导入是以/，./或../开头的

    `相对`的是文件本身,并且不能解析为一个`外部模块声明`

    下面是一些例子：

    ```typescript
    //
    import Entry from "./components/Entry";
    import { DefaultHeaders } from "../constants/http";
    import "/mod";
    ```

* 所有其它形式的导入被当作非相对的。

    `非相对` 编译器通过tsconfig文件的baseUrl及path路径映射，来找对应的文件， 它们还可以被解析成 `外部模块声明`

    下面是一些例子：

    ```typescript
    import * as $ from "jQuery";
    import { Component } from "@angular/core";
    ```

---

## 模块解析策略

共有两种可用的模块解析策略：`Node`和`Classic`。 你可以使用 `--moduleResolution`标记来指定使用哪种模块解析策略。若未指定，那么在使用了 `--module AMD | System | ES2015`时的默认值为`Classic`，其它情况时则为`Node`。

---

### Classic 策略

#### 相对路径导入-Classic

分析：`/root/src/folder/A.ts`文件里的`import { b } from "./moduleB"`

相对导入是从当前文件所在目录开始查。

策略解析流程如下：

1. /root/src/folder/moduleB.ts
2. /root/src/folder/moduleB.d.ts

#### 非相对路径导入-Classic

非相对导入是从当前文件所在目录，依次向上级目录开始查。

策略解析流程如下：

1. /root/src/folder/moduleB.ts
2. /root/src/folder/moduleB.d.ts
3. /root/src/moduleB.ts
4. /root/src/moduleB.d.ts
5. /root/moduleB.ts
6. /root/moduleB.d.ts
7. /moduleB.ts
8. /moduleB.d.ts

### Node.js的解析策略

通常，在`Node.js`里导入是通过 `require`函数调用进行的。 `Node.js`会根据 `require`的是`相对路径`还是`非相对路径`做出不同的行为。

#### 相对路径导入-Node.js

假设有一个文件路径为 `/root/src/moduleA.js`，包含了一个导入`var x = require("./moduleB");` Node.js以下面的顺序解析这个导入

1. 检查`/root/src/moduleB.js`文件是否存在。
2. 检查`/root/src/moduleB`目录是否包含一个`package.json`文件，且package.json文件指定了一个`"main"`模块。 在我们的例子里，如果Node.js发现文件 `/root/src/moduleB/package.json`包含了`{ "main": "lib/mainModule.js" }`，那么Node.js会引用`/root/src/moduleB/lib/mainModule.js`。
3. 检查`/root/src/moduleB`目录是否包含一个`index.js`文件, 这个文件会被隐式地当作那个文件夹下的`"main"`模块。

### 非相对路径导入-Node.js

非相对导入是从当前文件所在目录，依次向上级目录开始查。

假设`/root/src/moduleA.js`里使用的是非相对路径导入`var x = require("moduleB");`。 Node则会以下面的顺序去解析 moduleB，直到有一个匹配上。

1. /root/src/node_modules/moduleB.js
2. /root/src/node_modules/moduleB/package.json (如果指定了"main"属性)
3. /root/src/node_modules/moduleB/index.js

4. /root/node_modules/moduleB.js
5. /root/node_modules/moduleB/package.json (如果指定了"main"属性)
6. /root/node_modules/moduleB/index.js

7. /node_modules/moduleB.js
8. /node_modules/moduleB/package.json (如果指定了"main"属性)
9. /node_modules/moduleB/index.js

注意Node.js在步骤（4）和（7）会向上跳一级目录。

### ts的Node解析策略

在运行时模仿`Node.js`模块解析机制，TypeScript在Node解析逻辑基础上增加了TypeScript源文件的扩展名（ .ts，.tsx和.d.ts），同时，TypeScript在 package.json里使用字段`"types"`来表示类似`"main"`的意义

#### 相对路径导入-ts

有一个导入语句`import { b } from "./moduleB"`在`/root/src/moduleA.ts`里，会以下面的流程来定位"./moduleB"

1. /root/src/moduleB.ts
2. /root/src/moduleB.tsx
3. /root/src/moduleB.d.ts
4. /root/src/moduleB/package.json (如果指定了"types"属性)
5. /root/src/moduleB/index.ts
6. /root/src/moduleB/index.tsx
7. /root/src/moduleB/index.d.ts

回想一下Node.js先查找moduleB.js文件，然后是合适的package.json，再之后是index.js。

#### 非相对路径导入-ts

 `/root/src/moduleA.ts`文件里的`import { b } from "moduleB"`会以下面的查找顺序解析:

1. /root/src/node_modules/moduleB.ts
2. /root/src/node_modules/moduleB.tsx
3. /root/src/node_modules/moduleB.d.ts
4. /root/src/node_modules/moduleB/package.json (如果指定了"types"属性)
5. /root/src/node_modules/moduleB/index.ts
6. /root/src/node_modules/moduleB/index.tsx
7. /root/src/node_modules/moduleB/index.d.ts

8. /root/node_modules/moduleB.ts
9. /root/node_modules/moduleB.tsx
10. /root/node_modules/moduleB.d.ts
11. /root/node_modules/moduleB/package.json (如果指定了"types"属性)
12. /root/node_modules/moduleB/index.ts
13. /root/node_modules/moduleB/index.tsx
14. /root/node_modules/moduleB/index.d.ts

15. /node_modules/moduleB.ts
16. /node_modules/moduleB.tsx
17. /node_modules/moduleB.d.ts
18. /node_modules/moduleB/package.json (如果指定了"types"属性)
19. /node_modules/moduleB/index.ts
20. /node_modules/moduleB/index.tsx
21. /node_modules/moduleB/index.d.ts

不要被这里步骤的数量吓到 - TypeScript只是在步骤（8）和（15）向上跳了两次目录。 这并不比Node.js里的流程复杂。

# AMD模块定义规范

>本章节是从网上直接粘过来的，了解就行

AMD 即Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个**在浏览器端模块化开发的规范**，服务器端的规范是CommonJS。

AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。

## 特点

模块将被`异步加载`，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。

## define() 函数

AMD规范只定义了一个函数 define，它是全局变量。函数的描述为：

  define(id?, dependencies?, factory);

* id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）

## 模块名的格式

* 模块名是用正斜杠分割的有意义单词的字符串
* 单词须为驼峰形式，或者"."，".."
* 模块名不允许文件扩展名的形式，如“.js”
* 模块名可以为 "相对的" 或 "顶级的"。如果首字符为“.”或“..”则为相对的模块名
* 顶级的模块名从根命名空间的概念模块解析
* 相对的模块名从 "require" 书写和调用的模块解析
* 模块名用来唯一标识定义中模块，它们同样在依赖性数组中使用：

  * *依赖dependencies*：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。

  * 依赖参数是可选的，如果忽略此参数，它应该默认为["require", "exports", "module"]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。

  * 工厂方法factory：模块初始化要执行的函数或对象。依赖模块必须根据模块的工厂方法优先级执行，并且执行的结果应该按照依赖数组中的位置顺序以参数的形式传入（定义中模块的）工厂方法中。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。
  
## 例子
  
  创建一个名为"alpha"的模块，使用了require，exports，和名为"beta"的模块:
  
```javascript
define("alpha", ["require", "exports", "beta"], function (require, exports, beta) {
      exports.verb=function() {
          return beta.verb();
          //Or:returnrequire("beta").verb();
      }
  });
一个返回对象的匿名模块：
  define(["alpha"], function (alpha) {
      return {
        verb:function(){
          return alpha.verb() +2;
        }
      };
  });
一个没有依赖性的模块可以直接定义对象：
  define({
    add:function(x, y){
      return x + y;
    }
  });
一个使用了简单CommonJS转换的模块定义：
  define(function (require, exports, module) {
    var a =require('a'),
        b =require('b');

    exports.action=function () {};
  });
```

## 资料

[require API 介绍](https://github.com/amdjs/amdjs-api/wiki/require)

[AMD规范中文版](https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88))

目前，实现AMD的库有RequireJS 、curl 、Dojo 、Nodules 等。

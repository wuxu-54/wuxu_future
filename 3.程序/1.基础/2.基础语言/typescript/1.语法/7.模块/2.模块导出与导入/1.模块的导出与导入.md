# 模块导出导入

## 模块导出

1. 普通导出 `export+成员`

    ```typescript
    /**
     * 普通导出
    */
    export interface T{}//导出接口
    export class C{}//导出类
    export const vP = "123";//导出属性
    export function fun(){}//导出方法
    ```

2. 批量导出 `export{}`

    ```typescript
    /**
     * 批量导出
     */
    class Parent{}
    class Parent2{}
    class Parent3{}
    class Child extends Parent{}
    export { Parent,Parent2,Parent3}; // 可以批量导出
    export { Child as TTT}; //重命名,导出
    ```

3. 将其他模块，重新导出

    ```typescript
    /**
     * 将其他文件模块，重新导出
     */
    export { OtherClass } from "./a_module_export2"; //a_module_export2是其他的模块
    ```

4. 多模块合并导出 `export * from "module"`

    假如当前模块包括多个其他模块，可以使用* 合并导出全部内容

    ```typescript
    /**
    * 多模块合并导出
    * 
    * 使用* 
    */
    export * from "./a_module_export2"
    export * from "./a_module_export2"
    export * from "./a_module_export2"
    ```

5. 默认导出 `export default`

    与普通导出区别：
     * 1.同一模块，只能有一个，不论什么类型
     * 2.默认导出，无需{}，且默认导入时，命名随意
     * 3.关键字增加 default

    ```typescript
    const DefualtA= "A"
    const DefualtB= "B"
    const DefualtC = 1;
    function funTTT(){}
    export default DefualtA;
    // export default DefualtC;//报错，默认导出，只能有一个
    // export default funTTT();//报错，默认导出，只能有一个
    export {DefualtA,DefualtB};//普通导出，可以多个
    ```

6. export =

    目的：兼容CommonJS和AMD, 模块加载器会编译成各自版本的文件代码。

    注意：
     * 1.这种导出方式，导入时必须使用 `import 名字 = require("导入的模块文件")`
     * 2.不能在具有其他导出元素的模块中使用导出分配

    ```typescript
    class TestExport{}
    export AA =  TestExport;
    ```

---

## 模块导入

1. 普通导入

    ```typescript
    import { C } from "./a_module_export";//普通导入，属性名相同

    import {C as T} from "./a_module_export";//重命名导入

    import {type PInterface}  from "./a_module_export";//接口导入需要增加type关键字修饰
    ```

2. 整模块导入，设定变量

    ```typescript
    import * as TTTT from "./a_module_export";//as 是将所有导入内容用变量指代
    let c3 = new TTTT.C();//访问其导出的内容
    ```

3. 仅导入，不使用其导出内容

    目的：我只想导入模块，而不要这个模块内容的具体导出

    ```typescript
    import "./my-module.js";//不建议
    ```

4. 默认导入 `import default`

    与普通导入区别：
    1. 命名随意
    2. 不用{}

    ```typescript
    import AAA from "./a_module_export" // 默认导出，命名随意
    AAA.length;//DefualtA
    ```

5. require

    作用：
    1. 兼容CommonJS和AMD的导入  
    当 `export =` 形式导出，需要使用 `import = require`导入

        ```typescript
        /**
         * 兼容CommonJS和AMD的导入
        */
        import name11 = require("./a_module_export");
        ```

    2. 动态加载模块  
    配合`typeof` 实现可选加载，也就是动态加载

        ```typescript
        declare function require(moduleName: string): any;

        import { ZipCodeValidator as Zip } from "./ZipCodeValidator";

        if (needZipValidation) {
            let ZipCodeValidator: typeof Zip = require("./ZipCodeValidator");//这里通过typeof 强制指定版本，达到动态加载引入的目的
            let validator = new ZipCodeValidator();
            if (validator.isAcceptable("...")) { /* ... */ }
        }
        ```

---

# 装饰器写法

写法类似java中注解，采用`@expression`这种形式，标记在元素上。

1. `expression`是个函数，本身是个**固定格式的函数**（注意，函数的格式跟随被装饰成员类型确定，不同类型有不同的参数列表）。
2. 与java注解区别是，装饰器本质是个函数，可以对被装饰元素进行代码处理。

写法案例：

```typescript
function TTT(target){
    target.AAA = true;//target是类，AAA就是向类添加静态方法
}

@TTT
Class O{}
```

## 装饰器工厂

结构：普通函数 + 装饰器函数返回值

调用：@函数名(参数)
  >这里要清楚，装饰器工厂就是个函数，他返回值是个装饰器函数类型，所以在使用时，相当于调用这个工厂函数。本质仍然是装饰器函数类型修饰元素

```typescript
//装饰器工厂
function catchError(msg: string) {
    //返回值，这里格式，说明此装饰器修饰的元素是一个函数
  return function (target: any, key: string, descriptor: PropertyDescriptor) {
  };
}

class T{
    @catchError("111")//装饰器工厂函数，得加（），表示调用。其返回一个装饰器函数
    void test(){}
}
```

作用：可以向装饰器函数传数据。

## 组合装饰器

当多个装饰器修饰同一元素，此时就是组合装饰器。

写法：

```typescript
// 书写在同一行上：
@f @g x
// 书写在多行上：
@f
@g
y
```

特殊点是，它类似复合函数，有固定的调用规则。比如上面的组合装饰器，它相当于**f(g(x))**

ts组合装饰器执行规则：

1. 由上至下依次对装饰器表达式求值。（针对的是装饰器工厂，从上到下调用工厂函数）
2. 求值的结果会被当作函数，由下至上依次调用。（装饰器函数，由下到上执行）

使用`装饰器工厂`的例子来观察它们求值的顺序：

```typescript
function f() {
    console.log("f(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("f(): called");
    }
}
function g() {
    console.log("g(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("g(): called");
    }
}
class C {
    @f()
    @g()
    method() {}
}
// 结果：
// f(): evaluated
// g(): evaluated
// g(): called
// f(): called
```

# 装饰器分类

可以被装饰器修饰的元素有：`类声明`，`方法`，`访问符`，`属性`,`函数参数`

## 类装饰器

修饰在类的声明上，是对类的构造函数进行处理（构造函数是其唯一参数）

装饰器函数结构：

    function 装饰器名(target) { 函数体 }  

target指类的构造函数

## 类方法装饰器

修改类中的函数，包括静态和非静态

装饰器函数参数：

1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。
3. 成员的属性描述符。

装饰器函数返回值：  
如果方法装饰器返回一个值，它会被用作方法的属性描述符。

装饰器函数结构：

    function 装饰器名(构造函数或原型对象, 被装饰方法的名字, 被装饰方法的属性描述) {
        return descriptor;//返回值可写可不写，写上指的就是属性描述符
    }

**案例**:

    ```typescript
    //实例方法
    function readOnly(target,name,descript){
        descript.writable = false;//让类的方法变为只读
        return descript;//也可以不写
    }
    class Test{
        @readOnly
        test(){}
    }

    //静态方法
    function readOnlyStatic(target,name,descript){
        target.isTest = true;//向类添加静态属性
    }
    class TestStatic{
        @readOnlyStatic
        static ttt(){}
    }
    ```

## 访问器装饰器

应用于访问器的属性描述符并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 declare的类）里。
>访问器：类中的set、get方法  
**注意**  TypeScript不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的。

装饰器函数参数：

1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。
3. 成员的属性描述符。

>注意  如果代码输出目标版本小于ES5，Property Descriptor将会是undefined。

装饰器结构：

     function 装饰器名(构造函数或原型对象, 被装饰方法的名字, 被装饰方法的属性描述) {
        return descriptor;//返回值可写可不写，写上指的就是属性描述符
    }

**案例**:

    ```typescript
    class Point {
        private _x: number;
        private _y: number;
        constructor(x: number, y: number) {
            this._x = x;
            this._y = y;
        }

        @configurable(false)
        get x() { return this._x; }

        @configurable(false)
        get y() { return this._y; }
    }
    function configurable(value: boolean) {
        return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
            descriptor.configurable = value;
        };
    }
    ```

## 类属性装饰器

修饰类中的属性成员

装饰器函数参数：

1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 属性成员的名字。

>属性描述符（属性描述符就与上面函数描述符一样，有对属性的描述信息，如果writable等属性的控制）不会作为参数传入，官方文档有说明。

结构：function 装饰器名(构造函数或原型对象，属性成员名字)

**案例**:

    ```typescript
    class MyTestableClass {
        @testable
        name: string;

        constructor(name: string) {
            this.name = name;
        }
    }

    function testable(target, name) {
        console.log(arguments)
    }
    ```

## 参数装饰器

装饰器函数参数：

1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。
3. 参数在函数参数列表中的索引。

>参数装饰器只能用来监视一个方法的参数是否被传入。参数装饰器的返回值会被忽略。

**案例**：

    ```typescript
    class T{
        test(@t a:string){}
    }
    //用于标记参数必须传入
    function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {
        let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];
        existingRequiredParameters.push(parameterIndex);
        Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);
    }

    ```

# 模块扩展

此内容针对TS 兼容 JS来说的，JS中支持模块化编程，但是不支持`合并`，所以得通过扩展的方式，让编译器正常工作。

案例：

JS中：  

```typescript
// observable.js
export class Observable<T> {
    // ... implementation left as an exercise for the reader ...
}

// map.js
import { Observable } from "./observable";
Observable.prototype.map = function (f) {
    // ... another exercise for the reader
}
```

上述代码在JS中可以执行，因为JS可以动态添加 参数及值，TS中是没法识别map的，必须要提前知道map是啥。所以TS中如想实现 map属性，可以使用扩展模块：

```typescript
// observable.ts stays the same
// map.ts  这个模块就是扩展模块，扩展了原模块的内容
import { Observable } from "./observable";
declare module "./observable" {//declare module 这个就是对模块进行扩展内容
    interface Observable<T> {
        map<U>(f: (x: T) => U): Observable<U>;//声明一个结构，避免编译时报错
    }
}
Observable.prototype.map = function (f) {
    // ... another exercise for the reader
}


// consumer.ts
import { Observable } from "./observable";
import "./map";//这个模块就是扩展模块，使o有了map方法
let o: Observable<number>;
o.map(x => x.toFixed());
```

1. 模块名的解析和用 `import/ export`解析模块标识符的方式是一致的。
2. 当这些声明在扩展中合并时，就好像在原始位置被声明了一样。
3. 不能在扩展中声明新的顶级声明－仅可以扩展模块中已经存在的声明。

## 全局扩展

与扩展模块一样，只是把扩展设置到了全局作用域。

```typescript
// observable.ts
export class Observable<T> {
    // ... still no implementation ...
}

declare global {//declare global  这个表示全局作用域扩展
    interface Array<T> {
        toObservable(): Observable<T>;
    }
}

Array.prototype.toObservable = function () {
    // ...
}
```

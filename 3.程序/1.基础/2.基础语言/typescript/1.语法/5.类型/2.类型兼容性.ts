/**
 * 类型兼容性，指赋值时，不完全相同的类型可以兼容。
 * 
 * 兼容规则：
 * 1.ts运行不同类型兼容，兼容规则：如果x要兼容y，y结构必须包含x结构（y>=x）
 * 2.非函数的类型兼容，比较的是 命名+类型，如对象的兼容，会校验命名的，如果名字不匹配说明兼容不了。
 * 3.函数类型的兼容，比较的是参数列表类型+返回值类型，跟形参命名无关。
 *      注意：
 *      1. 参数的位置也要一致
 *      2. 目标函数结构必须包含源函数结构 （源函数：值 等号右边，目标函数：被赋值方 等号左边）
 * 4.函数重载时的兼容，源函数的每个重载函数，在目标函数都能兼容
 * 5.枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。
 * 6.比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。
 * 7.类的私有成员和受保护成员会影响兼容性。
 *      当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。
 *      同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。
 * 8.泛型类型，只有具体使用时，才会进行比较，如果一个泛型没有使用，那么不在兼容性比较范围内
 *      注意：
 *      1.泛型函数，当泛型没有明确时，编译器会编译为 any类型； <T>(x: T) => T 如果T没有明确类型，那编译后 (x: any) => any
*/

//--------------1---------------------
interface Named{
    name:string;
    // t:number;
}
class N{
    name:string
}
let a:Named; // 声明a结构是 接口 Named类型的。
a = new N();// 因为class N结构复合接口Named，所以a可以被赋值。 这就是类型的兼容


//--------------2---------------------

/**
 * TypeScript结构化类型系统的基本规则是，如果test要兼容y，那么y至少具有与test相同的属性。
 */
let test: Named;
// y's inferred type is { name: string; location: string; }
let y = { name: 'Alice', location: 'Seattle' };
test = y; // 这里可以赋值，因为ts运行，有相同属性的不同类型兼容赋值。


//---------------3--------------------
/**
 * 函数类型的兼容，比较的是参数列表类型+返回值类型，跟形参名无关
 */
let fun1 = (a:number)=>{}
let fun2 = (b:number,c:string)=>{}
let fun3 = (t:string,b:number,c:string)=>{}

// fun1 = fun2;//报错，fun1 结构小于fun2，缺少c类型
fun2 = fun1;//正确，因为fun2结构包含fun1，且参数位置一致。
// fun3 = fun1;//报错，fun3结构包含fun1，但参数位置不同


//--------------4---------------------
/**
 * 对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。
 */


//---------------8--------------------
/**
 * 泛型类型，只有具体使用时，才会进行比较，如果一个泛型没有使用，那么不在兼容性比较范围内
 * 
 */

interface Empty1<T> {
}
let em1: Empty1<number> = {};
let em2: Empty1<string> = {};

em2 = em1;  // 可以，因为泛型没有参与类型定义，所以编译器不会采用泛型的类型进行兼容性推导

interface NotEmpty<T> {
    data: T;
}
let notEmpty1: NotEmpty<number> = {data:1};
let notEmpty2: NotEmpty<string>= {data:"1"};

// notEmpty1 = notEmpty2;  // 不可以，泛型T参与属性的类型定义，无法兼容

let identity = function<T>(x: T): T {return x;}

let reverse = function<U>(y: U): U {return y;}

identity = reverse;  // OK，编译器会将没有明确声明的泛型，设定为any类型
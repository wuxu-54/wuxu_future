# 属性类型的检查规则

对元素的属性是否匹配，进行检查。

---

## 固有元素的属性检查

比较简单，在`JSX.IntrinsicElements`中直接写明即可。

```typescript
declare namespace JSX {
    interface IntrinsicElements {
    foo: { bar?: boolean }
    }
}

// `foo`的元素属性类型为`{bar?: boolean}`
<foo bar />;
```

## 基于值的元素的属性检查

不同于固有元素，这里需要在特殊结构：`JSX.ElementAttributesProperty`单独指明

```typescript
declare namespace JSX {
    interface ElementAttributesProperty {
    props; // 指定用来使用的属性名
    }
}

class MyComponent {
    // 在元素实例类型上指定属性
    props: {
    foo?: string;
    }
}

// `MyComponent`的元素属性类型为`{foo?: string}`
<MyComponent foo="bar" />
```

## 注意

1. 元素属性类型用于的JSX里进行属性的类型检查。 支持可选属性和必须属性。

    ```typescript
    declare namespace JSX {
        interface IntrinsicElements {
        foo: { requiredProp: string; optionalProp?: number }
        }
    }

    <foo requiredProp="bar" />; // 正确
    <foo requiredProp="bar" optionalProp={0} />; // 正确
    <foo />; // 错误, 缺少 requiredProp
    <foo requiredProp={0} />; // 错误, requiredProp 应该是字符串
    <foo requiredProp="bar" unknownProp />; // 错误, unknownProp 不存在
    <foo requiredProp="bar" some-unknown-prop />; // 正确, `some-unknown-prop`不是个合法的标识符
    ```

    >注意：如果一个属性名不是个合法的JS标识符（像`data-*`属性），并且它没出现在`元素属性类型约束`里时不会当做一个错误。

2. 延展操作符也可以使用

    ```typescript
    var props = { requiredProp: 'bar' };
    <foo {...props} />; // 正确

    var badProps = {};
    <foo {...badProps} />; // 错误
    ```

3. 其他补充
    * JSX还会使用`JSX.IntrinsicAttributes`接口来指定**额外的属性**，这些额外的属性通常不会被组件的`props`或`arguments`使用 - 比如`React里的key`。
    * `JSX.IntrinsicClassAttributes<T>`泛型类型也可以用来指定**额外属性**。这里的泛型参数表示**类实例类型**。

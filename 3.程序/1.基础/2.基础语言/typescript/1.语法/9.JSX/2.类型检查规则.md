# 类型检查

编译器需要对内容进行检查校验

类型检查需要了解`固有元素`与`基于值的元素` 以及二者之间区别。（TS使用与React相同规范，**这里的元素就是html中的元素**）

> JSX章节学习，因为JSX是React的核心内容，所以需要提前学习React知识

---

## 固有元素（明确的元素）

通过特殊接口`JSX.IntrinsicElements`确定的元素类型。（在接口中直接指明，元素的名称、类型、此元素的属性名和类型）

注意：如果`JSX.IntrinsicElements`不存在，编译时会全部通过，不会对固有元素进行类型检查吗，否则，编译器会在`JSX.IntrinsicElements`接口的属性里查找。

案例：  

```typescript
declare namespace JSX {
    interface IntrinsicElements {
        foo: any
    }
}
<foo />; // 正确
<bar />; // 错误,因为没在JSX.IntrinsicElements里指定
```

巧用：如果想避免上面的错误，可以在`JSX.IntrinsicElements`上指定一个用来捕获所有字符串索引

```typescript
declare namespace JSX {
    interface IntrinsicElements {
        [elemName: string]: any;
    }
}
```

---

## 基于值的元素（不是由特殊接口指明的元素）

根据类名、函数名、模块名等类型，设定的元素。

例如：  

```typescript
import MyComponent from "./myComponent";
                                
<MyComponent />; // 正确，模块名，直接作为一个元素
<SomeOtherComponent />; // 错误
```

设定基于值的元素的方式：

1. 无状态函数组件（简称SFC）
2. 类组件

### 无状态函数组件

函数，且第一个参数是`props对象`（个人理解props，指可以表示元素属性的对象）。

TS会强制将函数组件的返回值赋给`JSX.Element`

```typescript
const Button = (prop: {value: string}, context: { color: string }) => <button>//首参是props对象 ，也就是属性对象。返回值<button>是个JSX.Element
```

### 类组件

我们可以定义类组件。但是需要满足下面两种类型的检查。（`JSX.ElementClass` 可以指定结构的约束。编译器通过下面两种类型检查来确定是否符合约束）

1. 元素类的类型  
ES6下，如果是类，类类型是指 `类的构造函数和静态部分`。； 如果是函数，类类型为这个函数

2. 元素实例的类型，在类类型前提下存在。  
ES6下，如果是类，实例类型为这个`类的实例的类型` （什么是类的实例的类型，指对非静态部分的结构约束。*面向对象章节*有解释）；如果是函数，实例类型为这个`函数返回值类型`。

案例：

```typescript
class MyComponent {
    render() {}
}

// 使用构造签名
var myComponent = new MyComponent();

// 元素类的类型 => MyComponent
// 元素实例的类型 => { render: () => void }

function MyFactoryFunction() {
    return {
    render: () => {
    }
    }
}

// 使用调用签名
var myComponent = MyFactoryFunction();

// 元素类的类型 => FactoryFunction
// 元素实例的类型 => { render: () => void }
```

注意：JSX也可以设定结构约束

默认的`JSX.ElementClass`为`{}`，但是它可以被扩展用来限制JSX的类型以符合相应的接口。

```typescript
declare namespace JSX {
    interface ElementClass {
    render: any;
    }
}

class MyComponent {
    render() {}
}
function MyFactoryFunction() {
    return { render: () => {} }
}

<MyComponent />; // 正确
<MyFactoryFunction />; // 正确

class NotAValidComponent {}
function NotAValidFactoryFunction() {
    return {};
}

<NotAValidComponent />; // 错误
<NotAValidFactoryFunction />; // 错误,因为不符合实例类型的约束，缺少render成员
```

---

## 两种元素类型在类型检查时的区别

TypeScript使用与React相同的规范 来区别它们。 固有元素总是以一个小写字母开头，基于值的元素总是以一个大写字母开头。

1. 对于React，固有元素会生成字符串（React.createElement("div")），然而由你`自定义的组件（或者交基于值的元素）`却不会生成（React.createElement(MyComponent)）。
2. 传入JSX元素里的属性类型的查找方式不同。 `固有元素属性`本身就支持，然而`自定义的组件（或者交基于值的元素）`会自己去指定它们具有哪个属性。

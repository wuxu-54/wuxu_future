# 泛型解释

在 TypeScript 中，泛型是一种强大的工具，它允许你创建可重用的组件，这些组件可以处理多种类型而不是单一类型。泛型提供了一种方式来创建泛型类、泛型函数、泛型接口等，增强了代码的灵活性和可维护性。下面将从多个方面详细介绍 TypeScript 泛型。

## 1. 泛型函数

泛型函数可以处理不同类型的数据，通过在函数定义时使用泛型类型参数，在调用函数时指定具体的类型。

### 示例代码

```typescript
// 定义一个泛型函数，用于返回传入的值
function identity<T>(arg: T): T {
    return arg;
}

// 使用泛型函数，显式指定类型
let output1 = identity<string>("myString");
console.log(output1); 

// 类型推断，让 TypeScript 自动推断类型
let output2 = identity(100); 
console.log(output2); 
```

### 代码解释

- `identity<T>` 中的 `<T>` 是泛型类型参数，它是一个占位符，代表任意类型。
- `arg: T` 表示参数 `arg` 的类型是 `T`，函数的返回值类型也是 `T`。
- 在调用 `identity` 函数时，可以显式指定类型（如 `identity<string>("myString")`），也可以让 TypeScript 自动推断类型（如 `identity(100)`）。

## 2. 泛型类

泛型类与泛型函数类似，它允许类在实例化时使用不同的类型。

### 2.1 示例代码

```typescript
// 定义一个泛型类
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;

    constructor(zeroValue: T, addFunction: (x: T, y: T) => T) {
        this.zeroValue = zeroValue;
        this.add = addFunction;
    }
}

// 创建一个处理数字的实例
let myGenericNumber = new GenericNumber<number>(0, function (x, y) {
    return x + y;
});

// 创建一个处理字符串的实例
let stringNumeric = new GenericNumber<string>("", function (x, y) {
    return x + y;
});

console.log(myGenericNumber.add(1, 2)); 
console.log(stringNumeric.add("Hello, ", "World!")); 
```

### 2.2 代码解释

- `class GenericNumber<T>` 中的 `<T>` 是泛型类型参数。
- `zeroValue: T` 表示 `zeroValue` 属性的类型是 `T`，`add: (x: T, y: T) => T` 表示 `add` 方法接受两个类型为 `T` 的参数，并返回一个类型为 `T` 的值。
- 在实例化 `GenericNumber` 类时，可以指定具体的类型（如 `new GenericNumber<number>(...)` 和 `new GenericNumber<string>(...)`）。

## 3. 泛型接口

泛型接口定义了一个具有泛型类型参数的接口，可用于约束函数或对象的类型。

### 3.1 示例代码

```typescript
// 定义一个泛型接口
interface GenericIdentityFn<T> {
    (arg: T): T;
}

// 使用泛型接口定义函数
function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn<number> = identity;
console.log(myIdentity(10)); 
```

### 3.2 代码解释

- `interface GenericIdentityFn<T>` 定义了一个泛型接口，其中 `<T>` 是泛型类型参数。
- `(arg: T): T` 表示该接口描述的是一个函数，该函数接受一个类型为 `T` 的参数，并返回一个类型为 `T` 的值。
- `let myIdentity: GenericIdentityFn<number> = identity;` 表示将 `identity` 函数赋值给一个符合 `GenericIdentityFn<number>` 接口的变量。

## 4. 泛型约束

有时候，你可能希望泛型类型参数满足某些条件，这时可以使用泛型约束。

### 4.1 示例代码

```typescript
// 定义一个接口，用于约束泛型类型
interface Lengthwise {
    length: number;
}

// 定义一个泛型函数，使用泛型约束
function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length); 
    return arg;
}

// 可以传入具有 length 属性的对象
loggingIdentity("hello"); 
loggingIdentity([1, 2, 3]); 

// 不能传入没有 length 属性的对象
// loggingIdentity(10); // 报错
```

### 4.2 代码解释

- `interface Lengthwise` 定义了一个接口，该接口要求对象具有 `length` 属性。
- `function loggingIdentity<T extends Lengthwise>(arg: T): T` 中的 `T extends Lengthwise` 表示泛型类型参数 `T` 必须是 `Lengthwise` 接口的子类型，即 `T` 类型的对象必须具有 `length` 属性。

## 5. 泛型参数的默认类型

在 TypeScript 中，可以为泛型类型参数指定默认类型。

### 5.1 示例代码

```typescript
// 定义一个泛型函数，为泛型类型参数指定默认类型
function createArray<T = number>(length: number, value: T): T[] {
    let result: T[] = [];
    for (let i = 0; i < length; i++) {
        result[i] = value;
    }
    return result;
}

// 使用默认类型
let array1 = createArray(3, 10); 
console.log(array1); 

// 指定具体类型
let array2 = createArray<string>(3, "hello"); 
console.log(array2); 
```

### 5.2 代码解释

- `function createArray<T = number>(length: number, value: T): T[]` 中的 `<T = number>` 表示泛型类型参数 `T` 的默认类型是 `number`。
- 如果在调用 `createArray` 函数时没有指定具体类型，将使用默认类型（如 `createArray(3, 10)`）；如果指定了具体类型（如 `createArray<string>(3, "hello")`），则使用指定的类型。

通过使用泛型，你可以编写更加灵活和可重用的代码，同时保持类型安全。泛型在处理各种数据类型和场景时非常有用，是 TypeScript 中一个重要的特性。

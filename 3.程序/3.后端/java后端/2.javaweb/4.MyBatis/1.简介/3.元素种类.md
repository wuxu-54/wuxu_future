# 元素种类

MyBatis 支持多种元素来构建 SQL 映射和动态 SQL。以下是 MyBatis 中常用的元素种类：

## xml元素种类

在 MyBatis 的 XML 映射文件中，可以使用多种元素来定义 SQL 映射和动态 SQL。以下是 MyBatis XML 映射文件中常用的元素种类：

1. **·`<mapper>`**：定义映射文件的根元素，包含命名空间和其他映射元素。

2. **`<select>`**：定义一个查询操作，可以包含 `<resultType>` 或 `<resultMap>` 来指定返回结果的映射。

3. **`<insert>`**：定义一个插入操作，可以包含 `<useGeneratedKeys>` 来获取自动生成的主键。

4. **`<update>`**：定义一个更新操作。

5. **`<delete>`**：定义一个删除操作。

6. **`<resultType>`**：指定返回结果的 Java 类型。

7. **`<resultMap>`**：定义复杂的结果映射，可以包含 `<id>`、`<result>` 等子元素。

8. **`<parameterType>`**：指定传入参数的 Java 类型。

9. **`<sql>`**：定义可重用的 SQL 片段。

10. **`<if>`**：在动态 SQL 中用于条件判断。

11. **`<choose`**、**`<when>`**、**`<otherwise>`**：在动态 SQL 中用于多条件选择。

12. **`<where>`**：在动态 SQL 中用于包含 WHERE 子句，并自动处理多余的 AND/OR。

13. **`<set>`**：在动态 SQL 中用于构建 UPDATE 语句的 SET 部分。

14. **`<foreach>`**：在动态 SQL 中用于遍历集合，常用于构建 IN 条件。

15. **`<bind>`**：在动态 SQL 中用于创建变量并将其绑定到 OGNL 表达式。

16. **`<trim>`**：在动态 SQL 中用于处理前缀和后缀，可以自定义 SQL 的某些部分。

17. **`<include>`**：用于引入其他映射文件中定义的 SQL 片段。

18. **`<discriminator>`**：在 `<resultMap>` 中用于根据某个字段的值来动态选择子结果映射。

19. **`<cache>`**：用于配置结果集的缓存策略。

20. **`<typeDiscriminator>`**：用于在 `<resultMap>` 中根据类型字段的值来动态选择结果映射。

21. **`<parameterType>`**：用于指定传递给 SQL 语句的参数类型

22. **`<typeAlias>`**：用于为 Java 类定义一个简短的别名。

23. **`<parameterMap>`**：用于定义传递给 SQL 语句的参数映射。

这些元素共同构成了 MyBatis 的强大功能，使得开发者可以灵活地构建 SQL 语句，同时保持代码的清晰和易于维护。在实际开发中，根据具体需求选择合适的元素来实现业务逻辑。

---

## 注解元素种类

在 MyBatis 中，注解（Annotations）提供了一种在 Java 接口方法上直接定义 SQL 映射的方式，而不需要使用 XML 映射文件。以下是 MyBatis 支持的注解元素种类：

1. **@Select**：用于定义查询操作的 SQL 语句。

   ```java
   @Select("SELECT * FROM users WHERE id = #{id}")
   User selectUserById(int id);
   ```

2. **@SelectKey**：用于在插入操作后获取自动生成的键值。

   ```java
   @Insert("INSERT INTO users(name, email) VALUES(#{name}, #{email})")
   @SelectKey(statement="SELECT LAST_INSERT_ID()", keyProperty="id", before=false, resultType=int.class)
   void insertUser(User user);
   ```

3. **@Insert**：用于定义插入操作的 SQL 语句。

   ```java
   @Insert("INSERT INTO users(name, email) VALUES(#{name}, #{email})")
   void insertUser(User user);
   ```

4. **@Update**：用于定义更新操作的 SQL 语句。

   ```java
   @Update("UPDATE users SET name = #{name} WHERE id = #{id}")
   void updateUser(User user);
   ```

5. **@Delete**：用于定义删除操作的 SQL 语句。

   ```java
   @Delete("DELETE FROM users WHERE id = #{id}")
   void deleteUser(int id);
   ```

6. **@Results** / **@Result**：用于定义结果集的映射规则。
    >手动结果映射，将查询结果，手动设置给User类中的属性

   ```java
   @Results({
       @Result(property="id", column="id"),
       @Result(property="name", column="name")
   })
   @Select("SELECT id, name FROM users WHERE id = #{id}")
   User selectUserById(int id);
   ```

7. **@One**：用于一对一关联查询的结果映射。

   ```java
   @One(select="selectDetail")
   private Detail detail;
   ```

8. **@Many**：用于一对多关联查询的结果映射。

   ```java
   @Many(select="selectPosts")
   private List<Post> posts;
   ```

9. **@Options**：用于指定一些执行操作的选项，如使用生成的键。

   ```java
   @Insert("INSERT INTO users(name, email) VALUES(#{name}, #{email})")
   @Options(useGeneratedKeys=true, keyProperty="id") //正常查询返回不会有自动生成的主键值，如果我们要取可以使用Options注解，设置useGeneratedKeys，最终会自动将生成的主键值，赋值给user对象的id属性
   void insertUser(User user);
   ```

10. **@Provider**：用于指定一个类，该类提供动态 SQL 语句。

    ```java
    @SelectProvider(type=SqlProvider.class, method="findUser")
    User selectUser(String id);
    ```

11. **@MapUnderscoreToCamelCase**：用于自动将数据库中的下划线命名转换为 Java 类的驼峰命名。

12. **@CacheNamespace**：用于指定缓存策略。

这些注解可以直接应用于 Mapper 接口的方法上，提供了一种更加紧凑和 Java 代码风格的方式来定义 SQL 映射。使用注解可以使代码更加简洁，并且易于理解和维护，但可能会牺牲一些灵活性和可读性，特别是当 SQL 语句变得复杂时。在实际开发中，可以根据项目需求和团队习惯选择合适的配置方式。

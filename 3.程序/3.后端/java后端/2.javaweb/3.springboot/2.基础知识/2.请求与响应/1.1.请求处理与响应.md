# 请求与响应简介

在 Java Spring Boot 中，处理 HTTP 请求和生成响应是 Web 应用开发的核心。以下是 **请求与响应** 的关键知识点和示例：

---

## 一、请求处理

### 1. 控制器 (Controller)

- 使用 `@RestController` 或 `@Controller` 注解标记类为控制器。
- `@RestController` = `@Controller` + `@ResponseBody`（直接返回数据，而非视图）。

```java
@RestController
public class MyController {
    // 处理请求的方法
}
```

### 2. 请求映射 (RequestMapping)

- **方法级别**：`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping` 等。
- **路径参数**：通过 `@PathVariable` 获取 URL 中的动态参数。

```java
@GetMapping("/user/{id}")
public String getUserById(@PathVariable Long id) {
    return "User ID: " + id;
}
```

### 3. 请求参数

- **查询参数**：通过 `@RequestParam` 获取 URL 查询参数。

  ```java
  @GetMapping("/search")
  public String search(@RequestParam String keyword) {
      return "Searching for: " + keyword;
  }
  ```

- **表单数据**：使用 `@ModelAttribute` 或直接绑定到对象。

  ```java
  @PostMapping("/submit")
  public String submitForm(@ModelAttribute User user) {
      // 处理表单数据
      return "Success";
  }
  ```

- **JSON 请求体**：通过 `@RequestBody` 接收 JSON 数据并转换为 Java 对象。

  ```java
  @PostMapping("/create")
  public User createUser(@RequestBody User user) {
      // 处理 JSON 请求
      return userService.save(user);
  }
  ```

---

## 二、响应处理

### 1. 返回数据

- **直接返回对象**：Spring Boot 自动转换为 JSON（默认使用 Jackson 库）。

  ```java
  @GetMapping("/user/{id}")
  public User getUser(@PathVariable Long id) {
      return userService.findById(id);
  }
  ```

- **自定义状态码**：使用 `ResponseEntity` 控制状态码和响应头。

  ```java
  @GetMapping("/not-found")
  public ResponseEntity<User> getUser() {
      User user = userService.findUser();
      return user != null 
          ? ResponseEntity.ok(user) 
          : ResponseEntity.notFound().build();
  }
  ```

### 2. 返回视图（HTML）

- 使用 `@Controller` 结合模板引擎（如 Thymeleaf）返回 HTML 页面。

  ```java
  @Controller
  public class WebController {
      @GetMapping("/home")
      public String home(Model model) {
          model.addAttribute("message", "Hello Thymeleaf!");
          return "home"; // 对应 src/main/resources/templates/home.html
      }
  }
  ```

### 3. 文件上传与下载

- **文件上传**：通过 `MultipartFile` 接收文件。

  ```java
  @PostMapping("/upload")
  public String uploadFile(@RequestParam("file") MultipartFile file) {
      // 处理文件
      return "File uploaded: " + file.getOriginalFilename();
  }
  ```

- **文件下载**：使用 `ResponseEntity` 返回文件流。

  ```java
  @GetMapping("/download")
  public ResponseEntity<Resource> downloadFile() {
      File file = new File("path/to/file.txt");
      return ResponseEntity.ok()
          .header("Content-Disposition", "attachment; filename=\"" + file.getName() + "\"")
          .body(new FileSystemResource(file));
  }
  ```

---

## 三、请求与响应流程

1. **请求到达**：客户端发送 HTTP 请求到 Spring Boot 应用。
2. **路由匹配**：`DispatcherServlet` 根据 URL 找到对应的控制器方法。
3. **参数绑定**：Spring 自动将请求参数、路径变量、请求体等绑定到方法参数。
4. **业务处理**：执行控制器方法中的逻辑（如调用 Service 层）。
5. **生成响应**：将返回值转换为 JSON、HTML 视图或其他格式。

---

## 四、常见注解总结

| 注解 | 用途 |
|----------------|-------------------------|
| `@RestController` | 定义 RESTful 控制器 |
| `@RequestMapping` | 映射 HTTP 请求到方法 |
| `@PathVariable` | 获取 URL 路径中的参数 |
| `@RequestParam` | 获取 URL 查询参数或表单参数 |
| `@RequestBody` | 将请求体 JSON 转换为 Java 对象 |
| `@ResponseBody` | 表示方法返回值直接作为响应体 |

---

## 五、示例：完整的 REST API

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        User user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }

    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User savedUser = userService.saveUser(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedUser);
    }

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<String> handleUserNotFound(UserNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage());
    }
}
```

---

## 六、注意事项

1. **JSON 序列化**：确保实体类有默认构造函数和 getter/setter 方法。
2. **跨域问题**：使用 `@CrossOrigin` 注解或在全局配置中启用 CORS。
3. **异常处理**：通过 `@ControllerAdvice` 和 `@ExceptionHandler` 统一处理异常。

通过 Spring Boot 的自动配置和注解驱动开发，可以快速构建灵活且高效的请求-响应逻辑。

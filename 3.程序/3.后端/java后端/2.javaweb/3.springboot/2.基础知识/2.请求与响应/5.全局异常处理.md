# 全局异常处理

在Java Web开发中，全局异常处理是一个非常重要的部分，它可以让你在一个地方集中处理整个应用程序中的所有异常，而不是在每个方法中单独处理。这样不仅代码更加简洁，也便于维护和管理。Spring框架为Java Web开发提供了非常方便的全局异常处理机制。下面是一个详细的解释和示例。

## 1. Spring的全局异常处理机制

Spring提供了一个注解`@ControllerAdvice`和`@ExceptionHandler`，通过这两个注解，我们可以非常轻松的实现全局异常处理。

- `@ControllerAdvice`：用来定义一个全局异常处理类，可以作用于所有的Controller。
- `@ExceptionHandler`：用来定义具体某个异常的处理方法。

## 2. 全局异常处理示例

假设我们有一个简单的Spring Boot项目，需要处理以下几种异常：

- 自定义的业务异常`BusinessException`
- 全局性的`Exception`

### 2.1 自定义业务异常

首先，我们定义一个自定义的业务异常类：

```java
public class BusinessException extends RuntimeException {
    private int errorCode;

    public BusinessException(String message, int errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public int getErrorCode() {
        return errorCode;
    }
}
```

### 2.2 全局异常处理类

然后，我们创建一个全局异常处理类，并使用`@ControllerAdvice`和`@ExceptionHandler`注解：

```java
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

@ControllerAdvice
public class GlobalExceptionHandler {

    // 处理自定义业务异常
    @ExceptionHandler(BusinessException.class)
    @ResponseBody
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        ErrorResponse errorResponse = new ErrorResponse(ex.getMessage(), ex.getErrorCode(), HttpStatus.BAD_REQUEST.value());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // 处理全局异常
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public ResponseEntity<ErrorResponse> handleGlobalException(Exception ex) {
        ErrorResponse errorResponse = new ErrorResponse("An unexpected error occurred", 500, HttpStatus.INTERNAL_SERVER_ERROR.value());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

### 2.3 错误响应实体类

我们还需要一个实体类来表示错误响应的结构：

```java
public class ErrorResponse {
    private String message;
    private int errorCode;
    private int status;

    public ErrorResponse(String message, int errorCode, int status) {
        this.message = message;
        this.errorCode = errorCode;
        this.status = status;
    }

    // Getter and Setter methods
    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public int getErrorCode() {
        return errorCode;
    }

    public void setErrorCode(int errorCode) {
        this.errorCode = errorCode;
    }

    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }
}
```

### 2.4 使用示例

在Controller中抛出异常：

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class ExampleController {

    @GetMapping("/business-error")
    public String businessError() {
        throw new BusinessException("This is a business error", 1001);
    }

    @GetMapping("/global-error")
    public String globalError() {
        throw new RuntimeException("This is a global error");
    }
}
```

## 3. 运行结果

当你访问`/api/business-error`时，会得到类似以下的响应：

```json
{
    "message": "This is a business error",
    "errorCode": 1001,
    "status": 400
}
```

当你访问`/api/global-error`时，会得到类似以下的响应：

```json
{
    "message": "An unexpected error occurred",
    "errorCode": 500,
    "status": 500
}
```

## 总结

通过以上步骤，你已经实现了一个简单的全局异常处理机制。`@ControllerAdvice`和`@ExceptionHandler`的组合让你可以轻松地集中处理异常，极大地提高了代码的简洁性和可维护性。如果你在实际项目中还有其他特定异常需要处理，只需要在全局异常处理类中继续添加对应的`@ExceptionHandler`方法即可。

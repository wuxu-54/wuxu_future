# 事务传递

在 Spring 框架中，事务的传播行为（Transaction Propagation Behavior）定义了当一个事务方法被另一个事务方法调用时，事务如何被传播。Spring 支持多种事务传播行为，这些行为通过 `@Transactional` 注解的 `propagation` 属性来配置。

以下是 Spring 支持的事务传播行为：

1. **Propagation.REQUIRED**：
   - 默认值。如果当前存在事务，就加入该事务；如果当前没有事务，就创建一个新的事务。

2. **Propagation.REQUIRES_NEW**：
   - 总是创建一个新的事务，如果当前存在事务，就把当前事务挂起。

3. **Propagation.SUPPORTS**：
   - 如果当前存在事务，就加入该事务；如果当前没有事务，就以非事务方式执行。

4. **Propagation.NOT_SUPPORTED**：
   - 以非事务方式执行，如果当前存在事务，就把当前事务挂起。

5. **Propagation.MANDATORY**：
   - 如果当前存在事务，就加入该事务；如果当前没有事务，就抛出异常。

6. **Propagation.NEVER**：
   - 以非事务方式执行，如果当前存在事务，就抛出异常。

7. **Propagation.NESTED**：
   - 如果当前存在事务，就创建一个嵌套事务；如果当前没有事务，就创建一个新的事务。

8. **Propagation.NOT_REQUIRED**：
   - 如果当前存在事务，就加入该事务；如果当前没有事务，就以非事务方式执行。

9. **Propagation.SUPPORTS_TRANSACTION_MANAGER**：
   - 支持当前事务，如果当前没有事务，就以非事务方式执行。

10. **Propagation.MANDATORY_TRANSACTION_MANAGER**：
    - 支持当前事务，如果当前没有事务，就抛出异常。

以下是一些常见的事务传播行为的示例配置：

```java
// REQUIRED (默认值)
@Transactional(propagation = Propagation.REQUIRED)
public void methodA() {
    // ...
}

// REQUIRES_NEW
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void methodB() {
    // ...
}

// SUPPORTS
@Transactional(propagation = Propagation.SUPPORTS)
public void methodC() {
    // ...
}

// NOT_SUPPORTED
@Transactional(propagation = Propagation.NOT_SUPPORTED)
public void methodD() {
    // ...
}

// MANDATORY
@Transactional(propagation = Propagation.MANDATORY)
public void methodE() {
    // ...
}

// NEVER
@Transactional(propagation = Propagation.NEVER)
public void methodF() {
    // ...
}

// NESTED
@Transactional(propagation = Propagation.NESTED)
public void methodG() {
    // ...
}
```

事务传播行为的选择取决于业务需求和数据库事务的特性。例如，如果你需要确保一个方法总是在一个新事务中执行，不管当前是否存在事务，你应该使用 `REQUIRES_NEW`。如果你的方法可以运行在事务环境中，也可以在没有事务的环境中运行，那么 `SUPPORTS` 是一个合适的选择。

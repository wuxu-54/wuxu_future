# nodejs服务代码 与 web网页代码 打包部署

需求：将一个js 的 nodejs服务代码 与 web网页代码 打包放入到docker中，且web网页代码会访问nodejs服务端接口

## 解决方法

以下是将 Node.js 服务与 Web 网页打包到 Docker 并实现通信的完整方案，包含前后端分离架构和 Docker 编排：

### 一、项目结构

```txt
project-root/
├── server/                # Node.js 服务端
│   ├── src/
│   │   └── app.js        # 服务端代码（示例）
│   ├── package.json
│   └── Dockerfile
├── web/                   # Web 前端
│   ├── src/               # 前端源码（示例为静态文件）
│   │   └── index.html    # 访问接口的 HTML 页面
│   ├── nginx.conf        # Nginx 配置文件
│   └── Dockerfile
└── docker-compose.yml     # 容器编排文件
```

### 二、服务端代码（`server/src/app.js`）

```javascript
const express = require('express');
const app = express();
const port = 3000;

// 允许跨域（生产环境建议用 Nginx 代理避免跨域）
app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  next();
});

// 示例接口
app.get('/api/data', (req, res) => {
  res.json({ message: 'Hello from Node.js Server!' });
});

app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});
```

`server/package.json` 需包含 Express 依赖：

```json
{
  "name": "node-server",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2"
  },
  "scripts": {
    "start": "node src/app.js"
  }
}
```

### 三、前端代码（`web/src/index.html`）

```html
<!DOCTYPE html>
<html>
<head>
  <title>Dockerized App</title>
</head>
<body>
  <h1>Accessing Node.js API</h1>
  <button onclick="fetchData()">Fetch Data</button>
  <div id="result"></div>

  <script>
    async function fetchData() {
      try {
        // 访问 Node.js 服务接口（注意路径需与后端匹配）
        const response = await fetch('/api/data'); // Docker内访问,通过nginx实现代理访问
        const data = await response.json();
        document.getElementById('result').textContent = data.message;
      } catch (error) {
        console.error('Error:', error);
      }
    }
  </script>
</body>
</html>
```

### 四、服务端 Dockerfile（`server/Dockerfile`）

```dockerfile
FROM node:20-alpine

WORKDIR /app
COPY package*.json ./
RUN npm install --production

COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

### 五、前端 Dockerfile（`web/Dockerfile`）

```dockerfile
FROM nginx:alpine

# 复制前端静态文件到 Nginx 目录
COPY src/ /usr/share/nginx/html/

# 复制 Nginx 配置（处理反向代理）
COPY nginx.conf /etc/nginx/conf.d/default.conf
```

`web/nginx.conf` 配置（关键：反向代理到 Node.js 服务）：

```nginx
server {
  listen 80;
  server_name _;

  location / {
    root /usr/share/nginx/html;
    index index.html;
    try_files $uri $uri/ /index.html;
  }

  # 反向代理到 Node.js 服务（服务名与 docker-compose 中定义一致）
  location /api/ {
    proxy_pass http://node:3000/api/;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
  }
}
```

### 六、Docker 编排文件（`docker-compose.yml`）

```yaml
version: '3.8'

services:
  node:
    build: ./server
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:3000/api/data || exit 1"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: always
    networks:
      - app-network   # 新增这一行

  web:
    build: ./web
    ports:
      - "80:80"
    depends_on:
      - node
        # condition: service_healthy
    restart: always
    networks:
      - app-network

networks:
  app-network:
    driver: bridge
```

### 七、运行步骤

1. **构建并启动容器**：

```bash
docker-compose up --build
```

2. **访问应用**：

- 前端页面：`http://localhost`
- 服务端接口（直接访问）：`http://localhost:3000/api/data`

### 关键说明

1. **容器间通信**：
   - 通过 `docker-compose` 定义的服务名（如 `node`）在同一网络内直接通信
   - Nginx 通过 `http://node:3000` 代理到 Node.js 服务

2. **跨域处理**：
   - 方案一：服务端设置 `Access-Control-Allow-Origin`（示例代码已实现）
   - 方案二：通过 Nginx 代理统一路径（如将 `/api` 代理到服务端），避免跨域

3. **生产环境优化**：
   - 前端建议使用构建工具（如 Webpack/Vite）生成静态文件
   - Node.js 服务添加进程管理工具（如 PM2）
   - 增加环境变量配置（如端口、API 路径）
   - 添加 Docker 镜像体积优化（如使用多阶段构建）

4. **扩展场景**：
   - 若前端为单页应用（SPA），需配置 Nginx 的 `try_files` 指向 `index.html`
   - 可添加数据库服务（如 MySQL）到 `docker-compose` 中，通过服务名连接

通过以上方案，可实现 Node.js 服务与 Web 页面的 Docker 化部署，并确保两者在容器环境中正常通信。

# settings.gradle 和 build.gradle 区别

问题：gradle 里  settings.gradle 和 build.gradle 区别。为什么 settings.gradle 不可以使用task、ext等？

## `settings.gradle` 和 `build.gradle` 的区别

### 1. 功能定位

- **`settings.gradle`**
  - 主要用于项目的全局设置和项目结构的定义。它负责告知 Gradle 哪些项目会参与构建，也就是定义多项目构建的项目层次结构。在多项目构建中，它会指定子项目的位置和名称，从而让 Gradle 知道如何组织和处理这些项目。例如，在一个包含多个模块的 Android 项目或者 Java 项目中，`settings.gradle` 会列出所有要参与构建的子模块。
  - 它在构建过程中最先被执行，是构建初始化阶段的核心文件。
- **`build.gradle`**
  - 主要用于定义项目的构建逻辑和配置。它包含了项目的依赖管理、插件应用、任务定义等具体的构建信息。不同的项目可能有不同的 `build.gradle` 文件，比如根项目有根项目的 `build.gradle`，每个子项目也可以有自己的 `build.gradle`，它们可以分别对各自项目的构建过程进行定制。

### 2. 作用范围

- **`settings.gradle`**
  - 其作用范围是整个构建过程的初始化阶段，主要关注项目的整体结构和哪些项目会被包含在构建中。它不涉及具体的构建任务和项目的详细配置。
- **`build.gradle`**
  - 作用范围是项目的实际构建阶段。根项目的 `build.gradle` 可以为所有子项目提供通用的配置，而子项目的 `build.gradle` 可以对该子项目进行特定的配置和任务定义。

### 3. 执行时机

- **`settings.gradle`**
  - 在 Gradle 构建的初始化阶段执行，此时 Gradle 还没有开始对项目进行实际的构建操作，只是在确定要构建哪些项目。
- **`build.gradle`**
  - 在配置阶段执行，此时 Gradle 已经知道了要构建哪些项目，开始对这些项目进行详细的配置和任务的定义。

## 为什么 `settings.gradle` 不可以使用 `task`、`ext` 等

### 1. `task`

- **执行阶段差异**：`task` 是 Gradle 中用于定义具体构建任务的关键字。任务的定义和执行是在配置阶段和执行阶段进行的。而 `settings.gradle` 在初始化阶段执行，此时 Gradle 还没有进入到配置阶段，还不清楚具体要构建哪些项目的详细信息，所以不能在这个阶段定义任务。例如，一个任务可能需要依赖某个项目的配置信息，如果在 `settings.gradle` 中定义任务，此时项目的配置还未确定，任务将无法正常工作。
- **设计目的**：`settings.gradle` 的设计目的是为了确定项目结构，而不是定义具体的构建任务。任务的定义应该在 `build.gradle` 中进行，这样可以确保任务与具体的项目配置和依赖关系相匹配。

### 2. `ext`

- **上下文差异**：`ext` 用于在 Gradle 脚本中定义额外的属性。这些属性通常是为了在项目的配置和任务中使用。`settings.gradle` 主要关注项目结构，没有与具体项目配置相关的上下文。而 `ext` 定义的属性通常是与项目的构建配置相关的，例如定义依赖版本号等。在 `settings.gradle` 中使用 `ext` 没有实际的意义，因为它无法与具体项目的构建配置进行关联。
- **生命周期不匹配**：`ext` 定义的属性在配置阶段和执行阶段会被使用和处理。由于 `settings.gradle` 在初始化阶段执行，此时还没有进入到属性可以被有效使用的阶段，所以不适合在 `settings.gradle` 中使用 `ext`。

以下是一个简单的示例，展示了 `settings.gradle` 和 `build.gradle` 的基本用法：

**`settings.gradle`**

```groovy
// 定义多项目构建的子项目
include 'app', 'library'
```

**根项目 `build.gradle`**

```groovy
// 应用插件
plugins {
    id 'java'
}

// 定义额外属性
ext {
    springVersion = '5.3.10'
}

// 所有子项目的通用配置
subprojects {
    repositories {
        mavenCentral()
    }
}
```

**子项目 `app/build.gradle`**

```groovy
// 应用插件
apply plugin: 'java'

// 依赖管理
dependencies {
    implementation "org.springframework:spring-core:${springVersion}"
}

// 定义任务
task hello {
    doLast {
        println 'Hello from app project!'
    }
}
```

---

## build.gradle使用settings.gradle中的东西

由于settings是项目构建的基础gradle，此时还没有全局的rootProject，所以不能单纯的通过 `rootProject.ext.xxx` 来获取共享变量或方法。可以使用全局对象`gradle`的共享方法：`gradle.ext.xxx`，这个对象贯穿整个构建过程。

根据错误信息和代码分析，问题出在 `settings.gradle` 中对 `rootProject.ext` 的错误使用。以下是具体原因和解决方案：

### **错误原因分析**

1. **作用域混淆**：
   - 在 `settings.gradle` 中，`rootProject` 的类型是 `ProjectDescriptor`，它没有 `ext` 属性。
   - `ext` 是 `Project` 对象的扩展属性，但在 Settings 脚本阶段，`Project` 对象尚未完全初始化。

2. **生命周期问题**：
   - `settings.gradle` 执行时处于 Gradle 的初始化阶段，此时 `rootProject` 尚未关联到 `Project` 对象。
   - 直接操作 `rootProject.ext` 会导致 `MissingPropertyException`。

### **解决方案**

通过 `gradle.ext` 实现跨脚本共享方法：

#### **步骤 1：修改 `settings.gradle`**

```groovy
// settings.gradle
// 替换以下代码：
// rootProject.ext.getLocalPropertiesMap = this.&getLocalPropertiesMap

// 改为使用 gradle.ext 保存方法引用
gradle.ext {
    getLocalPropertiesMap = this.&getLocalPropertiesMap
}
```

#### **步骤 2：在 `build.gradle` 中调用**

```groovy
// build.gradle
def addExtProperties() {
    // 通过 gradle.ext 获取方法引用
    def getLocalPropertiesMap = gradle.ext.getLocalPropertiesMap
    def map = getLocalPropertiesMap() as Map<String, String>
    
    map.entrySet().forEach {
        println "1 settings.gradle ${it.key} = ${it.value}"
        ext.setProperty(it.key, it.value)
    }
}
```

### **技术原理**

1. **`gradle.ext` 的作用**：
   - `gradle` 是 Gradle 的全局对象，其 `ext` 属性可在整个构建过程（包括 `settings.gradle` 和所有 `build.gradle`）中共享数据。
   - 适合在不同构建阶段传递方法或属性。

2. **方法引用的正确传递**：
   - 通过 `this.&methodName` 语法将方法转为闭包（Closure），存储在 `gradle.ext` 中。
   - 在 `build.gradle` 中通过闭包方式调用。

### **验证方法**

在 `build.gradle` 中添加测试任务：

```groovy
task validateSettingsMethod {
    doLast {
        def map = gradle.ext.getLocalPropertiesMap()
        println "验证结果: ${map.getClass().simpleName} 内容: ${map}"
        assert map instanceof Map : "返回值不是 Map 类型"
    }
}
```

运行命令：

```bash
./gradlew validateSettingsMethod
```

如果输出包含 `local.properties` 中的键值对，则表明方法调用成功。

### **备选方案**

如果必须通过 `rootProject` 访问，需在 `build.gradle` 中动态挂载：

```groovy
// build.gradle
rootProject.ext {
    // 从 gradle.ext 中获取并挂载到 rootProject.ext
    getLocalPropertiesMap = gradle.ext.getLocalPropertiesMap
}

// 后续可直接使用
def map = rootProject.ext.getLocalPropertiesMap()
```

### **注意事项**

1. **作用域隔离**：
   - `settings.gradle` 和 `build.gradle` 有不同的作用域，避免直接跨脚本操作对象。
2. **类型安全**：
   - 建议在传递方法时添加类型声明：

     ```groovy
     gradle.ext {
         getLocalPropertiesMap = { -> 
             return this.getLocalPropertiesMap() 
         } as Closure<Map<String, String>>
     }
     ```

通过上述修改，可以解决 `MissingPropertyException` 问题并实现跨脚本方法调用。


# ext作用域隔离

问题：

android settings.gradle中调用 自定义gradle中的方法，并设置全局变量。但在其他gradle使用此变量时rootProject.ext 与settings.gradle中的ext不是同一个对象。导致找不到变量而报错。原因是什么，怎么解决？

---

## 解决方案

在 Android 项目的构建配置中，`settings.gradle` 和 `build.gradle` 的 `ext` 属性属于 **不同的作用域**，导致直接通过 `rootProject.ext` 访问 `settings.gradle` 中定义的变量会失败。以下是问题原因和解决方案：

---

### **问题原因**

1. **作用域隔离**：
   - `settings.gradle` 中的 `ext` 属于 **`Settings` 对象**。
   - `build.gradle` 中的 `rootProject.ext` 属于 **`Project` 对象**。
   - Gradle 的 `Settings` 和 `Project` 是独立的实例，它们的 `ext` 属性不共享。

2. **生命周期差异**：
   - `settings.gradle` 在 **初始化阶段** 执行，此时 `Project` 对象尚未创建。
   - `build.gradle` 在 **配置阶段** 执行，此时才能访问 `Project` 的 `ext`。

---

### **解决方案**

#### **方案 1：通过 `gradle.ext` 传递变量（推荐）**

利用 `gradle` 对象的 `ext` 属性，它是全局共享的，可以在 `Settings` 和 `Project` 之间传递变量。

**步骤**：

1. **在 `settings.gradle` 中定义变量**：

   ```groovy
   // settings.gradle
   gradle.ext.sharedVar = "value_from_settings" // 定义全局变量
   ```

2. **在根项目的 `build.gradle` 中将变量同步到 `rootProject.ext`**：

   ```groovy
   // 根项目的 build.gradle
   ext {
       // 从 gradle.ext 同步变量
       sharedVar = gradle.ext.sharedVar
   }
   ```

3. **在子模块中通过 `rootProject.ext` 访问**：

   ```groovy
   // app/build.gradle
   android {
       defaultConfig {
           buildConfigField "String", "VAR", "\"${rootProject.ext.sharedVar}\""
       }
   }
   ```

---

#### **方案 2：在 `settings.gradle` 中直接操作 `rootProject.ext`**

通过延迟初始化机制，在 `settings.gradle` 中直接向 `rootProject.ext` 注入变量。

**步骤**：

1. **在 `settings.gradle` 中定义初始化逻辑**：

   ```groovy
   // settings.gradle
   gradle.projectsLoaded { 
       rootProject.ext { 
           sharedVar = "value_from_settings" // 在 Project 可用后注入变量
       }
   }
   ```

2. **在子模块中直接使用**：

   ```groovy
   // app/build.gradle
   println "共享变量：${rootProject.ext.sharedVar}"
   ```

---

#### **方案 3：通过自定义脚本统一管理变量**

将变量定义在独立的 Gradle 脚本中，并在 `build.gradle` 中加载。

**步骤**：

1. **创建 `config.gradle`**：

   ```groovy
   // config.gradle
   ext {
       sharedVar = "value_from_config"
   }
   ```

2. **在根项目的 `build.gradle` 中加载脚本**：

   ```groovy
   // 根项目的 build.gradle
   apply from: 'config.gradle' // 应用配置脚本
   ```

3. **在子模块中访问**：

   ```groovy
   // app/build.gradle
   dependencies {
       implementation "com.lib:${rootProject.ext.sharedVar}"
   }
   ```

---

### **错误示例修正**

假设原始错误代码：

```groovy
// ❌ 错误的写法：settings.gradle
apply from: 'config.gradle' // 假设 config.gradle 中定义了 ext.sharedVar

// 尝试在 settings.gradle 中调用自定义方法设置变量
def setupVars() {
    ext.sharedVar = "value" // 此 ext 属于 Settings，非 Project
}
setupVars()
```

修正为：

```groovy
// ✅ 正确的写法：settings.gradle
gradle.ext.sharedVar = "value" // 使用 gradle.ext 传递

// 根项目的 build.gradle
apply from: 'config.gradle'
ext {
    sharedVar = gradle.ext.sharedVar // 同步到 Project.ext
}
```

---

### **总结**

| 场景                            | 推荐方案                     | 关键点                                                                 |
|---------------------------------|------------------------------|----------------------------------------------------------------------|
| 需要跨 `Settings` 和 `Project` | `gradle.ext` 传递            | 利用 `gradle` 对象的全局性，确保变量在生命周期各阶段可见                   |
| 需要统一管理配置                | 独立 `config.gradle` 脚本    | 集中管理变量，通过 `apply from` 加载到根项目的 `build.gradle` 中           |
| 动态注入变量                    | `gradle.projectsLoaded` 钩子 | 在 `Project` 初始化完成后操作 `rootProject.ext`，避免作用域隔离问题          |

通过以上方案，可以确保在 `settings.gradle` 中定义的变量能够正确传递到子模块的 `build.gradle` 中，避免 `No such property` 错误。

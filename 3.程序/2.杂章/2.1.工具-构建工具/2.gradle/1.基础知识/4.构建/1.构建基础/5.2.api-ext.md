# gradle `ext`

在 Gradle 中，`ext` 是一个非常重要的特性，它提供了一种灵活的方式来扩展项目的属性和方法。下面从概念、使用场景、具体用法、注意事项等方面详细介绍 `ext`。

## 概念

`ext` 是 `ExtraPropertiesExtension` 类的实例，它允许你在 Gradle 项目、任务、插件等对象上动态地添加额外的属性和方法。通过 `ext`，你可以在构建脚本中定义自定义的变量和函数，并且可以在整个构建过程中方便地访问和使用它们。

## 使用场景

- **版本号管理**：将项目中依赖库的版本号统一管理，避免在多个地方重复定义版本号，提高代码的可维护性。
- **配置参数共享**：在不同的任务或插件之间共享一些配置参数，例如 API 密钥、服务器地址等。
- **自定义功能扩展**：添加自定义的方法来封装一些常用的逻辑，方便在构建脚本中复用。

## 具体用法

### 1. 在项目级别定义额外属性

```groovy
// 在项目级别定义额外属性
ext {
    appName = "MyAwesomeApp"
    versionCode = 1
    versionName = "1.0.0"
}

// 访问这些属性
println "App Name: $appName"
println "Version Code: $versionCode"
println "Version Name: $versionName"
```

在上述代码中，通过 `ext` 块在项目级别定义了三个额外属性 `appName`、`versionCode` 和 `versionName`，然后可以直接在构建脚本中使用这些属性。

### 2. 在任务级别定义额外属性

```groovy
task myTask {
    // 在任务级别定义额外属性
    ext.taskProperty = "This is a task-specific property"

    doLast {
        println "Task Property: $taskProperty"
    }
}
```

这里在 `myTask` 任务中通过 `ext` 定义了一个额外属性 `taskProperty`，并在任务的 `doLast` 动作中访问该属性。

### 3. 动态添加和访问属性

```groovy
// 动态添加属性
ext.set("newProperty", "New value")

// 访问动态添加的属性
println "New Property: ${ext.newProperty}"
```

使用 `ext.set` 方法可以动态地添加属性，然后通过 `ext.属性名` 的方式访问这些属性。

### 4. 定义额外方法

```groovy
// 定义额外方法
ext.sayHello = { name ->
    println "Hello, $name!"
}

// 调用额外方法
sayHello("World")
```

通过 `ext` 可以定义自定义的方法，这里定义了一个 `sayHello` 方法，然后在构建脚本中调用该方法。

## 注意事项

- **作用域**：在项目级别定义的 `ext` 属性和方法可以在整个项目的构建脚本中访问；而在任务级别定义的 `ext` 属性和方法只能在该任务内部访问。
- **命名冲突**：要注意避免定义的属性和方法名与 Gradle 内置的属性和方法名冲突，否则可能会导致意外的结果。
- **性能影响**：虽然 `ext` 提供了很大的灵活性，但过多地使用动态属性和方法可能会影响构建脚本的性能和可读性，因此需要合理使用。

综上所述，`ext` 是 Gradle 中一个强大且灵活的特性，通过它可以方便地扩展项目的属性和方法，提高构建脚本的可维护性和复用性。

---

## `gradle.ext`、`rootProject.ext` 和 `settings.gradle`中的 `ext`

在 Gradle 构建系统中，`gradle.ext`、`rootProject.ext` 和 `settings.gradle` 中的 `ext` 分别属于不同的作用域和对象，理解它们的区别是解决变量共享问题的关键。以下是详细解释：

---

### **1. `gradle.ext`：全局共享的扩展属性**

- **所属对象**：`gradle` 对象（`Gradle` 类的实例）。
- **作用域**：**全局**，贯穿整个构建过程（包括 `settings.gradle` 和所有 `build.gradle` 文件）。
- **生命周期**：从构建开始到结束均有效。
- **用途**：在 `settings.gradle` 和 `build.gradle` 之间传递变量。
- **示例**：

  ```groovy
  // settings.gradle
  gradle.ext.sharedVar = "全局变量"  // 定义全局变量

  // 根项目的 build.gradle
  println "从 settings 获取: ${gradle.ext.sharedVar}"  // 输出 "全局变量"

  // 子模块的 build.gradle
  android {
      buildConfigField "String", "VAR", "\"${gradle.ext.sharedVar}\""
  }
  ```

---

### **2. `rootProject.ext`：根项目的扩展属性**

- **所属对象**：根项目的 `Project` 对象（即 `rootProject`）。
- **作用域**：仅在 **根项目和子项目的 `build.gradle`** 中有效。
- **生命周期**：在 **配置阶段**（`build.gradle` 执行时）初始化。
- **用途**：在子模块间共享配置（如版本号、依赖库版本）。
- **示例**：

  ```groovy
  // 根项目的 build.gradle
  ext {
      compileSdk = 34
      minSdk = 24
  }

  // 子模块的 build.gradle
  android {
      compileSdk rootProject.ext.compileSdk
      defaultConfig {
          minSdk rootProject.ext.minSdk
      }
  }
  ```

---

### **3. `settings.gradle` 中的 `ext`：Settings 对象的扩展属性**

- **所属对象**：`Settings` 对象（`settings.gradle` 文件中的上下文）。
- **作用域**：仅在 `settings.gradle` 文件中有效。
- **生命周期**：在 **初始化阶段**（解析 `settings.gradle` 时）生效。
- **用途**：配置项目结构或初始化全局工具（如 `include` 模块、动态加载子项目）。
- **示例**：

  ```groovy
  // settings.gradle
  ext.settingsVar = "Settings 变量"  // 仅在 settings.gradle 中可见

  include ':app'
  println "Settings 变量: ${ext.settingsVar}"  // 输出 "Settings 变量"
  ```

---

### **关键区别总结**

| 特性                | `gradle.ext`            | `rootProject.ext`       | `settings.gradle` 中的 `ext` |
|---------------------|-------------------------|-------------------------|-----------------------------|
| **所属对象**        | `Gradle` 实例           | 根项目的 `Project` 对象 | `Settings` 对象             |
| **作用域**          | 全局（所有构建脚本）    | 根项目和子项目          | 仅 `settings.gradle` 文件   |
| **生命周期**        | 整个构建过程            | 配置阶段                | 初始化阶段                  |
| **典型用途**        | 跨阶段传递变量          | 子模块共享配置          | 动态配置项目结构            |
| **访问方式**        | `gradle.ext.xxx`        | `rootProject.ext.xxx`   | `ext.xxx`                   |

---

### **常见问题与解决方案**

#### **问题 1：在 `settings.gradle` 中访问 `rootProject.ext` 报错**

- **错误信息**：

  ```
  No such property: ext for class: org.gradle.initialization.DefaultProjectDescriptor
  ```

- **原因**：`settings.gradle` 在初始化阶段执行，此时 `rootProject` 尚未创建。
- **解决**：使用 `gradle.ext` 传递变量，或通过钩子延迟操作：

  ```groovy
  // settings.gradle
  gradle.ext.sharedVar = "全局值"

  // 根项目的 build.gradle
  ext {
      sharedVar = gradle.ext.sharedVar  // 同步到 rootProject.ext
  }
  ```

#### **问题 2：`settings.gradle` 中的 `ext` 无法在 `build.gradle` 中访问**

- **原因**：`settings.gradle` 的 `ext` 属于 `Settings` 对象，与 `Project` 对象隔离。
- **解决**：通过 `gradle.ext` 桥接：

  ```groovy
  // settings.gradle
  gradle.ext.settingsVar = "从 Settings 传递"

  // build.gradle
  println "接收值: ${gradle.ext.settingsVar}"
  ```

---

### **最佳实践**

1. **跨阶段传递变量**：优先使用 `gradle.ext`。

   ```groovy
   // settings.gradle
   gradle.ext.apiKey = "12345"

   // build.gradle
   android.defaultConfig.buildConfigField "String", "API_KEY", "\"${gradle.ext.apiKey}\""
   ```

2. **子模块共享配置**：使用 `rootProject.ext`。

   ```groovy
   // 根项目的 build.gradle
   ext.libVersions = [
       retrofit: "2.9.0",
       glide   : "4.12.0"
   ]

   // 子模块的 build.gradle
   dependencies {
       implementation "com.squareup.retrofit2:retrofit:${rootProject.ext.libVersions.retrofit}"
   }
   ```

3. **动态配置项目**：在 `settings.gradle` 中使用 `ext` 和条件逻辑。

   ```groovy
   // settings.gradle
   ext.isCiBuild = System.getenv("CI") == "true"

   if (ext.isCiBuild) {
       include ':ci-module'
   }
   ```

---

通过理解这些概念的区别，可以避免作用域错误，确保构建脚本的高效性和可维护性。

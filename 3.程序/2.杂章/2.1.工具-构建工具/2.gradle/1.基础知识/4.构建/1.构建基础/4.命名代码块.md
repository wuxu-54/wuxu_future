# Gradle 命名代码块详细解释及执行时机

## **1. 什么是命名代码块**

在 Gradle 中，命名代码块是一种通过 `:` 分隔的语法结构，用于定义特定的逻辑或配置。它通常与闭包（Closure）结合使用，闭包是一种匿名代码块，可以接受参数并在运行时动态传递。

命名代码块的语法如下：

```groovy
name: {
    // 闭包中的代码
}
```

- `name`：代码块的名称，用于标识该代码块。
- `{}`：闭包，包含具体的逻辑代码。

与闭包的区别：

- **闭包** 是 Groovy 的核心语法特性，是一种灵活的匿名代码块，可以传递、嵌套和动态执行。
- **命名代码块** 是基于闭包的更高层次的抽象，通过名字标识闭包的用途，使代码更易读和维护。

---

## **命名代码块的执行机制**

1. **Gradle 生命周期阶段**：
   - Gradle 的构建过程分为三个阶段：**初始化阶段（Initialization）**、**配置阶段（Configuration）** 和 **执行阶段（Execution）**。
   - 命名代码块的执行时机取决于它所在的阶段和上下文。
   - ![Gradle生命周期](https://i.imgur.com/UfbIblj.png)

2. **自动执行**：
   - 命名代码块通常在 Gradle 解析和配置构建脚本时自动执行。
   - 例如，当 Gradle 解析 `build.gradle` 文件时，会执行脚本中的命名代码块来配置项目和任务。

3. **隐式调用**：
   - 在大多数情况下，命名代码块是通过 Gradle 的内置逻辑隐式调用的，并且不需要手动触发。

---

## **命名代码块的执行时机**

1. **配置阶段（Configuration Phase）**：
   - 大多数命名代码块在 **配置阶段** 执行。
   - 在此阶段，Gradle 配置项目和任务，解析依赖关系并设置构建环境。
   - 例如，任务的定义和配置代码块都会在此阶段执行。

2. **执行阶段（Execution Phase）**：
   - 部分命名代码块在 **执行阶段** 执行，特别是与任务行为相关联的代码块。
   - 例如，任务的 `doFirst` 和 `doLast` 代码块会在任务执行时触发。

---

## **命名代码块的执行方式**

- **显式定义和执行**：
  - 命名代码块通过 `name: { ... }` 的形式显式定义在构建脚本中。
  - 当 Gradle 解析和配置脚本时，会自动执行这些代码块。（也就是说，显示的命名代码块会在构建脚本中自动执行，无需调用）

    ```groovy
    // 定义一个命名代码块
    myNamedBlock: {
        println "This is my named block, and it's being executed."
        def localVar = 123
        println "Local variable value: $localVar"
    }

    println "After the named block definition."

    /**
    打印结果：

    This is my named block, and it's being executed.
    Local variable value: 123
    After the named block definition.
    */
    ```

- **闭包绑定**：
  - 命名代码块本质上是一个闭包，可以绑定到特定的上下文（如项目、任务或插件）。
  - 例如，在 `plugins` 命名代码块中，闭包绑定到 Gradle 的插件系统，用于配置插件。

---

## **示例：命名代码块的执行**

1. **任务定义**：

   ```groovy
   task myTask {
       doFirst { // 命名代码块
           println "Task myTask is starting."
       }
       doLast { // 命名代码块
           println "Task myTask is finished."
       }
   }
   ```

   - `doFirst` 和 `doLast` 代码块在任务执行时自动调用。

2. **插件配置**：

   ```groovy
    plugins {
        id 'java' version '1.8' // 闭包作为插件配置上下文
        id 'org.springframework.boot' version '2.5.4'
    }
   ```

   这段代码等价于：

    ```groovy
    plugins([
        id: 'java', version: '1.8',
        id: 'org.springframework.boot', version: '2.5.4'
    ])
    ```

   - 这个命名代码块在配置阶段执行，Gradle 会根据插件 ID 和版本号应用插件。

3. **动态配置**：

   ```groovy
   ext {
       myProperty = "Hello, Gradle!" // 命名代码块
   }
   ```

   - `ext` 命名代码块在脚本解析时执行，定义外部属性。

4. **主动显示执行**

```groovy
// 定义一个方法，将命名代码块放在方法内部
def executeMyNamedBlock() {
    myNamedBlock: { //@wuxu: 这里其实就是利用命名代码块自动隐式执行的特性
        println "Explicitly executing my named block."
        def anotherVar = 456
        println "Another variable value: $anotherVar"
    }
}

// 在需要的时候显式调用方法
println "Before method call."
executeMyNamedBlock()
println "After method call."
```

---

## **4. 总结**

- **命名代码块**：通过 `name: { ... }` 的形式定义，结合闭包实现动态逻辑。
- **执行时机**：取决于 Gradle 的生命周期阶段（初始化、配置、执行）。
- **应用场景**：任务定义、插件配置、动态属性设置等。

通过命名代码块，Gradle 提供了灵活的脚本编写方式，使构建逻辑更加清晰和可维护。

---

## 补充

在kotlin语法中，命名代码块已经不适用了，可以采用方法函数方式替代，创建方法，然后调用。

```kotlin
// Groovy 示例
// myTaskLogic: {
//     println "This is custom task logic"
// }
// 定义一个函数来封装任务逻辑
fun myTaskLogic() {
    println("This is custom task logic")
}

// 调用函数执行任务逻辑
myTaskLogic()
```

也可以结合gradle的任务函数，在gradle中定义一个任务，然后调用这个函数。

```kotlin
import org.gradle.api.Project

// 定义一个函数来封装任务逻辑
fun myTaskLogic(project: Project) {
    project.tasks.register("myCustomTask") {
        doLast {
            println("This is custom task logic in a Gradle task")
        }
    }
}

// 在项目中应用任务逻辑
myTaskLogic(project)
```

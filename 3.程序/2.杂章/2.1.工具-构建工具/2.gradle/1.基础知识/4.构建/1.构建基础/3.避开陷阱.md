# 避开陷阱

## Groovy 脚本变量

对于 Groovy DSL 的用户来说，理解 Groovy 如何处理脚本变量是很重要的。 Groovy 有两种类型的脚本变量。一个在本地范围内，一个在脚本范围内。

示例：变量范围：本地和脚本范围

```groovy
// scope.groovy
String localScope1 = 'localScope1'
def localScope2 = 'localScope2'
scriptScope = 'scriptScope'

println localScope1
println localScope2
println scriptScope

closure = {
    println localScope1
    println localScope2
    println scriptScope
}

def method() {
    try {
        localScope1
    } catch (MissingPropertyException e) {
        println 'localScope1NotAvailable'
    }
    try {
        localScope2
    } catch(MissingPropertyException e) {
        println 'localScope2NotAvailable'
    }
    println scriptScope
}

closure.call()
method()
```

Output of groovy scope.groovy

```sh
> groovy scope.groovy
localScope1
localScope2
scriptScope
localScope1
localScope2
scriptScope
localScope1NotAvailable
localScope2NotAvailable
scriptScope
```

使用类型修饰符声明的变量在闭包中可见，但在方法中不可见。

## 配置和执行阶段

请务必记住 Gradle 具有不同的配置和执行阶段（请参阅 构建生命周期 ）。

示例 1.不同的配置和执行阶段

```kotlin
// build.gradle.kts
val classesDir = file("build/classes")
classesDir.mkdirs() //配置阶段创建
tasks.register<Delete>("clean") {
    delete("build")//清除文件
}
tasks.register("compile") {
    dependsOn("clean")
    val classesDir = classesDir
    doLast {
        if (!classesDir.isDirectory) {
            println("The class directory does not exist. I can not operate")
            // do something
        }
        // do something
    }
}
```

Output of gradle -q compile

```sh
> gradle -q compile
The class directory does not exist. I can not operate
```

由于目录的创建发生在配置阶段，clean 任务会在执行阶段删除目录。

# 编写可维护构建的最佳实践

Gradle 具有丰富的 API，其中包含多种创建构建逻辑的方法。相关的灵活性很容易导致不必要的复杂构建，自定义代码通常直接添加到构建脚本中。在本章中，我们将介绍几种最佳实践，它们将帮助您开发易于使用且富有表现力且可维护的构建。

第三方 Gradle lint 插件 有助于在构建脚本中强制执行所需的代码样式（如果您对此感兴趣）。

## 避免在脚本中使用命令式逻辑

Gradle 运行时不强制构建逻辑的特定样式。正是出于这个原因，很容易得到一个将声明性 DSL 元素与命令式过程代码混合在一起的构建脚本。让我们谈谈一些具体的例子。

- Declarative code: 内置的、与语言无关的 DSL 元素（例如 Project.dependencies{} 或 Project.repositories{} ）或插件公开的 DSL
- Imperative code: 条件逻辑或非常复杂的任务动作实现

每个构建脚本的最终目标应该是只包含使代码更易于理解和维护的声明性语言元素。命令式逻辑应该存在于二进制插件中，然后应用于构建脚本。作为副产品，如果您将构件发布到二进制仓库，您会自动启用您的团队 在其他项目中重用插件逻辑。

以下示例构建显示了直接在构建脚本中使用条件逻辑的反面示例。虽然这个代码片段很小，但很容易想象一个使用大量过程语句的完整构建脚本及其对可读性和可维护性的影响。通过将代码移动到一个类中，它也可以单独进行测试。

示例 1.使用条件逻辑创建任务的构建脚本

```kotlin
// build.gradle.kts
if (project.findProperty("releaseEngineer") != null) {
    tasks.register("release") {
        doLast {
            logger.quiet("Releasing to production...")

            // release the artifact to production
        }
    }
}
```

让我们将构建脚本与作为二进制插件实现的相同逻辑进行比较。该代码乍一看可能更复杂，但显然更像是典型的应用程序代码。这个特定的插件类位于 buildSrc directory 中，这使得它可以自动用于构建脚本。

示例 2.一个实现命令式逻辑的二进制插件

```groovy
ReleasePlugin.java
package com.enterprise;

import org.gradle.api.Action;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.Task;
import org.gradle.api.tasks.TaskProvider;

public class ReleasePlugin implements Plugin<Project> {
    private static final String RELEASE_ENG_ROLE_PROP = "releaseEngineer";
    private static final String RELEASE_TASK_NAME = "release";

    @Override
    public void apply(Project project) {
        if (project.findProperty(RELEASE_ENG_ROLE_PROP) != null) {
            Task task = project.getTasks().create(RELEASE_TASK_NAME);

            task.doLast(new Action<Task>() {
                @Override
                public void execute(Task task) {
                    task.getLogger().quiet("Releasing to production...");

                    // release the artifact to production
                }
            });
        }
    }
}
```

现在构建逻辑已经被翻译成一个插件，您可以在构建脚本中应用它。构建脚本已从 8 行代码缩减为一行代码。

示例 3.应用封装命令式逻辑的插件的构建脚本

```kotlin
build.gradle.kts
plugins {
    id("com.enterprise.release")
}
```

## 避免使用内部 Gradle API

在插件和构建脚本中使用 Gradle 内部 API 有可能在 Gradle 或插件发生变化时破坏构建。

Gradle 公共 API 定义 中列出了以下包，名称中带有 internal 的任何子包除外：

```txt
org/gradle/*
org/gradle/api/**
org/gradle/authentication/**
org/gradle/buildinit/**
org/gradle/caching/**
org/gradle/concurrent/**
org/gradle/deployment/**
org/gradle/external/javadoc/**
org/gradle/ide/**
org/gradle/includedbuild/**
org/gradle/ivy/**
org/gradle/jvm/**
org/gradle/language/**
org/gradle/maven/**
org/gradle/nativeplatform/**
org/gradle/normalization/**
org/gradle/platform/**
org/gradle/play/**
org/gradle/plugin/devel/**
org/gradle/plugin/repository/*
org/gradle/plugin/use/*
org/gradle/plugin/management/*
org/gradle/plugins/**
org/gradle/process/**
org/gradle/testfixtures/**
org/gradle/testing/jacoco/**
org/gradle/tooling/**
org/gradle/swiftpm/**
org/gradle/model/**
org/gradle/testkit/**
org/gradle/testing/**
org/gradle/vcs/**
org/gradle/workers/**
```

## 常用内部 API 的替代品

要为您的自定义任务提供嵌套 DSL，请不要使用 `org.gradle.internal.reflect.Instantiator` ；使用 ObjectFactory 代替。阅读 延迟配置章节 也可能有所帮助。

不要使用 `org.gradle.api.internal.ConventionMapping` 。使用 Provider 和/或 Property 。您可以在 实施插件部分 中找到捕获用户输入以配置运行时行为的示例。

代替 `org.gradle.internal.os.OperatingSystem` ，使用另一种方法来检测操作系统，例如 Apache commons-lang SystemUtils 或 System.getProperty("os.name") 。

使用其他集合或 I/O 框架代替 `org.gradle.util.CollectionUtils` 、 `org.gradle.util.internal.GFileUtils` 和 `org.gradle.util.*`下的其他类。

Gradle 插件作者可能会发现 将插件实现限制为 [Gradle 的公共 API](https://doc.qzxdp.cn/gradle/8.1.1/userguide/designing_gradle_plugins.html#restricting_the_plugin_implementation_to_gradle_s_public_api) 上的设计 Gradle 插件小节很有帮助。

## 声明任务时遵循约定

任务 API 为构建作者提供了很大的灵活性，可以在构建脚本中声明任务。为了获得最佳的可读性和可维护性，请遵循以下规则：

- 任务类型应该是任务名称后括号内的唯一键值对。
- 其他配置应该在任务的配置块中完成。
- 任务动作 在声明任务时添加，只能使用方法 Task.doFirst{} 或 Task.doLast{} 声明。
- 当声明一个临时任务时——一个没有显式类型的任务——如果你只声明一个动作，你应该使用 Task.doLast{}。
- 任务应该定义组和描述。

示例 4.遵循最佳实践的任务定义

```kotlin
build.gradle.kts
import com.enterprise.DocsGenerate

tasks.register<DocsGenerate>("generateHtmlDocs") {
    group = JavaBasePlugin.DOCUMENTATION_GROUP
    description = "Generates the HTML documentation for this project."
    title.set("Project docs")
    outputDir.set(layout.buildDirectory.dir("docs"))
}

tasks.register("allDocs") {
    group = JavaBasePlugin.DOCUMENTATION_GROUP
    description = "Generates all documentation for this project."
    dependsOn("generateHtmlDocs")

    doLast {
        logger.quiet("Generating all documentation...")
    }
}
```

## 提高任务的可发现性

即使是构建的新用户也应该能够快速轻松地找到关键信息。在 Gradle 中，您可以为构建的任何任务声明一个 group 和一个 description。 任务报告 使用分配的值来组织和呈现任务以便于发现。分配组和描述对于您希望构建用户调用的任何任务最有帮助。

示例: 任务 generateDocs 以 HTML 页面的形式为项目生成文档。该任务应组织在存储桶 Documentation 下。描述应表达其意图。

示例 5.声明组和描述的任务

```kotlin
build.gradle.kts
tasks.register("generateDocs") {
    group = "Documentation"
    description = "Generates the HTML documentation for this project."

    doLast {
        // action implementation
    }
}
```

任务报告的输出反映了分配的值。

```sh
> gradle tasks

> Task :tasks

Documentation tasks
-------------------
generateDocs - Generates the HTML documentation for this project.
```

## 最小化配置阶段执行的逻辑

对于每个构建脚本开发人员来说，了解 构建生命周期 的不同阶段及其对构建逻辑的性能和评估顺序的影响非常重要。在配置阶段，项目及其领域对象应该是 configured ，而执行阶段只执行命令行上请求的任务及其依赖项的操作。请注意，任何不属于任务操作的代码都将使用构建的 every single run 执行。 构建扫描 可以帮助您确定每个生命周期阶段所花费的时间。它是诊断常见性能问题的宝贵工具。

让我们考虑上面描述的反模式的以下咒语。在构建脚本中，您可以看到分配给配置 printArtifactNames 的依赖项在任务操作之外得到解决。

示例 6.应避免在配置期间执行逻辑

```kotlin
build.gradle.kts
dependencies {
    implementation("log4j:log4j:1.2.17")
}

tasks.register("printArtifactNames") {
    // always executed
    val libraryNames = configurations.compileClasspath.get().map { it.name }

    doLast {
        logger.quiet(libraryNames.joinToString())
    }
}
```

解决依赖关系的代码应该移到任务操作中，以避免在实际需要依赖关系之前解决依赖关系的性能影响。

示例 7.优先在执行阶段执行逻辑

```kotlin
build.gradle.kts
dependencies {
    implementation("log4j:log4j:1.2.17")
}

tasks.register("printArtifactNames") {
    val compileClasspath: FileCollection = configurations.compileClasspath.get()
    doLast {
        val libraryNames = compileClasspath.map { it.name }
        logger.quiet(libraryNames.joinToString())
    }
}
```

## Avoid using the GradleBuild task type

GradleBuild 任务类型允许构建脚本定义调用另一个 Gradle 构建的任务。通常不鼓励使用这种类型。在某些极端情况下，调用的构建不会暴露与命令行或通过工具 API 相同的运行时行为，从而导致意外结果。

通常，有更好的方法来为需求建模。适当的方法取决于手头的问题。这里有一些选项：

- 如果打算将来自不同模块的任务作为统一构建执行，则将构建建模为 多项目构建。
- 复合构建 用于物理上分离但应偶尔构建为单个单元的项目。

## 避免项目间配置

Gradle 不限制构建脚本作者在 多项目构建 中从一个项目进入另一个项目的域模型。强耦合项目会损害 构建执行性能 以及代码的可读性和可维护性。

应避免以下做法：

- 通过 Task.dependsOn(java.lang.Object...) 明确依赖于另一个项目的任务。
- 在另一个项目的域对象上设置属性值或调用方法。
- 使用 GradleBuild 执行构建的另一部分。
- 声明不必要的 项目依赖 。

## 外部化和加密您的密码

大多数构建需要使用一个或多个密码。这种需求的原因可能各不相同。一些构建需要密码才能将构件发布到安全的二进制仓库，其他构建需要密码才能下载二进制文件。密码应始终保持安全以防止欺诈。在任何情况下，您都不应将密码以纯文本形式添加到构建脚本中，或在项目目录的 gradle.properties 文件中声明。这些文件通常位于版本控制仓库中，任何有权访问它的人都可以查看。

密码和任何其他敏感数据应保存在版本控制项目文件之外。 Gradle 公开了一个用于在 ProviderFactory 和 构建仓库 中提供凭据的 API，允许在构建需要时使用 Gradle 属性 提供凭据值。这样，凭据可以存储在驻留在用户主目录中的 gradle.properties 文件中，或者使用命令行参数或环境变量注入到构建中。

如果您将敏感凭证存储在用户主目录的 gradle.properties 中，请考虑对其进行加密。目前 Gradle 不提供用于加密、存储和访问密码的内置机制。 Gradle 凭据插件 是解决这个问题的好方法。

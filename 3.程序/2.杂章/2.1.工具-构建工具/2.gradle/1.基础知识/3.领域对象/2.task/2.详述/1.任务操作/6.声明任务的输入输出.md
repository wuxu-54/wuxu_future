# 声明任务的输入输出（增量构建）

在 Gradle 中，声明任务的输入和输出是构建缓存和增量构建的关键部分。通过正确声明输入和输出，Gradle 可以确定何时需要重新执行任务，以及何时可以使用构建缓存来提高构建效率。
>每个任务都有输入输出，gradle 通过此判断这个任务需不需要重复执行。当我们设定输入输出后，比如声明一个文件作为输入，同时输出一个文件作为输出。当所有条件都无变化，重新执行task，gradle会判断出这个任务已经执行过了，不需要重新执行，会跳过此任务。

## 声明任务输入（Inputs）

任务输入可以是属性、文件或者目录。以下是如何声明任务输入的示例：

```groovy
task myTask {
    // 声明一个属性作为输入
    inputs.property('myProperty', 'someValue')

    // 声明一个文件作为输入
    inputs.file('inputFile.txt')

    // 声明一个目录作为输入
    inputs.dir('inputDir')

    // 执行任务动作
    doLast {
        println 'Executing my task'
    }
}
```

## 声明任务输出（Outputs）

任务输出可以是文件或者目录。以下是如何声明任务输出的示例：

```groovy
task myTask {
    // 声明一个文件作为输出
    outputs.file('outputFile.txt')

    // 声明一个目录作为输出
    outputs.dir('outputDir')

    // 执行任务动作
    doLast {
        println 'Executing my task'
    }
}
```

## 使用 `@PathSensitive` 注解

Gradle 提供了 `@PathSensitive` 注解来指定输入文件的路径敏感性，这有助于 Gradle 更精确地确定任务的输入变化：

- `PathSensitive.ABSOLUTE`：路径绝对敏感，任何路径变化都会导致任务重新执行。
- `PathSensitive.RELATIVE`：路径相对敏感，只有相对于任务工作目录的路径变化会导致任务重新执行。
- `PathSensitive.NONE`：路径不敏感，路径变化不会导致任务重新执行。

```groovy
task myTask {
    // 声明一个文件作为输入，并指定路径敏感性
    inputs.file('inputFile.txt').withPathSensitivity(PathSensitivity.RELATIVE)

    // 执行任务动作
    doLast {
        println 'Executing my task'
    }
}
```

## 动态声明输入和输出

在某些情况下，你可能需要根据条件动态声明任务的输入和输出。你可以使用 `doFirst` 或 `doLast` 来添加动态逻辑：

```groovy
task myTask {
    // 动态声明输入
    doFirst {
        if (someCondition) {
            inputs.property('dynamicProperty', 'dynamicValue')
        }
    }

    // 动态声明输出
    doLast {
        if (someCondition) {
            outputs.file('dynamicOutputFile.txt')
        }
    }
}
```

### 增量构建和构建效率

1. **增量构建原理**：
   - Gradle 在构建任务之前会构建一个任务图（Task Graph），这个图包含了所有任务及其依赖关系。
   - Gradle 会检查任务的输入和输出是否发生变化。如果输入文件被修改或输出文件不存在，Gradle 将重新执行任务。
   - 这种机制称为增量构建，它允许 Gradle 只构建必要的部分，从而提高构建效率。

2. **提高构建效率**：
   - **并行构建**：Gradle 支持并行构建，可以同时执行多个任务，提高构建效率。可以通过在构建脚本中设置 `--parallel` 选项来启用并行构建。
   - **避免不必要的任务执行**：通过正确声明任务的输入和输出，Gradle 可以避免不必要的任务执行，从而提高构建速度。
   - **构建缓存**：Gradle 可以使用构建缓存来存储任务的输出，这样在后续构建中可以直接使用缓存的结果，而不是重新执行任务。

通过以上方法，Gradle 可以有效地管理任务的执行，确保只有当任务的输入或输出发生变化时才重新执行任务，从而提高构建效率。正确使用这些特性可以显著减少构建时间，特别是在大型项目中。

### 它是怎么实现的？

任务的 inputs 属性是 TaskInputs 类型。任务的 outputs 属性是 TaskOutputs 类型。

一个没有定义输出的任务将永远不会被当作是最新的。对于任务的输出并不是文件的场景，或者是更复杂的场景， TaskOutputs.upToDateWhen() 方法允许您以编程方式计算任务的输出是否应该被判断为最新状态。

一个只定义了输出的任务，如果自上一次构建以来它的输出没有改变，那么它会被判定为最新状态。

任务的重新执行判断是怎么实现的？

在第一次执行任务之前，Gradle 对输入进行一次快照。这个快照包含了输入文件集和每个文件的内容的哈希值。然后 Gradle 执行该任务。如果任务成功完成，Gradle 将对输出进行一次快照。该快照包含输出文件集和每个文件的内容的哈希值。Gradle 会保存这两个快照，直到任务的下一次执行。

之后每一次，在执行任务之前，Gradle 会对输入和输出进行一次新的快照。如果新的快照和前一次的快照一样，Gradle 会假定这些输出是最新状态的并跳过该任务。如果它们不一则， Gradle 则会执行该任务。Gradle 会保存这两个快照，直到任务的下一次执行。

请注意，如果一个任务有一个指定的输出目录，在它上一次执行之后添加到该目录的所有文件都将被忽略，并且不会使这个任务成为过时状态。这是不相关的任务可以在不互相干扰的情况下共用一个输出目录。如果你因为一些理由而不想这样，请考虑使用 `TaskOutputs.upToDateWhen()`

---

## up-to-date任务

在 Gradle 中，"up-to-date" 任务是指那些由于输入和输出没有变化而不需要重新执行的任务。Gradle 通过检查任务的输入和输出来确定一个任务是否是最新的。如果一个任务的输入和输出自上次构建以来没有变化，那么这个任务就会被认为是 "up-to-date"，并且 Gradle 会跳过执行这个任务，从而提高构建效率。

以下是关于 "up-to-date" 任务的一些关键点：

1. **输入和输出属性**：
   每个任务都有输入和输出属性，你需要使用这些属性来声明任务的输入和输出。如果一个任务的输出没有变化，那么它就会被认为是 "up-to-date"。

2. **增量构建**：
   Gradle 支持增量构建，这意味着它会缓存每次运行的结果。在下次运行时，Gradle 会检查输出结果是否有变化，如果没有变化，则任务会被标记为 "up-to-date" 并跳过执行。

3. **如何工作**：
   当一个任务首次执行时，Gradle 会获取输入的快照，包括输入文件和每个文件的内容的散列。如果任务成功完成，Gradle 也会获取输出的快照。在任务的下一次执行时，Gradle 会使用这些快照来判断任务是否是最新的。

4. **跳过 "up-to-date" 任务**：
   如果一个任务只定义了输出，并且输出没有变化，那么这个任务就会被标记为 "up-to-date"。Gradle 会跳过这些任务的执行，从而节省时间。

5. **`upToDateWhen` 方法**：
   对于某些场景，比如一个任务的输出不是文件，或者更复杂的场景，可以使用 `TaskOutputs.upToDateWhen()` 方法来计算任务的输出是否应被视为最新。

通过这些机制，Gradle 能够智能地跳过不需要重新执行的任务，从而提高构建性能。这对于大型项目或者频繁构建的项目尤其有用，因为它们可以显著减少构建时间。

---

## 文件监视系统

[传送门](https://doc.qzxdp.cn/gradle/8.1.1/userguide/file_system_watching.html)

# 依赖管理

Gradle 的依赖管理是构建自动化中的一个重要组成部分，它允许你声明项目所需的外部库（依赖），并管理这些依赖的版本和传递性。
>这里的依赖是指依赖库的管理，包括本地项目、远程库等

什么是依赖管理?

粗略的讲, 依赖管理由两部分组成:

- **dependencies(依赖项)**: Gradle 需要了解你的项目需要构建或运行的东西, 以便找到它们. 我们称这些传入的文件为项目的 dependencies(依赖项).
- **publications(发布项)**: Gradle 需要构建并上传你的项目产生的东西. 我们称这些传出的项目文件为 publications(发布项).

## 1. 声明依赖

在 `build.gradle` 文件中，你可以在 `dependencies` 代码块中声明依赖：

```groovy
apply plugin: 'java'
repositories {
    mavenCentral()
}
dependencies {
    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'
    testCompile group: 'junit', name: 'junit', version: '4.+'

    //上面依赖可以简写,是指Maven pom.xml依赖库的坐标。其含义是 Group ID、Artifact ID 和 Version
    implementation 'org.hibernate:hibernate-core:3.6.7.Final'
    testImplementation 'junit:junit:4.+'
}
```

## 2. 配置（Configurations）

配置是依赖管理的核心，它定义了依赖的使用范围，如 `implementation`、`compile`、`testImplementation` 等。下面是常用示例，还有更多配置方式及api，可查看官网说明。

- `implementation`: 依赖对项目内部可见，但不在外部二进制文件中暴露。`compile`被`implementation`替代。
- `api`: 与 `implementation` 类似，但依赖会暴露给其他模块。
- `compileOnly`、`runtimeOnly`: 这些配置不参与编译，只用于运行时或编译时。

## 3. 仓库（Repositories）

你需要配置仓库来指定 Gradle 应该从哪里下载依赖：

```groovy
repositories {
    mavenCentral()
    maven {//远程maven，指定路径
        url "http://repo.mycompany.com/maven2"
    }
    ivy {//远程ivy仓库
        url "http://repo.mycompany.com/repo"
    }
     ivy {
        //通过设定url可以将ivy仓库设为本地。maven同理
        url "../local-repo"
    }
    jcenter()
    google()
}
```

## 4. 依赖传递性

Gradle 会自动解析依赖的传递性，但你可以控制传递性依赖：

```groovy
dependencies {
    implementation('com.example:library:1.0') {
        transitive = false //false 不传递此依赖
    }
}
```

## 5. 依赖排除

排除特定依赖：

```groovy
dependencies {
    implementation('com.example:library:1.0') {
        exclude group: 'com.unwanted', module: 'unwanted-module'
    }
}
```

## 6. 版本管理

Gradle 支持动态版本和静态版本管理：

- 动态版本（如 `1.+`、`[1.0, 2.0)`）：Gradle 会选择最合适的版本。
- 静态版本（如 `1.0`）：指定一个固定版本。

## 7. 依赖冲突解决

Gradle 默认使用最新版本解决冲突，但你可以通过 `ResolutionStrategy` 定制冲突解决策略：

```groovy
configurations.all {
    resolutionStrategy {
        force 'com.fasterxml.jackson.core:jackson-databind:2.13.0'
        preferProject()
        failOnVersionConflict()
    }
}
```

## 8. 依赖替换

在多模块项目中，你可以替换一个模块的依赖为另一个模块：

```groovy
configurations.all {
    resolutionStrategy {
        dependencySubstitution {
            substitute module('com.example:old-module') with project(':new-module')
        }
    }
}
```

## 9. 依赖锁定

为了确保构建的可重复性，你可以锁定依赖的版本：

```groovy
configurations.all {
    resolutionStrategy {
        activateDependencyLocking()
    }
}
```

## 10. 依赖报告

Gradle 提供了依赖报告功能，帮助你理解项目的依赖树：

```shell
./gradlew dependencies
```

这个命令会显示项目的依赖树，帮助你识别和解决依赖冲突。

通过这些工具和策略，Gradle 提供了一个强大且灵活的依赖管理系统，可以帮助你有效地管理项目依赖，确保构建的一致性和可维护性。

---

## 依赖冲突

在 Gradle 中管理多项目依赖时，可能会遇到一些兼容问题。以下是一些处理这些问题的高级用法和策略：

## 1. 使用 `ResolutionStrategy` 强制依赖版本

在多项目构建中，可以通过 `ResolutionStrategy` API 强制所有模块使用特定版本的依赖，以避免版本冲突。例如：

```groovy
configurations.all {
    resolutionStrategy {
        force 'asm:asm-all:3.3.1', 'commons-io:commons-io:1.4'
    }
}
```

这可以确保所有模块都使用指定版本的依赖，从而避免版本冲突问题。

## 2. 依赖替换

在 `ResolutionStrategy` 中，可以使用 `dependencySubstitution` 来替换依赖，这在处理项目间依赖时非常有用：

```groovy
configurations.all {
    resolutionStrategy {
        dependencySubstitution {
            substitute module('org.gradle:api') using project(':api')
        }
    }
}
```

这样可以直接使用项目路径替换外部依赖，有助于解决项目间的依赖问题。

## 3. 排除传递性依赖

使用 `exclude` 关键字排除特定依赖的传递性依赖，解决冲突：

```groovy
dependencies {
    implementation('com.example:library:1.0') {
        exclude group: 'com.example', module: 'unwantedModule'
    }
}
```

这样可以避免不需要的模块被包含在构建中，减少依赖冲突。

## 4. 依赖洞察

使用 `dependencyInsight` 命令查看依赖关系，识别冲突的依赖项：

```shell
./gradlew dependencyInsight --dependency com.example:library
```

这有助于理解依赖树并识别导致冲突的具体依赖。

## 5. 依赖冲突策略

在 `ResolutionStrategy` 中，可以设置依赖冲突策略，例如：

```groovy
configurations.all {
    resolutionStrategy {
        failOnVersionConflict()
    }
}
```

这会在版本冲突时立即失败，有助于快速定位问题。

## 6. 依赖锁定

激活依赖锁定支持，以确保构建的可重复性：

```groovy
configurations.all {
    resolutionStrategy {
        activateDependencyLocking()
    }
}
```

这可以锁定依赖的版本，确保每次构建使用的是相同的版本。

通过这些高级用法和策略，可以有效地管理多项目依赖中的兼容问题，确保构建的稳定性和可预测性。

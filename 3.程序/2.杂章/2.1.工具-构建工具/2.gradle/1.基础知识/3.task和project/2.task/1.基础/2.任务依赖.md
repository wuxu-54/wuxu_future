# 任务依赖

## 概念

定义：任务依赖是指一个任务（称为依赖任务）需要在另一个任务（称为被依赖任务）完成后才能执行。

作用：确保构建过程中的任务按照预期的顺序执行，避免由于任务执行顺序错误而导致的构建失败或结果不正确。

## 声明方式

定义任务（task）时可以使用 `dependsOn` 属性来指定一个或多个前置任务（即当前任务执行前必须先执行的任务）。

### 写法一

通过 dependsOn属性在task内进行依赖

```groovy
task taskA {
    doLast {
        println 'Executing task A'
    }
}

task taskB {
    dependsOn taskA 
    doLast {
        println 'Executing task B (depends on task A)'
    }
}
```

### 写法二

在任务配置闭包中设置依赖

```groovy
task taskC {
    doLast {
        println 'Executing task C'
    }
}

task taskD {
    doLast {
        println 'Executing task D'
    }
}

// 在配置闭包中声明依赖
taskD.dependsOn taskC
```

### 写法三

是写法一的变种，在参数列表处直接设置：task 任务名(dependsOn: 被依赖任务名)

```groovy
task hello {
    doLast {
        println 'Hello, Gradle!'
    }
}

// 示例 1: 直接引用任务对象
task intro(dependsOn: hello) {
    doLast {
        println 'This is the intro task.'
    }
}

// 示例 2: 使用任务名称的字符串表示
task intro2(dependsOn: 'hello') {
    doLast {
        println 'This is the intro2 task.'
    }
}
```

## 直接引用和延迟依赖

上面方法三的示例，为啥有两种方式：直接引用任务对象或使用任务名称的字符串表示。

写法简例：

- 直接引用：dependsOn 任务名
- 延迟依赖：dependsOn '任务名'

以下是对这两个概念的详细解释。

### 一、直接引用依赖

直接引用依赖是指在任务定义时，直接通过`dependsOn`属性或方法指定任务之间的依赖关系。这种方式是最直观和常用的，它允许开发者在任务定义时明确指出哪些任务需要先执行。

#### 示例

```groovy
task taskA {
    doLast {
        println 'Executing task A'
    }
}

task taskB {
    dependsOn taskA // 直接引用依赖
    doLast {
        println 'Executing task B (depends on task A)'
    }
}
```

在这个例子中，`taskB`直接引用了`taskA`作为它的依赖。因此，当执行`taskB`时，Gradle会首先执行`taskA`，然后再执行`taskB`。

### 二、延迟依赖

延迟依赖是指依赖关系不是在任务定义时立即确定的，而是在某个后续阶段（如配置阶段或执行阶段）才确定的。这种方式提供了更大的灵活性，允许开发者根据构建脚本中的其他逻辑或条件来决定任务之间的依赖关系。

然而，在Gradle的任务依赖系统中，并没有一个明确的“延迟依赖”的概念或语法。但是，可以通过一些技巧来实现类似的效果，例如使用闭包或Lambda表达式来延迟依赖关系的计算。

#### 示例（使用闭包）

```groovy
task taskA {
    doLast {
        println 'Executing task A'
    }
}

task taskB {
    // 使用闭包延迟依赖关系的计算
    dependsOn {
        // 这里可以包含任何逻辑来决定依赖哪些任务
        // 例如，可以根据某些条件来决定是否依赖taskA
        return tasks.named('taskA')
    }
    doLast {
        println 'Executing task B (may depend on task A)'
    }
}
```

**注意**：上面的示例代码实际上并不是Gradle中标准的延迟依赖实现方式。在Gradle中，`dependsOn`属性通常接受一个任务名称或任务对象的列表，而不是一个闭包。但是，为了说明延迟依赖的概念，这里使用了闭包来模拟一个可能的实现方式。在实际应用中，可能需要采用其他方法（如自定义任务类型或插件）来实现真正的延迟依赖。

然而，在大多数情况下，Gradle的任务依赖关系是在配置阶段确定的，并且不需要延迟到执行阶段。如果确实需要根据某些条件来决定任务之间的依赖关系，可以考虑在配置阶段使用条件语句（如`if`）来动态地设置`dependsOn`属性。

#### 更实际的示例（使用条件语句）

```groovy
task taskA {
    doLast {
        println 'Executing task A'
    }
}

task taskB {
    doLast {
        println 'Executing task B'
    }

    // 在配置阶段根据条件设置依赖关系
    if (project.hasProperty('someCondition') && project.property('someCondition') == 'true') {
        taskB.dependsOn taskA
    }
}
```

在这个例子中，`taskB`是否依赖`taskA`取决于项目属性`someCondition`的值。如果`someCondition`为`true`，则`taskB`会依赖`taskA`；否则，它不会依赖`taskA`。

#### 区别

1. **直接引用任务对象** (`dependsOn: hello`)：
   - 在这种方式中，`hello` 是一个已经定义的任务对象的直接引用。
   - Gradle 在解析 `dependsOn` 属性时，会立即知道 `hello` 是一个任务，并且会在执行 `intro` 任务之前确保 `hello` 任务被执行。
   - 这种方式的优点是类型安全，因为 Gradle 在编译时就能检查到 `hello` 是否是一个有效的任务对象。

2. **使用任务名称的字符串表示** (`dependsOn: 'hello'`)：
   - 在这种方式中，`'hello'` 是一个字符串，表示任务的名称。
   - Gradle 在解析 `dependsOn` 属性时，会根据字符串查找对应的任务。
   - 这种方式的优点是灵活性更高，因为你可以使用字符串来引用尚未定义的任务（尽管这在实际应用中并不常见，因为通常你会先定义依赖的任务）。
   - 然而，这种方式在类型安全性方面稍逊于直接引用任务对象，因为 Gradle 只能在运行时检查任务名称是否有效。

#### 实际应用

在大多数情况下，使用任务名称的字符串表示（`dependsOn: 'hello'`）是更常见和更推荐的做法。这是因为：

- 字符串表示更加直观和易于理解，特别是当任务名称是动态生成或来自外部配置时。
- 字符串表示在 Gradle 构建脚本的上下文中通常是足够的，因为 Gradle 会在执行阶段解析任务依赖关系。
- 直接引用任务对象在某些情况下可能会导致代码的可读性和可维护性降低，特别是当任务定义变得复杂或分散在多个文件中时。

总之，虽然两种方式在功能上是等效的，但在实际应用中，使用任务名称的字符串表示通常更加灵活和易于管理。

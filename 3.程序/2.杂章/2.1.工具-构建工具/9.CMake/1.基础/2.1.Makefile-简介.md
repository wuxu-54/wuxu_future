# Makefile简介

Makefile 是一种用于**自动化构建程序**的配置文件，由 `make` 工具解析执行。它通过定义**目标（target）、依赖（prerequisites）和命令（commands）**，描述文件之间的依赖关系和构建步骤，实现“只重新编译修改过的文件及其依赖”的增量构建，大幅提升大型项目的编译效率。

## 一、Makefile 核心规则

Makefile 的基本组成单位是**规则（Rule）**，语法结构如下：

```makefile
目标: 依赖1 依赖2 ...
	命令1
	命令2
	...
```

- **目标（Target）**：要构建的文件（如可执行文件、目标文件 `.o`）或操作（如 `clean`，称为“伪目标”）。  
- **依赖（Prerequisites）**：构建目标所需要的文件或其他目标。若依赖不存在或比目标更新（修改时间更新），`make` 会执行命令重建目标。  
- **命令（Commands）**：构建目标的具体操作（如编译命令 `gcc -c`），**必须以 Tab 键开头**（不能用空格，这是常见错误）。  

### 示例：最简单的 Makefile

假设项目只有一个源文件 `main.c`，要生成可执行文件 `main`：

```makefile
# 注释：# 开头的行是注释
main: main.c  # 目标 main 依赖 main.c
	gcc main.c -o main  # 编译命令（Tab 开头）
```

在终端执行 `make` 时，`make` 会检查：  

1. 若 `main` 不存在，执行 `gcc main.c -o main` 生成 `main`；  
2. 若 `main` 存在，但 `main.c` 比 `main` 新（即 `main.c` 被修改过），重新执行命令；  
3. 若 `main` 比所有依赖都新，输出 `make: 'main' is up to date.`，不执行任何操作。  

## 二、变量：简化重复配置

Makefile 支持变量（类似“宏”），用于存储重复出现的内容（如编译器、编译选项、文件列表），简化维护。

### 1. 变量定义与使用

- 定义：`变量名 = 值`（或 `:=` 立即展开，`?=` 若未定义则赋值）。  
- 使用：`$(变量名)` 或 `${变量名}`。  

**示例**：  

```makefile
# 定义变量
CC = gcc  # 编译器
CFLAGS = -Wall -g  # 编译选项（-Wall 显示警告，-g 生成调试信息）
TARGET = main  # 目标可执行文件名
SRCS = main.c  # 源文件列表

# 使用变量
$(TARGET): $(SRCS)
	$(CC) $(CFLAGS) $(SRCS) -o $(TARGET)
```

### 2. 预定义变量（内置变量）

`make` 提供了一些默认变量，对应常用命令和选项，可直接使用或修改：  

| 变量       | 含义                          | 默认值（示例）       |
|------------|-------------------------------|----------------------|
| `CC`       | C 编译器                      | `cc`（通常指向 `gcc`）|
| `CXX`      | C++ 编译器                    | `g++`                |
| `CFLAGS`   | C 编译选项                    | 空                   |
| `CXXFLAGS` | C++ 编译选项                  | 空                   |
| `LDFLAGS`  | 链接选项（如 `-L` 指定库路径） | 空                   |
| `LDLIBS`   | 链接库（如 `-lm` 链接数学库） | 空                   |

**示例（C++ 项目）**：  

```makefile
CXX = g++
CXXFLAGS = -Wall -std=c++11 -g
TARGET = app
SRCS = main.cpp utils.cpp

$(TARGET): $(SRCS)
	$(CXX) $(CXXFLAGS) $(SRCS) -o $(TARGET)
```

## 三、多文件项目与目标文件

大型项目通常包含多个源文件（如 `a.c`、`b.c`），需先编译为目标文件（`.o`），再链接为可执行文件。Makefile 可通过多规则实现这一过程。

### 示例：多文件项目

项目结构：  

```txt
project/
├── main.c
├── utils.c
├── utils.h
└── Makefile
```

Makefile 内容：  

```makefile
CC = gcc
CFLAGS = -Wall -g
TARGET = app
# 源文件列表
SRCS = main.c utils.c
# 目标文件列表（将 .c 替换为 .o）
OBJS = $(SRCS:.c=.o)  # 等价于 main.o utils.o

# 最终目标：链接所有 .o 文件生成 app
$(TARGET): $(OBJS)
	$(CC) $(CFLAGS) $(OBJS) -o $(TARGET)

# 编译 main.c 生成 main.o
main.o: main.c utils.h  # 依赖头文件 utils.h
	$(CC) $(CFLAGS) -c main.c -o main.o

# 编译 utils.c 生成 utils.o
utils.o: utils.c utils.h
	$(CC) $(CFLAGS) -c utils.c -o utils.o

# 伪目标：清理构建产物
.PHONY: clean
clean:
	rm -f $(TARGET) $(OBJS)
```

#### 执行流程：

1. 执行 `make` 时，`make` 先检查最终目标 `app` 的依赖 `main.o` 和 `utils.o`；  
2. 若 `main.o` 不存在或 `main.c`/`utils.h` 已修改，执行 `gcc -c main.c ...` 生成 `main.o`；  
3. 同理处理 `utils.o`；  
4. 所有 `.o` 准备就绪后，执行链接命令生成 `app`。  

## 四、伪目标（PHONY Target）

若目标不是实际文件（如 `clean`、`all`），需用 `.PHONY` 声明为“伪目标”，避免与同名文件冲突（如误创建 `clean` 文件后，`make clean` 会失效）。

### 常用伪目标：

- `all`：默认目标（通常放在 Makefile 开头），可同时构建多个目标。  
- `clean`：删除构建产物（`.o`、可执行文件等）。  
- `install`：安装程序到系统目录（如 `/usr/local/bin`）。  

**示例**：  

```makefile
# 声明伪目标
.PHONY: all clean install

# 默认目标：构建 app 和 test
all: app test

# 构建 app
app: main.o
	gcc main.o -o app

# 构建测试程序
test: test.o
	gcc test.o -o test

# 清理
clean:
	rm -f app test *.o

# 安装（需 root 权限）
install: app
	cp app /usr/local/bin/
```

执行 `make` 等价于 `make all`，会同时构建 `app` 和 `test`；执行 `make clean` 会删除产物。

## 五、自动变量：简化命令编写

`make` 提供了**自动变量**，用于在命令中引用目标、依赖等，避免重复书写。常用自动变量：

| 变量  | 含义                                  | 示例（规则 `target: dep1 dep2` 中） |
|-------|---------------------------------------|-------------------------------------|
| `$@`  | 目标文件名                            | `$@` 代表 `target`                  |
| `$^`  | 所有依赖文件的列表（去重）            | `$^` 代表 `dep1 dep2`               |
| `$<`  | 第一个依赖文件                        | `$<` 代表 `dep1`                    |
| `$?`  | 所有比目标新的依赖文件                | 若 `dep1` 比 `target` 新，则 `$?` 为 `dep1` |
| `$*`  | 目标文件名的前缀（不含扩展名）        | 若目标是 `main.o`，`$*` 为 `main`   |

### 示例：用自动变量简化多文件规则

```makefile
CC = gcc
CFLAGS = -Wall -g
TARGET = app
SRCS = main.c utils.c
OBJS = $(SRCS:.c=.o)

# 链接：$@ 是 app，$^ 是所有 .o 文件
$(TARGET): $(OBJS)
	$(CC) $(CFLAGS) $^ -o $@

# 编译：通用规则（所有 .o 依赖对应的 .c 和头文件）
# $@ 是目标 .o，$< 是第一个依赖（.c 文件）
%.o: %.c utils.h
	$(CC) $(CFLAGS) -c $< -o $@

.PHONY: clean
clean:
	rm -f $(TARGET) $(OBJS)
```

- `%.o: %.c` 是**模式规则**：`%` 为通配符，匹配任意字符串，表示“所有 `.o` 文件依赖对应的 `.c` 文件”，无需为每个 `.o` 单独写规则。  

## 六、隐含规则与模式规则

`make` 内置了许多**隐含规则**（Implicit Rules），无需显式定义即可编译常见文件（如 `.c→.o`、`.o→可执行文件`），进一步简化 Makefile。

### 1. 隐含规则示例：

- `.c→.o`：默认命令为 `$(CC) $(CFLAGS) -c $< -o $@`，即无需写 `%.o: %.c` 规则，`make` 会自动处理。  
- `.o→可执行文件`：默认命令为 `$(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@`。  

利用隐含规则，多文件项目的 Makefile 可简化为：  

```makefile
CC = gcc
CFLAGS = -Wall -g
TARGET = app
SRCS = main.c utils.c
OBJS = $(SRCS:.c=.o)

# 仅需定义最终目标，依赖和命令由隐含规则处理
$(TARGET): $(OBJS)

.PHONY: clean
clean:
	rm -f $(TARGET) $(OBJS)
```

### 2. 自定义模式规则

若隐含规则不满足需求（如特殊编译选项），可自定义模式规则覆盖隐含规则：  

```makefile
# 自定义 .c→.o 规则，添加 -O2 优化
%.o: %.c
	$(CC) $(CFLAGS) -O2 -c $< -o $@
```

## 七、函数：处理文件与字符串

Makefile 提供了一系列函数，用于处理文件列表、字符串替换等，常用函数如下：

### 1. `wildcard`：匹配文件

语法：`$(wildcard 模式)`  
功能：返回当前目录中匹配模式的所有文件列表（类似 shell 通配符）。  

**示例**：  

```makefile
# 自动获取所有 .c 文件（无需手动写 SRCS = a.c b.c ...）
SRCS = $(wildcard *.c)  # 若当前目录有 main.c、utils.c，SRCS 为 "main.c utils.c"
OBJS = $(SRCS:.c=.o)
```

### 2. `patsubst`：字符串替换

语法：`$(patsubst 模式, 替换值, 字符串)`  
功能：将字符串中匹配“模式”的部分替换为“替换值”（`%` 为通配符）。  

**示例**：  

```makefile
# 将所有 .c 文件名替换为 .o（等价于 $(SRCS:.c=.o)）
OBJS = $(patsubst %.c, %.o, $(SRCS))
```

### 3. `foreach`：循环处理列表

语法：`$(foreach 变量, 列表, 操作)`  
功能：对列表中的每个元素执行“操作”，返回所有结果的拼接。  

**示例**：  

```makefile
# 为每个源文件生成对应的 .d 依赖文件（存储头文件依赖）
SRCS = main.c utils.c
DEPS = $(foreach src, $(SRCS), $(src:.c=.d))
```

## 八、条件判断：适配多环境

Makefile 支持条件判断（`ifeq`/`ifneq`/`ifdef`/`ifndef`），用于根据变量值或是否定义，执行不同规则（如跨平台适配）。

### 语法：

```makefile
ifeq ($(变量), 值)
  # 条件为真时的规则
else ifneq ($(变量), 值)
  # 其他条件为真时的规则
else
  # 所有条件为假时的规则
endif
```

### 示例：跨平台编译

```makefile
CC = gcc
TARGET = app
SRCS = main.c

# 根据操作系统定义不同的编译选项
ifeq ($(OS), Windows_NT)
  # Windows 平台（通过环境变量 OS 判断）
  TARGET := $(TARGET).exe  # 可执行文件加 .exe 后缀
  CFLAGS = -DWIN32
else
  # Linux/macOS 平台
  CFLAGS = -DUNIX
endif

$(TARGET): $(SRCS)
	$(CC) $(CFLAGS) $(SRCS) -o $(TARGET)
```

执行时可通过命令行指定变量：  

```bash
# Windows 平台
make OS=Windows_NT

# Linux 平台
make OS=Linux
```

## 九、依赖文件（.d 文件）：自动跟踪头文件

源文件（如 `main.c`）通常依赖头文件（如 `utils.h`），若头文件修改，`make` 需重新编译依赖它的 `.c` 文件。通过生成**依赖文件（.d）** 可自动跟踪这种依赖。

### 实现方法：

1. 用编译器生成 `.d` 文件（如 `gcc -MM` 输出依赖关系）；  
2. 在 Makefile 中引入 `.d` 文件。  

### 示例：自动生成依赖文件

```makefile
CC = gcc
CFLAGS = -Wall -g
TARGET = app
SRCS = $(wildcard *.c)
OBJS = $(SRCS:.c=.o)
DEPS = $(SRCS:.c=.d)  # 依赖文件列表（main.d、utils.d 等）

# 引入所有 .d 文件（若存在）
-include $(DEPS)

# 链接
$(TARGET): $(OBJS)
	$(CC) $(OBJS) -o $@

# 编译：同时生成 .d 依赖文件（-MMD 选项）
%.o: %.c
	$(CC) $(CFLAGS) -MMD -c $< -o $@  # -MMD 自动生成 .d 文件

.PHONY: clean
clean:
	rm -f $(TARGET) $(OBJS) $(DEPS)
```

- `-include $(DEPS)`：`-` 表示文件不存在时不报错；  
- `gcc -MMD`：编译 `.c` 时自动生成 `.d` 文件（如 `main.d` 包含 `main.o: main.c utils.h`），`make` 会根据 `.d` 跟踪头文件依赖。  

## 十、常见问题与调试

### 1. 命令不执行或报错

- **Tab 键问题**：命令必须以 Tab 键开头（不能用空格），若编辑器自动替换为空格，会导致 `make: *** missing separator.  Stop.` 错误。  
- **依赖不存在**：若依赖文件不存在且无规则生成，会报错 `No rule to make target 'xxx', needed by 'yyy'.`。  

### 2. 调试 Makefile

- 执行 `make -n`：打印要执行的命令，但不实际执行（预览构建步骤）。  
- 执行 `make -p`：输出 `make` 的所有内置规则和变量（了解隐含规则）。  
- 执行 `make -d`：输出详细调试信息（分析依赖关系）。  

## 总结

Makefile 通过**规则、变量、自动变量、函数**等机制，实现了项目的自动化增量构建。核心要点：  

- 基础规则：`目标: 依赖` + Tab 开头的命令；  
- 变量与自动变量：简化重复配置，如 `$(CC)`、`$@`、`$^`；  
- 伪目标：`all`、`clean` 等操作需用 `.PHONY` 声明；  
- 模式规则与隐含规则：简化多文件编译；  
- 依赖文件：自动跟踪头文件修改，确保增量构建正确性。  

对于小型项目，手写 Makefile 足够高效；大型项目建议配合 CMake 等工具生成 Makefile，减少手动维护成本。

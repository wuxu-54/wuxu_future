# CMakeLists中的常用API

CMake 提供了丰富的命令（API）用于构建配置，这些命令在 `CMakeLists.txt` 中组织项目的构建逻辑。以下按功能分类总结常用 API 及其说明，涵盖基础配置、目标管理、依赖处理、条件控制等核心场景，并标注关键参数和用途。

## 一、基础配置命令

### 1. `cmake_minimum_required`  

**功能**：指定项目所需的最低 CMake 版本，确保语法兼容性。  
**语法**：  

```cmake
cmake_minimum_required(VERSION <major>[.<minor>[.<patch>]] [FATAL_ERROR])
```  

**说明**：  

- 必须放在 `CMakeLists.txt` 开头（`project` 命令之前）。  
- `FATAL_ERROR`（可选）：若当前 CMake 版本低于要求，直接报错终止。  
**示例**：  

```cmake
cmake_minimum_required(VERSION 3.10 FATAL_ERROR)  # 要求最低 3.10 版本
```  

### 2. `project`  

**功能**：定义项目名称、版本、语言等基本信息。  
**语法**：  

```cmake
project(<PROJECT-NAME> 
  [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]
  [DESCRIPTION <project-description>]
  [HOMEPAGE_URL <url>]
  [LANGUAGES <language>...]
)
```  

**说明**：  

- 定义后会生成变量（如 `${PROJECT_NAME}`、`${PROJECT_VERSION}`）。  
- `LANGUAGES` 默认为 `C` 和 `CXX`（C++），可指定为 `NONE`（不默认启用语言）。  
**示例**：  

```cmake
project(MyApp 
  VERSION 1.2.3 
  DESCRIPTION "A demo application" 
  LANGUAGES CXX
)
```  

### 3. `set`  

**功能**：定义或修改变量（普通变量、缓存变量、环境变量）。  
**语法**：  

```cmake
# 普通变量（当前作用域有效）
set(<VAR> <VALUE>... [PARENT_SCOPE])

# 缓存变量（持久化，可在 cmake-gui 中修改，带类型提示）
set(<VAR> <VALUE>... CACHE <TYPE> <DOCSTRING> [FORCE])

# 环境变量
set(ENV{<VAR>} <VALUE>)
```  

**说明**：  

- `PARENT_SCOPE`：将变量传递到父作用域（如子目录的 `CMakeLists.txt` 向根目录传递变量）。  
- 缓存变量类型（`TYPE`）：`BOOL`、`STRING`、`PATH` 等，用于 cmake-gui 显示控件（如复选框）。  
**示例**：  

```cmake
set(SRC_FILES main.cpp utils.cpp)  # 普通变量
set(USE_LOGGING ON CACHE BOOL "Enable logging feature")  # 缓存变量（可在外部修改）
set(ENV{PATH} "$ENV{PATH}:/usr/local/bin")  # 修改环境变量
```  

### 4. `option`  

**功能**：定义布尔类型的缓存变量（常用于开关功能），比 `set` 更简洁。  
**语法**：  

```cmake
option(<option> "<description>" <initial-value>)
```  

**说明**：  

- `initial-value` 只能是 `ON` 或 `OFF`。  
- 变量会被添加到缓存，用户可通过 `-D<option>=ON/OFF` 在命令行修改。  
**示例**：  

```cmake
option(BUILD_TESTS "Build test cases" ON)  # 默认开启测试
```  

## 二、目标（Target）管理命令

目标是 CMake 构建的核心（可执行文件、库等），以下命令用于定义和配置目标。

### 1. `add_executable`  

**功能**：定义可执行目标（生成可执行文件）。  
**语法**：  

```cmake
add_executable(<target> [WIN32] [MACOSX_BUNDLE]
  [EXCLUDE_FROM_ALL]
  <source-file>...
)
```  

**说明**：  

- `WIN32`：Windows 平台生成 GUI 程序（不显示控制台）。  
- `MACOSX_BUNDLE`：macOS 平台生成 `.app` 捆绑包。  
- `EXCLUDE_FROM_ALL`：该目标不会被 `all` 目标默认构建，需手动指定构建。  
**示例**：  

```cmake
add_executable(myapp main.cpp)  # 从 main.cpp 生成 myapp 可执行文件
```  

### 2. `add_library`  

**功能**：定义库目标（静态库、动态库、模块库等）。  
**语法**：  

```cmake
add_library(<target> [STATIC | SHARED | MODULE]
  [EXCLUDE_FROM_ALL]
  <source-file>...
)
```  

**说明**：  

- 库类型：  
  - `STATIC`：静态库（`.a`/`.lib`）。  
  - `SHARED`：动态库（`.so`/`.dll`）。  
  - `MODULE`：可动态加载的模块（非链接用，如 Python 扩展）。  
  - 不指定类型时，由 `BUILD_SHARED_LIBS` 变量决定（`ON` 为 SHARED，默认 `OFF`）。  
**示例**：  

```cmake
add_library(mylib STATIC utils.cpp)  # 生成静态库 libmylib.a（或 mylib.lib）
```  

### 3. `target_include_directories`  

**功能**：为目标指定头文件搜索目录（替代全局 `include_directories`，推荐优先使用）。  
**语法**：  

```cmake
target_include_directories(<target>
  [BEFORE]
  <INTERFACE|PUBLIC|PRIVATE> <dir>...
  [<INTERFACE|PUBLIC|PRIVATE> <dir>...]...
)
```  

**说明**：  

- 作用域关键字（决定依赖传递性）：  
  - `PRIVATE`：仅当前目标生效，依赖该目标的其他目标不继承。  
  - `PUBLIC`：当前目标生效，且依赖该目标的其他目标也继承。  
  - `INTERFACE`：当前目标不生效，仅依赖该目标的其他目标继承。  
**示例**：  

```cmake
target_include_directories(myapp 
  PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/src  # 仅 myapp 用
  PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include  # myapp 及其依赖者都可用
)
```  

### 4. `target_link_libraries`  

**功能**：为目标链接库（包括其他目标库或系统库，替代全局 `link_libraries`）。  
**语法**：  

```cmake
target_link_libraries(<target>
  [BEFORE]
  <INTERFACE|PUBLIC|PRIVATE> <item>...
  [<INTERFACE|PUBLIC|PRIVATE> <item>...]...
)
```  

**说明**：  

- `<item>` 可以是：其他目标（如 `mylib`）、系统库（如 `pthread`）、链接标志（如 `-lm`）。  
- 作用域关键字同 `target_include_directories`，控制依赖传递。  
**示例**：  

```cmake
target_link_libraries(myapp 
  PRIVATE mylib  # 链接自定义库 mylib（仅 myapp 依赖）
  PUBLIC pthread  # 链接系统线程库，依赖 myapp 的目标也会链接
)
```  

### 5. `target_compile_definitions`  

**功能**：为目标添加预编译宏定义（替代全局 `add_definitions`）。  
**语法**：  

```cmake
target_compile_definitions(<target>
  [BEFORE]
  <INTERFACE|PUBLIC|PRIVATE> <definition>...
  [<INTERFACE|PUBLIC|PRIVATE> <definition>...]...
)
```  

**说明**：  

- 宏定义格式：`MY_DEFINE`（对应 `#define MY_DEFINE`）或 `MY_DEFINE=10`（对应 `#define MY_DEFINE 10`）。  
**示例**：  

```cmake
target_compile_definitions(myapp 
  PRIVATE DEBUG=1  # 仅 myapp 定义 DEBUG=1
  PUBLIC USE_LOG  # myapp 及其依赖者都定义 USE_LOG
)
```  

### 6. `target_compile_options`  

**功能**：为目标添加编译选项（如警告等级、优化选项）。  
**语法**：  

```cmake
target_compile_options(<target>
  [BEFORE]
  <INTERFACE|PUBLIC|PRIVATE> <option>...
  [<INTERFACE|PUBLIC|PRIVATE> <option>...]...
)
```  

**示例**：  

```cmake
target_compile_options(myapp 
  PRIVATE -Wall -Wextra  # GCC/Clang 警告选项
  $<$<CXX_COMPILER_ID:MSVC>:/W4>  # MSVC 警告选项（生成器表达式）
)
```  

### 7. `set_target_properties`  

**功能**：设置目标的属性（如输出路径、版本号、链接选项等）。  
**语法**：  

```cmake
set_target_properties(<target>... PROPERTIES <property> <value>...)
```  

**常用属性**：  

- `RUNTIME_OUTPUT_DIRECTORY`：可执行文件输出目录。  
- `LIBRARY_OUTPUT_DIRECTORY`：动态库输出目录。  
- `ARCHIVE_OUTPUT_DIRECTORY`：静态库输出目录。  
- `VERSION`：库版本号（如 `1.2.3`）。  
- `SOVERSION`：库 API 版本号（如 `1`）。  
**示例**：  

```cmake
set_target_properties(myapp PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin  # 可执行文件放 bin 目录
)

set_target_properties(mylib PROPERTIES
  VERSION 1.2.3
  SOVERSION 1  # 生成 libmylib.so.1.2.3 和符号链接 libmylib.so.1
)
```  

## 三、自定义构建步骤

用于定义额外的构建操作（如生成文件、复制资源等）。

### 1. `add_custom_command`  

**功能**：定义自定义命令（生成文件或绑定到目标的特定阶段）。  
**语法**（生成文件）：  

```cmake
add_custom_command(
  OUTPUT <output-file>...
  COMMAND <command> [args...]
  [MAIN_DEPENDENCY <file>]
  [DEPENDS <depends>...]
  [COMMENT <string>]
  [WORKING_DIRECTORY <dir>]
  [VERBATIM]
)
```  

**语法**（绑定目标）：  

```cmake
add_custom_command(
  TARGET <target>
  PRE_BUILD | PRE_LINK | POST_BUILD
  COMMAND <command> [args...]
  [COMMENT <string>]
  [WORKING_DIRECTORY <dir>]
  [VERBATIM]
)
```  

**说明**：  

- 生成文件时，需将 `OUTPUT` 文件添加到目标的源文件列表，否则命令不会执行。  
- 绑定目标时，`PRE_BUILD`（构建前）、`PRE_LINK`（编译后链接前）、`POST_BUILD`（构建后）指定执行时机。  
**示例**：见前文“自定义命令”详细说明。  

### 2. `add_custom_target`  

**功能**：定义自定义目标（无输出文件，需手动触发或作为依赖）。  
**语法**：  

```cmake
add_custom_target(<name>
  [ALL]  # 加入默认构建目标（make all 会触发）
  [DEPENDS <depends>...]  # 依赖的文件或目标
  [COMMENT <string>]
  [COMMAND <command> [args...]]
  [WORKING_DIRECTORY <dir>]
  [VERBATIM]
)
```  

**示例**：  

```cmake
# 定义一个清理临时文件的目标，手动执行 `make clean_temp` 触发
add_custom_target(clean_temp
  COMMAND ${CMAKE_COMMAND} -E remove *.tmp
  COMMENT "Cleaning temporary files"
  VERBATIM
)
```  

## 四、条件控制与循环

用于处理跨平台、多配置等分支逻辑。

### 1. `if` / `elseif` / `else` / `endif`  

**功能**：条件判断（支持变量、表达式、平台等）。  
**语法**：  

```cmake
if(<condition>)
  # 条件为真时执行
elseif(<condition>)
  # 其他条件为真时执行
else()
  # 所有条件为假时执行
endif()
```  

**常用条件**：  

- 变量检查：`if(DEFINED VAR)`、`if(VAR STREQUAL "value")`、`if(VAR)`（非空/非0为真）。  
- 平台检查：`if(WIN32)`、`if(UNIX)`、`if(APPLE)`、`if(CMAKE_SYSTEM_NAME STREQUAL "Linux")`。  
- 编译器检查：`if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")`、`if(MSVC)`。  
- 目标检查：`if(TARGET <target>)`（判断目标是否存在）。  
**示例**：  

```cmake
if(WIN32)
  target_compile_definitions(myapp PRIVATE _WIN32)
elseif(UNIX)
  target_compile_definitions(myapp PRIVATE _UNIX)
endif()
```  

### 2. `foreach` / `endforeach`  

**功能**：循环遍历列表。  
**语法**：  

```cmake
foreach(<var> <item>...)
  # 循环体
endforeach()

# 或遍历范围
foreach(<var> RANGE <start> <end> [<step>])
endforeach()
```  

**示例**：  

```cmake
set(SRCS a.cpp b.cpp c.cpp)
foreach(src ${SRCS})
  message("Source file: ${src}")  # 打印每个源文件
endforeach()

# 遍历数字 1-5（步长 2）
foreach(i RANGE 1 5 2)
  message("i = ${i}")  # 输出 1, 3, 5
endforeach()
```  

## 五、文件与目录操作

### 1. `file`  

**功能**：文件/目录操作（复制、删除、读取、生成等），支持多种子命令。  
**常用子命令**：  

- `file(COPY <files>... DESTINATION <dir>)`：复制文件/目录到目标路径（构建时执行）。  
- `file(REMOVE <files>...)`：删除文件。  
- `file(REMOVE_RECURSE <dirs>...)`：递归删除目录。  
- `file(GLOB <var> <patterns>)`：通过通配符匹配文件（不推荐用于源文件，可能漏文件）。  
- `file(READ <file> <var>)`：读取文件内容到变量。  
- `file(WRITE <file> <content>)`：写入内容到文件（配置时执行）。  
- `file(APPEND <file> <content>)`：追加内容到文件。  
- `file(MAKE_DIRECTORY <dirs>...)`：创建目录。  
**示例**：  

```cmake
file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/assets DESTINATION ${CMAKE_BINARY_DIR})  # 复制资源
file(GLOB HDRS ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)  # 匹配所有头文件
file(WRITE version.txt "1.2.3")  # 写入版本文件
```  

### 2. `include`  

**功能**：引入其他 CMake 脚本（`.cmake` 文件或其他 `CMakeLists.txt`）。  
**语法**：  

```cmake
include(<file|module> [OPTIONAL] [RESULT_VARIABLE <var>] [NO_POLICY_SCOPE])
```  

**说明**：  

- `OPTIONAL`：文件不存在时不报错。  
- 可引入 CMake 内置模块（如 `FindBoost.cmake`）或自定义脚本。  
**示例**：  

```cmake
include(./utils.cmake)  # 引入自定义脚本
include(FindThreads)    # 引入内置模块（查找线程库）
```  

### 3. `add_subdirectory`  

**功能**：添加子目录（子目录需包含 `CMakeLists.txt`），用于多目录项目。  
**语法**：  

```cmake
add_subdirectory(<dir> [binary_dir] [EXCLUDE_FROM_ALL])
```  

**说明**：  

- `binary_dir`：指定子目录的构建输出目录（默认与 `dir` 对应）。  
- `EXCLUDE_FROM_ALL`：子目录目标不被默认构建。  
**示例**：  

```cmake
add_subdirectory(src)  # 添加 src 子目录（构建输出在 build/src）
add_subdirectory(tests EXCLUDE_FROM_ALL)  # 测试目录需手动构建
```  

## 六、依赖查找与配置

### 1. `find_package`  

**功能**：查找系统中的第三方库（如 Boost、Qt 等），支持两种模式：  

- **模块模式**：查找 `Find<Package>.cmake` 模块（内置或用户提供）。  
- **配置模式**：查找库自带的 `<Package>Config.cmake` 配置文件。  
**语法**：  

```cmake
find_package(<Package> [version] [EXACT] [QUIET] [MODULE]
  [REQUIRED] [[COMPONENTS] [components...]]
)
```  

**说明**：  

- `REQUIRED`：库未找到时报错。  
- `COMPONENTS`：指定需查找的组件（如 `find_package(Boost COMPONENTS system thread)`）。  
- 找到后生成变量（如 `<Package>_FOUND`、`<Package>_INCLUDE_DIRS`、`<Package>_LIBRARIES`）。  
**示例**：  

```cmake
find_package(Boost 1.70 REQUIRED COMPONENTS system)
if(Boost_FOUND)
  target_include_directories(myapp PUBLIC ${Boost_INCLUDE_DIRS})
  target_link_libraries(myapp PUBLIC ${Boost_LIBRARIES})
endif()
```  

### 2. `find_library`  

**功能**：手动查找库文件（`.so`/`.a`/`.dll` 等），适用于无 `Find` 模块的库。  
**语法**：  

```cmake
find_library(<VAR> <name>
  [HINTS <path>...]
  [PATHS <path>...]
  [PATH_SUFFIXES <suffix>...]
)
```  

**示例**：  

```cmake
find_library(MATH_LIB m  # 查找 libm.so（数学库）
  HINTS /usr/local/lib
)
if(MATH_LIB)
  target_link_libraries(myapp PRIVATE ${MATH_LIB})
endif()
```  

### 3. `find_path`  

**功能**：手动查找头文件目录，配合 `find_library` 使用。  
**语法**：  

```cmake
find_path(<VAR> <header>
  [HINTS <path>...]
  [PATHS <path>...]
  [PATH_SUFFIXES <suffix>...]
)
```  

**示例**：  

```cmake
find_path(ZLIB_INCLUDE_DIR zlib.h  # 查找 zlib.h 所在目录
  HINTS /usr/include
)
if(ZLIB_INCLUDE_DIR)
  target_include_directories(myapp PRIVATE ${ZLIB_INCLUDE_DIR})
endif()
```  

## 七、安装部署命令

### `install`  

**功能**：定义安装规则（安装目标、文件、目录等），支持 `make install` 触发。  
**常用语法**：  

1. **安装目标**：  

```cmake
install(TARGETS <target>...
  [RUNTIME DESTINATION <dir>]  # 可执行文件/动态库（Windows）安装路径
  [LIBRARY DESTINATION <dir>]  # 动态库（Linux/macOS）安装路径
  [ARCHIVE DESTINATION <dir>]  # 静态库安装路径
  [PUBLIC_HEADER DESTINATION <dir>]  # 公共头文件安装路径
)
```  

2. **安装文件**：  

```cmake
install(FILES <files>... DESTINATION <dir>
  [PERMISSIONS <permissions>...]  # 权限（如 OWNER_READ GROUP_READ）
)
```  

3. **安装目录**：  

```cmake
install(DIRECTORY <dirs>... DESTINATION <dir>
  [FILE_PERMISSIONS <permissions>...]
  [DIRECTORY_PERMISSIONS <permissions>...]
  [PATTERN <pattern> EXCLUDE]  # 排除文件/目录
)
```  

**示例**：  

```cmake
# 安装可执行文件到 bin 目录，静态库到 lib 目录
install(TARGETS myapp mylib
  RUNTIME DESTINATION bin
  ARCHIVE DESTINATION lib
)

# 安装头文件到 include 目录
install(FILES include/utils.h DESTINATION include)

# 安装资源目录到 share/myapp
install(DIRECTORY assets/ DESTINATION share/myapp
  PATTERN "*.tmp" EXCLUDE  # 排除临时文件
)
```  

## 八、测试命令

### 1. `enable_testing`  

**功能**：启用测试支持（生成 `CTestTestfile.cmake`，允许 `ctest` 命令运行测试）。  
**语法**：  

```cmake
enable_testing()
```  

### 2. `add_test`  

**功能**：定义测试用例（配合 `ctest` 或 `make test` 运行）。  
**语法**：  

```cmake
add_test(NAME <name> COMMAND <command> [args...])
```  

**示例**：  

```cmake
enable_testing()
add_executable(test_app test.cpp)
add_test(NAME MyTest COMMAND test_app)  # 定义名为 MyTest 的测试，运行 test_app
```  

### 3. `set_tests_properties`  

**功能**：设置测试用例的属性（如超时时间、预期失败等）。  
**示例**：  

```cmake
set_tests_properties(MyTest PROPERTIES
  TIMEOUT 10  # 超时时间 10 秒
  PASS_REGULAR_EXPRESSION "All tests passed"  # 预期输出包含该字符串
)
```  

## 九、其他常用命令

### 1. `message`  

**功能**：输出信息到控制台（配置时显示）。  
**语法**：  

```cmake
message([<mode>] "message text")
```  

**模式**：  

- `STATUS`：普通状态信息（默认）。  
- `WARNING`：警告信息。  
- `AUTHOR_WARNING`：开发者警告。  
- `SEND_ERROR`：错误信息（继续配置）。  
- `FATAL_ERROR`：致命错误（终止配置）。  
**示例**：  

```cmake
message(STATUS "Building version: ${PROJECT_VERSION}")
message(WARNING "Deprecated option used")
```  

### 2. `mark_as_advanced`  

**功能**：将缓存变量标记为“高级”（在 cmake-gui 中默认隐藏，需开启“高级”选项才显示）。  
**语法**：  

```cmake
mark_as_advanced([CLEAR] <var>...)
```  

**示例**：  

```cmake
mark_as_advanced(INTERNAL_LIB_PATH)  # 隐藏内部路径变量
```  

### 3. `configure_file`  

**功能**：根据模板文件生成输出文件（替换 `@VAR@` 或 `${VAR}` 为变量值）。  
**语法**：  

```cmake
configure_file(<input> <output>
  [COPYONLY]  # 仅复制，不替换变量
  [ESCAPE_QUOTES]  # 转义引号
  [@ONLY]  # 仅替换 @VAR@，不替换 ${VAR}
)
```  

**示例**：  

```cmake
# 模板文件 version.h.in 内容：#define VERSION "@PROJECT_VERSION@"
configure_file(version.h.in ${CMAKE_BINARY_DIR}/version.h @ONLY)
```  

## 十、生成器表达式（Generator Expressions）

不是命令，而是特殊语法（`$<...>`），用于在生成构建文件时动态调整目标属性（依赖于配置、平台、编译器等）。  
**常用表达式**：  

- 配置相关：`$<CONFIG>`（当前配置，如 `Debug`）、`$<IF:$<CONFIG:Debug>,-O0,-O2>`（Debug 用 `-O0`，其他用 `-O2`）。  
- 目标文件：`$<TARGET_FILE:target>`（目标文件路径）、`$<TARGET_FILE_DIR:target>`（目标文件目录）。  
- 编译器检查：`$<CXX_COMPILER_ID:GNU>`（若编译器是 GCC 则为真）。  
**示例**：  

```cmake
# Debug 模式定义 DEBUG 宏，添加 -g 选项
target_compile_definitions(myapp PRIVATE $<IF:$<CONFIG:Debug>,DEBUG,>)
target_compile_options(myapp PRIVATE $<IF:$<CONFIG:Debug>,-g,>)
```  

## 总结

CMake 命令按功能可分为：  

- **基础配置**：`cmake_minimum_required`、`project`、`set` 等，定义项目基本信息。  
- **目标管理**：`add_executable`、`add_library` 及 `target_*` 系列，配置目标的依赖、编译选项等。  
- **自定义步骤**：`add_custom_command`、`add_custom_target`，处理额外构建操作。  
- **条件与循环**：`if`、`foreach`，处理分支和批量操作。  
- **依赖与安装**：`find_package`、`install`，查找第三方库并定义部署规则。  

实际使用中，应优先使用目标相关命令（`target_*`）而非全局命令（如 `include_directories`），以确保依赖传递清晰，提升项目可维护性。

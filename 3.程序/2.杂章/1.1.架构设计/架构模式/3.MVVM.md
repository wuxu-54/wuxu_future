# MVVM

---

**MVVM（Model-View-ViewModel）架构详解**  
MVVM 是一种以 **数据驱动** 为核心的架构模式，通过 **双向数据绑定** 技术实现 View 和 Model 的自动同步，广泛应用于前端框架（如 Vue.js、React）和桌面开发（如 WPF）。其核心目标是 **解耦界面逻辑与业务逻辑**，提升开发效率和可维护性。

---

## **1. 核心角色**

### **(1) Model（模型）**

- **职责**：与 MVC/MVP 中的 Model 一致。
  - 管理数据源（数据库、API、本地存储）。
  - 定义业务规则（如数据校验、计算逻辑）。
- **关键特性**：
  - **不感知 View 和 ViewModel 的存在**。
  - 通过事件或回调通知数据变化（被动更新）。

**示例**：用户信息模块中，Model 负责从服务器获取用户数据并存储到本地。

---

### **(2) View（视图）**

- **职责**：纯 UI 展示与用户交互。
  - 定义界面结构（如 HTML、XAML、XML）。
  - 绑定 ViewModel 的数据和命令（通过数据绑定语法）。
  - **不处理业务逻辑**，仅触发 ViewModel 的命令。
- **关键特性**：
  - **通过数据绑定自动更新**（无需手动操作 DOM 或 UI 控件）。
  - 完全被动，仅反映 ViewModel 的状态。

**示例**：用户列表页面通过数据绑定自动渲染 ViewModel 提供的用户数据。

---

### **(3) ViewModel（视图模型）**

- **职责**：连接 View 和 Model 的桥梁，**核心业务逻辑载体**。
  - 将 Model 的数据转换为 View 可直接使用的格式（如格式化日期、过滤列表）。
  - 暴露数据属性和命令供 View 绑定（如 `users` 列表、`onSubmit` 方法）。
  - 监听用户操作（如按钮点击），调用 Model 处理逻辑。
- **关键特性**：
  - **不直接引用 View**，仅通过数据绑定与 View 交互。
  - 可独立测试（不依赖具体界面实现）。

**示例**：用户搜索功能中，ViewModel 接收输入关键词，调用 Model 过滤数据，并更新绑定到 View 的结果列表。

---

## **2. 协作流程**

1. **用户操作 View**（如输入文本、点击按钮）。
2. **View 触发 ViewModel 的命令**（通过数据绑定）。
3. **ViewModel 调用 Model** 处理业务逻辑（如保存数据、发起网络请求）。
4. **Model 返回结果**（如更新后的数据、错误信息）。
5. **ViewModel 更新自身状态**（如修改绑定的数据属性）。
6. **View 自动同步最新数据**（通过双向数据绑定）。

---

## **3. MVVM vs MVC vs MVP 核心区别**

| **维度**       | **MVC**                  | **MVP**                  | **MVVM**                     |
|----------------|--------------------------|--------------------------|-----------------------------|
| **数据流**     | View 可直接读取 Model    | View 通过 Presenter 获取数据 | View 通过数据绑定自动同步 ViewModel 数据 |
| **业务逻辑载体** | Controller             | Presenter               | ViewModel                   |
| **UI 更新方式** | 手动更新 View           | Presenter 调用 View 接口 | 自动双向数据绑定            |
| **测试重点**   | 需 Mock View 和 Model   | 测试 Presenter 逻辑      | 测试 ViewModel 逻辑          |
| **适用场景**   | 传统 Web 应用           | 客户端应用（如 Android） | 数据驱动型应用（如 SPA）     |

---

## **4. 核心机制：数据绑定**

- **双向绑定**：  
  View 的输入控件（如输入框）与 ViewModel 属性自动同步。  
  **示例**：输入框内容修改 → ViewModel 的 `username` 属性自动更新 → Model 保存数据。
- **单向绑定**：  
  View 的展示控件（如列表）仅反映 ViewModel 的数据变化。  
  **示例**：ViewModel 的 `userList` 更新 → View 的列表自动重新渲染。

---

## **5. 优势与局限**

- **优势**：
  - **开发高效**：减少手动操作 UI 的样板代码（如 `document.getElementById`）。
  - **彻底解耦**：View 仅关注展示，ViewModel 专注逻辑。
  - **可维护性强**：数据驱动界面，修改业务逻辑无需调整 View。
- **局限**：
  - **学习曲线**：需掌握数据绑定和响应式编程。
  - **调试困难**：数据绑定错误可能隐式传播，不易定位。
  - **内存泄漏风险**：不当使用观察者模式可能导致资源未释放。

---

## **6. 适用场景**

- **数据驱动型应用**：如实时仪表盘、动态表单、聊天应用。
- **复杂交互界面**：需频繁更新 UI 的场景（如拖拽、动画）。
- **跨平台开发**：共享 ViewModel 逻辑（如 React Native、Flutter）。

---

## **7. 常见框架**

- **前端**：Vue.js（核心）、React（配合 Redux/MobX）、Angular。
- **桌面**：WPF（.NET）、JavaFX。
- **移动端**：Android Jetpack（ViewModel + LiveData + DataBinding）。

---

## **8. 代码示例（Vue.js）**

```javascript
// Model（模拟 API 请求）
const UserModel = {
  fetchUsers: () => axios.get("/api/users"),
};

// ViewModel
const UserViewModel = {
  data() {
    return {
      users: [],
      searchKeyword: "",
    };
  },
  methods: {
    async loadUsers() {
      this.users = await UserModel.fetchUsers();
    },
  },
  computed: {
    filteredUsers() {
      return this.users.filter(user => 
        user.name.includes(this.searchKeyword)
    },
  },
};

// View（Vue 模板）
<template>
  <div>
    <input v-model="searchKeyword" placeholder="搜索用户">
    <ul>
      <li v-for="user in filteredUsers" :key="user.id">{{ user.name }}</li>
    </ul>
    <button @click="loadUsers">加载用户</button>
  </div>
</template>
```

---

## **9. 总结**

- **Model**：数据的源头，独立于界面。
- **View**：数据的被动展示者，依赖数据绑定。
- **ViewModel**：逻辑的枢纽，驱动数据流转。

MVVM 是 **数据驱动开发** 的典范，适合需要快速响应数据变化的场景，但对框架的依赖较强。**核心价值在于通过双向绑定减少手动同步的冗余代码，使开发者更专注于业务逻辑**。

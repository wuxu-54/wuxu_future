# 策略模式

一个类的行为或算法可以在运行时动态更改。将每个算法封装起来，使它们可以互换使用，无需修改客户端代码。

类型：行为型

目的：解决在多种相似算法存在时，使用条件语句（如if...else）导致的复杂性和难以维护的问题。

## 结构

策略模式包含以下几个核心角色：

- **环境（Context）**：维护一个对策略对象的引用，负责将客户端请求委派给具体的策略对象执行。环境类可以通过依赖注入、简单工厂等方式来获取具体策略对象。
- **抽象策略（Abstract Strategy）**：定义了策略对象的公共接口或抽象类，规定了具体策略类必须实现的方法。
- **具体策略（Concrete Strategy）**：实现了抽象策略定义的接口或抽象类，包含了具体的算法实现。

## 适用场景

- 当需要在运行时根据不同的条件选择使用多种算法之一时。
- 当需要避免使用多重条件语句来选择算法时。
- 当需要替换或扩展算法时，不会影响到使用算法的客户端。

## 优缺点

- 优点
  - 算法切换自由：可以在运行时根据需要切换算法。
  - 避免多重条件判断：消除了复杂的条件语句。
  - 扩展性好：新增算法只需新增一个策略类，无需修改现有代码。
- 缺点
  - 策略类数量增多：每增加一个算法，就需要增加一个策略类。
  - 所有策略类都需要暴露：策略类需要对外公开，以便可以被选择和使用。

## 注意事项

- 如果系统中策略类数量过多，考虑使用其他模式或设计技巧来解决类膨胀问题。

## 示例

```java
// 策略接口
interface Strategy {
    void execute();
}

// 具体策略类A
class ConcreteStrategyA implements Strategy {
    @Override
    public void execute() {
        System.out.println("Executing ConcreteStrategyA");
    }
}

// 具体策略类B
class ConcreteStrategyB implements Strategy {
    @Override
    public void execute() {
        System.out.println("Executing ConcreteStrategyB");
    }
}

// 上下文
class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public void executeStrategy() {
        strategy.execute();
    }
}

// 客户端代码
public class StrategyPatternDemo {
    public static void main(String[] args) {
        Context context = new Context(new ConcreteStrategyA());
        context.executeStrategy(); // Executing ConcreteStrategyA

        context.setStrategy(new ConcreteStrategyB());
        context.executeStrategy(); // Executing ConcreteStrategyB
    }
}
```

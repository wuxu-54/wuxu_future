# 过滤器模式（又称：标准模式、规格模式）

类型：结构型

目的：对集合或对象进行过滤筛选时，通过过滤器模式可以动态组合过滤条件，增加灵活性。

## 结构

过滤器模式通常包含以下角色：

- **过滤器接口（Filter/Criteria）**：定义一个接口，用于筛选对象。该接口通常包含一个方法，用于根据特定条件过滤对象。
- **具体过滤器类（Concrete Filter/Concrete Criteria）**：实现过滤器接口，具体定义筛选对象的条件和逻辑。
- **对象集合（Items/Objects to be filtered）**：要被过滤的对象集合。这些对象通常是具有共同属性的实例，例如一组人、一组产品等。
- **客户端（Client）**：使用具体过滤器类来筛选对象集合。客户端将对象集合和过滤器结合起来，以获得符合条件的对象。

## 优缺点

- 优点：
  - **灵活性**：可以灵活地添加、组合、重用各种过滤条件。
  - **解耦**：将过滤逻辑与对象集合的业务逻辑分离，降低耦合度。
  - **可扩展性**：可以很容易地扩展新的过滤条件。

- 缺点：
  - **性能问题**：如果候选项集合很大，过滤操作可能会比较耗时。
  - **复杂性**：随着过滤条件的增加，系统复杂性也会增加。

## 使用场景

- 当需要根据不同的标准动态筛选数据时。
- 当系统中存在多个条件组合时，需要灵活地对这些条件进行组合和重用。
- 当需要将过滤逻辑与业务逻辑分离，提高代码的可维护性时。

## 使用建议

- 当筛选逻辑可能变化或需要根据不同标准动态筛选对象时，考虑使用过滤器模式。
- 在设计时，确保筛选器的接口和实现保持一致，以便于组合和扩展。

## 注意

- 确保筛选器的组合逻辑正确无误，避免引入逻辑错误。
- 在实现时，考虑性能影响，特别是在处理大量数据时。

## 示例

```java
// 被过滤的对象
class Candidate {
    private String attribute;

    public Candidate(String attribute) {
        this.attribute = attribute;
    }

    public String getAttribute() {
        return attribute;
    }
}

// 过滤器接口
interface Criteria {
    boolean meetCriteria(Candidate candidate);
}

// 具体过滤器
class ConcreteCriteria implements Criteria {
    private String requiredAttribute;

    public ConcreteCriteria(String requiredAttribute) {
        this.requiredAttribute = requiredAttribute;
    }

    @Override
    public boolean meetCriteria(Candidate candidate) {
        return candidate.getAttribute().equals(requiredAttribute);
    }
}

// 组合过滤器
class AndCriteria implements Criteria {
    private List<Criteria> criterias = new ArrayList<>();

    public void add(Criteria criteria) {
        criterias.add(criteria);
    }

    @Override
    public boolean meetCriteria(Candidate candidate) {
        for (Criteria criteria : criterias) {
            if (!criteria.meetCriteria(candidate)) {
                return false;
            }
        }
        return true;
    }
}

// 过滤器对象的集合
class Context {
    private List<Candidate> candidates;

    public Context() {
        candidates = new ArrayList<>();
    }

    public void add(Candidate candidate) {
        candidates.add(candidate);
    }

    public List<Candidate> filter(Criteria criteria) {
        List<Candidate> filtered = new ArrayList<>();
        for (Candidate candidate : candidates) {
            if (criteria.meetCriteria(candidate)) {
                filtered.add(candidate);
            }
        }
        return filtered;
    }
}

// 客户端代码
public class FilterPatternDemo {
    public static void main(String[] args) {
        Context context = new Context();
        context.add(new Candidate("A"));
        context.add(new Candidate("B"));
        context.add(new Candidate("C"));

        Criteria criteria1 = new ConcreteCriteria("B");
        Criteria criteria2 = new ConcreteCriteria("C");
        Criteria andCriteria = new AndCriteria();
        andCriteria.add(criteria1);
        andCriteria.add(criteria2);

        List<Candidate> filteredCandidates = context.filter(andCriteria);
        for (Candidate candidate : filteredCandidates) {
            System.out.println(candidate.getAttribute());
        }
    }
}
```

# 解释器模式

解释器模式通过构建一个抽象语法树来解释语言或表达式，适用于需要实现简单解释器的场景。这种模式在编译原理、配置文件解析、页面模板解析等领域有广泛应用。
>通俗讲：设定一系列规则（具体为表达式），按规则进行执行。

类型：行为型

目的：解释器模式用于构建一个能够解释特定语言或文法的句子的解释器。
>这种模式被用在 SQL 解析、符号处理引擎等，java中很有少适用的场景

## 实现方式

- 定义文法：明确语言的终结符和非终结符。
- 构建语法树：根据语言的句子构建对应的语法树结构。
- 创建环境类：包含解释过程中所需的全局信息，通常是一个HashMap。

## 结构

解释器模式包含以下几个主要角色：

- 抽象表达式（Abstract Expression）：定义了解释器的抽象接口，声明了解释操作的方法，通常是一个抽象类或接口。
- 终结符表达式（Terminal Expression）：实现了抽象表达式接口的终结符表达式类，用于表示语言中的终结符（如变量、常量等），并实现了对应的解释操作。
- 非终结符表达式（Non-terminal Expression）：实现了抽象表达式接口的非终结符表达式类，用于表示语言中的非终结符（如句子、表达式等），并实现了对应的解释操作。
- 上下文（Context）：包含解释器之外的一些全局信息，在解释过程中提供给解释器使用，通常用于存储变量的值、保存解释器的状态等。
- 客户端（Client）：创建并配置具体的解释器对象，并将需要解释的表达式传递给解释器进行解释。

## 适用场景

- 当某一特定类型的问题频繁出现，并且可以通过一种简单的语言来表达这些问题的实例时。
- 当有一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象语法树时。
- 当需要实现一个简单的解释器时。

## 优缺点

- 优点：
  - 可扩展性好：容易添加新的解释表达式的方式。
  - 灵活性：可以根据需要轻松扩展或修改文法。
  - 易于实现简单文法：对于简单的语言，实现起来相对容易。
- 缺点：
  - 使用场景有限：只适用于适合使用解释的简单文法。
  - 维护困难：对于复杂的文法，维护和扩展变得困难。
  - 类膨胀：可能会产生很多类，每个文法规则对应一个类。
  - 递归调用：解释器模式通常使用递归调用，这可能难以理解和跟踪。

## 注意事项

- 解释器模式在 Java 中可能不是首选，如果遇到适用场景，可以考虑使用如expression4J之类的库来代替。

## 示例

```java
// 抽象表达式
interface AbstractExpression {
    void interpret(Context context);
}

// 终结符表达式
class TerminalExpression implements AbstractExpression {
    @Override
    public void interpret(Context context) {
        // 解释终结符
        System.out.println("TerminalExpression interpret");
    }
}

// 非终结符表达式
class NonTerminalExpression implements AbstractExpression {
    private List<AbstractExpression> expressions = new ArrayList<>();

    public void add(AbstractExpression expression) {
        expressions.add(expression);
    }

    @Override
    public void interpret(Context context) {
        // 解释非终结符
        for (AbstractExpression expression : expressions) {
            expression.interpret(context);
        }
    }
}

// 上下文
class Context {
    // 全局信息
}

// 客户端代码
public class InterpreterPatternDemo {
    public static void main(String[] args) {
        Context context = new Context();
        AbstractExpression terminal = new TerminalExpression();
        AbstractExpression nonTerminal = new NonTerminalExpression();
        nonTerminal.add(terminal);

        nonTerminal.interpret(context); // 将依次调用添加到非终结符中的终结符表达式
    }
}
```

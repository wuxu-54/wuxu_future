# 状态模式

允许一个对象在其内部状态改变时改变其行为，看起来就像是改变了其类一样。

类型：行为型

目的：状态模式解决对象行为依赖于其状态的问题，使得对象可以在状态变化时切换行为。

## 解决问题

- 状态模式解决对象行为依赖于其状态的问题，使得对象可以在状态变化时切换行为。

## 结构

状态模式包含以下几个主要角色：

- **上下文（Context）**：定义了客户感兴趣的接口，并维护一个当前状态对象的引用。上下文可以通过状态对象来委托处理状态相关的行为。
- **状态（State）**：定义了一个接口，用于封装与上下文相关的一个状态的行为。
- **具体状态（Concrete State）**：实现了状态接口，负责处理与该状态相关的行为。具体状态对象通常会在内部维护一个对上下文对象的引用，以便根据不同的条件切换到不同的状态。

## 适用场景

- 当一个对象的行为取决于其状态，且状态变化会导致行为显著变化时。
- 当代码中包含大量与状态相关的条件分支语句时，可以使用状态模式重构。

## 优缺点

- 优点
  - **封装状态转换规则**：将状态转换逻辑封装在状态对象内部。
  - **易于扩展**：增加新的状态类不会影响现有代码。
  - **集中状态相关行为**：将所有与特定状态相关的行为集中到一个类中。
  - **简化条件语句**：避免使用大量的条件语句来切换行为。
  - **状态共享**：允许多个上下文对象共享同一个状态对象。
- 缺点
  - **增加类和对象数量**：每个状态都需要一个具体的状态类。
  - **实现复杂**：模式结构和实现相对复杂。
  - **开闭原则支持不足**：增加新状态或修改状态行为可能需要修改现有代码。

## 注意事项

- 状态模式适用于状态数量有限（通常不超过5个）的情况。
- 谨慎使用，以避免系统变得过于复杂。

## 示例

```java
// 状态接口
interface State {
    void handle(String request);
}

// 具体状态类A
class ConcreteStateA implements State {
    @Override
    public void handle(String request) {
        System.out.println("Handling request in ConcreteStateA");
        // 根据请求切换状态
    }
}

// 具体状态类B
class ConcreteStateB implements State {
    @Override
    public void handle(String request) {
        System.out.println("Handling request in ConcreteStateB");
        // 根据请求切换状态
    }
}

// 上下文
class Context {
    private State state;

    public Context(State state) {
        this.state = state;
    }

    public void setState(State state) {
        this.state = state;
    }

    public void request(String request) {
        state.handle(request);
    }
}

// 客户端代码
public class StatePatternDemo {
    public static void main(String[] args) {
        Context context = new Context(new ConcreteStateA());
        context.request("Do something");

        context.setState(new ConcreteStateB());
        context.request("Do something else");
    }
}
```

# 模版模式

在父类定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。

类型：行为型

目的：解决在多个子类中重复实现相同的方法的问题，通过将通用方法抽象到父类中来避免代码重复。

## 结构

包含的几个主要角色：

- **抽象父类（Abstract Class）**：定义了模板方法和一些抽象方法或具体方法。
- **具体子类（Concrete Classes）**：继承自抽象父类，并实现抽象方法。
- **钩子方法（Hook Method）（可选）**：在抽象父类中定义，可以被子类重写，以影响模板方法的行为。
- **客户端（Client）（可选）**：使用抽象父类和具体子类，无需关心模板方法的细节。

## 适用场景

- 当需要将算法的某些步骤延迟到子类中实现时。
- 当需要通过子类来扩展或修改算法的行为时。
- 当需要复用代码，同时保持算法结构不变时。

## 优缺点

- 优点：
  - **代码复用**：提高了代码的复用性，减少了代码的重复。
  - **行为扩展**：子类可以通过扩展或重写步骤来改变算法的行为。
  - **易于维护**：算法的变更只需要在超类中修改，不需要修改子类。
- 缺点：
  - **缺乏灵活性**：模板方法的框架在超类中定义，子类不能改变算法的骨架。
  - **过多的模板方法**：如果模板方法很多，可能会导致类体系结构变得复杂。

## 注意事项

- 为了防止恶意修改，模板方法通常使用final关键字修饰，避免被子类重写。

## 示例

```java
// 抽象类
abstract class AbstractClass {
    // 基本方法
    public void doSomething() {
        System.out.println("Doing something");
    }

    // 模板方法
    public final void templateMethod() {
        stepOne();
        stepTwo();
        stepThree();
    }

    // 钩子方法
    protected void hook() {
        System.out.println("Hook method");
    }

    // 抽象方法，由子类实现
    protected abstract void stepOne();
    protected abstract void stepTwo();
    protected void stepThree() {
        System.out.println("Step three common implementation");
    }
}

// 具体类
class ConcreteClass extends AbstractClass {
    @Override
    protected void stepOne() {
        System.out.println("Step one implementation");
    }

    @Override
    protected void stepTwo() {
        System.out.println("Step two implementation");
    }
}

// 客户端代码
public class TemplatePatternDemo {
    public static void main(String[] args) {
        ConcreteClass concreteClass = new ConcreteClass();
        concreteClass.templateMethod();
    }
}
```

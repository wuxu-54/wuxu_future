# 代理模式

类型：结构型

目的：设定一个代理对象充当客户端与原对象的中介，将二者解耦同时可以在中间做额外的处理。

## 代理模式的类型

1. 远程代理（Remote Proxy）：为远程对象提供局部代表。
2. 虚拟代理（Virtual Proxy）：延迟创建开销大的对象。
3. 保护代理（Protection Proxy）：控制对原始对象的访问权限。
4. 智能引用代理（Smart Reference Proxy）：在访问对象时执行额外的动作。

## 结构

代理模式通常包含以下角色：

- **抽象主题（Subject）**:定义了真实主题和代理主题的共同接口，这样在任何使用真实主题的地方都可以使用代理主题。
- **真实主题（Real Subject）**:实现了抽象主题接口，是代理对象所代表的真实对象。客户端直接访问真实主题，但在某些情况下，可以通过代理主题来间接访问。
- **代理主题（Proxy）**:实现了抽象主题接口，并持有对真实主题的引用。代理主题通常在真实主题的基础上提供一些额外的功能，例如延迟加载、权限控制、日志记录等。
- **客户端（Client）**:使用抽象主题接口来操作真实主题或代理主题，不需要知道具体是哪一个实现类。

## 适用场景

- 当需要为其他对象提供安全代理、智能引用或防火墙时。
- 当需要控制对原始对象的访问时。
- 当需要实现延迟初始化或按需初始化时。

## 优缺点

- 优点
  - 职责分离：代理模式将访问控制与业务逻辑分离。
  - 扩展性：可以灵活地添加额外的功能或控制。
  - 智能化：可以智能地处理访问请求，如延迟加载、缓存等。
  - 降低耦合度：真实主题和客户端之间通过代理主题进行交互，降低了耦合度。
- 缺点
  - 性能开销：增加了代理层可能会影响请求的处理速度。
  - 实现复杂性：某些类型的代理模式实现起来可能较为复杂。

## 注意事项

- 与适配器模式的区别：适配器模式改变接口，而代理模式不改变接口。
- 与装饰器模式的区别：装饰器模式用于增强功能，代理模式用于控制访问。

## 示例

```java
// 主题接口
interface Subject {
    void request();
}

// 真实主题
class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("RealSubject: Handling request.");
    }
}

// 代理主题
class Proxy implements Subject {
    private RealSubject realSubject;

    public Proxy() {
        this.realSubject = null;
    }

    public void setRealSubject(RealSubject realSubject) {
        this.realSubject = realSubject;
    }

    @Override
    public void request() {
        if (realSubject == null) {
            realSubject = new RealSubject();
        }
        // 代理可以在此处添加额外的处理逻辑
        realSubject.request();
    }
}

// 客户端代码
public class ProxyPatternDemo {
    public static void main(String[] args) {
        Proxy proxy = new Proxy();
        proxy.request(); // 代理将委托给真实主题
    }
}
```

# 备忘录模式

类型：行为型

目的：在不破坏封装性的前提下，捕获一个对象的内部状态，并允许在对象之外保存和恢复这些状态。

## 结构

备忘录模式包含以下几个主要角色：

- **备忘录（Memento）**：负责存储原发器对象的内部状态。备忘录可以保持原发器的状态的一部分或全部信息。
- **发起人/原发器（Originator）**：创建一个备忘录对象，并且可以使用备忘录对象恢复自身的内部状态。原发器通常会在需要保存状态的时候创建备忘录对象，并在需要恢复状态的时候使用备忘录对象。
- **负责人（Caretaker）**：负责保存备忘录对象，但是不对备忘录对象进行操作或检查。负责人只能将备忘录传递给其他对象。

## 适用场景

- 当需要保存和恢复一个对象的历史状态时。
- 当需要提供一个状态恢复机制时，但不想让用户直接访问对象的内部状态时。

## 优缺点

- 优点：
  - **保护性**：保护了对象的内部状态，只能通过特定的接口访问。
  - **封装性**：备忘录内部状态对负责人是透明的。
  - **灵活性**：可以捕获和存储任何状态，发起人可以在任何时刻创建备忘录。
- 缺点：
  - **资源消耗**：如果保存的状态较多，可能会消耗较多的资源。
  - **管理复杂性**：负责人需要管理多个备忘录，这可能会增加管理复杂性。

## 注意事项

- 为了降低耦合度，应通过备忘录管理类间接管理备忘录对象。
- 备忘录模式应谨慎使用，避免过度消耗系统资源。
- 考虑使用原型模式结合备忘录模式，以节约内存。

## 示例

```java
// 发起人
class Originator {
    private String state;

    public void setState(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }

    // 创建备忘录
    public Memento saveStateToMemento() {
        return new Memento(state);
    }

    // 从备忘录恢复内部状态
    public void getStateFromMemento(Memento memento) {
        state = memento.getState();
    }
}

// 备忘录
class Memento {
    private final String state;

    public Memento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}

// 负责人
class Caretaker {
    private Memento memento;

    public void setMemento(Memento memento) {
        this.memento = memento;
    }

    public Memento getMemento() {
        return memento;
    }
}

// 客户端代码
public class MementoPatternDemo {
    public static void main(String[] args) {
        Originator originator = new Originator();
        originator.setState("State #1");

        Caretaker caretaker = new Caretaker();
        caretaker.setMemento(originator.saveStateToMemento());

        // 改变发起人状态
        originator.setState("State #2");

        // 恢复到先前的状态
        originator.getStateFromMemento(caretaker.getMemento());
        System.out.println("Restored State: " + originator.getState());
    }
}
```

# 访问者模式

访问者模式通过将算法包含在独立的访问者类中，来对一组对象执行操作，从而分离了算法和对象结构。通过这种方式，元素的执行算法可以随着访问者改变而改变

类型：行为型

目的：旨在将数据结构与在该数据结构上执行的操作分离，可以在不修改对象结构的情况下，为一个对象结构（如组合结构）添加新的行为。

解决问题：解决在稳定数据结构和易变操作之间的耦合问题，使得操作可以独立于数据结构变化。

## 结构

包含的几个主要角色：

- **访问者（Visitor）**：定义了访问元素的接口。
- **具体访问者（Concrete Visitor）**：实现访问者接口，提供对每个具体元素类的访问和相应操作。
- **元素（Element）**：定义了一个接受访问者的方法。
- **具体元素（Concrete Element）**：实现元素接口，提供一个accept方法，允许访问者访问并操作。
- **对象结构（Object Structure）（可选）**：定义了如何组装具体元素，如一个组合类。
- **客户端（Client）（可选）**：使用访问者模式对对象结构进行操作。

## 关键代码

- 访问者接口：包含访问不同元素的方法。
- 具体访问者：实现了访问者接口，包含对每个元素类的访问逻辑。
- 元素接口：包含一个接受访问者的方法。
- 具体元素：实现了元素接口，提供给访问者访问的入口。

## 适用场景

- 当对象结构稳定，但需要对对象结构中的对象执行多种不同的操作时。
- 当想要在不修改对象类的情况下，为对象添加新的功能时。

## 优缺点

- 优点
  - 单一职责原则：访问者模式符合单一职责原则，每个类只负责一项职责。
  - 灵活性：访问者可以独立于数据结构变化。
  - 扩展性：可以在不修改对象结构的情况下添加新的操作。
  - 分离关注点：将算法从对象结构中分离出来，有助于保持系统的清晰和模块化。
- 缺点
  - 违反迪米特原则：元素需要向访问者公开其内部信息。
  - 元素类难以变更：元素类需要维持与访问者的兼容。
  - 依赖具体类：访问者模式依赖于具体类而不是接口，违反了依赖倒置原则。
  - 修改困难：要修改现有的访问者接口或者添加新的元素类可能比较困难，因为这会牵涉到多个类的改变。
  - 对象结构与访问者耦合：对象结构需要知道访问者的存在，这增加了耦合度。

## 示例

![访问者模式类图](../images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png)

```java
// 访问者接口
interface Visitor {
    void visitConcreteElementA(ConcreteElementA element);
    void visitConcreteElementB(ConcreteElementB element);
}

// 具体访问者
class ConcreteVisitor implements Visitor {
    @Override
    public void visitConcreteElementA(ConcreteElementA element) {
        // System.out.println("Accessing ConcreteElementA with ConcreteVisitor");
    }

    @Override
    public void visitConcreteElementB(ConcreteElementB element) {
        System.out.println("Accessing ConcreteElementB with ConcreteVisitor");
    }
}

// 元素接口
interface Element {
    void accept(Visitor visitor);
}

// 具体元素类A
class ConcreteElementA implements Element {
    @Override
    public void accept(Visitor visitor) {
        visitor.visitConcreteElementA(this);
    }
    
    // 其他功能...
}

// 具体元素类B
class ConcreteElementB implements Element {
    @Override
    public void accept(Visitor visitor) {
        visitor.visitConcreteElementB(this);
    }
    
    // 其他功能...
}

// 对象结构
class ObjectStructure {
    private List<Element> elements = new ArrayList<>();

    public void addElement(Element element) {
        elements.add(element);
    }

    public void visitElements(Visitor visitor) {
        for (Element element : elements) {
            element.accept(visitor);
        }
    }
}

// 客户端代码
public class VisitorPatternDemo {
    public static void main(String[] args) {
        ObjectStructure structure = new ObjectStructure();
        structure.addElement(new ConcreteElementA());
        structure.addElement(new ConcreteElementB());

        Visitor visitor = new ConcreteVisitor();
        structure.visitElements(visitor);
    }
}
```

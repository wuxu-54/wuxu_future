# 中介者模式

定义对象间的一种中介者对象，使得这些对象不必相互显示耦合，从而使耦合松散，而且可以独立地改变它们之间的交互。
>通俗讲：假设A、B俩对象通信，此模式就是设置一个中介对象，负责A、B间通信，使二者解耦。

类型：行为型

目的：解决对象间复杂的一对多关联问题，避免对象之间的高度耦合，简化系统结构。

## 实际应用实例

- WTO：中国加入WTO后，各国通过WTO进行贸易，简化了双边关系。
- 机场调度系统：协调飞机起降、跑道使用等。
- MVC框架：控制器作为模型和视图的中介者。

## 结构

中介者模式包含以下几个主要角色：

- 中介者（Mediator）：定义了一个接口用于与各个同事对象通信，并管理各个同事对象之间的关系。通常包括一个或多个事件处理方法，用于处理各种交互事件。
- 具体中介者（Concrete Mediator）：实现了中介者接口，负责实现各个同事对象之间的通信逻辑。它会维护一个对各个同事对象的引用，并协调它们的交互。
- 同事对象（Colleague）：定义了一个接口，用于与中介者进行通信。通常包括一个发送消息的方法，以及一个接收消息的方法。
- 具体同事对象（Concrete Colleague）：实现了同事对象接口，是真正参与到交互中的对象。它会将自己的消息发送给中介者，由中介者转发给其他同事对象。

## 适用场景

- 当系统中对象之间存在复杂的引用关系时，通过引入中介者可以简化这种关系。
- 当想通过一个中间类来封装多个类之间的交互逻辑时。
- 当希望将对象间的多对多交互转换为一对多交互时。

## 优缺点

- 优点
  - 降低复杂度：将多个对象间的一对多关系转换为一对一关系。
  - 解耦：对象之间不再直接引用，通过中介者进行交互。
  - 符合迪米特原则：对象只需知道中介者，不需要知道其他对象。
- 缺点
  - 中介者复杂性：中介者可能会变得庞大和复杂，难以维护。

## 注意事项

- 避免在职责不明确或混乱的情况下使用中介者模式，这可能导致中介者承担过多职责。

## 示例

```java
// 中介者接口
interface Mediator {
    void register(String colleagueName, Colleague colleague);
    void relay(String colleagueName, String message);
}

// 具体中介者
class ConcreteMediator implements Mediator {
    private Map<String, Colleague> colleagues = new HashMap<>();

    @Override
    public void register(String colleagueName, Colleague colleague) {
        colleagues.put(colleagueName, colleague);
    }

    @Override
    public void relay(String colleagueName, String message) {
        Colleague colleague = colleagues.get(colleagueName);
        if (colleague != null) {
            colleague.receive(message);
        }
    }
}

// 同事类接口
interface Colleague {
    void send(String targetName,String message);
    void receive(String message);
}

// 具体同事类A
public class ConcreteColleagueA implements Colleague {
    private Mediator mediator;
    private String name;
    public ConcreteColleagueA(Mediator mediator,String name) {
     this.mediator = mediator;
     this.name = name;
     this.mediator.register(name, this);
    }
    @Override
    public void send(String targetName,String message) {
       this.mediator.relay(targetName, message);
    }

    @Override
    public void receive(String message) {
        System.out.println(name + " received: " + message);
    }
}


// 具体同事类B
public class ConcreteColleagueB implements Colleague {
    private Mediator mediator;
    private String name;
    public ConcreteColleagueB(Mediator mediator,String name) {
     this.mediator = mediator;
     this.name = name;
     this.mediator.register(name, this);
    }
    @Override
    public void send(String targetName,String message) {
       this.mediator.relay(targetName, message);
    }

    @Override
    public void receive(String message) {
        System.out.println(name + " received: " + message);
    }
}


// 客户端代码
public class SimpleMain {
    public static void main(String[] args) {
        Mediator mediator = new ConcreteMediator();
        Colleague colleagueA = new ConcreteColleagueA(mediator,"A");
        Colleague colleagueB = new ConcreteColleagueB(mediator,"B");

        colleagueA.send("B","hi,B!");//A向B发送消息
        colleagueB.send("A","hello,A!");//B向A发送消息
    }
}

```

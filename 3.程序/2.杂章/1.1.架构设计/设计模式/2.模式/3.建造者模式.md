# 建造者模式

类型：创建型

目的：将复杂对象的创建与表示过程分离，创建出具有不同表示形式的对象。如一个类会根据不同参数创建出不同能力的对象实例，此时可以使用建造者模式。

## 结构

建造者模式包含以下几个主要角色：

- 产品（Product）：要构建的复杂对象。产品类通常包含多个部分或属性。
- 抽象建造者（Builder）：定义了构建产品的抽象接口，包括构建产品的各个部分的方法。
- 具体建造者（Concrete Builder）：实现抽象建造者接口，具体确定如何构建产品的各个部分，并负责返回最终构建的产品。
- 指导者（Director）：负责调用建造者的方法来构建产品，指导者并不了解具体的构建过程，只关心产品的构建顺序和方式。

## 优缺点

- 优点：
  - 分离构建过程和表示，使得构建过程更加灵活，可以构建不同的表示。
  - 可以更好地控制构建过程，隐藏具体构建细节。
  - 代码复用性高，可以在不同的构建过程中重复使用相同的建造者。
- 缺点：
  - 如果产品的属性较少，建造者模式可能会导致代码冗余。
  - 增加了系统的类和对象数量。

## 使用场景

- 需要生成的对象具有复杂的内部结构。
- 需要生成的对象内部属性相互依赖。

## 注意事项

与工厂模式的区别是：建造者模式更加关注于零件装配的顺序。
>解释：从目的可知，建造者模式适用于处理对象创建时变化部分装配。

## 简单示例1

```java
// 产品类
class Product {
    private List<String> parts = new ArrayList<>();

    public void addPart(String part) {
        parts.add(part);
    }

    @Override
    public String toString() {
        return "Product{" +
               "parts=" + parts +
               '}';
    }
}

// 抽象建造者
interface Builder {
    void buildPartOne();
    void buildPartTwo();
    Product getResult();
}

// 具体建造者
class ConcreteBuilder implements Builder {
    private Product product = new Product();

    @Override
    public void buildPartOne() {
        product.addPart("Part One");
    }

    @Override
    public void buildPartTwo() {
        product.addPart("Part Two");
    }

    @Override
    public Product getResult() {
        return product;
    }
}

// 指挥者
class Director {
    public Product construct(Builder builder) {
        builder.buildPartOne();
        builder.buildPartTwo();
        return builder.getResult();
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) {
        Builder builder = new ConcreteBuilder();
        Director director = new Director();
        Product product = director.construct(builder);
        System.out.println(product);
    }
}
```

在这个例子中，Product是最终要构建的复杂对象，Builder是一个接口，定义了构建产品的方法，ConcreteBuilder实现了Builder接口，具体实现了构建过程，Director负责使用Builder接口来构建产品。

## 简单示例2

采用链式调用，移除【抽象建造者和指挥者】两个角色，这是个更为常用的建造者模式示例。

```java
public class Computer {
    private String CPU;
    private String Disk;
    private String Memory;
    private String GPU;
    private String MainBoard;

    @Override
    public String toString() {
        return "Computer{" +
                "CPU='" + CPU + '\'' +
                ", Disk='" + Disk + '\'' +
                ", Memory='" + Memory + '\'' +
                ", GPU='" + GPU + '\'' +
                ", MainBoard='" + MainBoard + '\'' +
                '}';
    }

    private Computer(ComputerBuilder cb){
        this.CPU= cb.CPU;
        this.Disk= cb.Disk;
        this.Memory= cb.Memory;
        this.GPU= cb.GPU;
        this.MainBoard= cb.MainBoard;
    }

    public static class ComputerBuilder{
        private String CPU;
        private String Disk;
        private String Memory;
        private String GPU;
        private String MainBoard;

        public ComputerBuilder setCPU(String CPU) {
            this.CPU = CPU;
            return this;
        }

        public ComputerBuilder setDisk(String disk) {
            Disk = disk;
            return this;
        }

        public ComputerBuilder setMemory(String memory) {
            Memory = memory;
            return this;
        }

        public ComputerBuilder setGPU(String GPU) {
            this.GPU = GPU;
            return this;
        }

        public ComputerBuilder setMainBoard(String mainBoard) {
            MainBoard = mainBoard;
            return this;
        }
        public Computer createComputer(){
            return new Computer(this);
        }
    }
}
```

# 外观模式

类型：结构型

目的：隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口，客户端代码就可以通过这个简化的接口与子系统交互，而不需要了解子系统内部的复杂性

## 结构

外观模式通常包含以下角色：

- **外观（Facade）**:提供一个简化的接口，封装了系统的复杂性。外观模式的客户端通过与外观对象交互，而无需直接与系统的各个组件打交道。
- **子系统（Subsystem）**:由多个相互关联的类组成，负责系统的具体功能。外观对象通过调用这些子系统来完成客户端的请求。
- **客户端（Client）**:使用外观对象来与系统交互，而不需要了解系统内部的具体实现。

## 适用场景

- 当需要向复杂系统中的一组接口提供一个简化的接口时。
- 当需要客户端与复杂系统的耦合度降低时。
- 当需要封装复杂的系统，便于子系统的独立开发和维护时。

## 优缺点

- 优点：
  - **简化接口**：为复杂的子系统提供了一个简化的接口。
  - **解耦**：客户端与子系统之间解耦，客户端不需要了解子系统内部的复杂逻辑。
  - **易于维护**：子系统的实现可以独立于客户端进行变化，只要接口保持不变。

- 缺点：
  - **扩展性问题**：如果外观类的方法需要修改，可能会影响到客户端。
  - **降低透明度**：客户端可能不清楚外观类内部的实现细节。
  - **违反开闭原则**：对子系统的修改可能需要对外观类进行相应的修改。

## 注意事项

- 外观模式适用于层次化结构，可以为每一层提供一个清晰的入口。
- 避免过度使用外观模式，以免隐藏过多的细节，导致维护困难。

## 示例

```java
// 子系统接口
interface SubSystem {
    void operation();
}

// 具体子系统A
class SubSystemA implements SubSystem {
    @Override
    public void operation() {
        System.out.println("SubSystemA operation");
    }
}

// 具体子系统B
class SubSystemB implements SubSystem {
    @Override
    public void operation() {
        System.out.println("SubSystemB operation");
    }
}

// 外观
class Facade {
    private SubSystem subSystemA;
    private SubSystem subSystemB;

    public Facade() {
        subSystemA = new SubSystemA();
        subSystemB = new SubSystemB();
    }

    public void operation() {
        subSystemA.operation();
        subSystemB.operation();
    }
}

// 客户端代码
public class FacadePatternDemo {
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.operation();
    }
}
```

# 单例模式

类型：创建型

目的：

1. 确保一个类只有一个实例，提供一个全局访问点来访问实例
2. 解决频繁创建和销毁全局使用的类实例的问题。
3. 可以进行资源数据全局共享

---

## 简介

单例模式是一种常用的软件设计模式，其核心思想是确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。单例模式在很多场景下都非常有用，比如配置管理器、连接池、线程池等。

单例模式的实现通常有以下几种方式：

1. **懒汉式（线程不安全）**：
   - 这种方式在第一次调用`getInstance`方法时才会创建实例。
   - 由于没有进行线程同步，所以不是线程安全的。

   ```java
   public class Singleton {
       private static Singleton instance;

       private Singleton() {}

       public static Singleton getInstance() {
           if (instance == null) {
               instance = new Singleton();
           }
           return instance;
       }
   }
   ```

2. **懒汉式（线程安全）**：
   - 在`getInstance`方法中使用`synchronized`关键字来确保线程安全。
   - 但是每次调用`getInstance`时都会进行同步，效率较低。

   ```java
   public class Singleton {
       private static Singleton instance;

       private Singleton() {}

       public static synchronized Singleton getInstance() {
           if (instance == null) {
               instance = new Singleton();
           }
           return instance;
       }
   }
   ```

3. **饿汉式**：
   - 这种方式在类加载时就创建实例，是线程安全的。
   - 但是不管是否需要，类加载时就完成实例化，可能导致资源浪费。

   ```java
   public class Singleton {
       private static final Singleton instance = new Singleton();

       private Singleton() {}

       public static Singleton getInstance() {
           return instance;
       }
   }
   ```

4. **双重校验锁（Double-Check Locking）**：
   - 这种方式结合了懒汉式和饿汉式的优点，既实现了延迟加载，又保证了线程安全。
   - 使用了两次检查（double-check）来确保线程安全。

   ```java
   public class Singleton {
       private static volatile Singleton instance;

       private Singleton() {}

       public static Singleton getInstance() {
           if (instance == null) {
               synchronized (Singleton.class) {
                   if (instance == null) {
                       instance = new Singleton();
                   }
               }
           }
           return instance;
       }
   }
   ```

5. **静态内部类**：
   - 这种方式利用了Java的类加载机制来实现单例模式。
   - 静态内部类只有在第一次使用时才会加载，并且Java保证了一个类的加载过程是线程安全的。

   ```java
   public class Singleton {
       private Singleton() {}

       private static class SingletonHolder {
           private static final Singleton INSTANCE = new Singleton();
       }

       public static Singleton getInstance() {
           return SingletonHolder.INSTANCE;
       }
   }
   ```

6. **枚举**：
   - 使用枚举实现单例模式是最简单的方法，并且也是线程安全的。
   - 枚举类型本身是单例的，每个枚举常量都是唯一的。

   ```java
   public enum Singleton {
       INSTANCE;

       public void someMethod() {
           // 实现方法
       }
   }
   ```

每种实现方式都有其适用场景和优缺点，开发者可以根据具体需求选择合适的实现方式。

---

## 结构

单例模式包含以下几个主要角色：

- 单例类：包含单例实例的类，通常将构造函数声明为私有。
- 静态成员变量：用于存储单例实例的静态成员变量。
- 获取实例方法：静态方法，用于获取单例实例。
- 私有构造函数：防止外部直接实例化单例类。
- 线程安全处理：确保在多线程环境下单例实例的创建是安全的。

## 优缺点

- 优点：
  - 内存中只有一个实例，减少内存开销，尤其是频繁创建和销毁实例时（如管理学院首页页面缓存）。
  - 避免资源的多重占用（如写文件操作）。
- 缺点：
  - 没有接口，不能继承。
  - 与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心实例化方式。

## 使用场景

- 生成唯一序列号。
- WEB 中的计数器，避免每次刷新都在数据库中增加计数，先缓存起来。
- 创建消耗资源过多的对象，如 I/O 与数据库连接等。

## 注意事项

- 线程安全：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成实例被多次创建。
- 延迟初始化：实例在第一次调用 getInstance() 方法时创建。
- 序列化和反序列化：重写 readResolve 方法以确保反序列化时不会创建新的实例。
- 反射攻击：在构造函数中添加防护代码，防止通过反射创建新实例。
- 类加载器问题：注意复杂类加载环境可能导致的多个实例问题。

# 观察者模式

创建了对象间的一种一对多的依赖关系，当一个对象状态改变时，所有依赖于它的对象都会得到通知并自动更新。

类型：行为型

目的：观察者模式解决的是一个对象状态改变时，如何自动通知其他依赖对象的问题，同时保持对象间的低耦合和高协作性。

## 结构

- **主题（Subject）**：也称为被观察者或可观察者，它是具有状态的对象，并维护着一个观察者列表。主题提供了添加、删除和通知观察者的方法。
- **观察者（Observer）**：观察者是接收主题通知的对象。观察者需要实现一个更新方法，当收到主题的通知时，调用该方法进行更新操作。
- **具体主题（Concrete Subject）**：具体主题是主题的具体实现类。它维护着观察者列表，并在状态发生改变时通知观察者。
- **具体观察者（Concrete Observer）**：具体观察者是观察者的具体实现类。它实现了更新方法，定义了在收到主题通知时需要执行的具体操作。

## 适用场景

- 当一个对象的改变需要同时改变其他对象时，且其他对象需要实时更新。
- 当对象间的耦合关系是多变的，不希望它们之间紧密耦合时。

## 优缺点

- 优点：
  - **抽象耦合**：观察者和主题之间是抽象耦合的。
  - **触发机制**：建立了一套状态改变时的触发和通知机制。
- 缺点：
  - **性能问题**：如果观察者众多，通知过程可能耗时。
  - **循环依赖**：可能导致循环调用和系统崩溃。
  - **顺序问题**：观察者接收通知的顺序是不确定的。
  - **缺乏变化详情**：观察者不知道主题如何变化，只知道变化发生。

## 注意事项

- 避免循环引用：注意观察者和主题之间的依赖关系，避免循环引用。
- 异步执行：考虑使用异步通知避免单点故障导致整个系统卡壳。

## 示例

```java
// 观察者接口
interface Observer {
    void update(String message);
}

// 具体观察者
class ConcreteObserver implements Observer {
    private String name;

    public ConcreteObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " received message: " + message);
    }
}

// 主题接口
interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers();
}

// 具体主题
class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String state;

    public void registerObserver(Observer o) {
        observers.add(o);
    }

    public void removeObserver(Observer o) {
        observers.remove(o);
    }

    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(state);
        }
    }

    public void setState(String state) {
        this.state = state;
        notifyObservers();
    }

    public String getState() {
        return state;
    }
}

// 客户端代码
public class ObserverPatternDemo {
    public static void main(String[] args) {
        ConcreteSubject subject = new ConcreteSubject();

        Observer observer1 = new ConcreteObserver("Observer 1");
        Observer observer2 = new ConcreteObserver("Observer 2");

        subject.registerObserver(observer1);
        subject.registerObserver(observer2);

        subject.setState("New State"); // 通知所有观察者
    }
}
```

# 工厂模式

类型：创建型

目的：创建对象，封装对象创建过程，将创建对象代码与使用对象代码分离，提高代码灵活性和可维护性。

注意：复杂对象的创建适用工厂模式，简单的对象创建如直接new，无需使用工厂模式，这样反而会增加不必要的工厂类。

---

## 工厂模式类型

工厂模式分为以下类型：

### 1.简单工厂模式

* 通过一个单一的工厂类来创建所有的产品实例。
* 缺点是当产品类增加时，工厂类需要修改，违反了开闭原则。

### 2.工厂方法模式

在简单工厂基础上，增加了接口，通过创建不同的工厂类实现此接口，使用不同的工厂创建不同的对象。对比简单工厂模式，这个模式符合开闭原则，避免每次增加新对象类型就修改Factory。

* 定义了一个创建对象的接口，让子类决定实例化哪一个类。
* 工厂方法让类的实例化推迟到其子类。

### 3.抽象工厂模式

抽象工厂模式，是针对**工厂类的创建**增加了一个工厂的接口，可以动态创建不同的工厂类。

* 提供了一个接口，用于创建相关或依赖对象的家族，而不需指定具体类。
* 允许系统在不指定具体类的情况下，使用一个或多个类族。

---

## 结构

工厂模式包含以下几个主要角色：

* 抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。
* 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。
* 抽象工厂（Abstract Factory）：声明了创建产品的抽象方法，可以是接口或抽象类。它可以有多个方法用于创建不同类型的产品。
* 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责实际创建具体产品的对象。

---

## 工厂模式优缺点

* 优点：
  * 封装性：隐藏了对象创建的细节，调用者只需要关心工厂类提供的接口。
  * 扩展性：新增产品时，只需增加相应的具体产品类和具体工厂类，无需修改已有代码。
  * 代码复用：通过使用工厂方法，可以重复使用对象创建的代码。
  * 解耦：客户端不需要知道具体的类是如何实现的，只需要知道工厂接口。
* 缺点：
  * 增加系统复杂度：每增加一个产品类别，就需要增加一个具体类和产品类，增加了系统的复杂度。
  * 增加系统的抽象性：在系统对象结构更加复杂时，理解系统的整体结构将更加困难。

## 工厂模式使用场景

* 当创建逻辑复杂时，可以通过工厂模式简化对象的创建过程。
* 当类的条件编译较多时，可以通过工厂模式来降低条件编译的复杂度。
* 当需要通过子类来指定创建的对象时，可以使用工厂方法模式。

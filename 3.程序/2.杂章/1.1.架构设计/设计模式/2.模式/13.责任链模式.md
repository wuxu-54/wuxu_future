# 责任链模式

类型：行为型

目的：为请求创建了一个接收者对象的链，允许将请求沿着接收者链传递，直到请求被处理为止，对请求的发送者和接收者进行解耦。

## 结构

责任链模式通常定义以下角色：

- **Handler（处理器接口）**：定义一个接口，用于处理请求。
- **ConcreteHandler（具体处理器）**：实现处理器接口，负责处理它所负责的请求，并决定是否将请求转发给链中的下一个处理器。
- **Client（客户端）**：创建处理链，并发送请求。

## 实现方式

- 定义处理者接口：所有处理者必须实现同一个接口。
- 创建具体处理者：实现接口的具体类，包含请求处理逻辑和指向链中下一个处理者的引用。

## 适用场景

- 当有多个对象可以处理请求，且具体由哪个对象处理由运行时决定时。
- 当需要向多个对象中的一个提交请求，而不想明确指定接收者时。
- 当你想将请求的处理者和请求的发送者解耦时。

## 优缺点

- 优点：
  - 降低耦合度：请求发送者和接收者之间解耦。
  - 动态性：可以动态地添加或删除责任链中的处理器。
  - 多样性：可以灵活地处理多种类型的请求。
- 缺点：
  - 性能问题：如果责任链过长，可能会影响性能。
  - 处理不确定性：请求可能无法被任何处理器处理。
  - 难以观察：运行时特征不明显，可能妨碍除错。

## 示例

```java
// 处理器接口
interface Handler {
    void handleRequest(Request request);
}

// 具体处理器A
class ConcreteHandlerA implements Handler {
    private Handler nextHandler;

    public ConcreteHandlerA(Handler nextHandler) {
        this.nextHandler = nextHandler;
    }

    @Override
    public void handleRequest(Request request) {
        if (nextHandler != null) {
            nextHandler.handleRequest(request);
        } else {
            System.out.println("ConcreteHandlerA: 处理请求");
        }
    }
}

// 具体处理器B
class ConcreteHandlerB implements Handler {
    private Handler nextHandler;

    public ConcreteHandlerB(Handler nextHandler) {
        this.nextHandler = nextHandler;
    }

    @Override
    public void handleRequest(Request request) {
        if (nextHandler != null) {
            nextHandler.handleRequest(request);
        } else {
            System.out.println("ConcreteHandlerB: 处理请求");
        }
    }
}

// 请求
class Request {
    // 请求详情
}

// 客户端代码
public class ChainOfResponsibilityPatternDemo {
    public static void main(String[] args) {
        Handler handlerA = new ConcreteHandlerA(null);
        Handler handlerB = new ConcreteHandlerB(handlerA);

        handlerB.handleRequest(new Request());
    }
}
```

# 迭代器模式

迭代器模式通过分离集合对象的遍历行为，使得外部代码可以透明地访问集合内部数据，同时不暴露集合的内部结构。

类型：行为型

目的：顺序访问集合中的元素而不需要暴露其内部结构，通常提供一个迭代器对象。

## 结构

迭代器模式通常定义以下几种角色：

- 迭代器接口（Iterator）：定义了迭代集合元素的接口，通常包含hasNext()和next()方法。
- 具体迭代器（Concrete Iterator）：实现迭代器接口，记录遍历集合的状态。
- 聚合接口（Aggregate）：定义了一个方法用于获取迭代器对象，通常命名为getIterator()。
- 具体聚合（ConcreteAggregate）：实现聚合接口，返回一个具体迭代器的实例，用于遍历集合。
- 客户端（Client）：使用聚合对象和迭代器来访问集合。

## 实现方式

- 定义迭代器接口：包含hasNext()和next()等方法，用于遍历元素。
- 创建具体迭代器：实现迭代器接口，定义如何遍历特定的聚合对象。
- 聚合类：定义一个接口用于返回一个迭代器对象。

## 适用场景

- 当需要访问一个聚合对象的内部结构，而又不想暴露其内部结构时。
- 当需要提供多种方式遍历聚合对象时。
- 当需要在迭代过程中访问聚合对象的元素，而不破坏聚合对象的封装性时。

## 优缺点

- 优点
  - 支持多种遍历方式：不同的迭代器可以定义不同的遍历方式。
  - 简化聚合类：聚合类不需要关心遍历逻辑。
  - 多遍历支持：可以同时对同一个聚合对象进行多次遍历。
  - 扩展性：增加新的聚合类和迭代器类都很方便，无需修改现有代码。
- 缺点
  - 系统复杂性：每增加一个聚合类，就需要增加一个对应的迭代器类，增加了类的数量。

## 示例

```java
// 聚合接口
interface Aggregate {
    Iterator getIterator();
}

// 具体聚合
class ConcreteAggregate implements Aggregate {
    private List items = new ArrayList();

    public void addItem(Object item) {
        items.add(item);
    }

    @Override
    public Iterator getIterator() {
        return new ConcreteIterator(items);
    }
}

// 迭代器接口
interface Iterator {
    boolean hasNext();
    Object next();
}

// 具体迭代器
class ConcreteIterator implements Iterator {
    private ListIterator iterator;

    public ConcreteIterator(List list) {
        this.iterator = list.listIterator();
    }

    @Override
    public boolean hasNext() {
        return iterator.hasNext();
    }

    @Override
    public Object next() {
        return iterator.next();
    }
}

// 客户端代码
public class IteratorPatternDemo {
    public static void main(String[] args) {
        Aggregate aggregate = new ConcreteAggregate();
        aggregate.addItem("Item1");
        aggregate.addItem("Item2");
        aggregate.addItem("Item3");

        Iterator iterator = aggregate.getIterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

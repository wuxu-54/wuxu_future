# 服务定位器模式

服务定位器模式（Service Locator Pattern）用于在应用程序中实现依赖注入（DI）和查找服务或资源的过程。这种模式提供了一个中心化的服务访问点，客户端通过服务定位器来请求需要的服务，而不是直接创建或查找服务实例。

>个人理解：其实就是享元模式，只不过基于整个系统来设计，为了避免频繁创建服务。

类型：J2EE设计模式

目的：用于在应用程序中提供一个中心化的服务访问点，用以获取各种服务或资源。

解决问题：解决在应用程序中需要访问各种服务或资源时，避免硬编码服务访问逻辑的问题。

## 实现方式

- 服务定位器接口：定义获取服务的方法。
- 服务定位器实现：实现服务定位器接口，封装服务的查找和访问逻辑。
- 服务接口：定义服务的接口或契约。
- 具体服务：实现服务接口，提供具体的服务功能。

## 主要特点

- **中心化服务访问**：服务定位器作为中心化的服务访问点，所有服务请求都通过它进行。
- **依赖注入**：通过服务定位器实现依赖注入，降低组件之间的耦合度。
- **服务抽象**：服务定位器提供了一个抽象层，隐藏了服务的具体实现细节。
- **服务发现**：服务定位器负责查找和实例化服务，客户端不需要知道服务的具体位置。
- **配置灵活性**：通过配置文件或注册机制，可以灵活地更改服务的实现，而不影响客户端代码。

## 结构

包含的几个主要角色：

- **服务定位器接口（Service Locator Interface）**：定义获取服务的方法。
- **服务定位器实现（Service Locator Implementation）**：实现服务定位器接口，封装服务的查找和访问逻辑。
- **服务接口（Service Interface）**：定义服务的抽象表示。
- **具体服务（Concrete Service）**：实现服务接口，提供具体的服务功能。
- **客户端（Client）**：使用服务定位器来访问所需的服务。

## 适用场景

- 当需要集中管理和访问多个服务或资源时。
- 当希望降低组件之间的耦合度，实现依赖注入时。
- 当需要灵活更换服务实现，而不影响客户端代码时。

## 优缺点

- 优点
  - 解耦服务访问：将服务访问逻辑与使用服务的业务逻辑分离。
  - 集中管理：服务的访问点集中管理，便于维护和扩展。
  - 灵活性：易于添加、修改或替换服务。
- 缺点
  - 性能问题：服务定位器可能引入性能开销，特别是在每次服务请求都进行查找时。
  - 过度使用：可能导致设计模式的滥用，从而隐藏系统结构。

## 注意事项

- 避免过度依赖服务定位器，因为它可能掩盖系统的依赖关系，使得调试和优化变得困难。

## 说明

服务定位器模式是一种简单有效的依赖注入方式，尤其适用于小型项目或项目的初期阶段。然而，在大型项目中，可能需要更强大的依赖注入框架来管理复杂的依赖关系。

## 示例

```java
// 服务接口
interface Service {
    void doWork();
}

// 具体服务实现
class ConcreteService implements Service {
    @Override
    public void doWork() {
        // 实现服务逻辑
    }
}

// 服务定位器
class ServiceLocator {
    private static Service service;

    public static Service getService() {
        if (service == null) {
            // 根据配置或逻辑创建服务实例
            service = new ConcreteService();
        }
        return service;
    }
}

// 客户端代码
class Client {
    public void doTask() {
        Service service = ServiceLocator.getService();
        service.doWork();
    }
}

// 应用程序入口
public class ServiceLocatorPatternDemo {
    public static void main(String[] args) {
        Client client = new Client();
        client.doTask();
    }
}
```

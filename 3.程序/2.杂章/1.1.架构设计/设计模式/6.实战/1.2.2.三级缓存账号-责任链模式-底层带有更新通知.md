# 支持远程数据变化回调的三级缓存设计方案

为了支持远程数据变化的回调通知，同时保持三级缓存结构，我将设计一个结合观察者模式、责任链模式和仓储模式的解决方案。这个方案能让上层感知数据变化，同时保持缓存一致性。

## 设计方案概述

1. **核心模式**：
   - 观察者模式：用于数据变化通知
   - 责任链模式：维持三级缓存结构
   - 仓储模式：统一数据访问接口

2. **新增组件**：
   - `DataChangeObserver`：数据变化观察者接口
   - `DataChangePublisher`：数据变化发布中心
   - `PushService`：处理远程推送服务

3. **数据流优化**：
   - 远程数据变化 → 推送服务 → 发布中心 → 通知观察者 → 更新各级缓存

## 完整实现方案

```kotlin
// 1. 数据模型
data class Account(
    val id: String,
    val name: String,
    val email: String,
    val lastUpdated: Long = System.currentTimeMillis()
)

// 2. 数据变化观察者接口
interface DataChangeObserver<T> {
    fun onDataChanged(newData: T)
    fun onDataDeleted(id: String)
}

// 3. 数据变化发布中心（单例）
object DataChangePublisher {
    private val observers = mutableMapOf<String, MutableList<DataChangeObserver<Account>>>()

    fun registerObserver(accountId: String, observer: DataChangeObserver<Account>) {
        val list = observers.getOrPut(accountId) { mutableListOf() }
        if (!list.contains(observer)) {
            list.add(observer)
        }
    }

    fun unregisterObserver(accountId: String, observer: DataChangeObserver<Account>) {
        observers[accountId]?.remove(observer)
    }

    fun notifyDataChanged(account: Account) {
        observers[account.id]?.forEach { it.onDataChanged(account) }
    }

    fun notifyDataDeleted(accountId: String) {
        observers[accountId]?.forEach { it.onDataDeleted(accountId) }
    }
}

// 4. 数据源接口（增强版）
interface AccountDataSource : DataChangeObserver<Account> {
    fun getAccount(accountId: String, callback: (Account?) -> Unit)
    fun saveAccount(account: Account)
    fun deleteAccount(accountId: String)
}

// 5. 实现三级缓存数据源（均实现数据变化观察）

// 内存缓存
class MemoryDataSource : AccountDataSource {
    private val cache = LruCache<String, Account>(100)
    
    override fun getAccount(accountId: String, callback: (Account?) -> Unit) {
        callback(cache.get(accountId))
    }
    
    override fun saveAccount(account: Account) {
        cache.put(account.id, account)
    }
    
    override fun deleteAccount(accountId: String) {
        cache.remove(accountId)
    }
    
    // 实现观察者接口
    override fun onDataChanged(newData: Account) {
        saveAccount(newData)
    }
    
    override fun onDataDeleted(id: String) {
        deleteAccount(id)
    }
}

// 磁盘缓存
class DiskDataSource(context: Context) : AccountDataSource {
    private val dao: AccountDao by lazy { 
        AccountDatabase.getInstance(context).accountDao() 
    }
    
    override fun getAccount(accountId: String, callback: (Account?) -> Unit) {
        CoroutineScope(Dispatchers.IO).launch {
            callback(dao.getAccountById(accountId))
        }
    }
    
    override fun saveAccount(account: Account) {
        CoroutineScope(Dispatchers.IO).launch {
            dao.insertAccount(account)
        }
    }
    
    override fun deleteAccount(accountId: String) {
        CoroutineScope(Dispatchers.IO).launch {
            dao.deleteAccount(accountId)
        }
    }
    
    // 实现观察者接口
    override fun onDataChanged(newData: Account) {
        saveAccount(newData)
    }
    
    override fun onDataDeleted(id: String) {
        deleteAccount(id)
    }
}

// 网络数据源（带变化推送支持）
class NetworkDataSource : AccountDataSource {
    private val pushService = PushService()
    
    init {
        // 注册推送服务回调
        pushService.registerCallback(object : PushService.PushCallback {
            override fun onAccountChanged(account: Account) {
                // 通知发布中心
                DataChangePublisher.notifyDataChanged(account)
            }
            
            override fun onAccountDeleted(accountId: String) {
                DataChangePublisher.notifyDataDeleted(accountId)
            }
        })
    }
    
    override fun getAccount(accountId: String, callback: (Account?) -> Unit) {
        RetrofitClient.accountService.getAccount(accountId).enqueue(
            object : Callback<Account> {
                override fun onResponse(call: Call<Account>, response: Response<Account>) {
                    response.body()?.let(callback)
                }
                override fun onFailure(call: Call<Account>, t: Throwable) {
                    callback(null)
                }
            }
        )
    }
    
    override fun saveAccount(account: Account) {
        // 网络层通常不实现本地保存
    }
    
    override fun deleteAccount(accountId: String) {
        // 网络层通常不实现本地删除
    }
    
    // 实现观察者接口（接收来自服务器的推送）
    override fun onDataChanged(newData: Account) {
        // 当远程数据变化时，更新本地缓存
        // 实际处理在PushService回调中
    }
    
    override fun onDataDeleted(id: String) {
        // 当远程数据删除时，更新本地缓存
        // 实际处理在PushService回调中
    }
    
    // 推送服务模拟
    inner class PushService {
        interface PushCallback {
            fun onAccountChanged(account: Account)
            fun onAccountDeleted(accountId: String)
        }
        
        private var callback: PushCallback? = null
        
        fun registerCallback(callback: PushCallback) {
            this.callback = callback
            // 模拟建立长连接
            startWebSocketConnection()
        }
        
        private fun startWebSocketConnection() {
            // 这里实际实现WebSocket连接
            // 当收到服务器推送时，调用callback
        }
        
        // 模拟服务器推送
        fun simulatePushChange(account: Account) {
            callback?.onAccountChanged(account)
        }
        
        fun simulatePushDelete(accountId: String) {
            callback?.onAccountDeleted(accountId)
        }
    }
}

// 6. 增强版仓储（支持数据变化通知）
class AccountRepository(
    private val memorySource: AccountDataSource,
    private val diskSource: AccountDataSource,
    private val networkSource: NetworkDataSource
) : DataChangeObserver<Account> {
    
    init {
        // 注册数据源为观察者
        DataChangePublisher.registerObserver("global", memorySource)
        DataChangePublisher.registerObserver("global", diskSource)
        DataChangePublisher.registerObserver("global", networkSource)
    }
    
    // 获取账号数据（三级缓存）
    suspend fun getAccount(accountId: String): Account? {
        // 1. 检查内存
        var account: Account? = memorySource.getAccountSync(accountId)
        if (account != null) return account
        
        // 2. 检查磁盘
        account = diskSource.getAccountSync(accountId)
        if (account != null) {
            memorySource.saveAccount(account) // 回填内存
            return account
        }
        
        // 3. 请求网络
        account = networkSource.getAccountSync(accountId)
        if (account != null) {
            memorySource.saveAccount(account) // 更新内存
            diskSource.saveAccount(account)    // 更新磁盘
            return account
        }
        
        return null
    }
    
    // 注册UI层观察者
    fun registerUiObserver(accountId: String, observer: DataChangeObserver<Account>) {
        DataChangePublisher.registerObserver(accountId, observer)
    }
    
    // 注销UI层观察者
    fun unregisterUiObserver(accountId: String, observer: DataChangeObserver<Account>) {
        DataChangePublisher.unregisterObserver(accountId, observer)
    }
    
    // 实现观察者接口（用于接收系统级通知）
    override fun onDataChanged(newData: Account) {
        // 这里可以处理全局数据变化逻辑
    }
    
    override fun onDataDeleted(id: String) {
        // 这里可以处理全局数据删除逻辑
    }
    
    // 扩展方法：同步获取账号（仅供内部使用）
    private suspend fun AccountDataSource.getAccountSync(accountId: String): Account? {
        return suspendCoroutine { cont ->
            getAccount(accountId) { account ->
                cont.resume(account)
            }
        }
    }
}

// 7. ViewModel中使用
class AccountViewModel : ViewModel(), DataChangeObserver<Account> {
    private val repo = AccountRepository(
        MemoryDataSource(),
        DiskDataSource(context),
        NetworkDataSource()
    )
    
    private val accountId = "user123"
    
    // UI状态
    val accountData = MutableLiveData<Account?>()
    val loadingState = MutableLiveData<Boolean>()
    val errorMessage = MutableLiveData<String?>()
    
    init {
        // 注册为数据变化观察者
        repo.registerUiObserver(accountId, this)
        
        // 初始加载数据
        loadAccount()
    }
    
    fun loadAccount() {
        loadingState.value = true
        viewModelScope.launch {
            try {
                val account = repo.getAccount(accountId)
                accountData.value = account
                errorMessage.value = null
            } catch (e: Exception) {
                errorMessage.value = "加载账号失败: ${e.message}"
            } finally {
                loadingState.value = false
            }
        }
    }
    
    // 实现数据变化回调
    override fun onDataChanged(newData: Account) {
        // 当数据变化时更新UI
        accountData.postValue(newData)
    }
    
    override fun onDataDeleted(id: String) {
        if (id == accountId) {
            accountData.postValue(null)
            errorMessage.postValue("账号已被删除")
        }
    }
    
    override fun onCleared() {
        super.onCleared()
        // 清理时注销观察者
        repo.unregisterUiObserver(accountId, this)
    }
}

// 8. Activity/Fragment中使用
class AccountActivity : AppCompatActivity() {
    private val viewModel: AccountViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_account)
        
        // 观察LiveData
        viewModel.accountData.observe(this) { account ->
            account?.let { updateUI(it) }
        }
        
        viewModel.loadingState.observe(this) { isLoading ->
            progressBar.visibility = if (isLoading) View.VISIBLE else View.GONE
        }
        
        viewModel.errorMessage.observe(this) { error ->
            error?.let { showToast(it) }
        }
    }
    
    private fun updateUI(account: Account) {
        // 更新UI显示账号信息
        nameTextView.text = account.name
        emailTextView.text = account.email
        lastUpdatedTextView.text = "最后更新: ${formatTime(account.lastUpdated)}"
    }
    
    // 模拟远程数据变化（测试用）
    fun simulateRemoteChange(view: View) {
        val newAccount = Account(
            id = "user123",
            name = "新名称 ${Random.nextInt(100)}",
            email = "new${Random.nextInt(100)}@example.com"
        )
        (viewModel.repo.networkSource as NetworkDataSource)
            .PushService()
            .simulatePushChange(newAccount)
    }
}
```

## 关键设计说明

1. **数据变化通知机制**：
   - 通过`DataChangePublisher`实现发布-订阅模式
   - 支持细粒度的账号ID级通知
   - 缓存层自动更新：当收到变化通知时，内存和磁盘缓存会自动更新

2. **推送服务集成**：
   - `NetworkDataSource`内置`PushService`处理远程推送
   - 支持WebSocket或长轮询等实时通信技术
   - 推送事件触发缓存更新和UI刷新

3. **生命周期管理**：
   - ViewModel中注册/注销观察者
   - 避免内存泄漏
   - 确保UI只在活跃状态下更新

4. **缓存一致性**：
   - 远程数据变化时，自动更新所有层级缓存
   - 数据删除时清除所有相关缓存
   - 保证后续读取获取最新数据

5. **UI更新流程**：

   ```mermaid
   sequenceDiagram
       participant Server
       participant PushService
       participant DataChangePublisher
       participant MemoryCache
       participant DiskCache
       participant ViewModel
       participant UI
       
       Server->>PushService: 数据变化推送
       PushService->>DataChangePublisher: 通知变化
       DataChangePublisher->>MemoryCache: 更新缓存
       DataChangePublisher->>DiskCache: 更新缓存
       DataChangePublisher->>ViewModel: 通知变化
       ViewModel->>UI: 更新界面
   ```

## 优势与特点

1. **实时性**：远程数据变化秒级通知到UI
2. **一致性**：多级缓存自动同步更新
3. **解耦**：UI层与数据层完全解耦
4. **灵活性**：支持按账号ID订阅特定数据变化
5. **可扩展**：容易添加新的数据源或通知渠道
6. **生命周期安全**：自动处理观察者注册/注销

此设计完美解决了传统三级缓存无法感知远程数据变化的问题，使应用能够实时响应数据变更，同时保持了缓存的高效性和一致性。

# 三级缓存账号数据-责任链

在 Android 应用中实现三级缓存（内存缓存 → 磁盘缓存 → 网络请求）的账号数据获取功能，推荐结合使用以下设计模式：

## 最佳方案：**责任链模式 + 仓储模式 (Repository Pattern)**

这是最符合三级缓存场景的解决方案，结合了清晰的层级结构和数据源统一管理。

### 实现方案

```kotlin
// 1. 定义数据源接口 (统一行为)
interface AccountDataSource {
    fun getAccount(accountId: String, callback: (Account?) -> Unit)
    fun saveAccount(account: Account)
}

// 2. 实现三级缓存的具体责任链节点
// 内存缓存 (使用 LruCache)
class MemoryDataSource : AccountDataSource {
    private val cache = LruCache<String, Account>(MAX_MEMORY_ENTRIES)

    override fun getAccount(accountId: String, callback: (Account?) -> Unit) {
        callback(cache.get(accountId)) // 立即返回内存结果
    }

    override fun saveAccount(account: Account) {
        cache.put(account.id, account)
    }
}

// 磁盘缓存 (使用 Room/SQLite)
class DiskDataSource(private val context: Context) : AccountDataSource {
    private val dao: AccountDao by lazy { 
        AccountDatabase.getInstance(context).accountDao() 
    }

    override fun getAccount(accountId: String, callback: (Account?) -> Unit) {
        CoroutineScope(Dispatchers.IO).launch {
            callback(dao.getAccountById(accountId))
        }
    }

    override fun saveAccount(account: Account) {
        CoroutineScope(Dispatchers.IO).launch {
            dao.insertAccount(account)
        }
    }
}

// 网络数据源
class NetworkDataSource : AccountDataSource {
    override fun getAccount(accountId: String, callback: (Account?) -> Unit) {
        RetrofitClient.accountService
            .getAccount(accountId)
            .enqueue(object : Callback<Account> {
                override fun onResponse(call: Call<Account>, response: Response<Account>) {
                    response.body()?.let(callback)
                }
                override fun onFailure(call: Call<Account>, t: Throwable) {
                    callback(null)
                }
            })
    }
    
    override fun saveAccount(account: Account) {} // 网络层无需实现保存
}

// 3. 责任链协调器 (关键)
class AccountRepository(
    private val memorySource: AccountDataSource,
    private val diskSource: AccountDataSource,
    private val networkSource: AccountDataSource
) {
    fun getAccount(accountId: String, callback: (Account?) -> Unit) {
        // 1. 检查内存
        memorySource.getAccount(accountId) { account ->
            if (account != null) {
                callback(account)
                return@getAccount
            }

            // 2. 检查磁盘
            diskSource.getAccount(accountId) { account ->
                if (account != null) {
                    callback(account)
                    memorySource.saveAccount(account) // 回填内存
                    return@getAccount
                }

                // 3. 请求网络
                networkSource.getAccount(accountId) { account ->
                    if (account != null) {
                        callback(account)
                        memorySource.saveAccount(account) // 更新内存
                        diskSource.saveAccount(account)    // 更新磁盘
                    } else {
                        callback(null) // 所有源均无数据
                    }
                }
            }
        }
    }
}

// 4. 使用示例
class AccountViewModel : ViewModel() {
    private val repo = AccountRepository(
        MemoryDataSource(),
        DiskDataSource(context),
        NetworkDataSource()
    )

    fun loadAccount(accountId: String) {
        repo.getAccount(accountId) { account ->
            account?.let { updateUI(it) } 
            ?: showError("Account not found")
        }
    }
}
```

## 设计模式解析

1. **责任链模式 (Chain of Responsibility)**：
   - **内存 → 磁盘 → 网络** 形成明确的责任链
   - 每个数据源独立处理请求，当前节点无数据时转发到下一节点
   - 符合开闭原则（新增数据源无需修改原有逻辑）

2. **仓储模式 (Repository)**：
   - 统一数据访问接口 (`AccountRepository`)
   - 对ViewModel隐藏三级缓存的具体实现细节
   - 符合单一职责原则（数据获取/存储逻辑集中管理）

3. **策略模式 (Strategy)**（隐含）：
   - 不同数据源 (`Memory`/`Disk`/`Network`) 实现相同接口
   - 可灵活替换数据源实现（如更换网络库）

## 优势

1. **清晰的缓存层级**：严格遵循 `内存 → 磁盘 → 网络` 的优先级  
2. **异步友好**：天然支持异步回调（协程/RxJava可优化嵌套）  
3. **数据回填机制**：网络获取数据后自动更新下层缓存  
4. **错误隔离**：某一级缓存失败不影响整体流程  
5. **可扩展性**：轻松添加新数据源（如云备份源）

## 优化建议

1. **使用协程消除回调嵌套**：

```kotlin
// 使用协程版本
suspend fun getAccount(accountId: String): Account? {
    memorySource.getAccount(accountId)?.let { return it }
    diskSource.getAccount(accountId)?.let {
        memorySource.saveAccount(it)
        return it
    }
    return networkSource.getAccount(accountId)?.also { account ->
        memorySource.saveAccount(account)
        diskSource.saveAccount(account)
    }
}
```

2. **增加缓存时效控制**：

```kotlin
// 在Account类中添加时间戳
data class Account(
    val id: String,
    val name: String,
    val lastUpdated: Long = System.currentTimeMillis()
)

// 在Repository中校验时效性
private fun isValid(account: Account) = 
    System.currentTimeMillis() - account.lastUpdated < MAX_CACHE_AGE
```

3. **使用单例保证内存缓存全局唯一**：

```kotlin
object MemoryCache : AccountDataSource {
    private val cache = ConcurrentHashMap<String, Account>()
    // 实现接口方法...
}
```

## 替代方案对比

| 模式               | 适用场景                          | 三级缓存适用度 |
|--------------------|---------------------------------|--------------|
| **责任链+仓储**     | 多级数据源场景                    | ⭐⭐⭐⭐⭐        |
| 外观模式           | 简化复杂子系统访问                | ⭐⭐⭐⭐         |
| 代理模式           | 控制缓存访问（如延迟加载）        | ⭐⭐⭐          |
| 命令模式           | 需要支持撤销/重做操作时           | ⭐⭐           |

> 结论：**责任链+仓储模式**是最符合三级缓存场景的选择，兼顾清晰的结构和良好的扩展性。建议结合Kotlin协程或RxJava优化异步流处理。
